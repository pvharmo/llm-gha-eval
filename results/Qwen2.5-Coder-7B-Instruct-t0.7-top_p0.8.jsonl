{"id": "63c494a97843b61269a02a50", "level": "level1", "llm_response": "```yaml\nname: pytorch1_7_1-cuda11_0\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Build project\n        run: |\n          make build\n```", "answer": "```yaml name: pytorch1_7_1-cuda11_0\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu110\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.7.1-cu110\n      develop_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_7_1-cuda11_0` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c496986fc19abdf9c9cf90", "level": "level1", "llm_response": "```yaml\nname: Issue Check\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Setup .NET\n        uses: actions/setup-dotnet@v2\n        with:\n          dotnet-version: '6.0'\n\n      - name: Run issue check script\n        run: dotnet run --project ./IssueCheck.csproj\n```", "answer": "```yaml name: 'Issue Check'\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n    steps:\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == false\n        name: Close Issue\n        uses: peter-evans/close-issue@v1\n        with:\n          comment: |\n            Hello, Please use the Github template to report an issue. If this is a feature request, please take a look at the readme. <br/> Thanks, <br/> Ombi Bot\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == true\n        name: Create comment\n        uses: peter-evans/create-or-update-comment@v1\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            Hi!\n            <br/>Thanks for the issue report. Before a real human comes by, please make sure you used our bug report format.\n            <br/>Have you looked at the wiki yet? https://docs.ombi.app/\n            <br/>Before posting make sure you also read our [FAQ](https://docs.ombi.app/info/faq/).\n            <br/> Make the title describe your issue. Having 'not working' or 'I get this bug' for 100 issues, isn't really helpful.\n            <br/> If we need more information or there is some progress we tag the issue or update the tag and keep you updated.\n            <br/> Thanks!\n            <br/> Ombi Bot.\n```", "prompt": "Generate a GitHub Workflow named `Issue Check` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `issueCheck`. "}
{"id": "63c494da7843b61269a03d4f", "level": "level1", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      # Add your steps here\n```", "answer": "```yaml name: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\njobs:\n  build-and-deploy:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n      - name: Install \ud83c\udf31\n        run: |\n          sudo apt-get install -y pandoc\n      - name: Build \ud83d\udd27\n        run: |\n          ./run build itch\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4\n        with:\n          folder: build\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is GDScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets 3 environment variables to use: `BUTLER_API_KEY` is set to `${{ secrets.BUTLER_API_KEY }}`, `ITCHIO_USERNAME` is set to `${{ secrets.ITCHIO_USERNAME }}` and `ITCHIO_GAME` is set to `${{ secrets.ITCHIO_GAME }}`. The workflow has one job. The job id of the 1st job is `build-and-deploy`. "}
{"id": "63c4968933b087f6bde2ca3a", "level": "level1", "llm_response": "```yaml\nname: Nightly Smoketest\n\non:\n  schedule:\n    - cron: '0 3 * * 1-5'\n  workflow_dispatch:\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n      - name: Run smoketest\n        run: go test -v ./...\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# This workflow tests that we can stand up a CRDB cluster with the operator and execute SQL in the cluster. It uses the\n# steps that are outlined in our public docs to ensure that the flow we're recommending always works.\nname: Nightly Smoketest\n\non:\n  schedule:\n    # runs at 3am UTC Mon-Fri\n    # ref: <min> <hr> <month-day> <month> <weekday>\n    - cron: '0 3 * * 1-5'\n\n  # allows running from the actions tab in GitHub\n  workflow_dispatch: ~\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        # supported Kubenetes versions\n        NODE_VERSION: [1.19.16, 1.20.15, 1.21.9, 1.22.6, 1.23.3]\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: Bank Workload\n        env:\n          NODE_VERSION: ${{ matrix.NODE_VERSION }}\n        run: make test/smoketest\n```", "prompt": "Generate a GitHub Workflow named `Nightly Smoketest` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am, monday through friday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `smoketest`. "}
{"id": "63c496686fc19abdf9c9be9c", "level": "level1", "llm_response": "```yaml\nname: Unit testing (Ubuntu)\n\non:\n  push:\n    branches:\n      - main\n      - 'ver_*'\n      - dev\n    paths:\n      - '**.py'\n  pull_request:\n    branches:\n      - main\n      - 'ver_*'\n      - dev\n    paths:\n      - '**.py'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Run unit tests\n        run: |\n          pytest\n```", "answer": "```yaml name: Unit testing (Ubuntu)\non:\n  push:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n  pull_request:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n\njobs:\n  build:\n    strategy:\n      matrix:\n        # os: [macos-latest, windows-latest, ubuntu-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10']  # , '3.11-dev'\n    # runs-on: ${{ matrix.os }}\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        python -m pip install pytest coverage\n        pip install -r requirements.txt\n    - name: Test with pytest\n      env:\n        DEBUG_API_ID: ${{ secrets.DEBUG_API_ID }}\n        DEBUG_API_SECRET: ${{ secrets.DEBUG_API_SECRET }}\n        CROSS_DEBUG_KEY: ${{ secrets.CROSS_DEBUG_KEY }}\n        CROSS_DEBUG_SECRET: ${{ secrets.CROSS_DEBUG_SECRET }}\n      run: |\n        coverage run --source=src --omit=src/falconpy/debug.py -m pytest -s --ignore-glob=**/manual/*\n        coverage report\n```", "prompt": "Generate a GitHub Workflow named `Unit testing (Ubuntu)` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of push event matches a pattern in the paths filter(**.py), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of pull_request event matches a pattern in the paths filter(**.py), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c49698b008460c1df15628", "level": "level1", "llm_response": "```yaml\nname: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\npermissions:\n  contents: read\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\njobs:\n  add_to_gh_projects:\n    id: add_to_gh_projects\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run script\n        run: ./path/to/script.sh\n```", "answer": "```yaml name: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\npermissions:\n  contents: read\n\njobs:\n  add_to_gh_projects:\n    name: Adds issues to GH projects\n    runs-on: ubuntu-latest\n    steps:\n      - name: Add labeled issues to GH projects\n        uses: gradle/build-tool-issue-automation-actions/add-labeled-issues@v1\n```", "prompt": "Generate a GitHub Workflow named `add-to-gh-projects` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by multiple events: 1) an issue is opened or a label is added to an issue. 2) a pull request is created or a label is added to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}`. The workflow has one job. The 1st job is named `Adds issues to GH projects` and its job id is `add_to_gh_projects`. "}
{"id": "63c494f67843b61269a0479e", "level": "level1", "llm_response": "```yaml\nname: Sync-To-Gitlab\n\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request:\n    branches:\n      - master\n      - master-template\n    types: [closed]\n  workflow_dispatch:\n\njobs:\n  sync:\n    id: sync\n    runs-on: ubuntu-latest\n    steps:\n      # Add your steps here\n```", "answer": "```yaml name: Sync-To-Gitlab\nrun-name: Sync-To-Gitlab ${{ github.sha }}\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request_target:\n    types:\n      - closed\n    branches:\n      - master\n      - master-template\n  workflow_dispatch:\n\n\njobs:\n  sync:\n    concurrency:\n      group: ${{ github.workflow }}-${{ github.ref_name }}\n      cancel-in-progress: true\n    name: \"Sync To Gitlab\"\n    if: github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Mirror\n        env:\n          input_git_config_user_name: ${{ secrets.GITLAB_USERNAME }}\n          input_git_config_user_email: ${{ secrets.GITLAB_EMAIL }}\n          input_git_remote_url: ${{ secrets.GITLAB_URL }}\n          input_git_push_options: --force\n        run: |\n          git config --global user.name \"${{ env.input_git_config_user_name }}\"\n          git config --global user.email \"${{ env.input_git_config_user_email }}\"\n          git clone \"https://github.com/${{ github.repository }}.git\" \"git\"\n          cd git\n          git remote set-url origin \"${{ env.input_git_remote_url }}\"\n          git push ${{ env.input_git_push_options }} origin ${{ github.ref_name }}:${{ github.ref_name }}\n#      - name: Mirror + trigger CI\n#        uses: SvanBoxel/gitlab-mirror-and-ci-action@master\n#        with:\n#          args: \"https://gitlab.com/Zerek-Cheng/Simple-Assets-Platform\"\n#        env:\n#          FORCE_PUSH: \"true\"\n#          GITLAB_HOSTNAME: \"gitlab.com\"\n#          GITLAB_USERNAME: \"Zerek-Cheng\"\n#          GITLAB_PASSWORD: ${{ secrets.GITLAB_PASSWORD }}\n#          GITLAB_PROJECT_ID: \"40146411\"\n#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Sync-To-Gitlab` for a GitHub repository whose primary programming language is Java. The name for workflow runs is set to `Sync-To-Gitlab ${{ github.sha }}`. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named master-template. 2) a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named master-template. 3) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Sync To Gitlab` and its job id is `sync`. "}
{"id": "63c496561899db58864d23de", "level": "level1", "llm_response": "```yaml\nname: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  sqlite:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule docker\n      - name: Run Molecule tests\n        run: |\n          molecule test --all\n        env:\n          DEBUG_THE: ${{ github.event.inputs.debug-the }}\n```", "answer": "```yaml name: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  sqlite:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: sqlite\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Sqlite` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.sqlite.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/sqlite/** or roles/sqlite/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `sqlite`. "}
{"id": "63c494078052faa2781a8a1f", "level": "level1", "llm_response": "```yaml\nname: CLA Assistant\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [opened, closed, synchronize]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Run CLA Assistant\n        run: |\n          # Add your CLA Assistant command here\n          echo \"Running CLA Assistant...\"\n```", "answer": "```yaml name: \"CLA Assistant\"\non:\n  issue_comment:\n    types: [ created ]\n  pull_request_target:\n    types: [ opened,closed,synchronize ]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        uses: cla-assistant/github-action@v2.1.3-beta\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # the below token should have repo scope and must be manually added by you in the repository's secret\n          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: '.cla/v1/signatures.json'\n          path-to-document: 'https://github.com/christian-schlichtherle/truelicense/blob/develop/CLA.md'\n          branch: 'develop'\n          allowlist: bot*\n\n          #below are the optional inputs - If the optional inputs are not given, then default values will be taken\n          #remote-organization-name: enter the remote organization name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #remote-repository-name:  enter the  remote repository name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #create-file-commit-message: 'For example: Creating file for storing CLA Signatures'\n          #signed-commit-message: 'For example: $contributorName has signed the CLA in #$pullRequestNo'\n          #custom-notsigned-prcomment: 'pull request comment with Introductory message to ask new contributors to sign'\n          #custom-pr-sign-comment: 'The signature to be committed in order to sign the CLA'\n          #custom-allsigned-prcomment: 'pull request comment when all contributors has signed, defaults to **CLA Assistant Lite bot** All Contributors have signed the CLA.'\n          #lock-pullrequest-aftermerge: false - if you don't want this bot to automatically lock the pull request after merging (default - true)\n          #use-dco-flag: true - If you are using DCO instead of CLA\n```", "prompt": "Generate a GitHub Workflow named `CLA Assistant` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `CLAssistant`. "}
{"id": "63c494298052faa2781a98f8", "level": "level1", "llm_response": "```yaml\nname: Linux build with address sanitizer enabled\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up C++ environment\n        uses: actions/setup-cpp@v2\n        with:\n          cpp-version: '10'\n\n      - name: Install dependencies\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y clang libc++-dev\n\n      - name: Build with AddressSanitizer\n        run: |\n          mkdir build\n          cd build\n          cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_CXX_FLAGS=\"-fsanitize=address\" ..\n          make\n```", "answer": "```yaml name: Linux build with address sanitizer enabled\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n    container: ghcr.io/lballabio/quantlib-devenv:rolling\n    steps:\n    - uses: actions/checkout@v3\n    - name: Compiler version\n      run: |\n        gcc --version\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"gcc\" CXX=\"g++\" CXXFLAGS=\"-O2 -g0 -fsanitize=address,undefined -fno-sanitize-recover=all -fno-omit-frame-pointer -Wall -Wno-unknown-pragmas -Werror\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --log_level=message\n    - name: Run examples\n      run: |\n        make check-examples\n```", "prompt": "Generate a GitHub Workflow named `Linux build with address sanitizer enabled` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `sanitize`. "}
{"id": "63c493cd7843b612699fd710", "level": "level1", "llm_response": "```yaml\nname: Clean\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  delete-artifacts:\n    id: delete-artifacts\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Delete artifacts\n        run: |\n          rm -rf target\n          rm -rf build\n          rm -rf *.jar\n          rm -rf *.war\n```", "answer": "```yaml # This file was automatically generated by sbt-github-actions using the\n# githubWorkflowGenerate task. You should add and commit this file to\n# your git repository. It goes without saying that you shouldn't edit\n# this file by hand! Instead, if you wish to make changes, you should\n# change your sbt build configuration to revise the workflow description\n# to meet your needs, then regenerate this file.\n\nname: Clean\n\non: push\n\njobs:\n  delete-artifacts:\n    name: Delete Artifacts\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Delete artifacts\n        run: |\n          # Customize those three lines with your repository and credentials:\n          REPO=${GITHUB_API_URL}/repos/${{ github.repository }}\n\n          # A shortcut to call GitHub API.\n          ghapi() { curl --silent --location --user _:$GITHUB_TOKEN \"$@\"; }\n\n          # A temporary file which receives HTTP response headers.\n          TMPFILE=/tmp/tmp.$$\n\n          # An associative array, key: artifact name, value: number of artifacts of that name.\n          declare -A ARTCOUNT\n\n          # Process all artifacts on this repository, loop on returned \"pages\".\n          URL=$REPO/actions/artifacts\n          while [[ -n \"$URL\" ]]; do\n\n            # Get current page, get response headers in a temporary file.\n            JSON=$(ghapi --dump-header $TMPFILE \"$URL\")\n\n            # Get URL of next page. Will be empty if we are at the last page.\n            URL=$(grep '^Link:' \"$TMPFILE\" | tr ',' '\\n' | grep 'rel=\"next\"' | head -1 | sed -e 's/.*<//' -e 's/>.*//')\n            rm -f $TMPFILE\n\n            # Number of artifacts on this page:\n            COUNT=$(( $(jq <<<$JSON -r '.artifacts | length') ))\n\n            # Loop on all artifacts on this page.\n            for ((i=0; $i < $COUNT; i++)); do\n\n              # Get name of artifact and count instances of this name.\n              name=$(jq <<<$JSON -r \".artifacts[$i].name?\")\n              ARTCOUNT[$name]=$(( $(( ${ARTCOUNT[$name]} )) + 1))\n\n              id=$(jq <<<$JSON -r \".artifacts[$i].id?\")\n              size=$(( $(jq <<<$JSON -r \".artifacts[$i].size_in_bytes?\") ))\n              printf \"Deleting '%s' #%d, %'d bytes\\n\" $name ${ARTCOUNT[$name]} $size\n              ghapi -X DELETE $REPO/actions/artifacts/$id\n            done\n          done\n```", "prompt": "Generate a GitHub Workflow named `Clean` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The 1st job is named `Delete Artifacts` and its job id is `delete-artifacts`. "}
{"id": "63c494167843b612699fee3f", "level": "level1", "llm_response": "```yaml\nname: Dead Link Check\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up JDK 11\n      uses: actions/setup-java@v2\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n    - name: Run dead link check\n      run: ./gradlew checkLinks\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\n\nname: Dead Link Check\n\non: [push, pull_request]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    if: (github.repository == 'apache/incubator-linkis')\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gaurav-nelson/github-action-markdown-link-check@v1\n        with:\n          use-quiet-mode: 'no'\n          use-verbose-mode: 'yes'\n          folder-path: '../'\n          config-file: '.github/workflows/dlc.json'\n```", "prompt": "Generate a GitHub Workflow named `Dead Link Check` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `dead-links-check`. "}
{"id": "63c4964b33b087f6bde2aead", "level": "level1", "llm_response": "```yaml\nname: Build release\n\non:\n  push:\n    tags:\n      - 'v**'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Build with Gradle\n        run: ./gradlew build\n```", "answer": "```yaml name: Build release\n\non:\n  push:\n    tags:\n      - v**\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: set up JDK 11\n      uses: actions/setup-java@v3\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n        cache: gradle\n\n    - name: Set up ruby env\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: 2.7.2\n        bundler-cache: true\n\n    - name: Decode Service Account Key JSON File\n      uses: timheuer/base64-to-file@v1\n      id: service_account_json_file\n      with:\n        fileName: \"serviceAccount.json\"\n        encodedString: ${{ secrets.GOOGLE_JSON }}\n\n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n\n    - name: Create local properties\n      run: touch local.properties\n\n    - name: Create maps api key\n      run: echo \"MAPS_API_KEY=${{ secrets.MAPS_API_KEY }}\" > secrets.properties\n\n    - name: Decode Keystore\n      env:\n        ENCODED_STRING: ${{ secrets.KEYSTORE }}\n      run: |\n        mkdir app/keystore\n        echo $ENCODED_STRING | base64 -di > app/keystore/keystore.jks\n    - name: Decode Google Services json\n      env:\n        ENCODED_STRING: ${{ secrets.GOOGLE_SERVICES }}\n      run: |\n        echo $ENCODED_STRING | base64 -di > app/google-services.json\n        \n\n    - name: Build & deploy Android release\n      run: bundle exec fastlane android deploy\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n        ANDROID_JSON_KEY_FILE: ${{ steps.service_account_json_file.outputs.filePath }}\n\n#    - name: Build with Gradle\n#      run: ./gradlew app:bundleRelease\n#      env:\n#        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n#        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n#        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n#\n#    - name: Archive release bundle\n#      uses: actions/upload-artifact@v3\n#      with:\n#        name: bundle\n#        path: |\n#          app/build/outputs/bundle/release\n```", "prompt": "Generate a GitHub Workflow named `Build release` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v**. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c4956e8052faa2781b1ca5", "level": "level1", "llm_response": "```yaml\nname: Conventional PR\n\non:\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Setup .NET\n        uses: actions/setup-dotnet@v2\n        with:\n          dotnet-version: '6.0'\n\n      - name: Restore dependencies\n        run: dotnet restore\n\n      - name: Build\n        run: dotnet build --configuration Release --no-restore\n\n      - name: Test\n        run: dotnet test --configuration Release --no-restore --verbosity normal\n```", "answer": "```yaml name: Conventional PR\n\n# Controls when the action will run. \non:\n  pull_request:\n    branches:\n    - develop\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n      - name: semantic-pull-request\n        # Internal Unity mirror available at jesseo/action-semantic-pull-request, but actions from private repos aren't supported, so continue to use the public one below\n        uses: amannn/action-semantic-pull-request@b7a9a97cb10fa6e1ae02647e718798175f6b1f1d\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          # Provide custom types if you don't want the default ones from https://www.conventionalcommits.org\n          types: # optional\n          # Configure which scopes are allowed.\n          #scopes: # optional\n          # Configure that a scope must always be provided.\n          #requireScope: # optional\n          # Configure additional validation for the subject based on a regex. E.g. '^(?![A-Z]).+$' ensures the subject doesn't start with an uppercase character.\n          #subjectPattern: # optional\n          # If `subjectPattern` is configured, you can use this property to override the default error message that is shown when the pattern doesn't match. The variables `subject` and `title` can be used within the message.\n          #subjectPatternError: # optional\n          # For work-in-progress PRs you can typically use draft pull requests from Github. However, private repositories on the free plan don't have this option and therefore this action allows you to opt-in to using the special '[WIP]' prefix to indicate this state. This will avoid the validation of the PR title and the pull request checks remain pending. Note that a second check will be reported if this is enabled.\n          #wip: # optional\n          # When using \"Squash and merge\" on a PR with only one commit, GitHub will suggest using that commit message instead of the PR title for the merge commit, and it's easy to commit this by mistake. Enable this option to also validate the commit message for one commit PRs.\n          validateSingleCommit: true # optional\n```", "prompt": "Generate a GitHub Workflow named `Conventional PR` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c4965b33b087f6bde2b689", "level": "level1", "llm_response": "```yaml\nname: fortran-format-check\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  fortran-format-check:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Fortran\n        uses: ilammy/setup-fortran@v1\n\n      - name: Check for formatting errors\n        run: |\n          # Add your Fortran formatting check command here\n          # Example: flake8 --config=.flake8 .\n```", "answer": "```yaml name: fortran-format-check\n\non:\n  push:\n    branches: [ master, develop ]\n  pull_request:\n    branches: [ develop ]\n\njobs:\n  fortan-format-check:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash -l {0}\n\n    steps:\n      - uses: actions/checkout@v2.3.4\n\n      - name: Install Conda environment from environment.yml\n        uses: mamba-org/provision-with-micromamba@main\n        with:\n            cache-downloads: true\n            cache-env: true\n\n      - name: Install gfortran\n        uses: modflowpy/install-gfortran-action@v1\n\n      - name: Print python package versions\n        run: |\n          pip list\n\n      - name: Set and print branch name\n        run: |\n          .github/common/git-branch-export.sh\n\n      - name: Fortran source format check\n        run: |\n          .github/common/fortran-format-check.sh\n```", "prompt": "Generate a GitHub Workflow named `fortran-format-check` for a GitHub repository whose primary programming language is Fortran. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `fortan-format-check`. "}
{"id": "63c494c88052faa2781ad4bd", "level": "level1", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ros_distro: [noetic, melodic, kinetic]\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Run tests\n      run: npm test\n```", "answer": "```yaml name: CI\n\non: [push, pull_request]\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  ci:\n    name: ${{ matrix.ros_distro }}\n    if: ${{ github.actor != 'RWT-bot' }}\n    runs-on: ubuntu-latest\n    container: ros:${{ matrix.ros_distro }}-ros-core\n    strategy:\n      fail-fast: false\n      matrix:\n        ros_distro: [melodic, noetic]\n        node_version: [14]\n    env:\n      ROS_DISTRO: ${{ matrix.ros_distro }}\n    steps:\n      - uses: actions/checkout@v3\n        env:\n          TOKEN: \"${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' && secrets.RWT_BOT_PAT || github.token }}\"\n        with:\n          token: ${{ env.TOKEN }}\n      - uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node_version }}\n      - name: Own /github/home\n        run: |\n          chown -hR $(whoami):$(whoami) /github/home\n      - name: Install apt dependencies\n        run: |\n          apt-get update\n          apt-get install -y firefox ros-$ROS_DISTRO-rosbridge-server ros-$ROS_DISTRO-tf2-web-republisher ros-$ROS_DISTRO-common-tutorials ros-$ROS_DISTRO-rospy-tutorials ros-$ROS_DISTRO-actionlib-tutorials\n      - name: Tests\n        run: |\n          bash -c \"source /opt/ros/$ROS_DISTRO/setup.bash && bash test/build.bash\"\n      - uses: stefanzweifel/git-auto-commit-action@v4\n        if: ${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' }}\n        with:\n          commit_message: Update Build\n          file_pattern: 'build/*.js'\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The 1st job is named `${{ matrix.ros_distro }}` and its job id is `ci`. "}
{"id": "63c494287843b612699ff643", "level": "level1", "llm_response": "```yaml\nname: README to PDF\n\non:\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Install dependencies\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y texlive texlive-latex-extra\n\n    - name: Convert README to PDF\n      run: |\n        pandoc README.md -o README.pdf\n```", "answer": "```yaml name: README to PDF\n# This workflow is triggered on pushes to the repository.\non:\n#   push:\n#     branches:\n#       - main\n#     paths:\n#       - 'README.md'\n    \n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    name: Build PDF\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: baileyjm02/markdown-to-pdf@v1.1.0\n        with:\n          input_dir: .\n          output_dir: .\n          build_html: false\n          table_of_contents: false\n      - uses: actions/upload-artifact@v3\n        with:\n          name: python-engineer-roadmap\n          path: README.pdf\n      - name: Commit files\n        run: |\n          git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n          git config --local user.name \"github-actions[bot]\"\n          git add README.pdf\n          if ! git diff-index --quiet HEAD; then\n            git commit -m \"Generate PDF file\"\n          fi\n      - name: Push changes\n        uses: ad-m/github-push-action@master\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          branch: ${{ github.ref }}\n#       - name: Commit changes\n#         uses: EndBug/add-and-commit@v9\n#         with:\n#           default_author: github_actions\n#           add: 'README.pdf'\n#           new_branch: generate-pdf\n#           push: origin generate-pdf --set-upstream --force\n```", "prompt": "Generate a GitHub Workflow named `README to PDF` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Build PDF` and its job id is `converttopdf`. "}
{"id": "63c494578052faa2781aa8bb", "level": "level1", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\nenv:\n  CODECOV_TOKEN: 2fc0d617-8e9a-47d7-ab58-52fa92b23741\n  MAIN_GO_VER: 1.16\n  MAIN_HOST_OS: ubuntu-latest\n\njobs:\n  go_test_and_coverage:\n    runs-on: ${{ env.MAIN_HOST_OS }}\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: ${{ env.MAIN_GO_VER }}\n\n    - name: Run tests\n      run: go test -v ./...\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        token: ${{ env.CODECOV_TOKEN }}\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branchs:\n    - 'master'\n    - 'feature/**'\n    - 'dev/**'\n\nenv:\n  CODECOV_TOKEN: '2fc0d617-8e9a-47d7-ab58-52fa92b23741'\n  MAIN_GO_VER: '1.16'\n  MAIN_HOST_OS: 'ubuntu-latest'\n\njobs:\n  go_test_and_coverage:\n    strategy:\n      max-parallel: 6\n      matrix:\n        GO_VER: ['1.16']\n        HOST_OS: ['ubuntu-latest']\n\n    runs-on: ${{ matrix.HOST_OS }}\n\n    steps:\n\n    - name: Checkout Repositary\n      uses: actions/checkout@v3\n\n    - name: Setup Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.GO_VER }}\n      id: go\n\n    - name: Get Dependencies\n      run: |\n        echo GO_VER = ${{ matrix.GO_VER }}\n        go get golang.org/x/tools/cmd/cover\n        go install github.com/mattn/goveralls || go get github.com/mattn/goveralls\n        go get .\n\n    - name: Show Environments\n      run: |\n        echo repo status ======== && git status\n        echo GITHUB_REF = ${{ env.GITHUB_REF }}\n        echo GITHUB_REF_NAME = ${{ env.GITHUB_REF_NAME }}\n        echo GO_VER = ${{ matrix.GO_VER }}\n        echo HOST_OS = ${{ matrix.HOST_OS }}\n        which goveralls\n        echo envs ======== && printenv\n\n    - name: Test and Generate Coverage Report\n      run: |\n        go test -v -failfast -cover -covermode=atomic -coverprofile=coverage.out\n\n    # - name: Upload Coverage to Goveralls\n    #   run: |\n    #     goveralls -coverprofile=coverage.out -repotoken ${{ env.COVERALLS_TOKEN }}\n\n    # - name: Upload Coverage to Codecov\n    #   if: ${{ matrix.GO_VER }} == ${{ env.MAIN_GO_VER }}\n    #   run: |\n    #     bash <(curl -s https://codecov.io/bash) -t ${{ env.CODECOV_TOKEN }}\n\n    # - name: Convert Coverage file to lcov format\n    #   uses: jandelgado/gcov2lcov-action@v1.0.8\n    #   with:\n    #     infile: ./coverage.out\n    #     outfile: ./coverage.lcov\n\n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        files: ./coverage.out\n        fail_ci_if_error: true\n        flags: unittests\n        name: codecov-umbrella\n        path_to_write_report: ./coverage/codecov_report.txt\n        verbose: true\n\n    # - name: Coveralls GitHub Action\n    #   uses: coverallsapp/github-action@1.1.3\n    #   with:\n    #     path-to-lcov: ./coverage.lcov\n    #     github-token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow sets 3 environment variables to use: `CODECOV_TOKEN` is set to `2fc0d617-8e9a-47d7-ab58-52fa92b23741`, `MAIN_GO_VER` is set to `1.16` and `MAIN_HOST_OS` is set to `ubuntu-latest`. The workflow has one job. The job id of the 1st job is `go_test_and_coverage`. "}
{"id": "63c495297843b61269a05d37", "level": "level1", "llm_response": "```yaml\nname: pr\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Build project\n        run: npm run build\n\n  algolia:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Push to Algolia\n        run: npm run algolia:push\n```", "answer": "```yaml name: pr\non:\n  pull_request:\n\njobs:\n  release:\n    uses: the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main\n    with:\n      npmTag: alpha\n      buildScript: build\n      nodeVersion: 18\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n      npmToken: ${{ secrets.NPM_TOKEN }}\n\n\n  algolia:\n    uses: the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main\n    with:\n      domain: https://www.the-guild.dev/graphql/shield/\n      source: 'Shield'\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `pr` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The job id of the 1st job is `release`. The job id of the 2nd job is `algolia`. "}
{"id": "63c4959c7843b61269a08c2d", "level": "level1", "llm_response": "```yaml\nname: Rust Workflow\n\non:\n  push:\n    paths:\n      - .github/workflows/install.yml\n  schedule:\n    - cron: '17 0 * * 1'\n\npermissions:\n  contents: read\n\njobs:\n  cargo-install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          profile: minimal\n          toolchain: stable\n          override: true\n      - name: Install dependencies\n        run: cargo build --release\n```", "answer": "```yaml permissions:\n  contents: read\n\non:\n  push:\n    paths:\n      - \".github/workflows/install.yml\"\n  schedule:\n    - cron: \"17 0 * * 1\"\n\njobs:\n  cargo-install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: |\n          cargo install cargo-mutants\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/install.yml), the workflow runs. 2) the scheduled time has come: at 12:17 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `cargo-install`. "}
{"id": "63c4968e1899db58864d3b1c", "level": "level1", "llm_response": "```yaml\nname: HTML5 check\n\non:\n  push:\n    branches: [ main, master ]\n  pull_request:\n    branches: [ main, master ]\n\njobs:\n  HTML5-check:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up R\n        uses: r-lib/actions/setup-r@v2\n\n      - name: Install dependencies\n        run: |\n          install.packages(\"htmltools\")\n          install.packages(\"testthat\")\n\n      - name: Run HTML5 check\n        run: |\n          htmltools::test_html(\"path/to/your/html/file.html\")\n          testthat::test_file(\"path/to/your/test/file.R\")\n```", "answer": "```yaml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n\nname: HTML5 check\n\njobs:\n  HTML5-check:\n    uses: easystats/workflows/.github/workflows/html-5-check.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `HTML5 check` for a GitHub repository whose primary programming language is R. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch named master. The workflow has one job. The job id of the 1st job is `HTML5-check`. "}
{"id": "63c496861e3364807577b31b", "level": "level1", "llm_response": "```yaml\nname: license-check\n\non:\n  pull_request:\n\njobs:\n  license:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Check license\n      run: cargo license --json\n```", "answer": "```yaml name: license-check\non: pull_request\njobs:\n  license:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Check License Header\n      uses: apache/skywalking-eyes/header@501a28d2fb4a9b962661987e50cf0219631b32ff\n```", "prompt": "Generate a GitHub Workflow named `license-check` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `license`. "}
{"id": "63c4962c6fc19abdf9c9a4e3", "level": "level1", "llm_response": "```yaml\nname: Continuous integration\n\non:\n  push:\n    branches: [ main ]\n  release:\n    types: [ created ]\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Ruby\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: 2.7\n    - name: Install dependencies\n      run: bundle install\n    - name: Run tests\n      run: bundle exec rspec\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: test\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Ruby\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: 2.7\n    - name: Install dependencies\n      run: bundle install\n    - name: Deploy to production\n      run: bundle exec cap production deploy\n```", "answer": "```yaml name: Continuous integration\non: push\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:14-alpine\n        ports: [\"5432:5432\"]\n        env:\n          POSTGRES_PASSWORD: postgres\n\n      redis:\n        image: redis:alpine\n        ports: [\"6379:6379\"]\n\n      opensearch:\n        image: opensearchproject/opensearch:latest\n        ports: [\"9200:9200\"]\n        env:\n          discovery.type: single-node\n          plugins.security.disabled: true\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          bundler-cache: true\n\n      - name: Lint with RuboCop\n        run: bundle exec rubocop --parallel\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3.5.1\n        with:\n          cache: yarn\n\n      - name: Install Node modules\n        run: bin/yarn install --frozen-lockfile\n\n      - name: Run ESLint\n        run: bin/yarn lint\n\n      - name: Run Tests\n        env:\n          DB_HOST: localhost\n          DB_USER: postgres\n          DB_PASSWORD: postgres\n          RAILS_ENV: test\n          SECRET_KEY_BASE: we-dont-need-a-secret-here\n          APP_ADMIN_EMAIL: admin@example.org\n          APP_ADMIN_PASSWORD: secret\n          APP_EMAIL: reply@example.org\n          APP_HOST: example.org\n          AWS_ACCESS_KEY_ID: my-access-key\n          AWS_SECRET_ACCESS_KEY: my-secret\n          AWS_BUCKET: my-bucket\n          AWS_REGION: eu-central-1\n          CI: true\n        run: |\n          bundle exec rake assets:precompile\n          bundle exec rake db:create db:schema:load\n          bundle exec rake spec\n\n  deploy:\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'\n    needs: test\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build, push and deploy the LATEST image\n        if: github.ref == 'refs/heads/develop'\n        run: |\n          export COMMIT_TIME=$(git show -s --format=%cD ${GITHUB_SHA})\n          export COMMIT_SHA=${GITHUB_SHA}\n          docker buildx build --build-arg COMMIT_TIME --build-arg COMMIT_SHA -t ghcr.io/ledermann/docker-rails/docker-rails:latest .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:latest\n          curl -X POST ${{ secrets.DEPLOY_HOOK_APP }}\n          curl -X POST ${{ secrets.DEPLOY_HOOK_WORKER }}\n\n      - name: Build and push the STABLE image\n        if: github.ref == 'refs/heads/master'\n        run: |\n          docker buildx build -t ghcr.io/ledermann/docker-rails/docker-rails:stable .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:stable\n```", "prompt": "Generate a GitHub Workflow named `Continuous integration` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The job id of the 1st job is `test`. The job id of the 2nd job is `deploy`. "}
{"id": "63c495707843b61269a07a00", "level": "level1", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '43 20 * * 1'\n  push:\n    branches:\n      - master\n\npermissions:\n  contents: read\n  packages: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run Scorecards analysis\n        run: |\n          # Add your Scorecards analysis command here\n```", "answer": "```yaml name: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '43 20 * * 1'\n  push:\n    branches: [ master ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      # Used to receive a badge. (Upcoming feature)\n      id-token: write\n      actions: read\n      contents: read\n    \n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@a12a3943b4bdde767164f792f33f40b04645d846 # v3.0.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@3e15ea8318eee9b333819ec77a36aca8d39df13e # v1.1.1\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # (Optional) Read-only PAT token. Uncomment the `repo_token` line below if:\n          # - you want to enable the Branch-Protection check on a *public* repository, or\n          # - you are installing Scorecards on a *private* repository\n          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action#authentication-with-pat.\n          # repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n\n          # Publish the results for public repositories to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results. \n          # For private repositories, `publish_results` will automatically be set to `false`, regardless \n          # of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF\n      # format to the repository Actions tab.\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8 # v3.1.0\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n      \n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 08:43 pm, only on monday. 3) The workflow would run whenever there is a push event to: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. "}
{"id": "63c495c68052faa2781b4231", "level": "level1", "llm_response": "```yaml\nname: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pullRequestHandler:\n    id: pullRequestValidator\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up PowerShell\n        uses: actions/setup-powershell@v2\n\n      - name: Validate Pull Request\n        run: |\n          # Add your PowerShell script here to validate the pull request\n          Write-Output \"Validating pull request...\"\n```", "answer": "```yaml name: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pullRequestHandler:\n    name: Pull Request Validator\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Pull Request Validation\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: startsWith(github.event.comment.body, '/verify')\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          SKIP_UPDATED: '1'\n```", "prompt": "Generate a GitHub Workflow named `Commented Pull Request` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The 1st job is named `Pull Request Validator` and its job id is `pullRequestHandler`. "}
{"id": "63c4969e1899db58864d41ef", "level": "level1", "llm_response": "```yaml\nname: Auto message on pr merge\n\non:\n  pull_request:\n    types: [closed]\n\njobs:\n  auto-response:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Run auto-response script\n      run: node auto-response.js\n```", "answer": "```yaml name: Auto message on pr merge\n\non:\n\n  pull_request_target:\n\n    types: [closed]\n\njobs:\n\n  auto-response:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - uses: derekprior/add-autoresponse@master\n\n      env:\n\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      with:\n\n        respondableId: ${{ github.event.pull_request.node_id }}\n\n        response: \"Thank you @${{ github.event.pull_request.user.login }} for taking out your valuable time in order to contribute to our project. Looking forward for more such amazing contributions :).\"\n\n        author: ${{ github.event.pull_request.user.login }}\n\n        exemptedAuthors: \"Amit366\"\n```", "prompt": "Generate a GitHub Workflow named `Auto message on pr merge` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a pull request is closed. The workflow has one job. The job id of the 1st job is `auto-response`. "}
{"id": "63c4966b33b087f6bde2bde4", "level": "level1", "llm_response": "```yaml\nname: tests\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        name: [python-3.6, python-3.7, python-3.8, python-3.9]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Run tests\n        run: |\n          pytest\n```", "answer": "```yaml name: tests\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    name: ${{ matrix.name }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - {name: '3.11-dev', python: '3.11-dev', os: ubuntu-latest, tox: py311}\n          - {name: Linux, python: '3.10', os: ubuntu-latest, tox: py310}\n          - {name: Windows, python: '3.10', os: windows-latest, tox: py310}\n          - {name: Mac, python: '3.10', os: macos-latest, tox: py310}\n          - {name: '3.9', python: '3.9', os: ubuntu-latest, tox: py39}\n          - {name: 'PyPy', python: 'pypy-3.9', os: ubuntu-latest, tox: pypy39}\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python }}\n      - name: install system dependencies\n        run: sudo apt-get install libxml2-dev libxslt1-dev --yes\n        if: ${{ matrix.python == '3.11-dev' }}\n      - name: update pip\n        run: |\n          pip install -U wheel\n          pip install -U setuptools\n          python -m pip install -U pip\n      - run: pip install tox\n      - run: tox -e ${{ matrix.tox }}\n```", "prompt": "Generate a GitHub Workflow named `tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named develop. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `tests`. "}
{"id": "63c495c88052faa2781b42d4", "level": "level1", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Set up JDK 11\n      uses: actions/setup-java@v2\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: java\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        queries: security-and-quality,security-extended\n\n    # Autobuild failed (OOM)\n    # Hence, supply memory args for gradle build\n    - run: |\n        JAVA_OPTS=\"-Xmx1000M\" ./gradlew --no-scan compileJava\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. When all the path names of pull_request event match patterns in the paths-ignore filter(**/*.json, **/*.md, **/*.properties or **/*.txt), the workflow will not run. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. "}
{"id": "63c495e48052faa2781b4f0b", "level": "level1", "llm_response": "```yaml\nname: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install changelog-generator\n\n    - name: Generate changelog\n      run: |\n        changelog-generator --from-tag ${{ github.event.inputs.from-this }} --to-tag ${{ github.event.inputs.to-this }}\n```", "answer": "```yaml name: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n    inputs:\n      from:\n        description: 'Generate from this release/commit (defaults to the latest release)'\n        required: false\n        # default is calculated dynamically\n      to:\n        description: 'Generate until this release/commit (defaults to latest development)'\n        required: false\n        default: 'HEAD'\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n    if: ${{ github.repository_owner == 'Mudlet' }}\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Install Lua 5.1.5\n      uses: leafo/gh-actions-lua@v9\n      with:\n        luaVersion: \"5.1.5\"\n\n    - name: Install Luarocks\n      uses: leafo/gh-actions-luarocks@v4\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install argparse\n        luarocks install lunajson\n\n    - name: Calculate from and to releases\n      run: |\n        if [[ -z \"${{ github.event.inputs.from }}\" ]] ; then\n            FROM_RELEASE=$(git tag --sort=committerdate | tail -1)\n        else\n            FROM_RELEASE=${{ github.event.inputs.from }}\n        fi\n\n        if [[ -z \"${{ github.event.inputs.to }}\" ]] ; then\n            TO_RELEASE=\"HEAD\"\n        else\n            TO_RELEASE=${{ github.event.inputs.to }}\n        fi\n\n        echo \"Generating a changelog from $FROM_RELEASE until $TO_RELEASE\"\n\n        echo \"FROM_RELEASE=$FROM_RELEASE\" >> $GITHUB_ENV\n        echo \"TO_RELEASE=$TO_RELEASE\" >> $GITHUB_ENV\n\n    - name: Generate changelog\n      run: |\n        changelog=$(lua CI/generate-changelog.lua -m release --start-commit $FROM_RELEASE --end-commit $TO_RELEASE)\n        echo \"$changelog\" >> changelog.html\n\n        echo \"[INFO] Changelog generated (from $FROM_RELEASE to $TO_RELEASE). If it's too big, Github won't show it, so it's available as an artifact as well at: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts\"\n        echo \"[INFO] Changelog is:\"\n        echo $changelog\n\n    - name: Upload changelog as html\n      uses: actions/upload-artifact@v3\n      with:\n        name: changelog.html\n        path: changelog.html\n```", "prompt": "Generate a GitHub Workflow named `Generate a changelog` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am. 2) someone manually triggers the workflow. This workflow receives 2 inputs: from-this input represents generate from this release/commit (defaults to the latest release) and it is optional; to-this input represents generate until this release/commit (defaults to latest development), it is optional and its default value is HEAD. The workflow has one job. The job id of the 1st job is `generate-changelog`. "}
{"id": "63c494347843b612699ffa9f", "level": "level1", "llm_response": "```yaml\nname: Release Charts\n\non:\n  push:\n    tags:\n      - 'chart-v*'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Build charts\n        run: go build -o charts\n\n  publish:\n    runs-on: ubuntu-latest\n    needs: build\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Publish charts on GitHub Pages\n        run: |\n          git config --global user.name 'github-actions[bot]'\n          git config --global user.email 'github-actions[bot]@users.noreply.github.com'\n          git checkout -b gh-pages\n          cp -r charts/* .\n          git add -A\n          git commit -m \"Publish charts\"\n          git push origin gh-pages\n```", "answer": "```yaml name: Release Charts\n\non:\n  push:\n    tags:\n      - 'chart-v*'\n\njobs:\n  build:\n    runs-on: ubuntu-20.04\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - name: Check chart version\n        run: |\n          tag_version=${GITHUB_REF##*/chart-v}\n          chart_version=$(cat charts/moco/Chart.yaml | grep 'version:' | sed 's/version:\\s//')\n          if [ \"$tag_version\" != \"$chart_version\" ]; then\n            echo \"Different versions: tag \\\"$tag_version\\\", chart \\\"$chart_version\\\"\"\n            exit 1\n          fi\n      - name: Packaging the chart\n        run: helm package ./charts/moco/\n\n      - uses: actions/upload-artifact@v3\n        with:\n          name: helm-charts\n          path: ./moco-*.tgz\n          retention-days: 1\n\n  publish:\n    name: Publish charts on GitHub Pages\n    runs-on: ubuntu-20.04\n    needs: build\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: gh-pages\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - uses: actions/download-artifact@v3\n        with:\n          name: helm-charts\n\n      - name: Update charts index\n        run: helm repo index --url https://cybozu-go.github.io/moco/ --merge index.yaml .\n\n      - run: git add .\n\n      - name: Check diffs\n        run: |\n          diffs=$(git status -s)\n          if [ \"$diffs\" = \"\" ]; then\n            echo \"NO_DIFF=1\" >> $GITHUB_ENV\n          else\n            printf \"%s\\n\" \"$diffs\"\n          fi\n      - name: Commit changes\n        if: env.NO_DIFF != '1'\n        run: |\n          git config --global user.name 'Cybozu Neco'\n          git config --global user.email 'cybozu-neco@users.noreply.github.com'\n          git commit -m 'update'\n      - name: Push to gh-pages\n        if: env.NO_DIFF != '1'\n        run: git push origin gh-pages\n```", "prompt": "Generate a GitHub Workflow named `Release Charts` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches chart-v*. The workflow has 2 jobs. The job id of the 1st job is `build`. The 2nd job is named `Publish charts on GitHub Pages` and its job id is `publish`. "}
{"id": "63c495ca8052faa2781b43be", "level": "level1", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Run tests\n        run: |\n          pytest\n```", "answer": "```yaml name: Release\non:\n  push:\n    branches:\n      - master\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: '0'\n      - name: Bump version and push tag\n        id: tagging\n        uses: anothrNick/github-tag-action@1.52.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          INITIAL_VERSION: 1.0.0\n          DEFAULT_BUMP: none\n      -\n        name: \"Set up QEMU\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-qemu-action@v2\n      -\n        name: \"Set up Docker Buildx\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-buildx-action@v2\n      -\n        name: \"Login to DockerHub\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      -\n        name: \"Login to Quay.io\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          registry: quay.io\n          username: ${{ secrets.QUAY_BOT_USERNAME }}\n          password: ${{ secrets.QUAY_BOT_PASSWORD }}\n      -\n        name: \"Build and push\"\n        if: steps.tagging.outputs.part\n        id: docker_build\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          platforms: linux/amd64,linux/arm64,linux/arm/v7,linux/ppc64le,linux/s390x\n          tags: |\n            docker.io/kiwigrid/k8s-sidecar:latest\n            docker.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n            quay.io/kiwigrid/k8s-sidecar:latest\n            quay.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n      - name: \"Build Changelog\"\n        if: steps.tagging.outputs.part\n        id: build_changelog\n        uses: mikepenz/release-changelog-builder-action@v3\n        with:\n          configuration: \".github/workflows/release-notes-config.json\"\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      - name: \"Create Github Release\"\n        if: steps.tagging.outputs.part\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token\n        with:\n          tag_name: ${{ steps.tagging.outputs.tag }}\n          release_name: v${{ steps.tagging.outputs.tag }}\n          body: ${{ steps.build_changelog.outputs.changelog }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c494007843b612699fe516", "level": "level1", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  repository_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n    - name: Run make\n      run: make\n\n  bazel:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n    - name: Install Bazel\n      run: |\n        echo -e \"deb [arch=amd64] https://storage.googleapis.com/bazel-apt stable jdk1.8\" | sudo tee /etc/apt/sources.list.d/bazel.list\n        curl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -\n        sudo apt-get update\n        sudo apt-get install bazel\n    - name: Run Bazel\n      run: bazel build //...\n```", "answer": "```yaml name:\n  Test\n\non:\n  push\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-20.04\n    strategy:\n      matrix:\n        py: [\"3.7\"]\n        pylint: [\"==2.9.6\"]\n        go: [ \"1.18\", \"1.19\" ]\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.py }}\n    - name: Install pylint\n      run: pip install --user pylint${{ matrix.pylint }}\n    - name: pylint\n      run: |\n        pylint adapters/python/martian_shell.py\n        pylint adapters/python/martian.py\n        pylint test/martian_test.py\n    - uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n    - uses: actions/setup-node@v3\n      with:\n        node-version: \"lts/*\"\n        cache: \"npm\"\n        cache-dependency-path: |\n          web/martian/yarn.lock\n          tools/syntax/vscode/yarn.lock\n    - name: make all\n      run: make all tarball\n    - name: darwin build\n      run: GOOS=darwin go build ./cmd/...\n    - name: Integration tests\n      run: make longtests\n\n  bazel:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: \"3.x\"\n    - uses: actions/setup-go@v3\n      id: setup_go\n      with:\n        go-version: \">=1.19\"\n    - name: Show bazel variables\n      run: |\n        bazel info\n        echo \"bazel_repository_cache=$(bazel info repository_cache)\" >> $GITHUB_ENV\n        echo \"bazel_output_base=$(bazel info output_base)\" >> $GITHUB_ENV\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_output_base }}/external\n        key: bazel-build-cache-${{steps.setup_go.outputs.go-version}}-${{hashFiles('deps.bzl', 'WORKSPACE')}}\n        restore-keys: |\n          bazel-build-cache-${{steps.setup_go.outputs.go-version}}\n          bazel-build-cache-\n    - name: Cache bazel external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_repository_cache }}\n        key: bazel-repo-cache-${{hashFiles('deps.bzl', 'WORKSPACE', 'web/martian/yarn.lock')}}\n        restore-keys: |\n          bazel-repo-cache-\n    - name: test\n      run: |\n        bazel test --nobuild_tests_only \\\n                   --verbose_failures \\\n                   --discard_analysis_cache \\\n                   --notrack_incremental_state \\\n                   --nokeep_state_after_build \\\n                   //...\n    - name: Show build timing summary\n      run: bazel analyze-profile ${{ env.bazel_output_base }}/command.profile.gz\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `make`. The job id of the 2nd job is `bazel`. "}
{"id": "63c494257843b612699ff4b7", "level": "level1", "llm_response": "```yaml\nname: functional-identity\n\non:\n  pull_request:\n    paths:\n      - 'identity/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-identity:\n    id: functional-identity\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        name: [openstack-keystone]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Run identity acceptance tests\n        run: go test -v ./identity/acceptance\n```", "answer": "```yaml name: functional-identity\non:\n  pull_request:\n    paths:\n      - '**identity**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-identity:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: \"^.*identity.*$\"\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-identity-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-identity` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**identity**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests` and its job id is `functional-identity`. "}
{"id": "63c495038052faa2781aede6", "level": "level1", "llm_response": "```yaml\nname: Linux Testing\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Run tests\n        run: |\n          python -m unittest discover\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n        numpy_version: ['>=1.22.0', '==1.20.*']\n        exclude:\n          - python-version: '3.10'\n            numpy_version: '==1.20.*'\n    services:\n      redis:\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n      mongodb:\n        image: mongo:4.4.11\n        ports:\n          - 27017:27017\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Setup Miniconda\n      uses: conda-incubator/setup-miniconda@master\n      with:\n          channels: conda-forge\n          python-version: ${{ matrix.python-version }}\n      env:\n        ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n    # Runs a set of commands using the runners shell\n    - name: Create Conda environment with the rights deps\n      shell: \"bash -l {0}\"\n      run: |\n        conda create -n zarr-env python==${{matrix.python-version}} bsddb3 numcodecs lmdb pip nodejs flake8 mypy\n        conda activate zarr-env\n        npm install -g azurite\n    - name: Install dependencies\n      shell: \"bash -l {0}\"\n      run: |\n        conda activate zarr-env\n        python -m pip install --upgrade pip\n        python -m pip install -U pip setuptools wheel codecov line_profiler\n        python -m pip install -rrequirements_dev_minimal.txt numpy${{matrix.numpy_version}} -rrequirements_dev_optional.txt pymongo redis\n        python -m pip install .\n        python -m pip freeze\n    - name: Tests\n      shell: \"bash -l {0}\"\n      env:\n        COVERAGE_FILE: .coverage.${{matrix.python-version}}.${{matrix.numpy_version}}\n        ZARR_TEST_ABS: 1\n        ZARR_TEST_MONGO: 1\n        ZARR_TEST_REDIS: 1\n        ZARR_V3_EXPERIMENTAL_API: 1\n      run: |\n        conda activate zarr-env\n        mkdir ~/blob_emulator\n        azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n        pytest --cov=zarr --cov-config=.coveragerc --doctest-plus --cov-report xml --cov=./ --timeout=300\n    - uses: codecov/codecov-action@v3\n      with:\n        #token: ${{ secrets.CODECOV_TOKEN }} # not required for public repos\n          #files: ./coverage1.xml,./coverage2.xml # optional\n          #flags: unittests # optional\n          #name: codecov-umbrella # optional\n          #fail_ci_if_error: true # optional (default = false)\n        verbose: true # optional (default = false)\n```", "prompt": "Generate a GitHub Workflow named `Linux Testing` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c4967e33b087f6bde2c5c4", "level": "level1", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Build project\n      run: npm run build\n\n    - name: Deploy to production\n      run: npm run deploy\n```", "answer": "```yaml name: Build and Deploy\non:\n  push:\n    branches:\n    - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n        \n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install\n          npm run build\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.0.0\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist #  The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build-and-deploy`. "}
{"id": "63c496926fc19abdf9c9cd93", "level": "level1", "llm_response": "```yaml\nname: Contributor License Agreement (CLA)\n\non:\n  pull_request:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n\n      - name: Install dependencies\n        run: bundle install\n\n      - name: Check CLA\n        run: bundle exec cla-checker check\n```", "answer": "```yaml name: Contributor License Agreement (CLA)\n\non:\n  pull_request_target:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    if: |\n      (github.event.issue.pull_request \n        && !github.event.issue.pull_request.merged_at\n        && contains(github.event.comment.body, 'signed')\n      ) \n      || (github.event.pull_request && !github.event.pull_request.merged)\n    steps:\n      - uses: Shopify/shopify-cla-action@v1\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          cla-token: ${{ secrets.CLA_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Contributor License Agreement (CLA)` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) a pull request is created or a pull request's head branch is updated. 2) a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `cla`. "}
{"id": "63c496836fc19abdf9c9c720", "level": "level1", "llm_response": "```yaml\nname: TagBot\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Julia\n        uses: julia-actions/setup-julia@v1\n        with:\n          version: '1.6'\n\n      - name: Run TagBot script\n        run: |\n          # Add your TagBot script here\n```", "answer": "```yaml name: TagBot\non:\n  schedule:\n    - cron: 0 0 * * *\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `TagBot`. "}
{"id": "63c496741e3364807577abc2", "level": "level1", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [created]\n  pull_request:\n    types: [created]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Julia\n        uses: julia-actions/setup-julia@v1\n        with:\n          version: '1.6'\n      - name: Run TagBot\n        run: |\n          # Add your TagBot logic here\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. "}
{"id": "63c495f37843b61269a0b108", "level": "level1", "llm_response": "```yaml\nname: PR Approval Bypass Notifier\n\non:\n  pull_request:\n    branches:\n      - main\n    types:\n      - closed\n\npermissions:\n  pull-requests: read\n\njobs:\n  approval:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Notify PR Approval Bypass\n        run: echo \"PR Approval Bypass Notifier triggered\"\n```", "answer": "```yaml name: PR Approval Bypass Notifier\non:\n  pull_request:\n    types:\n      - closed\n    branches:\n      - main\npermissions:\n  pull-requests: read\njobs:\n  approval:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Fail If No Approval\n        if: ${{ github.event.pull_request.merged }}\n        env:\n          AUTH_HEADER: 'Authorization: token ${{ secrets.GITHUB_TOKEN }}'\n          JSON_HEADER: 'Content-Type: application/json'\n          REVIEWS_URL: 'https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews'\n        run: |\n          curl -sSL -H \"${JSON_HEADER}\" -H \"${AUTH_HEADER}\" \"${REVIEWS_URL}\" \\\n            | jq -e '. | map({user: .user.login, state: .state})\n                       | reduce .[] as $x ({}; .[$x.user] = $x.state)\n                       | to_entries | map(.value)\n                       | contains([\"APPROVED\"]) and (contains([\"CHANGES_REQUESTED\"]) | not)'\n      - name: Slack Notification\n        if: ${{ failure() }}\n        run: |\n          jq --null-input '{ text: \"Oh no! The following PR was merged without approval: w${{github.event.pull_request.html_url}}\" }' \\\n          | curl -sSL -X POST -H 'Content-Type: application/json' -d @- '${{ secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK }}'\n```", "prompt": "Generate a GitHub Workflow named `PR Approval Bypass Notifier` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `approval`. "}
{"id": "63c496561e3364807577a06a", "level": "level1", "llm_response": "```yaml\nname: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '30 17 * * *'\n\nenv:\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run script\n        run: npm run gather-data\n```", "answer": "```yaml name: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"30 17 * * *\"\n#  push:\n#    branches:\n#      - main\n\nenv:\n  # please change to your own config.\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    name: Gather RQ statistical data and write it to google sheet\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n      - run: yarn\n      - run: yarn rq\n```", "prompt": "Generate a GitHub Workflow named `Gather RQ statistical data and write it to google sheet` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 05:30 pm. The workflow sets 11 environment variables to use: `RQ_COOKIE` is set to `${{ secrets.RQ_COOKIE }}`, `RQ_CSRF_TOKEN` is set to `${{ secrets.RQ_CSRF_TOKEN }}`, `RQ_USERID` is set to `${{ secrets.RQ_USERID }}`, `GOOGLE_SHEET_ID` is set to `${{ secrets.GOOGLE_SHEET_ID }}`, `GOOGLE_API_CLIENT_EMAIL` is set to `${{ secrets.GOOGLE_API_CLIENT_EMAIL }}`, `GOOGLE_API_PRIVATE_KEY` is set to `${{ secrets.GOOGLE_API_PRIVATE_KEY }}`, `BARK_KEY` is set to `${{ secrets.BARK_KEY }}`, `GARMIN_USERNAME` is set to `${{ secrets.GARMIN_USERNAME }}`, `GARMIN_PASSWORD` is set to `${{ secrets.GARMIN_PASSWORD }}`, `GARMIN_GLOBAL_USERNAME` is set to `${{ secrets.GARMIN_GLOBAL_USERNAME }}` and `GARMIN_GLOBAL_PASSWORD` is set to `${{ secrets.GARMIN_GLOBAL_PASSWORD }}`. The workflow has one job. The 1st job is named `Gather RQ statistical data and write it to google sheet` and its job id is `build`. "}
{"id": "63c4957d8052faa2781b22a0", "level": "level1", "llm_response": "```yaml\nname: Close stale\n\non:\n  schedule:\n    - cron: '0 1 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Close stale issues\n        run: |\n          gh issue list --state open --since \"30 days ago\" --json number | jq -r '.[].number' | xargs -I {} gh issue edit {} --state closed\n```", "answer": "```yaml # Copyright 2020 The Knative Authors.\n# SPDX-License-Identifier: Apache-2.0\n\n# This file is automagically synced here from github.com/knative-sandbox/knobots\nname: 'Close stale'\n\non:\n  schedule:\n  - cron: '0 1 * * *'\n\njobs:\n\n  stale:\n    uses: knative/actions/.github/workflows/stale.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `Close stale` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 01:00 am. The workflow has one job. The job id of the 1st job is `stale`. "}
{"id": "63c4959f7843b61269a08d83", "level": "level1", "llm_response": "```yaml\nname: CompatHelper\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Julia\n        uses: julia-actions/setup-julia@v1\n        with:\n          version: '1.6'\n      - name: Run CompatHelper\n        run: julia -e 'using CompatHelper; CompatHelper.run()'\n```", "answer": "```yaml name: CompatHelper\n\non:\n  schedule:\n    - cron: '00 00 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: [1.2.0]\n        julia-arch: [x86]\n        os: [ubuntu-latest]\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n      - name: CompatHelper.main()\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          COMPATHELPER_PRIV: ${{ secrets.TAGBOT }}\n        run: julia -e 'using CompatHelper; CompatHelper.main()'\n```", "prompt": "Generate a GitHub Workflow named `CompatHelper` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `CompatHelper`. "}
{"id": "63c494358052faa2781a9de3", "level": "level1", "llm_response": "```yaml\nname: JumpServer repos generic handler\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  release:\n    types: [ created ]\n\njobs:\n  generic_handler:\n    id: generic_handler\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run generic handler\n        run: npm run generic-handler\n```", "answer": "```yaml on: [push, pull_request, release]\n\nname: JumpServer repos generic handler\n\njobs:\n  generic_handler:\n    name: Run generic handler\n    runs-on: ubuntu-latest\n    steps:\n      - uses: jumpserver/action-generic-handler@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.PRIVATE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `JumpServer repos generic handler` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. 3) release activity in the repository occurs. The workflow has one job. The 1st job is named `Run generic handler` and its job id is `generic_handler`. "}
{"id": "63c494998052faa2781ac05b", "level": "level1", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - dev\n  pull_request:\n    branches:\n      - dev\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: javascript\n\n      - name: Perform CodeQL analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ dev ]\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java', 'javascript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://git.io/codeql-language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      run: |\n        cd etc/build\n        npm install workbox-cli@6.3.0 --global\n        ant\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 01:06 pm. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. "}
{"id": "63c494298052faa2781a98fa", "level": "level1", "llm_response": "```yaml\nname: Check test times\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [clone]\n\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up C++ environment\n      uses: actions/setup-cpp@v2\n      with:\n        cpp-version: '10'\n    - name: Run tests\n      run: |\n        make\n        ./test\n    - name: Capture test times\n      run: |\n        ./test --gtest_output=xml:results.xml\n    - name: Upload test times\n      uses: actions/upload-artifact@v2\n      with:\n        name: test-results\n        path: results.xml\n```", "answer": "```yaml name: Check test times\non: [push, pull_request]\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Cache\n      uses: hendrikmuhs/ccache-action@v1.2\n      with:\n        key: linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-${{ hashFiles('**/*.hpp', '**/*.cpp') }}\n        restore-keys: |\n          linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-\n          linux-ci-build-times-${{ github.ref }}-\n          linux-ci-build-times-refs/heads/master-\n          linux-ci-build-times-\n    - name: Setup\n      run: |\n        sudo apt update\n        sudo apt install -y libboost-dev autoconf automake libtool ccache\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"ccache gcc\" CXX=\"ccache g++\" CXXFLAGS=\"-O2 -g0\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,faster.xml:HRF,message -- --faster\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,fast.xml:HRF,message -- --fast\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,all.xml:HRF,message\n    - name: Save test times\n      uses: actions/upload-artifact@v3\n      with:\n        name: test-reports\n        path: ./all.xml\n    - name: Check test times\n      run: |\n        python ./tools/check_test_times.py\n```", "prompt": "Generate a GitHub Workflow named `Check test times` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check-test-times`. "}
{"id": "63c496981899db58864d3f6f", "level": "level1", "llm_response": "```yaml\nname: Re-run Workflow\n\non:\n  workflow_run:\n    workflows: [CI]\n    types: [completed]\n  pull_request:\n    types: [closed, labeled, unlabeled]\n  schedule:\n    - cron: '30 */3 * * *'\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run workflow\n        run: |\n          gh workflow run CI --ref ${{ github.ref }}\n```", "answer": "```yaml name: Re-run Workflow\n\non:\n  workflow_run:\n    workflows:\n      - CI\n    types:\n      - completed\n  pull_request_target:\n    types:\n      - closed\n      - labeled\n      - unlabeled\n  schedule:\n    - cron: '30 */3 * * *' # every 3 hours (30 minutes past the hour)\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    if: >\n      startsWith(github.repository, 'Homebrew/') &&\n      (\n        github.event.label.name == 'ci-requeue' ||\n        github.event.label.name == 'ci-retry' ||\n        github.event.label.name == 'ci-skip-appcast' ||\n        github.event.label.name == 'ci-skip-install' ||\n        github.event.label.name == 'ci-syntax-only' ||\n        !github.event.label.name\n      )\n    runs-on: ubuntu-latest\n    steps:\n      - name: Re-run CI workflow\n        uses: reitermarkus/rerun-workflow@c8d5bc3526acb50c12004f31c0dcb1598c87e32d\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n          once-label: ci-requeue\n          continuous-label: ci-retry\n          trigger-labels: ci-skip-appcast,ci-skip-install,ci-syntax-only\n          workflow: ci.yml\n```", "prompt": "Generate a GitHub Workflow named `Re-run Workflow` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) the workflow named CI is completed. 2) a pull request is closed, a label is added to a pull request or a label is removed from a pull request. 3) the scheduled time has come: at 30 minutes past the hour, every 3 hours. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `rerun-workflow`. "}
{"id": "63c493bc7843b612699fd432", "level": "level1", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n  push:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Lint code\n        run: npm run lint\n\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Build project\n        run: npm run build\n```", "answer": "```yaml env: {}\n\n# FILE GENERATED WITH: npx ghat fregante/ghatemplates/node\n# SOURCE: https://github.com/fregante/ghatemplates\n# OPTIONS: {\"exclude\":[\"jobs.Test\"]}\n\nname: CI\non:\n  - pull_request\n  - push\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n      - name: install\n        run: npm ci || npm install\n      - name: XO\n        run: npx xo\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: install\n        run: npm ci || npm install\n      - name: build\n        run: npm run build\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) a commit or tag is pushed, or a repository is cloned. The workflow has 2 jobs. The job id of the 1st job is `Lint`. The job id of the 2nd job is `Build`. "}
{"id": "63c493f47843b612699fe037", "level": "level1", "llm_response": "```yaml\nname: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Run script to update list of images\n        run: python update_images.py\n```", "answer": "```yaml name: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"0 10 * * *\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        include:\n          - { branch: master, channel: latest/edge }\n          - { branch: 1.24, channel: 1.24 }\n          - { branch: 1.23, channel: 1.23 }\n          - { branch: 1.22, channel: 1.22 }\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ matrix.branch }}\n      - name: Update image list\n        run: |\n          ./build-scripts/update-images.sh ${{ matrix.channel }} build-scripts/images.txt\n      - name: Create pull request\n        uses: peter-evans/create-pull-request@v4\n        with:\n          commit-message: update list of images used by ${{ matrix.channel }}\n          title: \"[${{ matrix.channel }}] Update MicroK8s images\"\n          body: update list of images used by ${{ matrix.channel }}\n          reviewers: neoaggelos,ktsakalozos\n          branch: auto-update-images/${{ matrix.branch }}\n          delete-branch: true\n          base: ${{ matrix.branch }}\n```", "prompt": "Generate a GitHub Workflow named `Update list of images` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `update`. "}
{"id": "63c494368052faa2781a9e20", "level": "level1", "llm_response": "```yaml\nname: build\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - 'v*'\n  pull_request:\n\npermissions:\n  contents: write\n  id-token: write\n  packages: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Build\n        run: go build -v ./...\n```", "answer": "```yaml name: build\n\non:\n  push:\n    branches:\n      - 'main'\n    tags:\n      - 'v*'\n  pull_request:\n\npermissions:\n   contents: write\n   id-token: write\n   packages: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      -\n        name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: 1.17\n      -\n        name: Cache Go modules\n        uses: actions/cache@v3\n        with:\n          path: ~/go/pkg/mod\n          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}\n          restore-keys: |\n            ${{ runner.os }}-go-\n      -\n        name: CI\n        run: |\n          go mod tidy\n          go test -v ./...\n          go build -o tt .\n      - uses: sigstore/cosign-installer@v2.8.1\n      -\n        name: Run GoReleaser\n        uses: goreleaser/goreleaser-action@v3\n        if: success() && startsWith(github.ref, 'refs/tags/')\n        with:\n          distribution: goreleaser-pro\n          version: latest\n          args: release --rm-dist\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n          FURY_TOKEN: ${{ secrets.FURY_TOKEN }}\n          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}\n          TWITTER_CONSUMER_KEY: ${{ secrets.TWITTER_CONSUMER_KEY }}\n          TWITTER_CONSUMER_SECRET: ${{ secrets.TWITTER_CONSUMER_SECRET }}\n          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}\n          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}\n          COSIGN_PWD: ${{ secrets.COSIGN_PWD }}\n          AUR_KEY: ${{ secrets.AUR_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a tag whose name matches v*. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope, write access is granted to the GITHUB_TOKEN in the `id-token` scope and write access is granted to the GITHUB_TOKEN in the `packages` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c493b77843b612699fd355", "level": "level1", "llm_response": "```yaml\nname: docs\n\non:\n  push:\n    branches:\n      - develop\n      - release\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n    branches:\n      - develop\n      - release\n\nconcurrency:\n  group: docs\n  cancel-in-progress: true\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install mkdocs\n\n      - name: Build documentation\n        run: mkdocs build\n\n      - name: Deploy documentation\n        run: |\n          # Add deployment steps here\n```", "answer": "```yaml name: docs\n\nconcurrency: docs\n\non:\n  push:\n    branches: [ develop, release ]\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Track Docs Branch\n      run: git branch docs -t origin/docs\n    - uses: actions/setup-python@v4\n      with:\n        python-version: 3.x\n    - uses: actions/cache@v3\n      with:\n        key: ${{ github.ref }}\n        path: .cache\n    - uses: pnpm/action-setup@v2.2.2\n      with:\n        version: 7\n    - name: Lint Docs\n      run: |\n        pnpm i\n        pnpm lint\n    - name: Update pip\n      run: python -m pip install -U pip setuptools\n    - name: Set Git author\n      run: |\n        git config user.name \"github-actions[bot]\"\n        git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n    - name: Install native dependencies\n      run: sudo apt-get install libcairo2-dev libfreetype6-dev libffi-dev libjpeg-dev libpng-dev libz-dev\n    - name: Install wheel\n      run: pip install wheel\n    - name: Install Material for MkDocs Insiders\n      run: pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git\n      if: ${{ github.repository_owner == 'mastercomfig' && github.event_name != 'pull_request' }}\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Install dependencies\n      run: pip install -r docs/requirements.txt\n    - name: Update from Remote\n      run: git fetch --tags -f\n    - name: Build docs (latest)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/release' }}\n      run: mike deploy --alias-type copy -b docs -up $(git describe --tags --abbrev=0) latest page\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs (develop)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/develop' }}\n      run: mike deploy --alias-type copy -b docs -p dev\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs\n      if: ${{ github.event_name == 'pull_request' }}\n      run: mike deploy --config-file mkdocs.base.yml -u $(git describe --tags) latest\n```", "prompt": "Generate a GitHub Workflow named `docs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named develop or a branch named release. Only if at least one path of push event matches a pattern in the paths filter(docs/**, mkdocs.yml or .github/workflows/docs.yml), the workflow runs. 2) there is activity relating to a pull request. Only a single workflow using the docs concurrency group will run at a time. The workflow has one job. The job id of the 1st job is `deploy`. "}
{"id": "63c495a68052faa2781b342a", "level": "level1", "llm_response": "```yaml\nname: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches:\n      - master\n      - 1.x\n      - release\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Build with Maven\n        run: mvn clean deploy -DskipTests\n\n      - name: Deploy to Maven Central\n        run: mvn deploy:deploy-file -Dfile=target/my-artifact-1.0-SNAPSHOT.jar -DgroupId=com.example -DartifactId=my-artifact -Dversion=1.0-SNAPSHOT -Dpackaging=jar -DrepositoryId=maven-central -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/\n        env:\n          MAVEN_USERNAME: ${{ secrets.MAVEN_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.MAVEN_PASSWORD }}\n```", "answer": "```yaml name: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches: [master, 1.x, release]\n\njobs:\n  release:\n    if: github.repository == 'jdbc-observations/datasource-proxy'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Maven Central Repository\n        uses: actions/setup-java@v3\n        with:\n          java-version: 8\n          distribution: temurin\n          server-id: ossrh\n          server-username: MAVEN_USERNAME\n          server-password: MAVEN_PASSWORD\n          gpg-private-key: ${{ secrets.MAVEN_GPG_PRIVATE_KEY }}\n          gpg-passphrase: MAVEN_GPG_PASSPHRASE\n      - name: Publish package\n        run: ./mvnw --batch-mode deploy -DskipTests=true -Pgithub-ossrh\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}\n          MAVEN_GPG_PASSPHRASE: ${{ secrets.MAVEN_GPG_PASSPHRASE }}\n\n```", "prompt": "Generate a GitHub Workflow named `Release to Maven Central (Deploy Snapshot or Stage Release)` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master, a branch named 1.x or a branch named release. The workflow has one job. The job id of the 1st job is `release`. "}
{"id": "63c494257843b612699ff4be", "level": "level1", "llm_response": "```yaml\nname: functional-orchestration\n\non:\n  pull_request:\n    paths:\n      - 'orchestration/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-orchestration:\n    id: functional-orchestration\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        name: [openstack-heat]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n      - name: Install dependencies\n        run: go mod tidy\n      - name: Run orchestration acceptance tests\n        run: go test -v ./orchestration/acceptance\n```", "answer": "```yaml name: functional-orchestration\non:\n  pull_request:\n    paths:\n      - '**orchestration**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-orchestration:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n          conf_overrides: |\n            enable_plugin heat https://opendev.org/openstack/heat ${{ matrix.openstack_version }}\n          enabled_services: 'h-eng,h-api,h-api-cfn,h-api-cw'\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: ^.*orchestration.*$\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-orchestration-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-orchestration` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**orchestration**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests` and its job id is `functional-orchestration`. "}
{"id": "63c495167843b61269a0553c", "level": "level1", "llm_response": "```yaml\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Set up JDK 11\n      uses: actions/setup-java@v2\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n\n    - name: Add issue to DEPR project board\n      run: |\n        gh project column-item add --project-url <project-url> --column-id <column-id> --issue-number ${{ github.event.issue.number }}\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml # Run the workflow that adds new tickets that are either:\n# - labelled \"DEPR\"\n# - title starts with \"[DEPR]\"\n# - body starts with \"Proposal Date\" (this is the first template field)\n# to the org-wide DEPR project board\n\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    uses: openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master\n    secrets:\n      GITHUB_APP_ID: ${{ secrets.GRAPHQL_AUTH_APP_ID }}\n      GITHUB_APP_PRIVATE_KEY: ${{ secrets.GRAPHQL_AUTH_APP_PEM }}\n      SLACK_BOT_TOKEN: ${{ secrets.SLACK_ISSUE_BOT_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Add newly created DEPR issues to the DEPR project board` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `routeissue`. "}
{"id": "63c495e88052faa2781b50cc", "level": "level1", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [created]\n  pull_request:\n    types: [created]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Julia\n        uses: julia-actions/setup-julia@v1\n        with:\n          version: '1.6'\n      - name: Run TagBot script\n        run: |\n          # Add your TagBot script here\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. "}
{"id": "63c496876fc19abdf9c9c8bb", "level": "level1", "llm_response": "```yaml\nname: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: '*/30 * * * *'\n\njobs:\n  build-feeds:\n    id: build-feeds\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run build script\n        run: npm run build\n\n      - name: Publish feed resources\n        run: npm run publish\n```", "answer": "```yaml name: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: \"*/30 * * * *\"\n\njobs:\n  build-feeds:\n    name: Update latest feed data from source repo\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n      - name: Install Dependencies\n        run: yarn\n      - name: Checkout Data Source Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n        with:\n          repository: smartcontractkit/reference-data-directory\n          path: data-source\n          token: ${{ secrets.GH_API_KEY }}\n      # - name: Read Data Source\n      #   run: cat data-source/package.json\n      - name: Process Data\n        run: yarn process\n      - name: Deploy to Firebase\n        uses: w9jds/firebase-action@94389a881adad57284e35860f5d258ab262dcd91\n        with:\n\n          args: -c firebase-addresses.json deploy --only hosting\n        env:\n          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n          PROJECT_ID: cl-docs-addresses\n```", "prompt": "Generate a GitHub Workflow named `Build and Publish Feed Resources` for a GitHub repository whose primary programming language is Solidity. This workflow will be triggered by an event: the scheduled time has come: every 30 minutes. The workflow has one job. The 1st job is named `Update latest feed data from source repo` and its job id is `build-feeds`. "}
{"id": "63c494298052faa2781a98f7", "level": "level1", "llm_response": "```yaml\nname: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  build: ${{ github.workspace }}/build\n\njobs:\n  Analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up MSVC\n        uses: microsoft/setup-msvc@v1\n        with:\n          version: 'latest'\n\n      - name: Create build directory\n        run: mkdir -p ${{ env.build }}\n\n      - name: Run code analysis\n        run: |\n          cd ${{ env.build }}\n          cmake .. -G \"Visual Studio 16 2019\"\n          cmake --build . --config Release --target code-analysis\n```", "answer": "```yaml name: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  # Path to the CMake build directory.\n  build: '${{ github.workspace }}/build'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: windows-2022\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup\n        run: |\n          $Url = \"https://boostorg.jfrog.io/artifactory/main/release/1.75.0/binaries/boost_1_75_0-msvc-14.2-64.exe\"\n          (New-Object System.Net.WebClient).DownloadFile($Url, \"$env:TEMP\\boost.exe\")\n          Start-Process -Wait -FilePath \"$env:TEMP\\boost.exe\" \"/SILENT\",\"/SP-\",\"/SUPPRESSMSGBOXES\",\"/DIR=C:\\local\\boost-1.75.0\"\n\n      - name: Configure CMake\n        env:\n          BOOST_ROOT: C:\\local\\boost-1.75.0\n        run: cmake -B ${{ env.build }} -DQL_USE_STD_CLASSES=ON\n\n      - name: Initialize MSVC Code Analysis\n        uses: microsoft/msvc-code-analysis-action@v0.1.1\n        # Provide a unique ID to access the sarif output path\n        id: run-analysis\n        env:\n          CAExcludePath: C:\\local\\boost-1.75.0\n        with:\n          cmakeBuildDirectory: ${{ env.build }}\n          buildConfiguration: Release\n          ruleset: '${{ github.workspace }}/.msvc-analysis.ruleset'\n\n      - name: Upload SARIF to GitHub\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: ${{ steps.run-analysis.outputs.sarif }}\n\n      - name: Upload SARIF as an Artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: sarif-file\n          path: ${{ steps.run-analysis.outputs.sarif }}\n\n```", "prompt": "Generate a GitHub Workflow named `Microsoft C++ Code Analysis` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow sets an environment variable to use: `build` is set to `${{ github.workspace }}/build`. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. "}
{"id": "63c494a48052faa2781ac54a", "level": "level1", "llm_response": "```yaml\nname: cspell-action\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Install cspell\n        run: npm install -g cspell\n\n      - name: Run cspell\n        run: cspell .\n```", "answer": "```yaml name: cspell-action\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: streetsidesoftware/cspell-action@v2\n```", "prompt": "Generate a GitHub Workflow named `cspell-action` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `cspell`. "}
{"id": "63c495197843b61269a056bc", "level": "level1", "llm_response": "```yaml\nname: Code Scanning - Action\n\non:\n  pull_request:\n    branches:\n      - dev\n      - master\n\njobs:\n  CodeQL-Build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Build the Go application\n        run: go build -v ./...\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n\n      - name: Perform CodeQL analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml name: \"Code Scanning - Action\"\n\non:\n  pull_request:\n    branches: [dev, master]\n    types: [opened, synchronize]\n\njobs:\n  CodeQL-Build:\n    # CodeQL runs on ubuntu-latest, windows-latest, and macos-latest\n    runs-on: ubuntu-latest\n\n    permissions:\n      # required for all workflows\n      security-events: write\n\n      # only required for workflows in private repositories\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      # Initializes the CodeQL tools for scanning.\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n        # Override language selection by uncommenting this and choosing your languages\n        # with:\n        #   languages: go, javascript, csharp, python, cpp, java\n\n      # Autobuild attempts to build any compiled languages (C/C++, C#, or Java).\n      # If this step fails, then you should remove it and run the build manually (see below).\n      # - name: Autobuild\n      #   uses: github/codeql-action/autobuild@v2\n\n      # \u2139\ufe0f Command-line programs to run using the OS shell.\n      # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n      # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following\n      #    three lines and modify them (or add more) to build your code if your\n      #    project uses a compiled language\n\n      #- run: |\n      #     make bootstrap\n      #     make release\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `Code Scanning - Action` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created or a pull request's head branch is updated. The workflow would run whenever there is a pull_request event targeting: a branch named dev or a branch named master. The workflow has one job. The job id of the 1st job is `CodeQL-Build`. "}
{"id": "63c495547843b61269a06e8e", "level": "level1", "llm_response": "```yaml\nname: Build and Release [Manual]\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      \n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      \n      - name: Install dependencies\n        run: npm install\n      \n      - name: Build project\n        run: npm run build\n      \n      - name: Release\n        run: echo \"Release triggered manually\"\n```", "answer": "```yaml name: Build and Release [Manual]\n\non: [workflow_dispatch]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    if: github.actor == 'ayuhito'\n\n    steps:\n      - name: checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: \"0\"\n\n      - name: Enable PNPM\n        uses: pnpm/action-setup@v2\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"16\"\n          cache: \"pnpm\"\n\n      - name: Install\n        run: pnpm install --frozen-lockfile\n\n      - name: Install\n        run: pnpm i\n\n      - name: Fetch API # Calls Google Font Metadata to fetch the latest data from Google's Developer API\n        run: pnpm --filter scripts exec gfm generate $GOOGLE_API_KEY\n        env:\n          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}\n\n      - name: Parse API # Process generated API data\n        run: pnpm --filter scripts exec gfm parse\n\n      - name: Build fonts # Build all updated Google Fonts in repository\n        run: pnpm run build:google\n\n      - name: Generate fontlist # Generate FONTLIST.json and FONTLIST.md\n        run: pnpm run util:fontlist\n\n      - name: Generate Algolia index # Generate Algolia search index for website\n        run: pnpm run util:algolia\n        env:\n          ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }}\n\n      - name: Lint files\n        run: pnpm run lint\n\n      - name: Format files\n        run: pnpm run format\n\n      - name: Stage, commit and push files\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): update packages [Manual]\"\n        continue-on-error: true\n\n      - name: Check font files # Detects if all binaries are downloaded successfully and in the right place\n        run: pnpm run util:run-check\n\n      - name: If error, commit again before publishing\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): resolve file check errors [Manual]\"\n        continue-on-error: true\n\n      - name: Configure CI Git\n        run: |\n          git config --global user.email \"83556432+fontsource-bot@users.noreply.github.com\"\n          git config --global user.name \"fontsource-bot\"\n\n      - name: Publish package # Call mass-publish\n        run: pnpm run deploy:ci\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build and Release [Manual]` for a GitHub repository whose primary programming language is CSS. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c494ee8052faa2781ae44b", "level": "level1", "llm_response": "```yaml\nname: Add PR Deploy Badge\n\non:\n  deployment_status:\n    types: [created]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build project\n        run: npm run build\n\n      - name: Add deploy badge\n        run: |\n          echo \"[![Deploy Status](https://img.shields.io/badge/deploy-${{ github.deployment_status.state }}-blue)](https://github.com/${{ github.repository }}/deployments/${{ github.event.deployment.id }})\" >> README.md\n```", "answer": "```yaml name: Add PR Deploy Badge\n# https://docs.github.com/en/actions/reference/events-that-trigger-workflows\non: [deployment_status]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    permissions:\n      pull-requests: write\n    # only runs this job on successful deploy\n    if: github.event.deployment_status.state == 'success'\n    steps:\n    - name: Kb Pull Request Deployment Badges\n      uses: kibibit/kb-badger-action@v2\n      with:\n        github-token: ${{secrets.GITHUB_TOKEN}}\n        badge-left: demo\n        badge-right: application\n        badge-logo: heroku\n        badge-path: api\n        badge2-left: demo\n        badge2-right: api-docs\n        badge2-color: 85EA2D\n        badge2-logo: swagger\n        badge2-path: api/docs\n```", "prompt": "Generate a GitHub Workflow named `Add PR Deploy Badge` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a new deployment status is created. The workflow has one job. The job id of the 1st job is `badge`. "}
{"id": "63c4968b33b087f6bde2caaa", "level": "level1", "llm_response": "```yaml\nname: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\nenv:\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Setup .NET SDK\n      uses: actions/setup-dotnet@v2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n    - name: Build and publish\n      run: dotnet build --configuration Release --output ./publish\n```", "answer": "```yaml name: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n\nenv:\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  publish:\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.0.2\n        with:\n          submodules: recursive\n\n      - name: Setup .NET Core\n        uses: actions/setup-dotnet@v2.1.0\n        with:\n          dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n      - name: Verify .NET Core\n        run: dotnet --info\n\n      - name: Restore packages in preparation for ASFEnhance publishing\n        run: dotnet restore ASFEnhance -p:ContinuousIntegrationBuild=true --nologo\n\n      - name: Publish ASFEnhance on Windows\n        shell: pwsh\n        run: |\n          $script = \"./build.ps1\";\n          Set-Location ${{ github.workspace }};\n          powershell $script;\n\n      - name: Upload ASFEnhance-zh-Hans\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-zh-Hans\n          path: dist/ASFEnhance-zh-Hans.zip\n\n      - name: Upload ASFEnhance-en-US\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-en-US\n          path: dist/ASFEnhance-en-US.zip\n```", "prompt": "Generate a GitHub Workflow named `AutoBuild-Dev` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) a commit or tag is pushed, or a repository is cloned. The workflow sets an environment variable to use: `DOTNET_SDK_VERSION` is set to `6.0.x`. The workflow has one job. The job id of the 1st job is `publish`. "}
{"id": "63c494b78052faa2781acd9d", "level": "level1", "llm_response": "```yaml\nname: Merge me!\n\non:\n  workflow_run:\n    workflows: [\"Continuous Integration\"]\n    types: [completed]\n\njobs:\n  merge-me:\n    id: merge-me\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Merge code\n        run: |\n          git checkout main\n          git merge ${{ github.event.workflow_run.workflow_run.inputs.branch }}\n          git push origin main\n```", "answer": "```yaml name: Merge me!\n\non:\n  workflow_run:\n    types:\n      - completed\n    workflows:\n      - 'Continuous Integration'\n\njobs:\n  merge-me:\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    name: Merge me!\n    runs-on: ubuntu-latest\n    steps:\n      - name: Merge me!\n        uses: ridedott/merge-me-action@master\n        with:\n          GITHUB_TOKEN: ${{ secrets.DOTTBOTT_TOKEN }}\n    timeout-minutes: 5\n```", "prompt": "Generate a GitHub Workflow named `Merge me!` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: the workflow named Continuous Integration is completed. The workflow has one job. The 1st job is named `Merge me!` and its job id is `merge-me`. "}
{"id": "63c494a37843b61269a027ed", "level": "level1", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: 1.16\n\n      - name: Run tests\n        run: go test -v ./...\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\n\nname: CI\n\njobs:\n  test:\n    ## We want to define a strategy for our job\n    strategy:\n      ## this will contain a matrix of all the combinations\n      ## we wish to test again:\n      matrix:\n        go-version: [1.17.x]\n        platform: [ubuntu-latest, macos-latest, windows-latest]\n\n    ## Defines the platform for each test run\n    runs-on: ${{ matrix.platform }}\n\n    ## the steps that will be run through for each version and platform\n    ## combination\n    steps:\n    ## sets up go based on the version\n    - name: Install Go\n      uses: actions/setup-go@v3.3.0\n      with:\n        go-version: ${{ matrix.go-version }}\n\n    ## checks out our code locally, so we can work with the files\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n\n    ## runs go test ./...\n    - name: Build\n      run: go build ./...\n\n    ## runs go test ./...\n    - name: Test\n      run: go test ./...\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `test`. "}
{"id": "63c493b87843b612699fd399", "level": "level1", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run Release Please\n        uses: release-please/release-please-action@v3\n        with:\n          release-type: javascript\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\nname: release-please\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: GoogleCloudPlatform/release-please-action@v2\n        with:\n          release-type: node\n          package-name: release-please-action\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. "}
{"id": "63c4941e7843b612699ff1f7", "level": "level1", "llm_response": "```yaml\nname: Demo link\n\non:\n  pull_request:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    id: add_demo_link\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Add demo link to PR description\n        run: |\n          echo \"Please add a demo link to your PR description.\" >> $GITHUB_PULL_REQUEST_BODY\n```", "answer": "```yaml name: Demo link\n\non:\n  pull_request_target:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    name: Add demo link to PR description\n    runs-on: ubuntu-latest\n    env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    permissions:\n      pull-requests: write\n    steps:\n      - name: Update PR description\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const pullRequestId = context.payload.pull_request.number\n            const pullRequestBranch = context.payload.pull_request.head.ref\n\n            github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: pullRequestId,\n              body: `\ud83d\udc40 [Visit Preview](https://${pullRequestBranch}--welcome-ui.netlify.app)`\n            });\n```", "prompt": "Generate a GitHub Workflow named `Demo link` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a pull request is created. The workflow has one job. The 1st job is named `Add demo link to PR description` and its job id is `add_demo_link`. "}
{"id": "63c494608052faa2781aabf4", "level": "level1", "llm_response": "```yaml\nname: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n      - name: Check go.mod\n        run: go mod tidy\n```", "answer": "```yaml name: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    name: go.mod check\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - uses: actions/setup-go@c4a742cab115ed795e34d4513e2cf7d472deb55f\n        with:\n          go-version: 1.17\n\n      - name: Check go.mod files\n        shell: bash\n        run: |\n          cd gomod-sync\n          go run main.go check\n```", "prompt": "Generate a GitHub Workflow named `go.mod check` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) there is activity relating to a pull request. The workflow has one job. The 1st job is named `go.mod check` and its job id is `check`. "}
{"id": "63c494be7843b61269a0325c", "level": "level1", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: typescript\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"main\" ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'javascript', 'typescript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 02:25 am, only on thursday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. "}
{"id": "63c494228052faa2781a95a5", "level": "level1", "llm_response": "```yaml\nname: snyk-pr\n\non:\n  pull_request:\n    branches:\n      - master\n\njobs:\n  whitesource:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up .NET Core\n        uses: actions/setup-dotnet@v1\n        with:\n          dotnet-version: '3.1'\n      - name: Run Snyk PR Check\n        run: snyk pr test\n```", "answer": "```yaml name: snyk-pr\non:\n  pull_request:\n    branches:\n      - master\njobs:\n  whitesource:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa' }}\n    steps:\n    - name: checkout\n      uses: actions/checkout@v3\n      with:\n        ref: ${{ github.event.pull_request.head.ref }}\n        fetch-depth: 0\n\n    - name: checkout action\n      uses: actions/checkout@v3\n      with:\n        repository: snowflakedb/whitesource-actions\n        token: ${{ secrets.WHITESOURCE_ACTION_TOKEN }}\n        path: whitesource-actions\n\n    - name: PR\n      uses: ./whitesource-actions/snyk-pr\n      env:\n        PR_TITLE: ${{ github.event.pull_request.title }}\n      with:\n        jira_token: ${{ secrets.JIRA_TOKEN_PUBLIC_REPO }}\n        gh_token: ${{ secrets.GITHUB_TOKEN }}\n        amend: false # true if you want the commit to be amended with the JIRA number\n```", "prompt": "Generate a GitHub Workflow named `snyk-pr` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `whitesource`. "}
{"id": "63c493c37843b612699fd587", "level": "level1", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up TSQL\n        run: |\n          # Add steps to set up TSQL environment if necessary\n\n      - name: Run Release Drafter\n        uses: release-drafter/release-drafter@v5\n        with:\n          config-name: config\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    # branches to consider in the event; optional, defaults to all\n    branches:\n      - main\n  # pull_request event is required only for autolabeler\n  pull_request:\n    # Only following types are handled by the action, but one can default to all as well\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Draft Release\n        uses: release-drafter/release-drafter@v5\n        with:\n          tag_name: vNext\n          release_name: vNext\n          draft: true\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is TSQL. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created, a previously closed pull request is reopened or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `update_release_draft`. "}
{"id": "63c495238052faa2781afbf5", "level": "level1", "llm_response": "```yaml\nname: Greetings\n\non:\n  pull_request:\n  issues:\n\njobs:\n  greeting:\n    runs-on: macos-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Print greeting\n      run: echo \"Hello, world!\"\n```", "answer": "```yaml name: Greetings\n\non: [pull_request, issues]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/first-interaction@v1\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        issue-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to fix your issue ASAP. Make sure that you have read about issue format in the docs'\n        pr-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to review your PR ASAP. Make sure that you have read about requirements to pull requests in the docs'\n```", "prompt": "Generate a GitHub Workflow named `Greetings` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) activity related to an issue occurs. The workflow has one job. The job id of the 1st job is `greeting`. "}
{"id": "63c496956fc19abdf9c9ce1c", "level": "level1", "llm_response": "```yaml\nname: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Check licenses\n        run: npm run check-licenses\n```", "answer": "```yaml name: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    name: Check licenses\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set Node.js 16.x\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16.x\n          cache: npm\n      - run: npm ci\n      - name: Install licensed\n        run: |\n          cd $RUNNER_TEMP\n          curl -Lfs -o licensed.tar.gz https://github.com/github/licensed/releases/download/3.4.4/licensed-3.4.4-linux-x64.tar.gz\n          sudo tar -xzf licensed.tar.gz\n          sudo mv licensed /usr/local/bin/licensed\n      - run: licensed status\n```", "prompt": "Generate a GitHub Workflow named `Licensed` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Check licenses` and its job id is `test`. "}
{"id": "63c494937843b61269a02136", "level": "level1", "llm_response": "```yaml\nname: e2e melange bootstrap + build\n\non:\n  push:\n    branches: [ main ]\n    tags: [ '*' ]\n  pull_request:\n    branches: [ main ]\n  repository:\n    types: [ pushed, cloned ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.17'\n    - name: Bootstrap package\n      run: go mod tidy\n    - name: Build project\n      run: go build -v ./...\n```", "answer": "```yaml name: e2e melange bootstrap + build\n\non:\n  push:\n  pull_request:\n\njobs:\n  build:\n    name: bootstrap package\n    runs-on: ubuntu-latest\n    container:\n      image: alpine:latest\n      options: |\n        --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n\n    steps:\n    - name: Fetch dependencies\n      run: |\n        cat >/etc/apk/repositories <<_EOF_\n        https://dl-cdn.alpinelinux.org/alpine/edge/main\n        https://dl-cdn.alpinelinux.org/alpine/edge/community\n        https://dl-cdn.alpinelinux.org/alpine/edge/testing\n        _EOF_\n\n        apk upgrade -Ua\n        apk add go cosign build-base git bubblewrap\n    - uses: actions/checkout@2541b1294d2704b0964813337f33b291d3f8596b\n    - name: Mark workspace as a safe repository\n      run: git config --global --add safe.directory ${GITHUB_WORKSPACE}\n    - name: Build bootstrap melange tool (stage1)\n      run: make melange\n    - name: Generate a package signing keypair\n      run: |\n        ./melange keygen\n        mv melange.rsa.pub /etc/apk/keys\n    - name: Prepare build workspace for stage2\n      run: |\n        git clone . workspace-stage2/x86_64\n    - name: Build stage2 melange package with bootstrap melange\n      run: ./melange build --pipeline-dir=pipelines/ --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage2/\n    - name: Install stage2 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage2 artifacts to stage2 directory\n      run: |\n        mv packages stage2\n    - name: Verify operation of stage2 melange\n      run: melange version\n    - name: Prepare build workspace for stage3\n      run: |\n        git clone . workspace-stage3/x86_64\n    - name: Build stage3 melange package with stage2 melange\n      run: melange build --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage3/\n    - name: Install stage3 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage3 artifacts to stage3 directory\n      run: |\n        mv packages stage3\n    - name: Ensure melange package is reproducible\n      run: |\n        sha256sum stage2/x86_64/*.apk | sed -e 's:stage2/:stage3/:g' | sha256sum -c\n    - name: Verify operation of stage3 melange\n      run: melange version\n```", "prompt": "Generate a GitHub Workflow named `e2e melange bootstrap + build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `bootstrap package` and its job id is `build`. "}
{"id": "63c495e58052faa2781b4f4c", "level": "level1", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 */6 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install github-issues-stale\n\n      - name: Mark stale issues and pull requests\n        run: |\n          github-issues-stale --repo <owner>/<repo> --days 30 --label \"stale\"\n```", "answer": "```yaml name: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '0 */6 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v6\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        days-before-pr-stale: 14\n        days-before-pr-close: 14\n        stale-pr-label: 'inactive'\n        close-pr-label: 'auto-close'\n        exempt-pr-labels: 'keep-open'\n        stale-pr-message: >\n          This pull request has been inactive for 14 days. \n          If you are finished with your changes, don't forget to sign off. See the [contributor guide](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-write-pull-request-automation?branch=main) for instructions. \n          If this PR is inactive for 14 more days, it will be closed automatically. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n        close-pr-message: >\n          This pull request has been inactive for 28 days. At this time, we are closing the PR.  \n          If you decide to continue working on your change, you can reopen the PR and continue working. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n          \n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: every 6 hours. The workflow has one job. The job id of the 1st job is `stale`. "}
{"id": "63c4951f7843b61269a0593c", "level": "level1", "llm_response": "```yaml\nname: docker-push\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n\n    - name: Build the Docker image\n      run: |\n        GOOS=linux GOARCH=amd64 go build -o myapp .\n\n    - name: Login to Docker Hub\n      uses: docker/login-action@v1\n      with:\n        username: ${{ secrets.DOCKER_USERNAME }}\n        password: ${{ secrets.DOCKER_PASSWORD }}\n\n    - name: Push Docker image\n      uses: docker/build-push-action@v2\n      with:\n        context: .\n        push: true\n        tags: myusername/myapp:latest\n```", "answer": "```yaml name: docker-push\non:\n  push:\n    tags:\n      - \"v*\"\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n\n      - name: docker meta\n        id: meta\n        uses: docker/metadata-action@v4.1.0\n        with:\n          images: fsouza/fake-gcs-server\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n\n      - name: setup qemu\n        uses: docker/setup-qemu-action@v2.1.0\n\n      - name: setup buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2.1.0\n\n      - name: login to docker hub\n        uses: docker/login-action@v2.1.0\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: build and push\n        uses: docker/build-push-action@v3.2.0\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          platforms: linux/amd64,linux/arm64\n```", "prompt": "Generate a GitHub Workflow named `docker-push` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The job id of the 1st job is `build-and-push`. "}
{"id": "63c495407843b61269a06679", "level": "level1", "llm_response": "```yaml\nname: Tests\n\non:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Run tests\n        run: |\n          pytest\n```", "answer": "```yaml name: Tests\n\non:\n- pull_request\n- workflow_dispatch\n\njobs:\n  tests:\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10', '3.11-dev']\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install Linux packages for Qt 5 support\n      run: |\n        sudo apt-get update\n        sudo apt-get install qt5-default\n        sudo apt-get install libxkbcommon-x11-0\n        sudo apt-get install libxcb-icccm4\n        sudo apt-get install libxcb-image0\n        sudo apt-get install libxcb-keysyms1\n        sudo apt-get install libxcb-randr0\n        sudo apt-get install libxcb-render-util0\n        sudo apt-get install libxcb-xinerama0\n      if: matrix.os == 'ubuntu-latest'\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies and local packages\n      run: |\n        python -m pip install .[test]\n    - name: Create clean test directory\n      run: |\n        mkdir testdir\n    - name: Test Traits package\n      uses: GabrielBB/xvfb-action@v1\n      with:\n        working-directory: testdir\n        run: python -m unittest discover -v traits\n```", "prompt": "Generate a GitHub Workflow named `Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `tests`. "}
{"id": "63c495448052faa2781b0abc", "level": "level1", "llm_response": "```yaml\nname: Node Blog CI\n\non:\n  push:\n    branches:\n      - '!release'\n  pull_request:\n    branches:\n      - '!release'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build project\n        run: npm run build\n\n      - name: Run tests\n        run: npm test\n```", "answer": "```yaml name: Node Blog CI\n\non:\n  push:\n    branches-ignore:\n    - release\n  pull_request:\n    branches-ignore:\n    - release\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16.x]\n    steps:\n    - uses: actions/checkout@master\n    - name: Launch MongoDB\n      uses: wbari/start-mongoDB@master\n      with:\n        mongoDBVersion: 5\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@master\n      with:\n        node-version: ${{ matrix.node-version }}\n    - name: yarn install, build, and test\n      run: |\n        yarn install\n        yarn run build\n        yarn run test:cov\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@master\n      with:\n        token: ${{secrets.CODECOV_TOKEN}}\n      env:\n        CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node Blog CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event unless the push event is to: a branch named release. 2) The workflow would run whenever there is a pull_request event unless the pull request is targeting: a branch named release. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c496561899db58864d23cc", "level": "level1", "llm_response": "```yaml\nname: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  mysql:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n      - name: Install dependencies\n        run: |\n          pip install molecule docker\n      - name: Run Molecule\n        run: |\n          molecule test --debug-the ${{ github.event.inputs.debug-the }}\n```", "answer": "```yaml name: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      # Plugins\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  mysql:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: mysql\n      versions: '[5.6, 5.7, \"8.0\", \"galera.3.mysql_wsrep.5.6\", \"galera.4.10.mysql_wsrep.8.0.26\", \"mariadb.10.3\", \"mariadb.10.4\", \"mariadb.10.5\", \"mariadb.10.6\"]'\n```", "prompt": "Generate a GitHub Workflow named `Molecule - MySQL` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.mysql.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/mysql.*/**, roles/mysql/**, plugins/filter/mysql_config.py, plugins/filter/staten.py or plugins/lookup/templates_exclusive.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `mysql`. "}
{"id": "63c495a88052faa2781b34fc", "level": "level1", "llm_response": "```yaml\nname: Build iso from elemental-iso-build as external user\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Build Go application\n        run: go build -o elemental-iso-build .\n\n      - name: Run elemental-iso-build\n        run: ./elemental-iso-build\n```", "answer": "```yaml name: Build iso from elemental-iso-build as external user\n# Test building the iso from an external point of view\n# This tests doesn't clone the repo, just interacts with the script as an external user would do\n# Gets the script only and runs it to see if the building is done properly\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Install Docker\n        uses: docker-practice/actions-setup-docker@v1\n      - name: Install deps\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y mkisofs\n      - name: Build iso from script\n        run: |\n          # Just a simple run to test the build script, no need to upload the generated iso!\n          echo \"TEST\" > config.yaml\n          curl -fsSL https://raw.githubusercontent.com/rancher/elemental/main/.github/elemental-iso-build -o elemental-iso-build\n          chmod +x ./elemental-iso-build\n          ./elemental-iso-build config.yaml\n      - name: Check config was inserted\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Extract config and check against our config\n          isoinfo -x /livecd-cloud-config.yaml -R -i $ISO > livecd-cloud-config.yaml\n          # This checks that the files are the same content\n          cmp config.yaml livecd-cloud-config.yaml\n      - name: Basic sanity checks for ISO\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Check it has eltorito\n          isoinfo -d -i $ISO|grep -q Eltorito\n          # check bootable flag\n          isoinfo -d -i $ISO|grep -q bootable        \n```", "prompt": "Generate a GitHub Workflow named `Build iso from elemental-iso-build as external user` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `deploy`. "}
{"id": "63c495878052faa2781b26e9", "level": "level1", "llm_response": "```yaml\nname: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Close issue\n        run: |\n          echo \"::close-issue::\"\n```", "answer": "```yaml name: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoclose issues\n        uses: arkon/issue-closer-action@v3.4\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          ignoreLabel: do-not-autoclose\n          rules: |\n            [\n              {\n                \"type\": \"title\",\n                \"regex\": \".*<(Source Name|short description)>*\",\n                \"message\": \"You did not fill out the description in the title\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*DELETE THIS SECTION IF YOU HAVE READ AND ACKNOWLEDGED IT.*\",\n                \"message\": \"The acknowledgment section was not removed\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*\\\\* (Aniyomi version|Android version|Device|Name|Link|Extension version): \\\\?.*\",\n                \"message\": \"The requested information was not filled out\"\n              }\n            ]\n```", "prompt": "Generate a GitHub Workflow named `Issue closer` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: an issue is opened, the title or body on an issue is edited or a closed issue is reopened. The workflow has one job. The job id of the 1st job is `autoclose`. "}
{"id": "63c495257843b61269a05b78", "level": "level1", "llm_response": "```yaml\nname: Flatpak dependency updates\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up C++\n        uses: actions/setup-cpp@v2\n        with:\n          cpp-version: '10'\n\n      - name: Run Flatpak dependency checker\n        run: flatpak-builder --check-deps\n```", "answer": "```yaml name: Flatpak dependency updates\non:\n  schedule: # for scheduling to work this file must be in the default branch\n  - cron: \"0 0 * * *\" # run every day\n  workflow_dispatch: # can be manually dispatched under GitHub's \"Actions\" tab \n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-20.04\n\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          # we can't push changes to a fork via a shallow update, we need to clone the full repo\n          fetch-depth: 0\n          # by default when persisting credentials the local git config will use the workflow provided GITHUB_TOKEN, not our own GITHUB_TOKEN env var for the container\n          # we must not use the provided GITHUB_TOKEN, as it will fail to push to the fork since the provided GITHUB_TOKEN is only for the repository where the workflow is running \n          persist-credentials: false\n\n      - uses: docker://ghcr.io/flathub/flatpak-external-data-checker:latest\n        env:\n          GIT_AUTHOR_NAME: EasyEffects Bot\n          GIT_COMMITTER_NAME: EasyEffects Bot\n          # email sets \"EasyEffects Bot\" user as commit author\n          GIT_AUTHOR_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GIT_COMMITTER_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GITHUB_TOKEN: ${{ secrets.EASYEFFECTS_BOT }}\n        with:\n          args: --update --always-fork util/flatpak/com.github.wwmm.easyeffects.Devel.json\n```", "prompt": "Generate a GitHub Workflow named `Flatpak dependency updates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `flatpak-external-data-checker`. "}
{"id": "63c494a27843b61269a02770", "level": "level1", "llm_response": "```yaml\nname: Doc Site\n\non:\n  push:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  build-and-deploy-site:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build the site\n        run: npm run build\n\n      - name: Deploy the site\n        run: npm run deploy\n```", "answer": "```yaml # This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Doc Site\n\non:\n  push:\n    branches: [master]\n  workflow_dispatch:\n\njobs:\n  build-and-deploy-site:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n\n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install --legacy-peer-deps\n          npm run docs:build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4.2.5\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist/site # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Doc Site` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build-and-deploy-site`. "}
{"id": "63c495bf8052faa2781b3ef6", "level": "level1", "llm_response": "```yaml\nname: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - master\n    paths:\n      - .github/workflows/mol_tree2_lib.yml\n      - tree2/**\n  pull_request:\n  schedule:\n    - cron: '0 7 * * *'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Build project\n        run: npm run build\n```", "answer": "```yaml name: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches: \n      - master\n    paths:\n      - '.github/workflows/mol_tree2_lib.yml'\n      - 'tree2/**'\n  pull_request:\n  schedule:\n    - cron: \"0 7 * * *\"\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    \n    steps:\n    \n    - uses: hyoo-ru/mam_build@master2\n      with:\n        package: mol\n        modules: tree2/lib\n    \n    - uses: JS-DevTools/npm-publish@v1\n      if: ${{ github.ref == 'refs/heads/master' }}\n      with:\n        token: ${{ secrets.NPM_AUTH_TOKEN }}\n        package: ./mol/tree2/lib/-/package.json\n```", "prompt": "Generate a GitHub Workflow named `mol_tree2_lib` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/mol_tree2_lib.yml or tree2/**), the workflow runs. 3) there is activity relating to a pull request. 4) the scheduled time has come: at 07:00 am. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c496361e33648075779191", "level": "level1", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install release-drafter\n\n      - name: Update release draft\n        run: release-drafter\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. "}
{"id": "63c496561899db58864d23d2", "level": "level1", "llm_response": "```yaml\nname: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        default: 'false'\n        type: boolean\n\njobs:\n  ntp:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: |\n          pip install molecule ansible\n\n      - name: Run Molecule tests\n        run: |\n          molecule test\n        env:\n          MOLECULE_DEBUG: ${{ github.event.inputs.debug-the }}\n```", "answer": "```yaml name: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  ntp:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: ntp\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Ntp` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.ntp.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/ntp/** or roles/ntp/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `ntp`. "}
{"id": "63c494847843b61269a01ad6", "level": "level1", "llm_response": "```yaml\nname: Release v1 NPM Package\n\non:\n  workflow_dispatch:\n    inputs:\n      tag-this:\n        description: 'Enter the version for the release tag'\n        required: true\n        type: string\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  merge-to-v1-branch:\n    id: merge-to-v1-branch\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Create release tag\n        run: git tag ${{ github.event.inputs.tag-this }} && git push origin ${{ github.event.inputs.tag-this }}\n\n      - name: Push changes to v1 branch\n        run: git checkout v1 && git merge master && git push origin v1\n```", "answer": "```yaml name: \"Release v1 NPM Package\"\non:\n  workflow_dispatch:\n    inputs:\n      tag:\n        description: |\n          Enter the version for the release tag.\n          Must be larger than last tag.\n          Use patch (0.0.x) for bug fixes.\n          Use minor (0.x.0) for new actions.\n        type: string\n        required: true\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false\njobs:\n  merge-to-v1-branch:\n    name: Create release by rebasing master to v1 and create a new tag\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n          registry-url: 'https://registry.npmjs.org'\n      - run: yarn install\n      - name: Set git name, mail and origin\n        run: |\n          git config --global user.name \"Josef Fr\u00f6hle\"\n          git config --global user.email \"github@josef-froehle.de\"\n          git remote set-url origin https://${{ secrets.BOT_PIPELINE_TOKEN }}@github.com/${{ github.repository }}\n      - name: Checkout v1 branch and merge\n        run: |\n          git checkout v1\n          git merge --ff-only master\n      - name: Generate new tag, push tag and branch\n        run: |\n          yarn run build\n          yarn version --non-interactive --no-git-tag-version --new-version ${{ github.event.inputs.tag }}\n          yarn run changelog\n          yarn run documentation\n          git add -A\n          yarn version --non-interactive --no-git-tag-version --new-version 0.0.0\n          yarn version --non-interactive --new-version ${{ github.event.inputs.tag }}\n          git push\n          git push --tags\n          git checkout master\n          git merge --ff-only v1\n          git push\n          git subtree split --prefix docs -b gh-pages\n          git push -f origin gh-pages:gh-pages\n      - run: yarn publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release v1 NPM Package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: tag-this input represents enter the version for the release tag.\nmust be larger than last tag.\nuse patch (0.0.x) for bug fixes.\nuse minor (0.x.0) for new actions.\n, the data type is string and it must be supplied. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Create release by rebasing master to v1 and create a new tag` and its job id is `merge-to-v1-branch`. "}
{"id": "63c4963f1e3364807577960f", "level": "level1", "llm_response": "```yaml\nname: Validate Gradle Wrapper\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  validation:\n    id: validation\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Kotlin\n      uses: jvm-actions/setup-java@v2\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n\n    - name: Validate Gradle Wrapper\n      run: ./gradlew wrapper --gradle-version=7.0 --refresh-dependencies\n```", "answer": "```yaml name: \"Validate Gradle Wrapper\"\n\non: [ pull_request ]\n\njobs:\n  validation:\n    name: \"Validation\"\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gradle/wrapper-validation-action@v1\n```", "prompt": "Generate a GitHub Workflow named `Validate Gradle Wrapper` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Validation` and its job id is `validation`. "}
{"id": "63c4969cb008460c1df157a0", "level": "level1", "llm_response": "```yaml\nname: Post-release\n\non:\n  release:\n    types: [published, prereleased, edited]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run TypeScript\n        run: npm run build\n```", "answer": "```yaml name: Post-release\non:\n  release:\n    types:\n      - published\n      - edited\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: apexskier/github-release-commenter@v1\n        with:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          comment-template: This is addressed by {release_link}.\n          label-template: released\n```", "prompt": "Generate a GitHub Workflow named `Post-release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published or the details of a release, pre-release, or draft release are edited. The workflow has one job. The job id of the 1st job is `release`. "}
{"id": "63c4946e8052faa2781ab27f", "level": "level1", "llm_response": "```yaml\nname: test\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n  testacc:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: test\npermissions:\n  contents: read\n\non:\n  push:\n    branches:\n    - master\n  pull_request:\n    branches:\n    - master\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        os:\n        - ubuntu-latest\n        - macOS-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-go@v3\n      with:\n        go-version-file: '.go-version'\n        cache: true\n    - name: test\n      run: make test\n  testacc:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        terraform:\n        - 1.0.0\n        - 0.15.5\n        - 0.14.11\n        - 0.13.7\n        - 0.12.31\n    env:\n      TERRAFORM_VERSION: ${{ matrix.terraform }}\n    steps:\n    - uses: actions/checkout@v3\n    - name: docker build\n      run: docker-compose build\n    - name: terraform --version\n      run: docker-compose run --rm tfschema terraform --version\n    - name: testacc\n      run: docker-compose run --rm tfschema make testacc\n```", "prompt": "Generate a GitHub Workflow named `test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `test`. The job id of the 2nd job is `testacc`. "}
{"id": "63c495297843b61269a05d16", "level": "level1", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  golangci:\n    id: golangci\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Run golangci-lint\n        run: go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.42.1\n        shell: bash\n\n      - name: Lint with golangci-lint\n        run: golangci-lint run\n```", "answer": "```yaml name: Lint\n# Lint runs golangci-lint over the entire cosmos-sdk repository\n# This workflow is run on every pull request and push to main\n# The `golangci` will pass without running if no *.{go, mod, sum} files have been changed.\non:\n  pull_request:\n  push:\n    branches:\n      - main\njobs:\n  golangci:\n    name: golangci-lint\n    runs-on: ubuntu-latest\n    timeout-minutes: 8\n    steps:\n      - uses: actions/setup-go@v3\n        with:\n          go-version: 1.18\n      - uses: actions/checkout@v3\n      - uses: technote-space/get-diff-action@v6.1.0\n        with:\n          PATTERNS: |\n            **/**.go\n            go.mod\n            go.sum\n      - uses: golangci/golangci-lint-action@v3.2.0\n        with:\n          version: v1.47.2\n          args: --timeout 10m\n          github-token: ${{ secrets.github_token }}\n        if: env.GIT_DIFF\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The 1st job is named `golangci-lint` and its job id is `golangci`. "}
{"id": "63c4951f7843b61269a0593e", "level": "level1", "llm_response": "```yaml\nname: goreleaser\n\non:\n  push:\n    tags:\n      - '*'\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Run Goreleaser\n        run: goreleaser release --snapshot --rm-dist\n```", "answer": "```yaml name: goreleaser\non:\n  push:\n    tags:\n      - \"*\"\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          fetch-depth: 0\n\n      - name: fetch tags\n        run: git fetch --tags --force\n\n      - uses: actions/setup-go@v3.3.0\n        with:\n          go-version: 1.19\n\n      - uses: goreleaser/goreleaser-action@v3.1.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          distribution: goreleaser\n          version: latest\n          args: release -f ci/.goreleaser.yml\n```", "prompt": "Generate a GitHub Workflow named `goreleaser` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches *. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `release`. "}
{"id": "63c4967e33b087f6bde2c5c1", "level": "level1", "llm_response": "```yaml\nname: Dependabot auto-merge\n\non:\n  pull_request:\n    types: [opened, synchronize]\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Merge Dependabot PRs\n        if: github.event.pull_request.user.login == 'dependabot[bot]'\n        run: |\n          go get github.com/dependabot/dependabot-core/cmd/dependabot-merge\n          dependabot-merge --token ${{ secrets.GITHUB_TOKEN }} --repo ${{ github.repository }} --pr ${{ github.event.pull_request.number }}\n```", "answer": "```yaml ---\nname: Dependabot auto-merge\n\"on\": pull_request\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n    if: ${{ github.actor == 'dependabot[bot]' }}\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        uses: dependabot/fetch-metadata@v1.3.4\n        with:\n          github-token: \"${{ secrets.GITHUB_TOKEN }}\"\n      - name: Enable auto-merge for Dependabot PRs\n        if: >-\n          ${{\n          steps.metadata.outputs.update-type == 'version-update:semver-patch' ||\n          steps.metadata.outputs.update-type == 'version-update:semver-minor'\n          }}\n        run: gh pr merge --auto --merge \"$PR_URL\"\n        env:\n          PR_URL: ${{github.event.pull_request.html_url}}\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n```", "prompt": "Generate a GitHub Workflow named `Dependabot auto-merge` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope and write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `dependabot`. "}
{"id": "63c496326fc19abdf9c9a7c5", "level": "level1", "llm_response": "```yaml\nname: Test CI\n\non:\n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Fennel\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y fennel\n\n    - name: Run tests\n      run: fennel test/test.lua\n```", "answer": "```yaml name: Test CI\n\non: \n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on:   ubuntu-latest\n    container: alpine\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Install requirements\n      run: |\n        apk update && apk upgrade \n        apk add make bash coreutils neovim lua5.4\n        # links lua5.4 -> lua\n        ln -sv /usr/bin/lua5.4           /usr/bin/lua\n        ln -sv /usr/lib/lua5.4/liblua.so /usr/lib/liblua5.4.so\n\n    - name: Install Tangerine\n      run:  make install\n\n    - name: Build Runner\n      run:  make runner\n\n    - name: Run Tests\n      run:  yes | make test\n```", "prompt": "Generate a GitHub Workflow named `Test CI` for a GitHub repository whose primary programming language is Fennel. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) Only if at least one path of push event matches a pattern in the paths filter(lua/**, test/** or .github/**), the workflow runs. The workflow has one job. The job id of the 1st job is `test`. "}
{"id": "63c495207843b61269a059a2", "level": "level1", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up shell\n      uses: actions/setup-shell@v1\n\n    - name: Apply labels to pull request\n      run: |\n        # Add your label application logic here\n        echo \"Applying labels to pull request\"\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler/blob/master/README.md\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/labeler@v4\n      with:\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. "}
{"id": "63c494378052faa2781a9e70", "level": "level1", "llm_response": "```yaml\nname: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches:\n      - main\n    types:\n      - opened\n      - synchronize\n      - reopened\n      - ready_for_review\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n\n      - name: Run lint\n        run: cargo lint\n```", "answer": "```yaml name: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches: [ main ]\n    types: [opened, synchronize, reopened, ready_for_review]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v3\n        with:\n          # Full git history isn't needed to get a proper list of changed files within `super-linter`\n          fetch-depth: 0\n\n      - name: Protobuf format\n        uses: jidicula/clang-format-action@v4.9.0\n        with:\n          clang-format-version: '14'\n  \n      - name: Lint shell, Docker and protobuf\n        uses: github/super-linter/slim@v4\n        env:\n          VALIDATE_ALL_CODEBASE: false\n          DEFAULT_BRANCH: main\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # Select file types to lint. Python and Rust linters are configured separately.\n          VALIDATE_SHELL_SHFMT: true\n          #\n          # disable hadolint \n          # https://github.com/hadolint/hadolint/issues/821\n          # VALIDATE_DOCKERFILE_HADOLINT: true\n          # DOCKERFILE_HADOLINT_FILE_NAME: .github/config/.hadolint.yaml\n          #\n          # Enable after fixing proto lint issues.\n          # VALIDATE_PROTOBUF: true\n```", "prompt": "Generate a GitHub Workflow named `Miscellaneous Lint` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named devnet. 2) a pull request is created, a pull request's head branch is updated, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `lint`. "}
{"id": "63c496561899db58864d23b6", "level": "level1", "llm_response": "```yaml\nname: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      # Add your steps here\n```", "answer": "```yaml name: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      # Plugins\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  docker:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: docker\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Docker` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.docker.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/docker/**, roles/docker/**, plugins/filter/json.py, plugins/filter/staten.py or plugins/lookup/docker_applications.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `docker`. "}
{"id": "63c496851899db58864d36f3", "level": "level1", "llm_response": "```yaml\nname: Test with Pre-commit\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pre-commit\n\n      - name: Run pre-commit\n        run: pre-commit run --all-files\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Test with Pre-commit\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.10\"]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pre-commit\n          pre-commit install-hooks\n      - name: Lint with pre-commit\n        run: pre-commit run --all-files\n```", "prompt": "Generate a GitHub Workflow named `Test with Pre-commit` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c495e58052faa2781b4fae", "level": "level1", "llm_response": "```yaml\nname: Self-assign\n\non:\n  issue_comment:\n    types: [created]\n  pull_request_comment:\n    types: [created]\n\njobs:\n  one:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n    - name: Assign issue or pull request\n      run: |\n        if [ \"$GITHUB_EVENT_NAME\" == \"issue_comment\" ]; then\n          gh issue edit $GITHUB_EVENT_ISSUE_NUMBER --assignee $GITHUB_ACTOR\n        elif [ \"$GITHUB_EVENT_NAME\" == \"pull_request_comment\" ]; then\n          gh pr edit $GITHUB_EVENT_PULL_REQUEST_NUMBER --assignee $GITHUB_ACTOR\n        fi\n```", "answer": "```yaml # Allow users to automatically tag themselves to issues\n\nname: Self-assign\non:\n  issue_comment:\n    types: created\njobs:\n  one:\n    runs-on: ubuntu-latest\n    if: >-\n      (github.event.comment.body == '#take' ||\n       github.event.comment.body == '#self-assign') &&\n       (!github.event.issue.pull_request)\n    steps:\n      - run: |\n          echo \"Assigning issue ${{ github.event.issue.number }} to ${{ github.event.comment.user.login }}\"\n          curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -d '{\"assignees\": [\"${{ github.event.comment.user.login }}\"]}' https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/assignees\n```", "prompt": "Generate a GitHub Workflow named `Self-assign` for a GitHub repository whose primary programming language is Jupyter Notebook. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `one`. "}
{"id": "63c496561899db58864d23c2", "level": "level1", "llm_response": "```yaml\nname: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        default: 'false'\n        type: boolean\n\njobs:\n  java:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Java\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Run Molecule\n        run: |\n          molecule test --all\n        env:\n          DEBUG_THE: ${{ github.event.inputs.debug-the }}\n```", "answer": "```yaml name: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  java:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: java\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Java` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.java.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/java/** or roles/java/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `java`. "}
{"id": "63c4957c8052faa2781b2239", "level": "level1", "llm_response": "```yaml\nname: Add Issues/PRs to TF Provider DevEx team board\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    id: add-content-to-project\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n      - name: Run script to add content to project\n        run: ./add_to_project.sh\n```", "answer": "```yaml # Based on https://github.com/leonsteinhaeuser/project-beta-automations\n\nname: \"Add Issues/PRs to TF Provider DevEx team board\"\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request_target:\n    # NOTE: The way content is added to project board is equivalent to an \"upsert\".\n    # Calling it multiple times will be idempotent.\n    #\n    # See https://securitylab.github.com/research/github-actions-preventing-pwn-requests/\n    #\u00a0to see the reasoning behind using `pull_request_target` instead of `pull_request`\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    name: \"Add Content to project\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Set Issue to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'issues'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.issue.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n      - name: \"Set Pull Request to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'pull_request_target'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.pull_request.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n```", "prompt": "Generate a GitHub Workflow named `Add Issues/PRs to TF Provider DevEx team board` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) an issue is opened or a closed issue is reopened. 2) a pull request is created, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow has one job. The 1st job is named `Add Content to project` and its job id is `add-content-to-project`. "}
{"id": "63c49697b008460c1df15590", "level": "level1", "llm_response": "```yaml\nname: Release\n\non:\n  release:\n    types: [published, prereleased, drafted]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build project\n        run: npm run build\n```", "answer": "```yaml name: Release\n\non:\n  release:\n    types: [published]\n\njobs:\n  release:\n    name: Prepare release\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n\n      # Build\n      - name: Build the file\n        run: |\n          cd /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card\n          npm install\n          npm run build\n\n      # Upload build file to the releas as an asset.\n      - name: Upload zip to release\n        uses: svenstaro/upload-release-action@v1-release\n\n        with:\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          file: /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card/dist/thermostat-dark-card.js\n          asset_name: thermostat-dark-card.js\n          tag: ${{ github.ref }}\n          overwrite: true\n      - name: HACS Action\n        uses: \"hacs/action@main\"\n        with:\n          category: \"plugin\"\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow has one job. The 1st job is named `Prepare release` and its job id is `release`. "}
{"id": "63c4955b8052faa2781b1498", "level": "level1", "llm_response": "```yaml\nname: CI v2\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n      - name: Build\n        run: go build -v ./...\n      - name: Test\n        run: go test -v ./...\n```", "answer": "```yaml name: CI v2\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go: ['1.16']\n    steps:\n    - name: Setup\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Prerequisites\n      run: |\n        sudo apt-get update\n        sudo apt-get -y install libvlc-dev vlc-plugin-base vlc-plugin-video-output vlc-plugin-access-extra\n\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Dependencies\n      working-directory: ./v2\n      run: |\n        go version\n        go get -v -t -d ./...\n        go install golang.org/x/lint/golint@latest\n\n    - name: Lint\n      working-directory: ./v2\n      run: golint -set_exit_status=1 ./...\n\n    - name: Vet\n      working-directory: ./v2\n      run: go vet -unsafeptr=false ./...\n\n    - name: Test\n      working-directory: ./v2\n      run: go test -v -coverprofile=coverage.txt -covermode=atomic ./...\n\n    - name: Coverage\n      uses: codecov/codecov-action@v3\n```", "prompt": "Generate a GitHub Workflow named `CI v2` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c494b87843b61269a03054", "level": "level1", "llm_response": "```yaml\nname: autoupdate\n\non:\n  push:\n    branches-ignore:\n      - version-bump/**\n      - dependabot/**\n      - bot/**\n      - all-contributors/**\n  pull_request:\n    branches-ignore:\n      - version-bump/**\n      - dependabot/**\n      - bot/**\n      - all-contributors/**\n\njobs:\n  autoupdate-for-bot:\n    id: autoupdate-for-bot\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run autoupdate script\n        run: ./scripts/autoupdate.sh\n```", "answer": "```yaml # This action is centrally managed in https://github.com/asyncapi/.github/\r\n# Don't make changes to this file in this repo as they will be overwritten with changes made to the same file in above mentioned repo\r\n\r\n# This workflow is designed to work with:\r\n# - autoapprove and automerge workflows for dependabot and asyncapibot.\r\n# - special release branches that we from time to time create in upstream repos. If we open up PRs for them from the very beginning of the release, the release branch will constantly update with new things from the destination branch they are opened against\r\n\r\n# It uses GitHub Action that auto-updates pull requests branches, whenever changes are pushed to their destination branch.\r\n# Autoupdating to latest destination branch works only in the context of upstream repo and not forks\r\n\r\nname: autoupdate\r\n\r\non:\r\n  push:\r\n    branches-ignore:  \r\n      - 'version-bump/**'\r\n      - 'dependabot/**'\r\n      - 'bot/**'\r\n      - 'all-contributors/**'\r\n\r\njobs:\r\n  autoupdate-for-bot:\r\n    if: startsWith(github.repository, 'asyncapi/')\r\n    name: Autoupdate autoapproved PR created in the upstream\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - name: Autoupdating\r\n        uses: docker://chinthakagodawita/autoupdate-action:v1\r\n        env:\r\n          GITHUB_TOKEN: '${{ secrets.GH_TOKEN_BOT_EVE }}'\r\n          PR_FILTER: \"labelled\"\r\n          PR_LABELS: \"autoupdate\"\r\n          PR_READY_STATE: \"ready_for_review\"\r\n          MERGE_CONFLICT_ACTION: \"ignore\"\r\n```", "prompt": "Generate a GitHub Workflow named `autoupdate` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: The workflow would run whenever there is a push event unless the push event is to: a branch whose name matches version-bump/**, a branch whose name matches dependabot/**, a branch whose name matches bot/** or a branch whose name matches all-contributors/**. The workflow has one job. The 1st job is named `Autoupdate autoapproved PR created in the upstream` and its job id is `autoupdate-for-bot`. "}
{"id": "63c494877843b61269a01c1e", "level": "level1", "llm_response": "```yaml\nname: Prepare Release\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version number'\n        required: true\n        type: string\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set version\n        run: echo \"VERSION=${{ github.event.inputs.version }}\" >> $GITHUB_ENV\n      - name: Print version\n        run: echo \"Preparing release for version $VERSION\"\n```", "answer": "```yaml \nname: Prepare Release\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version Number'\n        required: true\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Push Tag\n      run: | \n            echo \"version is ${{ github.event.inputs.version }}\"\n            git config user.name \"GitHub Actions Bot\"\n            git config user.email \"<>\"\n            sed -i \"/is_master/d\" fxmanifest.lua\n            sed -i \"/^version/c\\version '${{ github.event.inputs.version }}'\" fxmanifest.lua\n            git add .\n            git commit -m \"${{ github.event.inputs.version }}\"\n            git tag -a ${{ github.event.inputs.version }} -m \"Version ${{ github.event.inputs.version }}\"\n            sed -i \"/^version/ais_master 'yes'\" fxmanifest.lua\n            git add .\n            git commit -m \"Update Version\"\n            git push --follow-tags\n```", "prompt": "Generate a GitHub Workflow named `Prepare Release` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: version-this input represents version number and it must be supplied. The workflow has one job. The job id of the 1st job is `create`. "}
{"id": "63c4966d33b087f6bde2bebf", "level": "level1", "llm_response": "```yaml\nname: CodeQL\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    id: analyse\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n      - name: Run CodeQL analysis\n        uses: github/codeql-action/analyze@v1\n```", "answer": "```yaml name: \"CodeQL\"\n\non:\n  workflow_dispatch:\n  push:\n    branches: [main]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [main]\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    name: Analyse\n    runs-on: ubuntu-20.04\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n      with:\n        # We must fetch at least the immediate parents so that if this is\n        # a pull request then we can checkout the head.\n        fetch-depth: 2\n\n    # If this run was triggered by a pull request event, then checkout\n    # the head of the pull request instead of the merge commit.\n    - run: git checkout HEAD^2\n      if: ${{ github.event_name == 'pull_request' }}\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      # Override language selection by uncommenting this and choosing your languages\n      with:\n        languages: go\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) The workflow would run whenever there is a pull_request event targeting: a branch named main. 4) the scheduled time has come: at 05:00 am, only on sunday. The workflow has one job. The 1st job is named `Analyse` and its job id is `analyse`. "}
{"id": "63c496581e3364807577a144", "level": "level1", "llm_response": "```yaml\nname: Remove ALL artifacts\n\non:\n  workflow_dispatch:\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Remove artifacts\n      run: |\n        rm -rf ./artifacts\n```", "answer": "```yaml name: Remove ALL artifacts\n\non:\n  workflow_dispatch: # only manually\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - name: Remove ALL artifacts\n        uses: c-hive/gha-remove-artifacts@v1\n        with:\n          age: '0 days'\n          skip-tags: true\n          skip-recent: 0\n```", "prompt": "Generate a GitHub Workflow named `Remove ALL artifacts` for a GitHub repository whose primary programming language is C. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `remove-all-artifacts`. "}
{"id": "63c494e18052faa2781adf45", "level": "level1", "llm_response": "```yaml\nname: Deploy to GH Pages\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - docs/**\n      - !.github/workflows/deploy-storybook.yml\n      - .storybook/**\n      - .wordpress-org/**\n      - __mocks__/**\n      - __static__/**\n      - bin/**\n      - tests/**\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    id: build-storybook\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build Storybook\n        run: npm run build-storybook\n\n  deploy-gh-pages:\n    id: deploy-gh-pages\n    runs-on: ubuntu-latest\n    needs: build-storybook\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./storybook-static\n```", "answer": "```yaml name: Deploy to GH Pages\n\non:\n  push:\n    # Don't run for irrelevant changes.\n    paths-ignore:\n      - 'docs/**'\n      - '!.github/workflows/deploy-storybook.yml'\n      - '.storybook/**'\n      - '.wordpress-org/**'\n      - '__mocks__/**'\n      - '__static__/**'\n      - 'bin/**'\n      - 'tests/**'\n    branches:\n      - main\n\npermissions:\n  contents: read\n\n# Cancels all previous workflow runs for pull requests that have not completed.\nconcurrency:\n  # The concurrency group contains the workflow name and the (target) branch name.\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    name: Build storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Setup Node\n        uses: actions/setup-node@8c91899e586c5b171469028077307d293428b516\n        with:\n          node-version-file: '.nvmrc'\n          cache: npm\n\n      - name: Install dependencies\n        run: npm ci\n        env:\n          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true\n\n      - name: Build storyook\n        run: npm run storybook:build\n\n      - name: Upload storybook\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: storybook-files\n          path: build/storybook\n\n  deploy-gh-pages:\n    name: Deploy storybook\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write # for Git to git push\n    timeout-minutes: 10\n    needs: [build-storybook]\n    steps:\n      - name: Harden Runner\n        uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n        with:\n          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs\n\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n        with:\n          ref: gh-pages\n          token: ${{ secrets.GOOGLEFORCREATORS_BOT_TOKEN }}\n\n      - name: Download storybook files\n        uses: actions/download-artifact@fb598a63ae348fa914e94cd0ff38f362e927b741\n        with:\n          name: storybook-files\n          path: storybook-files\n\n      - name: Move storybook assets\n        run: |\n          mkdir -p storybook\n          rm -rf storybook/*\n          mv storybook-files/* storybook/\n\n      - name: Commit updates\n        run: |\n          git add .\n          git status\n          git diff --staged --quiet && echo 'No changes to commit; exiting!' && exit 0\n          git commit -m \"Deploy storybook for ${{ github.sha }}\"\n          git pull --rebase --no-edit --quiet\n          git push origin gh-pages\n        env:\n          GIT_AUTHOR_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_AUTHOR_NAME: googleforcreators-bot\n          GIT_COMMITTER_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_COMMITTER_NAME: googleforcreators-bot\n```", "prompt": "Generate a GitHub Workflow named `Deploy to GH Pages` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**, !.github/workflows/deploy-storybook.yml, .storybook/**, .wordpress-org/**, __mocks__/**, __static__/**, bin/** or tests/**), the workflow will not run. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.head_ref || github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `Build storybook` and its job id is `build-storybook`. The 2nd job is named `Deploy storybook` and its job id is `deploy-gh-pages`. "}
{"id": "63c496571899db58864d2453", "level": "level1", "llm_response": "```yaml\nname: Lint Checks\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  contents: read\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install flake8\n      - name: Run lint\n        run: flake8 .\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Run lint\n        run: cargo +stable lint\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Run cargo lock check\n        run: cargo +stable check --locked\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Run cargo doc check\n        run: cargo +stable doc --all --no-deps\n```", "answer": "```yaml # Syntax reference:\n# https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions\n\nname: Lint Checks\npermissions: read-all\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    types: [opened, synchronize]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          persist-credentials: false\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n      - run: pip install flake8\n      - run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude src/external\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Rustfmt check\n        run: (cd src && cargo fmt -- --check)\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Cargo update check\n        run: |\n          # This will return an error if any versions of local crates in the Cargo.lock\n          # are out of date compared to the crate versions in Cargo.toml. This can fail\n          # if the Shadow version is bumped without using Cargo to update the lock file.\n          (cd src && cargo update --locked --workspace)\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Cargo doc check\n        run: |\n          cmake -S . -B build\n          (cd src && RUSTDOCFLAGS='-D warnings' cargo doc)\n```", "prompt": "Generate a GitHub Workflow named `Lint Checks` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `CARGO_TERM_COLOR` is set to `always`. The workflow has 4 jobs. The job id of the 1st job is `lint-python`. The job id of the 2nd job is `lint-rust`. The job id of the 3rd job is `lint-cargo-lock`. The job id of the 4th job is `lint-cargo-doc`. "}
{"id": "63c4956e7843b61269a0794c", "level": "level1", "llm_response": "```yaml\nname: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\njobs:\n  black:\n    id: black\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install black\n      - name: Run Black\n        run: black .\n\n  flake8:\n    id: flake8\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install flake8\n      - name: Run Flake8\n        run: flake8 .\n\n  isort:\n    id: isort\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Run isort\n        run: isort .\n```", "answer": "```yaml name: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\n\njobs:\n  black:\n    runs-on: ubuntu-latest\n    name: Black\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n      - name: Black\n        uses: psf/black@22.3.0  # already includes args \"--check --diff\"\n  flake8:\n    runs-on: ubuntu-latest\n    name: Flake8\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade wheel pip\n          pip install .[lint]\n      - name: Lint examples\n        run: flake8 examples --show-source\n      - name: Lint scripts\n        run: flake8 setup.py docs/conf.py scripts --show-source\n      - name: Lint tests\n        run: flake8 tests --show-source\n      - name: Lint moviepy\n        run: flake8 moviepy --show-source\n  isort:\n    runs-on: ubuntu-latest\n    name: isort\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Check imports\n        run: isort --check-only moviepy tests examples docs/conf.py scripts\n```", "prompt": "Generate a GitHub Workflow named `Code Format Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. The workflow has 3 jobs. The 1st job is named `Black` and its job id is `black`. The 2nd job is named `Flake8` and its job id is `flake8`. The 3rd job is named `isort` and its job id is `isort`. "}
{"id": "63c493ea8052faa2781a7e17", "level": "level1", "llm_response": "```yaml\nname: master\n\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  test:\n    id: test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Run tests\n        run: cargo test\n```", "answer": "```yaml name: master\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0' # 00:00 Sunday\n\njobs:\n\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust: [1.31.0, stable]\n    steps:\n      - uses: actions/checkout@v3\n      - uses: dtolnay/rust-toolchain@master\n        with:\n          toolchain: ${{ matrix.rust }}\n      - run: cargo build\n      - run: ./ci/test_full.sh\n```", "prompt": "Generate a GitHub Workflow named `master` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The 1st job is named `Test` and its job id is `test`. "}
{"id": "63c495668052faa2781b18dd", "level": "level1", "llm_response": "```yaml\nname: release management\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n\n      - name: Update draft release\n        run: |\n          # Add your commands to update the draft release here\n```", "answer": "```yaml name: release management\non:\n  push:\n    branches: [master]\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: toolmantim/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `release management` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `update-draft-release`. "}
{"id": "63c494608052faa2781aac1c", "level": "level1", "llm_response": "```yaml\nname: ASF-ci\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: True\n  DOTNET_NOLOGO: True\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Setup .NET SDK\n      uses: actions/setup-dotnet@v2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Restore dependencies\n      run: dotnet restore\n\n    - name: Build\n      run: dotnet build --configuration Release --no-restore\n\n    - name: Test\n      run: dotnet test --no-build --verbosity normal\n```", "answer": "```yaml name: ASF-ci\n\non: [push, pull_request]\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: true\n  DOTNET_NOLOGO: true\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    strategy:\n      fail-fast: false\n      matrix:\n        configuration: [Debug, Release]\n        os: [macos-latest, ubuntu-latest, windows-latest]\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n      with:\n        submodules: recursive\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v3.0.2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --info\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test ArchiSteamFarm.Tests -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Upload latest strings for translation on Crowdin\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && matrix.configuration == 'Release' && startsWith(matrix.os, 'ubuntu-') }}\n      uses: crowdin/github-action@1.4.16\n      with:\n        crowdin_branch_name: main\n        config: '.github/crowdin.yml'\n        project_id: ${{ secrets.ASF_CROWDIN_PROJECT_ID }}\n        token: ${{ secrets.ASF_CROWDIN_API_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `ASF-ci` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow sets 3 environment variables to use: `DOTNET_CLI_TELEMETRY_OPTOUT` is set to `True`, `DOTNET_NOLOGO` is set to `True` and `DOTNET_SDK_VERSION` is set to `6.0.x`. The workflow has one job. The job id of the 1st job is `main`. "}
{"id": "63c495da7843b61269a0a66e", "level": "level1", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Run tests\n        run: go test -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    strategy:\n      matrix:\n        go:\n          - 1.19\n        os:\n          - ubuntu-20.04\n          - ubuntu-22.04\n          - macos-11\n          - macos-12\n          - windows-2019\n          - windows-2022\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: ${{ matrix.go }}\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `main`. "}
{"id": "63c494247843b612699ff48a", "level": "level1", "llm_response": "```yaml\nname: Rust\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Rust\n      uses: actions-rs/toolchain@v1\n      with:\n        toolchain: stable\n        profile: minimal\n        override: true\n    - name: Build the project\n      run: cargo build --release\n    - name: Run tests\n      run: cargo test --release\n```", "answer": "```yaml name: Rust\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@master\n      - uses: hecrj/setup-rust-action@master\n        with:\n          rust-version: stable\n      - name: Check Cargo availability\n        run: cargo --version\n      - name: Check Rustup default toolchain\n        run: rustup default | grep stable\n      - name: Build without default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check --no-default-features\n      - name: Build with default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check\n```", "prompt": "Generate a GitHub Workflow named `Rust` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c494fd7843b61269a04a9b", "level": "level1", "llm_response": "```yaml\nname: Automatic Releases\n\non:\n  milestone:\n    closed:\n      types: [closed]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up PHP\n        uses: shivammathur/setup-php@v2\n        with:\n          php-version: '7.4'\n\n      - name: Create git tag\n        run: git tag -a v1.0.0 -m \"Release v1.0.0\"\n\n      - name: Create release\n        id: create_release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: v1.0.0\n          release_name: Release v1.0.0\n          draft: false\n          prerelease: false\n\n      - name: Create merge-up PR\n        id: create_pr\n        uses: peter-evans/create-pull-request@v3\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          base: main\n          head: release/v1.0.0\n          commit-message: \"Merge release v1.0.0 into main\"\n```", "answer": "```yaml name: \"Automatic Releases\"\n\non:\n  milestone:\n    types:\n      - \"closed\"\n\njobs:\n  release:\n    name: \"Git tag, release & create merge-up PR\"\n    uses: \"doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0\"\n    secrets:\n      GIT_AUTHOR_EMAIL: ${{ secrets.GIT_AUTHOR_EMAIL }}\n      GIT_AUTHOR_NAME: ${{ secrets.GIT_AUTHOR_NAME }}\n      ORGANIZATION_ADMIN_TOKEN: ${{ secrets.ORGANIZATION_ADMIN_TOKEN }}\n      SIGNING_SECRET_KEY: ${{ secrets.SIGNING_SECRET_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Automatic Releases` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: a milestone is closed. The workflow has one job. The 1st job is named `Git tag, release & create merge-up PR` and its job id is `release`. "}
{"id": "63c4957d8052faa2781b22ad", "level": "level1", "llm_response": "```yaml\nname: nix-build\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main, 'release-v**' ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Rust\n      uses: actions-rs/toolchain@v1\n      with:\n        toolchain: stable\n        profile: minimal\n        override: true\n\n    - name: Build with Nix\n      run: nix-build\n```", "answer": "```yaml name: nix-build\non:\n  pull_request:\n  push:\n    branches: [main, 'release-v**']\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Nix Flakes doesn't work on shallow clones\n          fetch-depth: 0\n      - uses: cachix/install-nix-action@v17\n        with:\n          install_url: https://releases.nixos.org/nix/nix-2.10.3/install\n      - uses: cachix/cachix-action@v10\n        with:\n          name: centrifuge-chain\n          authToken: \"${{ secrets.CACHIX_AUTH_TOKEN }}\"\n      - name: Build centrifuge-chain\n        run: nix build --no-allow-dirty -L```", "prompt": "Generate a GitHub Workflow named `nix-build` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches release-v**. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c4968a6fc19abdf9c9ca16", "level": "level1", "llm_response": "```yaml\nname: conda builds\n\non:\n  pull_request:\n    paths:\n      - conda-environment.yml\n      - .github/workflows/test_conda-build.yml\n  schedule:\n    - cron: '17 22 * * 6'\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install conda\n      - name: Build conda environment\n        run: |\n          conda env create -f conda-environment.yml\n          conda activate myenv\n          conda install -c conda-forge pytest\n      - name: Run tests\n        run: pytest\n```", "answer": "```yaml name: conda builds\n\non:\n  pull_request:\n    paths:\n      - 'conda-environment.yml'\n      - '.github/workflows/test_conda-build.yml'\n  schedule:\n    - cron: '17 22 * * 6'  # Every Saturday at 22:17\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: checkout cylc-flow\n        uses: actions/checkout@v3\n\n      - name: build conda env\n        run: |\n          # write environment file\n          env_file='conda-environment.yml'\n          echo \"  - pip\"  >> \"$env_file\"  # list pip as a dependency\n          echo \"  - pip:\" >> \"$env_file\"  # add a pip section\n          echo \"    - .\"  >> \"$env_file\"  # install cylc-flow (pip install .)\n          cat \"$env_file\"\n          # install environment\n          conda env create \\\n            -f \"$env_file\" \\\n            --prefix cylc-dev\n          . /usr/share/miniconda/etc/profile.d/conda.sh\n          # check cylc-flow was installed correctly\n          conda run --prefix cylc-dev cylc version --long\n\n      - name: check for activate scripts\n        run: |\n          # https://github.com/cylc/cylc-flow/issues/3704#issuecomment-897442365\n          # locate all activate scripts\n          find ./cylc-dev/ -name \"activate.d\" | tee > activates.txt\n          # ignore the conda activate script itself\n          sed -i '/cylc-dev\\/etc\\/conda\\/activate.d/d' activates.txt\n          # check to make sure no packages have contributed new activate scripts\n          # (we rely on having a conda activate-less environment)\n          if [[ $(cat activates.txt | wc -l) -ne 0 ]]; then\n              echo '::error::Found activate scripts in installation.'\n              cat activates.txt >&2\n              exit 1\n          fi\n```", "prompt": "Generate a GitHub Workflow named `conda builds` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(conda-environment.yml or .github/workflows/test_conda-build.yml), the workflow runs. 2) the scheduled time has come: at 10:17 pm, only on saturday. 3) someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `test_conda_install`. "}
{"id": "63c496411e3364807577968e", "level": "level1", "llm_response": "```yaml\nname: Add to project\n\non:\n  issues:\n    types: [opened, transferred]\n\njobs:\n  add-to-project:\n    id: add-to-project\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: Add to project\n\non:\n  issues:\n    types: [opened,transferred]\n\njobs:\n  add-to-project:\n    name: Add issue to project\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/add-to-project@main\n        id: add_project\n        with:\n          project-url: ${{ secrets.PROJECT_PLANNING }}\n          github-token: ${{ secrets.BOT_TOKEN_PROJECT }}\n      - name: Set Team\n        env:\n          GITHUB_TOKEN: ${{ secrets.BOT_TOKEN_PROJECT }}\n        run: |\n          gh api graphql -f query='\n          mutation(\n              $project: ID!\n              $item: ID!\n              $status_field: ID!\n              $status_value: String!\n            )  {\n            updateProjectV2ItemFieldValue(\n              input: {\n               projectId: $project\n                itemId: $item\n                fieldId: $status_field\n                value: { \n                  singleSelectOptionId: $status_value\n                  }\n              }\n            ) {\n              projectV2Item {\n                id\n              }\n            }\n          }' -f project=${{ secrets.PROJECT_PLANNING_ID }} -f item=${{ steps.add_project.outputs.itemId }} -f status_field=${{ secrets.PLANNING_TEAM_FIELD_ID }} -f status_value=ed46988b --silent```", "prompt": "Generate a GitHub Workflow named `Add to project` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: an issue is opened or an issue is transferred to another repository. The workflow has one job. The 1st job is named `Add issue to project` and its job id is `add-to-project`. "}
{"id": "63c494c17843b61269a0331c", "level": "level1", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    branches: [ dev ]\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v1\n        with:\n          languages: 'javascript'\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v1\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"dev\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"dev\" ]\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n    - run: ./mvnw -q -Dmaven.test.skip=true -Dscala.version=2.12.8 -Dscala.binary.version=2.12 clean install || ./mvnw -q -Dmaven.test.skip=true clean install\n  \n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Vue. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 04:20 pm, only on friday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. "}
{"id": "63c496861e3364807577b319", "level": "level1", "llm_response": "```yaml\nname: documentation\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  skip_duplicate_jobs:\n    runs-on: ubuntu-latest\n\n  deploy:\n    runs-on: ubuntu-latest\n```", "answer": "```yaml # adapted from:\n#\n# * base code: https://peterevans.dev/posts/github-actions-how-to-automate-code-formatting-in-pull-requests/\n# * fix push auth: https://github.com/ad-m/github-push-action\n# * checkout PR head commit https://github.com/actions/checkout#checkout-pull-request-head-commit-instead-of-merge-commit\nname: documentation\non:\n  push:\n    branches:\n      - master\njobs:\n  skip_duplicate_jobs:\n    runs-on: ubuntu-latest\n    outputs:\n      should_skip: ${{ steps.skip_check.outputs.should_skip }}\n    steps:\n      - id: skip_check\n        uses: fkirc/skip-duplicate-actions@master\n        with:\n          concurrent_skipping: 'same_content'\n          skip_after_successful_duplicate: 'true'\n          paths: '[\"doc/**\"]'\n  deploy:\n    needs: skip_duplicate_jobs\n    if: ${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2.3.1\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Create output directories\n        run: mkdir -p output/reference\n\n      - name: Copy index.html\n        run: cp website/index.html output/index.html\n\n      - name: Generate reference\n        id: adocbuild\n        uses: tonynv/asciidoctor-action@master\n        with:\n            program: asciidoctor doc/index.adoc -o output/reference/index.html\n\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.1.7\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: output # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `documentation` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has 2 jobs. The job id of the 1st job is `skip_duplicate_jobs`. The job id of the 2nd job is `deploy`. "}
{"id": "63c496496fc19abdf9c9b198", "level": "level1", "llm_response": "```yaml\nname: Run checks\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  go-checks:\n    id: go-checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run Shell checks\n        run: |\n          # Add your Shell checks here\n\n  action-checks:\n    id: action-checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run Shell checks\n        run: |\n          # Add your Shell checks here\n```", "answer": "```yaml on: pull_request\nname: Run checks\njobs:\n  go-checks:\n    name: Run go checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Test Go Modules Vendor\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules_vendored\n    - name: Test Go Modules\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules\n    - name: Test Go Standard\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_standard\n  action-checks:\n    permissions:\n      contents: read\n    name: Run action checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Install dockerfile_lint\n      run: sudo npm i -g dockerfile_lint\n    - name: Lint\n      run: make lint\n    - name: Test\n      run: make test\n    - name: Docker Build\n      run: make build\n    - name: Check all versions\n      run: make docker-check\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Run go checks` and its job id is `go-checks`. The 2nd job is named `Run action checks` and its job id is `action-checks`. "}
{"id": "63c4964f6fc19abdf9c9b3d1", "level": "level1", "llm_response": "```yaml\nname: Package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install setuptools wheel\n      - name: Build package\n        run: python setup.py bdist_wheel\n\n  package-windows:\n    runs-on: windows-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install setuptools wheel\n      - name: Build package\n        run: python setup.py bdist_wheel\n\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install setuptools wheel\n      - name: Build package\n        run: python setup.py bdist_wheel\n```", "answer": "```yaml name: Package\non: [push, pull_request]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    env:\n      PIPENV_VENV_IN_PROJECT: 1\n      PIPENV_IGNORE_VIRTUALENVS: 1\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pipenv\n          pipenv install pyqt5 lxml\n          pipenv run pip install pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pipenv run make qt5py3\n          rm -rf build dist\n      - name: Package LabelImg\n        run: |\n          pipenv run python setup.py py2app\n          open dist/labelImg.app\n      - name: Archive macOS app\n        run: |\n          cd dist/\n          tar czf labelImg.tgz labelImg.app\n      - uses: actions/upload-artifact@v3\n        with:\n          name: macOS artifact\n          path: dist/labelImg.tgz\n  package-windows:\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Windows artifact\n          path: dist/labelImg.exe\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Linux artifact\n          path: dist/labelImg\n```", "prompt": "Generate a GitHub Workflow named `Package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has 3 jobs. The job id of the 1st job is `package-macos`. The job id of the 2nd job is `package-windows`. The job id of the 3rd job is `package-linux`. "}
{"id": "63c495c68052faa2781b4230", "level": "level1", "llm_response": "```yaml\nname: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n\njobs:\n  Issue Handler:\n    id: issueHandler\n    runs-on: windows-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up PowerShell\n        uses: actions/setup-dotnet@v1\n        with:\n          dotnet-version: '6.0'\n      - name: Run PowerShell script\n        run: .\\handle-issue.ps1\n```", "answer": "```yaml name: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n\njobs:\n  issueHandler:\n    runs-on: windows-latest\n    name: Issue Handler\n    steps:\n      - uses: actions/checkout@v3\n      - name: Issue Handler\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: github.event.action == 'opened' || (github.event.action == 'labeled' && contains(github.event.issue.labels.*.name, 'verify'))\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Issues` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: an issue is opened or a label is added to an issue. The workflow has one job. The 1st job is named `Issue Handler` and its job id is `issueHandler`. "}
{"id": "63c494c78052faa2781ad471", "level": "level1", "llm_response": "```yaml\nname: cla\n\non:\n  issues:\n    types: [comment_created]\n  pull_request:\n    types: [opened, closed, edited, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run CLA check\n        run: ./check_cla.sh\n```", "answer": "```yaml name: \"cla\"\non:\n  issue_comment:\n    types: [created]\n  pull_request_target:\n    types: [opened, closed, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Get Team Members\"\n        id: team\n        # github-script, v6.1.0\n        uses: actions/github-script@7a5c598405937d486b0331594b5da2b14db670da\n        with:\n          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n          result-encoding: string\n          script: |\n            const members = await github.paginate(\n              github.rest.orgs.listMembers,\n              { org: \"skalenetwork\" },\n            );\n            return members.map(m => m.login).join(\",\");\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        # Beta Release, v2.1.3-beta\n        uses: cla-assistant/github-action@ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          PERSONAL_ACCESS_TOKEN : ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: 'signatures/version1/cla.json'\n          path-to-document: 'https://skale.network/cla.txt'\n          remote-organization-name: 'skalenetwork'\n          remote-repository-name: cla-sigs\n          allowlist: '${{ steps.team.outputs.result }},*[bot]'\n```", "prompt": "Generate a GitHub Workflow named `cla` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `cla`. "}
{"id": "63c495f07843b61269a0af74", "level": "level1", "llm_response": "```yaml\nname: Acquire activation file\n\non:\n  workflow_dispatch:\n\njobs:\n  activation:\n    id: activation\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Request manual activation file\n        run: echo \"Manual activation file requested\"\n```", "answer": "```yaml \ufeffname: Acquire activation file\non:\n  workflow_dispatch: {}\njobs:\n  activation:\n    name: Request manual activation file\n    runs-on: ubuntu-latest\n    steps:\n      - name: Request manual activation file\n        id: getManualLicenseFile\n        uses: game-ci/unity-request-activation-file@v2\n      - name: Expose as artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: ${{ steps.getManualLicenseFile.outputs.filePath }}\n          path: ${{ steps.getManualLicenseFile.outputs.filePath }}\n```", "prompt": "Generate a GitHub Workflow named `Acquire activation file` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Request manual activation file` and its job id is `activation`. "}
{"id": "63c4967d33b087f6bde2c593", "level": "level1", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n    paths-ignore:\n      - assets/**\n      - .vscode/**\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run tests\n        run: npm test\n\n  deploy-site:\n    id: deploy-site\n    runs-on: ubuntu-latest\n    needs: check\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build site\n        run: npm run build\n\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./dist\n```", "answer": "```yaml name: Release\n\non:\n  push:\n    paths-ignore:\n      - 'assets/**'\n      - '.vscode/**'\n    branches:\n      - master\n\njobs:\n  check:\n    name: Run checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Check\n        run: yarn check\n\n      - name: Lint\n        run: yarn lint\n\n      - name: Test\n        run: yarn test\n\n  deploy-site:\n    name: Deploy site\n    runs-on: ubuntu-latest\n    environment: github-pages\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Build Site\n        shell: bash\n        run: |\n          yarn --cwd apps/site ci:build\n\n      - name: Deploy Website\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./apps/site/out\n          cname: tamagui.dev\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. When all the path names of push event match patterns in the paths-ignore filter(assets/** or .vscode/**), the workflow will not run. The workflow has 2 jobs. The 1st job is named `Run checks` and its job id is `check`. The 2nd job is named `Deploy site` and its job id is `deploy-site`. "}
{"id": "63c495418052faa2781b099b", "level": "level1", "llm_response": "```yaml\nname: 60 Days Stale Check\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      \n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      \n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      \n      - name: Check for stale issues\n        run: |\n          python check_stale_issues.py\n```", "answer": "```yaml name: 60 Days Stale Check\non:\n  schedule:\n    - cron: '00 00 * * *' # Run each day at 00:00 UTC\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/stale@v3.0.14\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          stale-issue-message: 'This issue is stale because it has been open 60 days with no activity.'\n          stale-pr-message: 'This PR is stale because it has been open 60 days with no activity.'\n          days-before-stale: -1 # 60 days before marking anything stale - Turned off\n          days-before-close: -1 # Do not close anything automatically\n          stale-issue-label: 'stale'\n          stale-pr-label: 'stale'\n          exempt-pr-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n          exempt-issue-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n```", "prompt": "Generate a GitHub Workflow named `60 Days Stale Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `stale`. "}
{"id": "63c496731e3364807577abab", "level": "level1", "llm_response": "```yaml\nname: Automatically crawl CVEs\n\non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n  schedule:\n    - cron: '15 * * * *'\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Run the script\n        run: python crawl_cves.py\n```", "answer": "```yaml name: Automatically crawl CVEs \non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n    branches:\n      - master\n  schedule:\n    - cron: '15 * * * *'\n\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Check out repo\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.8\n      - uses: actions/cache@v2\n        name: Configure pip caching\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install Python dependencies\n        run: |\n          python -m pip install -r requirements.txt\n\n      - name: Crawl CVEs\n        run: |-\n          python main.py -g \"${{ secrets.CRAWL_PWD }}\" --gtk ${{ secrets.GRAPAQL_TOKEN }}\n\n      # \u82e5\u8be5\u65f6\u95f4\u6bb5\u6ca1\u6709 CVE\uff0c \u5219 file://cache/mail.dat \u6587\u4ef6\u4e0d\u4f1a\u751f\u6210\uff0c\u6b64\u65f6\u4e0d\u4f1a\u53d1\u9001\u90ae\u4ef6\n      # - name: Send mail\n      #   if: ${{ secrets.CRAWL_PWD != '' && github.event_name != 'pull_request' }}\n      #   uses: lyy289065406/action-send-mail@master\n      #   with:\n      #     server_address: ${{ secrets.MAIL_SMTP }}\n      #     server_port: 465\n      #     username: ${{ secrets.MAIL_USER }}\n      #     password: ${{ secrets.MAIL_PASS }}\n      #     from: ${{ secrets.MAIL_USER }}\n      #     to: file://cache/mail_recvs.dat\n      #     body: file://cache/mail_content.dat\n      #     content_type: text/html\n      #     subject: \u5a01\u80c1\u60c5\u62a5\u64ad\u62a5\n\n      # \u5982\u679c\u4e0d\u5e0c\u671b\u6c61\u67d3 commit \u8bb0\u5f55\uff0cuser.email \u548c user.name \u968f\u4fbf\u586b\u5373\u53ef\n      # Github Runner \u662f\u6709\u6743\u9650\u63d0\u4ea4\u5230\u4ed3\u5e93\u7684\uff0c\u53ea\u8981 user \u4e0d\u662f owner \uff0c\u5f53\u6b21 commit \u4e0d\u4f1a\u88ab\u8bb0\u5f55\n      - name: Commit and push Github page (if changed)\n        if: ${{ github.event_name != 'pull_request' }}\n        run: |-\n          git diff\n          git config --global user.email \"github-bot@example.com\"\n          git config --global user.name \"Github-Bot\"\n          git add -A\n          git commit -m \"Updated by Github Bot\" || exit 0\n          git push origin master\n\n```", "prompt": "Generate a GitHub Workflow named `Automatically crawl CVEs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch named master. 2) someone manually triggers the workflow. 3) the scheduled time has come: at 15 minutes past the hour. The workflow has one job. The job id of the 1st job is `build-and-deploy`. "}
{"id": "63c496891e3364807577b43b", "level": "level1", "llm_response": "```yaml\nname: Build Docker\n\non:\n  push:\n    branches:\n      - trunk\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/**'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n  pull_request:\n    branches:\n      - trunk\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/**'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n\nconcurrency:\n  group: 'build-docker-${{ github.event_name }}-${{ github.ref }}'\n  cancel-in-progress: true\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up PHP\n        uses: shivammathur/setup-php@v2\n        with:\n          php-version: '7.4'\n\n      - name: Install dependencies\n        run: composer install\n\n      - name: Build Docker image\n        run: docker build -t jetpack-dev-env .\n\n      - name: Publish Docker image\n        run: docker push jetpack-dev-env\n```", "answer": "```yaml name: Build Docker\non:\n  push:\n    branches: [ 'trunk' ]\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n  pull_request:\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\nconcurrency:\n  group: build-docker-${{ github.event_name }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    name: Build and publish Jetpack Dev Environment\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    timeout-minutes: 60  # 2021-10-26: Build for arm64 is S-L-O-W. Sigh.\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up qemu\n        uses: docker/setup-qemu-action@v2\n        with:\n          platforms: arm64\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: matticbot\n          password: ${{ secrets.DOCKER_HUB_MATTICBOT_TOKEN }}\n\n      - name: Log in to GitHub Packages\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Fetch build args\n        id: buildargs\n        run: |\n          source .github/versions.sh\n          source .github/files/gh-funcs.sh\n\n          gh_set_output php-version \"$PHP_VERSION\"\n          gh_set_output composer-version \"$COMPOSER_VERSION\"\n          gh_set_output node-version \"$NODE_VERSION\"\n          gh_set_output pnpm-version \"$PNPM_VERSION\"\n\n          # We're not git-tagging for the env. Just tag all trunk builds as latest.\n          if [[ \"$GITHUB_EVENT_NAME\" == \"push\" ]]; then\n            gh_set_output tags \"type=raw,latest\"\n            gh_set_output images $'automattic/jetpack-wordpress-dev\\nghcr.io/automattic/jetpack-wordpress-dev'\n          elif [[ \"$GITHUB_EVENT_NAME\" == \"pull_request\" ]]; then\n            gh_set_output tags \"type=ref,event=pr\"\n            gh_set_output images \"ghcr.io/automattic/jetpack-wordpress-dev\"\n          else\n            echo \"Unknown GITHUB_EVENT_NAME $GITHUB_EVENT_NAME\"\n            exit 1\n          fi\n\n      - name: Extract Docker metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          flavor: latest=false\n          tags: ${{ steps.buildargs.outputs.tags }}\n          images: ${{ steps.buildargs.outputs.images }}\n          labels: |\n            org.opencontainers.image.title=Jetpack Development Environment\n            org.opencontainers.image.description=Unified environment for developing in the Jetpack Monorepo using Docker containers.\n            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/trunk/tools/docker/README.md\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v3\n        with:\n          context: tools/docker\n          platforms: linux/amd64,linux/arm64\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          build-args: |\n            PHP_VERSION=${{ steps.buildargs.outputs.php-version }}\n            COMPOSER_VERSION=${{ steps.buildargs.outputs.composer-version }}\n            NODE_VERSION=${{ steps.buildargs.outputs.node-version }}\n            PNPM_VERSION=${{ steps.buildargs.outputs.pnpm-version }}\n```", "prompt": "Generate a GitHub Workflow named `Build Docker` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named trunk. Only if at least one path of push event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. 2) Only if at least one path of pull_request event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. Only a single workflow using the build-docker-${{ github.event_name }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Build and publish Jetpack Dev Environment` and its job id is `build`. "}
{"id": "63c494318052faa2781a9bf5", "level": "level1", "llm_response": "```yaml\nname: Test a branch on canary\n\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n        type: string\n\npermissions:\n  contents: read\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\n\ndefaults:\n  run:\n    shell: pwsh\n\njobs:\n  update_tag:\n    id: update_tag\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Update the rc tag\n        run: |\n          git tag -a \"rc-${{ env.COMMIT_SHA }}\" -m \"Release candidate for commit ${{ env.COMMIT_SHA }}\"\n          git push origin \"rc-${{ env.COMMIT_SHA }}\"\n```", "answer": "```yaml name: Test a branch on canary\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\ndefaults:\n  run:\n    shell: pwsh\n\npermissions:  # added using https://github.com/step-security/secure-workflows\n  contents: read\n\njobs:\n  update_tag:\n    name: Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n    - uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34 # v1\n      with:\n        allowed-endpoints: \n          api.github.com:443\n          github.com:443\n\n    - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 # v2\n    - name: Update the rc tag\n      uses: step-security/publish-action@b438f840875fdcb7d1de4fc3d1d30e86cf6acb5d\n      with:\n        rc-sha: ${{ env.COMMIT_SHA }}\n        rc: true\n\n    - name: Canary test\n      uses: docker://ghcr.io/step-security/integration-test/int:latest\n      env:\n        PAT: ${{ secrets.PAT }}\n        canary: true\n```", "prompt": "Generate a GitHub Workflow named `Test a branch on canary` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: COMMIT_SHA-this input represents commit sha to be tested and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `COMMIT_SHA` is set to `${{ github.event.inputs.COMMIT_SHA }}`. For all run steps in the workflow, default shell is set to pwsh. The workflow has one job. The 1st job is named `Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit` and its job id is `update_tag`. "}
{"id": "63c4964733b087f6bde2ad41", "level": "level1", "llm_response": "```yaml\nname: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - py-*\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [windows-latest, macos-latest]\n    defaults:\n      run:\n        shell: bash\n```", "answer": "```yaml name: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - py-*\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, windows-latest]\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.7'\n\n      - name: Fix README symlink\n        run: |\n          rm py-polars/README.md\n          cp README.md py-polars/README.md\n\n      - name: Publish wheel\n        uses: messense/maturin-action@v1\n        env:\n          MATURIN_PASSWORD: ${{ secrets.PYPI_PASS }}\n          RUSTFLAGS: -C target-feature=+fxsr,+sse,+sse2,+sse3,+sse4.1,+sse4.2\n        with:\n          rust-toolchain: nightly-2022-10-06\n          maturin-version: '0.13.5'\n          command: publish\n          args: -m py-polars/Cargo.toml --no-sdist --skip-existing -o wheels -i python -u ritchie46\n```", "prompt": "Generate a GitHub Workflow named `Create Python release windows macos` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches py-*. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The job id of the 1st job is `win-macos`. "}
{"id": "63c496566fc19abdf9c9b6ef", "level": "level1", "llm_response": "```yaml\nname: automerge\n\non:\n  pull_request:\n    types: [labeled]\n\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Merge pull request\n      run: |\n        git config --global user.name \"GitHub Actions\"\n        git config --global user.email \"github-actions@github.com\"\n        git pull origin ${{ github.ref }}\n        git push origin ${{ github.ref }}\n      if: github.event.label.name == 'merge'\n```", "answer": "```yaml name: automerge\non:\n  pull_request_target:\n    types:\n      - labeled\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: enable automerge\n        if: contains( github.event.pull_request.labels.*.name, 'automerge')\n        uses: peter-evans/enable-pull-request-automerge@v2\n        with:\n          token: ${{ secrets.PAT }}\n          pull-request-number: ${{ github.event.pull_request.number }}\n          merge-method: rebase\n```", "prompt": "Generate a GitHub Workflow named `automerge` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: a label is added to a pull request. The workflow has one job. The job id of the 1st job is `automerge`. "}
{"id": "63c4941d8052faa2781a937b", "level": "level1", "llm_response": "```yaml\nname: update-flake-lock\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Less\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y less\n\n      - name: Update flake-lock\n        run: |\n          lessc --lint --update\n```", "answer": "```yaml name: update-flake-lock\non:\n  workflow_dispatch: # allows manual triggering\n  schedule:\n    - cron: '0 0 * * 0' # runs weekly on Sunday at 00:00\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Install Nix\n        uses: cachix/install-nix-action@v18\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n      - name: Update flake.lock\n        uses: DeterminateSystems/update-flake-lock@v14\n        with:\n          # we update nixos-common-styles manual\n          # and the rest of the inputs are content inputs\n          inputs: nixpkgs\n```", "prompt": "Generate a GitHub Workflow named `update-flake-lock` for a GitHub repository whose primary programming language is Less. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The job id of the 1st job is `lockfile`. "}
{"id": "63c4965533b087f6bde2b378", "level": "level1", "llm_response": "```yaml\nname: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    id: packagist\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up PHP\n        uses: shivammathur/setup-php@v2\n        with:\n          php-version: '7.4'\n\n      - name: Update Packagist\n        run: |\n          composer config --global http-basic.packagist.org ${{ secrets.PACKAGIST_USERNAME }} ${{ secrets.PACKAGIST_PASSWORD }}\n          composer update --no-dev --optimize-autoloader\n          composer dist-pack\n          php bin/console packagist:release\n```", "answer": "```yaml name: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    name: Update Packagist\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update Packagist\n        run: |\n          curl -X POST \"https://packagist.org/api/update-package?username=svix&apiToken=$PACKAGIST_API_KEY\" \\\n            -H 'content-type: application/json' \\\n            -d '{\"repository\":{\"url\":\"https://packagist.org/packages/svix/svix\"}}'\n        env:\n          PACKAGIST_API_KEY: ${{ secrets.PACKAGIST_API_KEY }}```", "prompt": "Generate a GitHub Workflow named `PHP Release` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Update Packagist` and its job id is `packagist`. "}
{"id": "63c4959c7843b61269a08c30", "level": "level1", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  workflow_dispatch:\n\npermissions:\n  contents: read\n  issues: read\n  pull_requests: read\n  repositories: read\n  security_events: read\n  statuses: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run Scorecards analysis\n        run: |\n          cargo install scorecard\n          scorecard\n```", "answer": "```yaml name: Scorecards supply-chain security\n# Run only manually, because the answers don't change often and the results have \n# many unhelpful positives.\n  \non:\n  workflow_dispatch: \n  # Only the default branch is supported.\n  # branch_protection_rule:\n  # schedule:\n  #   - cron: '38 17 * * 6'\n  # push:\n  #  branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c8416b0b2bf627c349ca92fc8e3de51a64b005cf # v1.0.2\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. "}
{"id": "63c495547843b61269a06e6c", "level": "level1", "llm_response": "```yaml\nname: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 1 * * *'\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\njobs:\n  recreate:\n    id: recreate\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Recreate runners\n        run: |\n          # Add your runner recreation script here\n```", "answer": "```yaml name: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    # Once each 24 hours, at 1 during the night\n    - cron: \"0 1 * * *\"\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  recreate:\n    if: github.repository == 'Homebrew/homebrew-core'\n    runs-on: ubuntu-22.04\n    env:\n      # TODO agree on one label for all runners\n      RUNNER_LABEL: TODO\n    strategy:\n      matrix:\n        runner_name:\n          - linux-self-hosted-1\n    steps:\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.2.1\n        with:\n          project_id: ${{ secrets.GCP_PROJECT_ID }}\n          service_account_key: ${{ secrets.GCP_SA_KEY }}\n          export_default_credentials: true\n\n      - name: Wait for idle runner\n        id: killable\n        uses: Homebrew/actions/wait-for-idle-runner@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n      - name: Kill runner and create a new one\n        if: ${{ steps.killable.outputs.runner-found == 'true' && steps.killable.outputs.runner-idle == 'true' }}\n        uses: Homebrew/actions/create-gcloud-instance@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          gcp_project_id: ${{ secrets.GCP_PROJECT_ID }}\n          gcp_service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n          gcp_sa_key: ${{ secrets.GCP_SA_KEY }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Recreate Linux self-hosted runners on schedule` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 01:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the recreate-linux-runners concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `recreate`. "}
{"id": "63c4942a8052faa2781a9911", "level": "level1", "llm_response": "```yaml\nname: Integration tests\n\non:\n  push:\n    branches:\n      - main\n      - dev\n  workflow_dispatch:\n\njobs:\n  integration_tests:\n    id: integration_tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Run tests\n        run: go test -v ./...\n```", "answer": "```yaml name: Integration tests\non:\n  workflow_dispatch: null\n  push:\n    branches:\n      - main\n      - dev\njobs:\n  integration_tests:\n    name: Run integration tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f # pin@v2\n      - uses: actions/setup-go@37335c7bb261b353407cff977110895fa0b4f7d8 # pin@v2\n        with:\n          go-version: '1.18'\n      - run: go version\n      - run: make testacc\n        env:\n          LINODE_TOKEN: ${{ secrets.DX_LINODE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Integration tests` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main or a branch named dev. The workflow has one job. The 1st job is named `Run integration tests` and its job id is `integration_tests`. "}
{"id": "63c4942a8052faa2781a9910", "level": "level1", "llm_response": "```yaml\nname: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n  pull_request:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n    - name: Run AccTest Command\n      run: go run ./cmd/acctest\n```", "answer": "```yaml name: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.issue.pull_request }}\n    steps:\n      - name: Generate App Installation Token\n        id: generate_token\n        uses: tibdex/github-app-token@v1\n        with:\n          app_id: ${{ secrets.DX_ACCTEST_APP_ID }}\n          private_key: ${{ secrets.DX_ACCTEST_PRIV_KEY }}\n\n      - name: Slash Command Dispatch\n        uses: peter-evans/slash-command-dispatch@v1\n        env:\n          TOKEN: ${{ steps.generate_token.outputs.token }}\n        with:\n          token: ${{ env.TOKEN }}\n          reaction-token: ${{ secrets.GITHUB_TOKEN }}\n          issue-type: pull-request\n          commands: acctest\n          named-args: true\n          permission: write\n```", "prompt": "Generate a GitHub Workflow named `AccTest Command` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `acctest-command`. "}
{"id": "63c4940f7843b612699feb8d", "level": "level1", "llm_response": "```yaml\nname: Go Coverage\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Run tests and generate coverage report\n        run: |\n          go test -v ./... -coverprofile=coverage.out\n\n      - name: Upload coverage report\n        uses: codecov/codecov-action@v2\n        with:\n          file: coverage.out\n```", "answer": "```yaml # add public code coverage reports\non:\n  push:\n    branches:\n    - main\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - run: \"make test-cover\"\n    - uses: codecov/codecov-action@v2\n    with:\n      file: ./coverage.out\n      fail_ci_if_error: true\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `coverage`. "}
{"id": "63c496a06fc19abdf9c9d2e3", "level": "level1", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '18 9 * * 4'\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: read\n  packages: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run Scorecards\n        run: |\n          cargo install scorecard\n          scorecard check\n```", "answer": "```yaml # This file is part of ICU4X. For terms of use, please see the file\n# called LICENSE at the top level of the ICU4X source tree\n# (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).\n\nname: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '18 9 * * 4'\n  push:\n    branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c1aec4ac820532bab364f02a81873c555a0ba3a1 # v1.0.4\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 09:18 am, only on thursday. 3) The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. "}
{"id": "63c495257843b61269a05b79", "level": "level1", "llm_response": "```yaml\nname: Update translation templates\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-templates:\n    id: update-templates\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up C++\n        uses: actions/setup-cpp@v2\n        with:\n          cpp-version: '10'\n\n      - name: Run translation template update script\n        run: ./update_translation_templates.sh\n```", "answer": "```yaml on:\n  push:\n    branches: [ master ]\n\nname: Update translation templates\njobs:\n  update-templates:\n    name: Update translation templates\n    runs-on: ubuntu-20.04\n    container:\n      image: archlinux\n    steps:\n      # install git first otherwise checkout will not give us an actual git repo\n      - name: Install git\n        run: pacman -Syu --noconfirm git\n    \n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n\n      - name: Install deps\n        run: |\n          # install general build deps\n          pacman -Syu --noconfirm ninja gcc pkgconf python3 python-pip which\n          # install easyeffects deps\n          source ./PKGBUILD && pacman -Syu --noconfirm --needed --asdeps \"${makedepends[@]}\" \"${depends[@]}\"\n          \n      # workaround upstream permissions issue github.com/peter-evans/create-pull-request/issues/1170\n      - name: Change git permissions\n        run: git config --global --add safe.directory \"$GITHUB_WORKSPACE\"\n\n      - name: Run meson targets\n        run: |\n          meson build\n          cd build\n          ../util/update_translation_templates.sh\n          cd ..\n\n      - name: Check for non-timestamp diff\n        run: |\n          # see https://stackoverflow.com/a/26622262\n          DIFF_LINES=$(git diff --unified=0 | grep '^[+-]' | grep -Ev '^(--- a/|\\+\\+\\+ b/)')\n\n          if [[ $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\") != \"$DIFF_LINES\" ]]; then\n            echo \"The calculated diff includes modifications besides just timestamp changes (POT-Creation-Date).\"\n            echo \"Letting the PR continue as this is a valid reason to open a PR.\"\n          else\n            echo \"The calculated diff just has timestamp changes (POT-Creation-Date).\"\n            echo \"Restoring original files since this is not a valid reason to open a PR.\"\n            git restore .\n          fi\n\n          echo \"All diff lines count: $(echo \"$DIFF_LINES\" | wc -l)\"\n          echo \"Diff lines count where POT-Creation-Date was changed: $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\" | wc -l)\"\n\n      # TODO it would be ideal to refresh metainfo fully by copying release notes from the upcoming release in NEWS.yaml to metainfo, and then running the above update template script,\n      # however this is not possible without putting a dummy release in the metainfo with said upcoming release notes which would later have to be adjusted to the real release.\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4.1.3\n        with:\n          title: Update translation templates\n          body: Ensure to merge all other Pull Requests before merging this. Conflicts here will automatically be resolved in case of changes in master.\n          commit-message: Update translation templates\n          # email sets \"EasyEffects Bot\" user as commit author\n          committer: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          author: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          branch: automatically-update-translation-templates\n          # the easyeffects_bot secret/token is only valid for a fork\n          # note the machine user (easyeffects-bot) must have already forked the repository  where the action is running for this to work\n          push-to-fork: easyeffects-bot/easyeffects\n          token: ${{ secrets.EASYEFFECTS_BOT }}\n```", "prompt": "Generate a GitHub Workflow named `Update translation templates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The 1st job is named `Update translation templates` and its job id is `update-templates`. "}
{"id": "63c4967d1899db58864d33af", "level": "level1", "llm_response": "```yaml\nname: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      package_name:\n        description: 'Package name'\n        required: true\n        default: 'generateblocks'\n\njobs:\n  build-package:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build package\n        run: npm run build -- ${{ github.event.inputs.package_name }}\n```", "answer": "```yaml name: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      name:\n        description: 'Package name'\n        default: 'generateblocks'\n        required: true\n\njobs:\n\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n          cache: 'npm'\n\n      - name: NPM install\n        run: npm install\n\n      - name: NPM build\n        run: npm run build\n\n      - name: Grunt action-package\n        run: npm run action-package\n\n      - name: Build zip file\n        uses: actions/upload-artifact@v3.1.0\n        with:\n          name: ${{ github.event.inputs.name }}\n          path: |\n            package/\n          retention-days: 1\n```", "prompt": "Generate a GitHub Workflow named `Build package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: name-this input represents package name, its default value is generateblocks and it must be supplied. The workflow has one job. The job id of the 1st job is `build-package`. "}
{"id": "63c494637843b61269a00d3a", "level": "level1", "llm_response": "```yaml\nname: olm\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\n\nenv:\n  GO_VERSION: \"1.19\"\n  KIND_IMG_TAG: \"v1.25.0\"\n\njobs:\n  tests:\n    id: main\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: ${{ env.GO_VERSION }}\n\n      - name: Run tests\n        run: go test ./...\n```", "answer": "```yaml name: olm\non:\n  push:\n    branches:\n      - main\n  pull_request:\nenv:\n  GO_VERSION: '1.19'\n  KIND_IMG_TAG: v1.25.0\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\njobs:\n  main:\n    name: tests\n    runs-on: ubuntu-22.04\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Download binaries\n      run: |\n        mkdir -p ${GITHUB_WORKSPACE}/build\n        echo \"${GITHUB_WORKSPACE}/build\" >> ${GITHUB_PATH}\n        make operator-sdk\n        make opm\n\n    - uses: actions/setup-go@268d8c0ca0432bb2cf416faae41297df9d262d7f\n      with:\n        go-version: ${{ env.GO_VERSION }}\n    - name: Install dependencies\n      run: |\n        sudo apt update\n        sudo apt install -y libseccomp-dev libelf-dev libapparmor-dev\n        sudo hack/install-libbpf.sh\n\n    - name: Create and verify bundle\n      run: |\n        make verify-bundle\n\n    - name: Create and set up K8s KinD Cluster\n      run: |\n        ./hack/kind-with-registry.sh\n\n    - name: Run the tests\n      run: ./hack/ci/e2e-olm.sh\n```", "prompt": "Generate a GitHub Workflow named `olm` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: none access is granted to the GITHUB_TOKEN in the `actions` scope, none access is granted to the GITHUB_TOKEN in the `checks` scope, none access is granted to the GITHUB_TOKEN in the `contents` scope, none access is granted to the GITHUB_TOKEN in the `deployments` scope, none access is granted to the GITHUB_TOKEN in the `id-token` scope, none access is granted to the GITHUB_TOKEN in the `issues` scope, none access is granted to the GITHUB_TOKEN in the `discussions` scope, none access is granted to the GITHUB_TOKEN in the `packages` scope, none access is granted to the GITHUB_TOKEN in the `pull-requests` scope, none access is granted to the GITHUB_TOKEN in the `repository-projects` scope, none access is granted to the GITHUB_TOKEN in the `security-events` scope and none access is granted to the GITHUB_TOKEN in the `statuses` scope. This permission setting applies to all jobs in the workflow. The workflow sets 2 environment variables to use: `GO_VERSION` is set to `1.19` and `KIND_IMG_TAG` is set to `v1.25.0`. The workflow has one job. The 1st job is named `tests` and its job id is `main`. "}
{"id": "63c494c78052faa2781ad49a", "level": "level1", "llm_response": "```yaml\nname: Pull Request Labeler\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run labeler script\n        run: npm run labeler\n```", "answer": "```yaml name: \"Pull Request Labeler\"\non:\n  - pull_request_target\n\njobs:\n  triage:\n    permissions:\n      contents: read\n      pull-requests: write\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/labeler@v4\n        with:\n          repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Pull Request Labeler` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `triage`. "}
{"id": "63c495928052faa2781b2bc0", "level": "level1", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, synchronize, labeled]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Erlang\n        uses: erlang/otp@v2\n        with:\n          otp-version: \"24.0\"\n\n      - name: Install dependencies\n        run: make get-deps\n\n      - name: Run labeler script\n        run: ./scripts/labeler.sh\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n    - uses: rhysd/changelog-from-release/action@v2\n      with:\n        file: CHANGELOG.md\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. "}
{"id": "63c494608052faa2781aabf2", "level": "level1", "llm_response": "```yaml\nname: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run Configlet\n        run: configlet check\n```", "answer": "```yaml name: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    uses: exercism/github-actions/.github/workflows/configlet.yml@main\n```", "prompt": "Generate a GitHub Workflow named `Configlet` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. 3) someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `configlet`. "}
{"id": "63c4949e7843b61269a025e6", "level": "level1", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [commented]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Julia\n        uses: julia-actions/setup-julia@v1\n        with:\n          version: '1.6'\n      - name: Run TagBot script\n        run: julia path/to/tagbot.jl\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. "}
{"id": "63c495d98052faa2781b4aa8", "level": "level1", "llm_response": "```yaml\nname: NMake\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  nmake:\n    runs-on: windows-latest\n    strategy:\n      matrix:\n        name: [ \"NMake\" ]\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Visual Studio\n      uses: microsoft/setup-msbuild@v1\n      with:\n        msbuild-version: '16.0'\n\n    - name: Build with NMake\n      run: nmake\n```", "answer": "```yaml name: NMake\non: [push, pull_request]\njobs:\n  nmake:\n    name: ${{ matrix.name }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - name: Windows NMake x86\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86\n\n          - name: Windows NMake x64 compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes\n\n          - name: Windows NMake x64 Symbol Prefix\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64 Symbol Prefix Compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n\n          - name: Windows NMake ARM No Test\n            os: windows-2022\n            makefile: win32/Makefile.arm\n            arch: x86_arm\n\n          - name: Windows NMake ARM64 No Test\n            os: windows-2022\n            makefile: win32/Makefile.a64\n            arch: x86_arm64\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Setup development environment\n      uses: ilammy/msvc-dev-cmd@v1.10.0\n      with:\n        arch: ${{ matrix.arch }}\n\n    - name: Compile source code\n      shell: cmd\n      run: nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}\n\n    - name: Run test cases\n      shell: cmd\n      # Don't run tests on Windows ARM\n      if: contains(matrix.arch, 'arm') == false\n      run: |\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} test\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} testdll\n```", "prompt": "Generate a GitHub Workflow named `NMake` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `nmake`. "}
{"id": "63c493b77843b612699fd377", "level": "level1", "llm_response": "```yaml\nname: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - 'public/**'\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          profile: minimal\n          toolchain: stable\n          override: true\n\n      - name: Build website\n        run: cargo build --release\n\n      - name: Deploy website\n        run: |\n          # Add deployment commands here\n          echo \"Deploying website...\"\n```", "answer": "```yaml name: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - \"public/**\"\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install Nix\n        uses: cachix/install-nix-action@v15\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build\n        run: nix build .#website\n\n      - name: Deploy \ud83d\ude80\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./result\n          cname: mdzk.app\n```", "prompt": "Generate a GitHub Workflow named `Publish website` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(public/**), the workflow runs. The workflow has one job. The job id of the 1st job is `deploy-website`. "}
{"id": "63c4946f7843b61269a011d1", "level": "level1", "llm_response": "```yaml\nname: I2::Dev::Nightly::Publish\n\non:\n  workflow_dispatch:\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v1\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Build and push Docker image\n        run: |\n          docker build -t your-dockerhub-username/your-repo:nightly .\n          docker push your-dockerhub-username/your-repo:nightly\n```", "answer": "```yaml name: I2::Dev::Nightly::Publish\n\non: workflow_dispatch\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n    container:\n      image: 7272721/i2-ci:nightly\n    steps:\n      - uses: actions/checkout@v3\n      - uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push iroha2:dev-nightly image\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          tags: hyperledger/iroha2:dev-nightly-${{ github.sha }}\n          labels: commit=${{ github.sha }}\n          build-args: TAG=dev\n```", "prompt": "Generate a GitHub Workflow named `I2::Dev::Nightly::Publish` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `dockerhub`. "}
{"id": "63c4941b7843b612699ff0aa", "level": "level1", "llm_response": "```yaml\nname: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - 'zap/zap.gradle.kts'\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Build with Gradle\n        run: ./gradlew build\n\n      - name: Release\n        run: echo \"Release process triggered\"\n```", "answer": "```yaml name: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - 'zap/zap.gradle.kts'\n\njobs:\n  release:\n    name: Build and Release\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n        persist-credentials: false\n    - name: Setup Java\n      uses: actions/setup-java@v3\n      with:\n        distribution: 'temurin'\n        java-version: 11\n    - name: Build and Release\n      env:\n        INSTALL4J_LICENSE: ${{ secrets.INSTALL4J_LICENSE }}\n        ZAPBOT_TOKEN: ${{ secrets.ZAPBOT_TOKEN }}\n        ZAP_RELEASE: 1\n        ZAP_JAVA_VERSION: 11\n      run: ./gradlew \"-Dorg.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m\" :zap:createMainRelease\n```", "prompt": "Generate a GitHub Workflow named `Release Main Version` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(zap/zap.gradle.kts), the workflow runs. The workflow has one job. The 1st job is named `Build and Release` and its job id is `release`. "}
{"id": "63c494a97843b61269a02a52", "level": "level1", "llm_response": "```yaml\nname: pytorch1_8_1-cuda11_1\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install torch==1.8.1+cu111 torchvision==0.9.1+cu111 torchaudio==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html\n      - name: Build project\n        run: make\n```", "answer": "```yaml name: pytorch1_8_1-cuda11_1\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu111\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.8.1-cu111\n      develop_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_8_1-cuda11_1` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c493ff8052faa2781a8681", "level": "level1", "llm_response": "```yaml\nname: Check License Lines\n\non:\n  push:\n    branches: [ '*' ]\n\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up JDK 11\n      uses: actions/setup-java@v2\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n\n    - name: Check license lines\n      run: |\n        # Add your license line check command here\n        # For example:\n        # grep -r \"Copyright 2022\" .\n```", "answer": "```yaml name: Check License Lines\non:\n  push:\n    branches: '**'\n#  pull_request:\n#    branches:\n#      - main\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Check License Lines\n        uses: kt3k/license_checker@v1.0.6```", "prompt": "Generate a GitHub Workflow named `Check License Lines` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch whose name matches * or a branch whose name matches *. The workflow has one job. The job id of the 1st job is `check-license-lines`. "}
{"id": "63c494888052faa2781abb68", "level": "level1", "llm_response": "```yaml\nname: MERGE_MASTER_TO_DEVELOP\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run tests\n        run: npm test\n\n      - name: Merge master to develop\n        run: |\n          git checkout develop\n          git merge master\n          git push origin develop\n```", "answer": "```yaml name: MERGE_MASTER_TO_DEVELOP\non:\n  push:\n    branches:\n    - \"master\"\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n    - name: Checkout develop\n      uses: actions/checkout@v3\n      with:\n        ref: develop\n        fetch-depth: 0\n    - name: Merge master to develop and push\n      run: |\n        git config user.name '${{ secrets.BPMN_IO_USERNAME }}'\n        git config user.email '${{ secrets.BPMN_IO_EMAIL }}'\n        git merge -m 'Merge master to develop' --no-edit origin/master\n        git push\n\n    - name: Notify failure on Slack\n      if: failure()\n      uses: slackapi/slack-github-action@v1.15.0\n      with:\n        channel-id: ${{ secrets.SLACK_CHANNEL_ID }}\n        slack-message: \"Automatic merge of <https://github.com/${{ github.repository }}/tree/${{ github.ref }}|${{ github.ref }}> to <https://github.com/${{ github.repository }}/tree/develop|${{ github.repository }}#develop> failed.\"\n      env:\n        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `MERGE_MASTER_TO_DEVELOP` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `Merge_master_to_develop`. "}
{"id": "63c494298052faa2781a987a", "level": "level1", "llm_response": "```yaml\nname: Hypothesis Tests\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 6 * * *'\n\npermissions:\n  issues: write\n\nenv:\n  python_version: 3.10\n\njobs:\n  hypothesis:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      \n      - name: Set up Python ${{ env.python_version }}\n        uses: actions/setup-python@v2\n        with:\n          python-version: ${{ env.python_version }}\n      \n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install hypothesis\n      \n      - name: Run hypothesis tests\n        run: |\n          pytest\n```", "answer": "```yaml name: Hypothesis Tests\non:\n  workflow_dispatch:\n  schedule:\n    # min hour dom month dow\n    - cron:  '0 6 * * *'\nenv:\n  python_version: '3.10'\n\npermissions:\n  issues: write\n\njobs:\n\n  hypothesis:\n    runs-on: ubuntu-22.04\n    timeout-minutes: 90\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Install Linux Dependencies\n        uses: ./.github/actions/linux_dependencies\n      - name: Set up Python\n        uses: actions/setup-python@v4.3.0\n        with:\n          python-version: ${{ env.python_version }}\n      - name: Use Python Dependency Cache\n        uses: actions/cache@v3.0.11\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}-20.04\n      - name: Use Hypothesis Cache\n        uses: pat-s/always-upload-cache@v3.0.1\n        with:\n          path: .hypothesis\n          key: ${{ runner.os }}-hypothesis\n      - name: Install Dependencies and Test\n        uses: ./.github/actions/setup_and_test\n      - name: Test with Hypothesis\n        run: xvfb-run poetry run pytest -m hypothesis --hypothesis-profile=ci\n        shell: bash\n      - uses: nashmaniac/create-issue-action@v1.1\n        if: failure()\n        name: Create Issue on Failure\n        with:\n          title: Hypothesis tests failed\n          token: ${{secrets.GITHUB_TOKEN}}\n          labels: bug,hypothesis\n          body: |\n            Test run failed for commit ${{github.sha}}.\n            See https://github.com/gaphor/gaphor/actions/workflows/hypothesis-test.yml.\n```", "prompt": "Generate a GitHub Workflow named `Hypothesis Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 06:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `python_version` is set to `3.10`. The workflow has one job. The job id of the 1st job is `hypothesis`. "}
{"id": "63c495038052faa2781aede8", "level": "level1", "llm_response": "```yaml\nname: Python package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  windows:\n    id: windows\n    runs-on: windows-latest\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n    - name: Run tests\n      run: |\n        python -m unittest discover\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Python package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  windows:\n    name: Windows Tests\n    runs-on: \"windows-latest\"\n    strategy:\n      fail-fast: True\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: conda-incubator/setup-miniconda@v2\n        with:\n          auto-update-conda: true\n          python-version: ${{ matrix.python-version }}\n          channels: conda-forge\n        env:\n          ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n      - name: Create Conda environment with the rights deps\n        shell: bash -l {0}\n        run: |\n          conda create -n zarr-env python==${{matrix.python-version}} numcodecs pip nodejs\n      - name: Install dependencies\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          python -m pip install --upgrade pip\n          python -m pip install -U pip setuptools wheel\n          python -m pip install -r requirements_dev_numpy.txt -r requirements_dev_minimal.txt -r requirements_dev_optional.txt\n          python -m pip install .\n          python -m pip freeze\n          npm install -g azurite\n      - name: Run Tests\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          mkdir ~/blob_emulator\n          azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n          pytest -sv --timeout=300\n        env:\n          ZARR_TEST_ABS: 1\n          ZARR_V3_EXPERIMENTAL_API: 1\n      - name: Conda info\n        shell: bash -l {0}\n        run: conda info\n      - name: Conda list\n        shell: pwsh\n        run: conda list\n```", "prompt": "Generate a GitHub Workflow named `Python package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Windows Tests` and its job id is `windows`. "}
{"id": "63c494347843b612699ffaac", "level": "level1", "llm_response": "```yaml\nname: Monitor CI Scaler\n\non:\n  schedule:\n    - cron: '0 5 * * *'\n    - cron: '0 17 * * *'\n\njobs:\n  MonitorCI:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n\n      - name: Run CI scaler script\n        run: ./path/to/ci_scaler_script.sh\n```", "answer": "```yaml name: Monitor CI Scaler\n\non:\n  # workflow_dispatch:\n  schedule:\n    - cron: '0 5,17 * * *'\n\njobs:\n  MonitorCI:\n    name: monitor ci scaler\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v1\n        with:\n          submodules: recursive\n      - name: setup environment\n        run: bash ./scripts/dev_setup.sh  -b -t -y\n      - name: check scaler\n        run: python3 ./scripts/monitor_autoscaler_recreate.py\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Monitor CI Scaler` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: the scheduled time has come: at 05:00 am and 05:00 pm. The workflow has one job. The 1st job is named `monitor ci scaler` and its job id is `MonitorCI`. "}
{"id": "63c494cf8052faa2781ad80f", "level": "level1", "llm_response": "```yaml\nname: Release Documentation\n\non:\n  release:\n    types: [published, prereleased, draft]\n\nenv:\n  GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  java-build:\n    id: java-build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Build with Gradle\n        run: ./gradlew build\n\n      - name: Publish Documentation\n        run: ./gradlew publishDocs\n```", "answer": "```yaml name: Release Documentation\non:\n  release:\n    types: [published]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  GRADLE_OPTS: '-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail'\n\njobs:\n  java-build:\n    name: Publish Release Documentation\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        java: [ '8' ]\n        os: ['ubuntu-22.04' ]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Cache Gradle dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/caches\n          key: ${{ runner.os }}-gradle-caches-${{ hashFiles('**/*.gradle') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-caches-\n      - name: Cache Gradle wrappers\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-wrapper\n      - name: Setup java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: ${{ matrix.java }}\n      - name: Build with Gradle\n        run: ./gradlew tutorialPublish -Paeron.ci.apiKey=${{ secrets.WIKI_PAGE_TOKEN }} --stacktrace\n```", "prompt": "Generate a GitHub Workflow named `Release Documentation` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow sets an environment variable to use: `GRADLE_OPTS` is set to `-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail`. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Publish Release Documentation` and its job id is `java-build`. "}
{"id": "63c4967d6fc19abdf9c9c492", "level": "level1", "llm_response": "```yaml\nname: gradio-ui\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\nenv:\n  CI: 'True'\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: '1'\n  NODE_OPTIONS: '--max-old-space-size=4096'\n\nconcurrency:\n  group: 'deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}'\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ui\n\n  functional-test:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ui\n```", "answer": "```yaml name: gradio-ui\n\non:\n  push:\n    branches:\n      - \"main\"\n  pull_request:\n\ndefaults:\n  run:\n    working-directory: ui\n\nenv:\n  CI: true\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: \"1\"\n  NODE_OPTIONS: \"--max-old-space-size=4096\"\n\nconcurrency:\n  group: deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    name: static checks\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: install dependencies\n        run: pnpm i --frozen-lockfile\n      - name: formatting check\n        run: pnpm format:check\n      - name: typecheck\n        run: pnpm ts:check\n      - name: unit tests\n        run: pnpm test:run\n  functional-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: Install Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.x'\n      - run: cd .. && bash scripts/install_gradio.sh\n      - run: pip install -r ../demo/outbreak_forecast/requirements.txt\n      - run: pnpm install --frozen-lockfile\n      - run: pnpm exec playwright install chromium\n      - run: pnpm test:browser:full\n      - name: Upload failed tests screenshots\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          retention-days: 3\n          name: test-failure-${{ github.run_id }}\n          path: ui/packages/app/test-results\n```", "prompt": "Generate a GitHub Workflow named `gradio-ui` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow sets 3 environment variables to use: `CI` is set to `True`, `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` is set to `1` and `NODE_OPTIONS` is set to `--max-old-space-size=4096`. For all run steps in the workflow, default working directory is set to ui. Only a single workflow using the deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `static checks` and its job id is `quick-checks`. The job id of the 2nd job is `functional-test`. "}
{"id": "63c496851899db58864d368d", "level": "level1", "llm_response": "```yaml\nname: Bump repositories\n\non:\n  schedule:\n    - cron: '0 20 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Run go mod tidy\n        run: go mod tidy\n\n      - name: Run go fmt\n        run: go fmt ./...\n\n      - name: Run go test\n        run: go test -v ./...\n```", "answer": "```yaml name: Bump repositories\non: \n schedule:\n   - cron: 0 20 * * *\n workflow_dispatch:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Bump cos \ud83d\udd27\n      run: |\n           docker run --name=yq -v \"${PWD}\":/workdir mikefarah/yq\n           docker cp yq:/usr/bin/yq ./\n           export YQ=$PWD/yq\n           sudo -E bash ./.github/bump_repositories.sh\n           rm -rf yq\n    - name: Create Pull Request\n      uses: peter-evans/create-pull-request@v4\n      with:\n        token: ${{ secrets.PAT_TOKEN }}\n        push-to-fork: ci-robbot/c3os\n        commit-message: \":arrow_up: Update repositories\"\n        title: \"Repositories bump\"\n        body: \"Bump of luet repositories\"\n```", "prompt": "Generate a GitHub Workflow named `Bump repositories` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 08:00 pm. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c4945a7843b61269a00a52", "level": "level1", "llm_response": "```yaml\nname: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n```", "answer": "```yaml name: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      - name: Build and export to Docker\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          load: true\n          push: false\n          tags: ${{ env.TEST_TAG }}\n      - name: Run\n        run: |\n          docker run --rm ${{ env.TEST_TAG }} ci\n```", "prompt": "Generate a GitHub Workflow named `ci` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow sets an environment variable to use: `TEST_TAG` is set to `protoc-gen-validate:${{ github.sha }}`. The workflow has one job. The job id of the 1st job is `docker`. "}
{"id": "63c49698b008460c1df15629", "level": "level1", "llm_response": "```yaml\nname: Auto Assign PR to Author\n\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Assign PR to author\n        run: gh pr edit ${{ github.event.pull_request.number }} --add-assignee ${{ github.event.pull_request.user.login }}\n```", "answer": "```yaml name: 'Auto Assign PR to Author'\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    permissions:\n      contents: read  # for kentaro-m/auto-assign-action to fetch config file\n      pull-requests: write  # for kentaro-m/auto-assign-action to assign PR reviewers\n    runs-on: ubuntu-latest\n    steps:\n      - uses: kentaro-m/auto-assign-action@v1.2.1\n```", "prompt": "Generate a GitHub Workflow named `Auto Assign PR to Author` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by an event: a pull request is created. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `add-reviews`. "}
{"id": "63c494a87843b61269a02a08", "level": "level1", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Run tests\n        run: |\n          pytest\n```", "answer": "```yaml name: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-python@v4\n        with:\n          python-version: 3.x\n      - run: pip install -r requirements/build-docs.txt\n      - run: linkcheckMarkdown docs/ -v -r\n      - run: mkdocs build --verbose\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `docs`. "}
{"id": "63c4956d7843b61269a07890", "level": "level1", "llm_response": "```yaml\nname: Issue Comments for merge\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [commented]\n\njobs:\n  check_comments_merge:\n    id: check_comments_merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Terraform\n        uses: hashicorp/setup-terraform@v1\n      - name: Check for /merge comment\n        run: |\n          if [[ $GITHUB_EVENT_COMMENT_BODY == *\"/merge\"* ]]; then\n            echo \"::set-output name=merge_required::true\"\n          else\n            echo \"::set-output name=merge_required::false\"\n          fi\n\n  merge:\n    id: merge\n    runs-on: ubuntu-latest\n    needs: check_comments_merge\n    if: needs.check_comments_merge.outputs.merge_required == 'true'\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Terraform\n        uses: hashicorp/setup-terraform@v1\n      - name: Merge pull request\n        run: terraform apply\n\n  commentFeedback:\n    id: commentFeedback\n    runs-on: ubuntu-latest\n    needs: check_comments_merge\n    if: needs.check_comments_merge.outputs.merge_required == 'false'\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Terraform\n        uses: hashicorp/setup-terraform@v1\n      - name: Comment feedback\n        run: terraform plan\n```", "answer": "```yaml on: issue_comment\nname: Issue Comments for merge\njobs:\n  check_comments_merge:\n    name: Check comments for /merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        uses: xt0rted/slash-command-action@v1.1.0\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          command: merge\n          reaction: \"true\"\n          reaction-type: \"eyes\"\n          allow-edits: \"false\"\n          permission-level: admin\n  merge:\n    runs-on: ubuntu-latest\n    needs: [check_comments_merge]\n    steps:\n      - name: Merge Pull Request\n        uses: juliangruber/merge-pull-request-action@v1.1.0\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          number: ${{ github.event.issue.number }}\n          method: merge\n  commentFeedback:\n    runs-on: ubuntu-latest\n    needs: [merge]\n    steps:\n      - name: Add reaction on success\n        uses: peter-evans/create-or-update-comment@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}\n          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}\n          reaction-type: hooray\n```", "prompt": "Generate a GitHub Workflow named `Issue Comments for merge` for a GitHub repository whose primary programming language is HCL. This workflow will be triggered by an event: activity related to an issue or pull request comment occurs. The workflow has 3 jobs. The 1st job is named `Check comments for /merge` and its job id is `check_comments_merge`. The job id of the 2nd job is `merge`. The job id of the 3rd job is `commentFeedback`. "}
{"id": "63c495888052faa2781b2739", "level": "level1", "llm_response": "```yaml\nname: \u2744\ufe0f Lint\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    id: misc\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run misc checks\n        run: |\n          # Add your misc checks here\n\n  ci-eclint:\n    id: ci-eclint\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Lua\n        uses: lukka/lua-action@v1\n\n      - name: Run Eclint\n        run: |\n          eclint check .\n```", "answer": "```yaml name: \u2744\ufe0f Lint\n\non: [push, pull_request]\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    name: misc checker\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v3.1.0\n      - name: spell check\n        run: |\n          pip install codespell==2.1.0\n          git grep --cached -l '' | xargs codespell --ignore-words=.ignore_words\n      - name: Merge conflict\n        run: |\n          bash ./utils/check-merge-conflict.sh\n      - name: Plugin Code\n        run: |\n          bash ./utils/check-plugins-code.sh\n\n  ci-eclint:\n    runs-on: ubuntu-latest\n    timeout-minutes: 5\n\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v3.1.0\n\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v3.5.1\n        with:\n          node-version: '12'\n\n      - name: Install eclint\n        run: |\n          sudo npm install -g eclint\n\n      - name: Run eclint\n        run: |\n          eclint check\n```", "prompt": "Generate a GitHub Workflow named `\u2744\ufe0f Lint` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `misc checker` and its job id is `misc`. The job id of the 2nd job is `ci-eclint`. "}
{"id": "63c4951b8052faa2781af857", "level": "level1", "llm_response": "```yaml\nname: Docs Build\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - master\n\njobs:\n  docs-build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build docs\n        run: npm run build:docs\n```", "answer": "```yaml name: Docs Build\n\non:\n  # allows to manually run the job at any time\n  workflow_dispatch:\n  \n  # run on every push on the master branch\n  push:\n    branches:\n      - master\n\njobs:\n  docs-build:\n    timeout-minutes: 10\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Install deps\n        run: |\n          npm install vuepress -D\n          npm install macaca-ecosystem -D\n\n      - name: Build docs\n        run: npm run docs:build\n\n      - name: Deploy to GitHub Pages\n        if: success()\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs_dist\n```", "prompt": "Generate a GitHub Workflow named `Docs Build` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `docs-build`. "}
{"id": "63c494027843b612699fe5e4", "level": "level1", "llm_response": "```yaml\nname: CLA\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Scala\n      uses: scala-actions/setup-scala@v1\n      with:\n        scala-version: '2.13'\n\n    - name: Run CLA check\n      run: |\n        # Add your CLA check command here\n        echo \"Running CLA check...\"\n```", "answer": "```yaml name: CLA\non: [pull_request]\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v1\n    - run: ./ci/check-cla.sh \"${{ github.event.pull_request.user.login }}\"\n```", "prompt": "Generate a GitHub Workflow named `CLA` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check`. "}
{"id": "63c496831e3364807577b1f9", "level": "level1", "llm_response": "```yaml\nname: Fastlane Metadata\n\non:\n  push:\n    branches:\n      - main\n      - '[0-9]+.[0-9]+.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n  pull_request:\n    branches:\n      - main\n      - '[0-9]+.[0-9]+.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n\njobs:\n  validate:\n    id: validate\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n      - name: Run Fastlane validate_metadata\n        run: fastlane validate_metadata\n\n  play-store-upload:\n    id: play-store-upload\n    runs-on: ubuntu-latest\n    needs: validate\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n      - name: Run Fastlane upload_to_play_store\n        run: fastlane upload_to_play_store\n```", "answer": "```yaml name: Fastlane Metadata\non:\n  push:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n  pull_request:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n\njobs:\n  validate:\n    name: Validate\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    steps:\n      - uses: actions/checkout@v3\n      - uses: ashutoshgngwr/validate-fastlane-supply-metadata@v2\n        with:\n          usePlayStoreLocales: true\n\n  play-store-upload:\n    name: Play Store Upload\n    needs: validate\n    if: github.event_name == 'push'\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    steps:\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n      - uses: actions/checkout@v3\n      - run: bundle install\n      - run: echo \"$SERVICE_ACCOUNT_KEY\" > service-account-key.json\n        env:\n          SERVICE_ACCOUNT_KEY: ${{ secrets.SERVICE_ACCOUNT_KEY }}\n      - run: bundle exec fastlane upload_metadata\n      - if: ${{ always() }}\n        run: rm -f service-account-key.json\n```", "prompt": "Generate a GitHub Workflow named `Fastlane Metadata` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of push event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of pull_request event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. The workflow has 2 jobs. The 1st job is named `Validate` and its job id is `validate`. The 2nd job is named `Play Store Upload` and its job id is `play-store-upload`. "}
{"id": "63c496701e3364807577aa6c", "level": "level1", "llm_response": "```yaml\nname: dds-rtps\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  Linux:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up C++ environment\n      uses: actions/setup-cpp@v2\n      with:\n        cpp-version: '10'\n    - name: Build project\n      run: |\n        mkdir build\n        cd build\n        cmake ..\n        make\n```", "answer": "```yaml name: \"omg-dds/dds-rtps\"\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n\n  Linux:\n    runs-on: ubuntu-20.04\n    steps:\n    - name: checkout OpenDDS\n      uses: actions/checkout@v3\n      with:\n        path: OpenDDS\n        submodules: true\n    - name: checkout dds-rtps\n      uses: actions/checkout@v3\n      with:\n        repository: omg-dds/dds-rtps\n        path: dds-rtps\n    - name: checkout ACE_TAO\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/ACE_TAO\n        ref: Latest_Micro\n        path: OpenDDS/ACE_TAO\n    - name: get ACE_TAO commit\n      shell: bash\n      run: |\n        cd OpenDDS/ACE_TAO\n        export ACE_COMMIT=$(git rev-parse HEAD)\n        echo \"ACE_COMMIT=$ACE_COMMIT\" >> $GITHUB_ENV\n    - name: get compiler version\n      shell: bash\n      run: |\n        export COMPILER_VERSION=$(g++ --version 2>&1 | head -n 1)\n        echo \"COMPILER_VERSION=$COMPILER_VERSION\" >> $GITHUB_ENV\n    - name: checkout MPC\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/MPC\n        path: OpenDDS/ACE_TAO/ACE/MPC\n    - name: configure OpenDDS\n      run: |\n        cd OpenDDS\n        ./configure --optimize --no-debug --static --no-inline\n        tools/scripts/show_build_config.pl\n    - uses: ammaraskar/gcc-problem-matcher@0.1\n    - name: build OpenDDS\n      shell: bash\n      run: |\n        cd OpenDDS\n        make -j4 OpenDDS_Rtps_Udp\n    - name: build shape_main\n      shell: bash\n      run: |\n        cd dds-rtps/srcCxx\n        . ../../OpenDDS/setenv.sh\n        mwc.pl -type gnuace\n        make -sj4\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: ${{ github.job }}_artifact\n        path: dds-rtps/srcCxx/shape_main\n```", "prompt": "Generate a GitHub Workflow named `omg-dds/dds-rtps` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `Linux`. "}
{"id": "63c495277843b61269a05c66", "level": "level1", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Dart\n        uses: dart-lang/setup-dart@v1\n        with:\n          sdk-version: '2.12'\n      - name: Run build\n        run: dart pub get && dart pub run build_runner build\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    # runs the CI everyday at 10AM\n    - cron: \"0 10 * * *\"\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        package:\n          - packages/freezed\n          - packages/freezed_annotation\n        channel:\n          - master\n          - stable\n        dependencies:\n          - get\n          - downgrade\n        exclude:\n          - channel: master\n            dependencies: downgrade\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: subosito/flutter-action@v2\n        with:\n          channel: ${{ matrix.channel }}\n          cache: ${{ matrix.channel == 'stable' }}\n\n      # It is executed separately\n      - name: Removing example folder\n        run: rm -rf example\n        working-directory: ${{ matrix.package }}\n\n      - name: Install dependencies\n        run: |\n          flutter pub ${{ matrix.dependencies }}\n        working-directory: ${{ matrix.package }}\n\n      - name: Check format\n        # Check format only on master\n        if: matrix.channel == 'master'\n        run: flutter format --set-exit-if-changed .\n        working-directory: ${{ matrix.package }}\n\n      - name: Generate\n        run: |\n          if grep -q build_runner \"pubspec.yaml\"; then\n            flutter pub run build_runner build --delete-conflicting-outputs\n          fi\n        working-directory: ${{ matrix.package }}\n\n      - name: Analyze\n        run: flutter analyze\n        working-directory: ${{ matrix.package }}\n\n      - name: Run tests\n        run: |\n          if grep -q \"name: example\" \"pubspec.yaml\"; then\n            flutter test\n          else\n            dart test\n          fi\n        working-directory: ${{ matrix.package }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `freezed`. "}
{"id": "63c4968933b087f6bde2ca37", "level": "level1", "llm_response": "```yaml\nname: e2e-kind-upgrades\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Run tests\n        run: go test ./...\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: e2e-kind-upgrades\n\non:\n  # Triggers the workflow on push or pull request events but only for the master branch\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: End-to-end (k3d)\n        run: make test/e2e/k3d-upgrades\n```", "prompt": "Generate a GitHub Workflow named `e2e-kind-upgrades` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. 3) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `e2e-kind-upgrades`. "}
{"id": "63c494147843b612699fedb4", "level": "level1", "llm_response": "```yaml\nname: test-chart-testing-action\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test_ct_action:\n    id: test_ct_action\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Install chart-testing\n        run: |\n          wget https://github.com/helm/chart-testing/releases/download/v3.3.0/chart-testing_3.3.0_linux_amd64.tar.gz\n          tar -zxvf chart-testing_3.3.0_linux_amd64.tar.gz\n          mv chart-testing_3.3.0_linux_amd64/chart-testing /usr/local/bin/\n          chart-testing --version\n\n  test_ct_action_custom:\n    id: test_ct_action_custom\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Install Custom chart-testing\n        run: |\n          wget https://github.com/helm/chart-testing/releases/download/v3.3.0/chart-testing_3.3.0_linux_amd64.tar.gz\n          tar -zxvf chart-testing_3.3.0_linux_amd64.tar.gz\n          mv chart-testing_3.3.0_linux_amd64/chart-testing /usr/local/bin/chart-testing-custom\n          chart-testing-custom --version\n```", "answer": "```yaml name: test-chart-testing-action\n\non: [pull_request]\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n\n    name: Install chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.7.1' ]]; then\n          echo 'should be v3.7.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n\n    name: Install Custom chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n      with:\n        version: 'v3.5.1'\n        yamllint_version: '1.27.1'\n        yamale_version: '3.0.4'\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.5.1' ]]; then\n          echo 'should be v3.5.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n```", "prompt": "Generate a GitHub Workflow named `test-chart-testing-action` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Install chart-testing and test presence in path` and its job id is `test_ct_action`. The 2nd job is named `Install Custom chart-testing and test presence in path` and its job id is `test_ct_action_custom`. "}
{"id": "63c494fc8052faa2781aead3", "level": "level1", "llm_response": "```yaml\nname: Update Release List\n\non:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [completed]\n    branches: [master]\n\npermissions:\n  contents: write\n\nenv:\n  USER_NAME: \"ctags-win32 CI\"\n  USER_EMAIL: \"ctags-win32-ci@users.noreply.github.com\"\n  COL_RED: \u001b[31m\n  COL_GREEN: \u001b[32m\n  COL_YELLOW: \u001b[33m\n  COL_RESET: \u001b[m\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: Update Release List\n\non:\n  #release:\n  #  types: [published]\n  workflow_run:\n    workflows: [\"Build\"]\n    branches: [master]\n    types: [completed]\n\npermissions:\n  contents: write # to update wiki\n\nenv:\n  # Account for committing\n  USER_NAME: \"ctags-win32 CI\"\n  USER_EMAIL: \"ctags-win32-ci@users.noreply.github.com\"\n\n  # Escape sequences\n  COL_RED: \"\\x1b[31m\"\n  COL_GREEN: \"\\x1b[32m\"\n  COL_YELLOW: \"\\x1b[33m\"\n  COL_RESET: \"\\x1b[m\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        path: main\n\n    - uses: actions/checkout@v3\n      with:\n        repository: \"${{ github.repository }}.wiki\"\n        path: wiki\n\n    - name: Update Release List\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      run: |\n        cd main\n        latest=$(cat ctagsver.txt)\n        cd ../wiki\n        ../main/scripts/update-release-list.py\n        git add Releases-in-*.md\n        if git diff HEAD --quiet; then\n          echo ${COL_YELLOW}No updates.${COL_RESET}\n        else\n          git config --local user.name ${USER_NAME}\n          git config --local user.email ${USER_EMAIL}\n          git commit -a -m \"Update Release List to ${latest}\"\n          git push origin HEAD\n        fi\n```", "prompt": "Generate a GitHub Workflow named `Update Release List` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the workflow named Build is completed on a branch whose name matches master. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets 6 environment variables to use: `USER_NAME` is set to `ctags-win32 CI`, `USER_EMAIL` is set to `ctags-win32-ci@users.noreply.github.com`, `COL_RED` is set to `\u001b[31m`, `COL_GREEN` is set to `\u001b[32m`, `COL_YELLOW` is set to `\u001b[33m` and `COL_RESET` is set to `\u001b[m`. The workflow has one job. The job id of the 1st job is `update`. "}
{"id": "63c4969c1899db58864d4153", "level": "level1", "llm_response": "```yaml\nname: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    id: backend-tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Run backend tests\n        run: pytest backend\n\n  frontend-tests:\n    id: frontend-tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Run frontend and end-to-end tests\n        run: npm run test\n\n  build-release:\n    id: build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Docker\n        uses: docker/setup-buildx-action@v1\n      - name: Build Docker image\n        run: docker build -t my-python-app:${{ github.sha }} .\n      - name: Push Docker image\n        run: docker push my-python-app:${{ github.sha }}\n\n  notify-discord:\n    id: notify-discord\n    runs-on: ubuntu-latest\n    steps:\n      - name: Notify Discord\n        run: echo \"Notification sent to Discord channel\"\n\n  deploy-demo:\n    id: deploy-demo\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to demo environment\n        run: echo \"Deploying to demo environment\"\n```", "answer": "```yaml name: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    name: \"Backend Server Tests\"\n    uses: ./.github/workflows/partial-backend.yml\n\n  frontend-tests:\n    name: \"Frontend and End-to-End Tests\"\n    uses: ./.github/workflows/partial-frontend.yml\n\n  build-release:\n    name: Build Tagged Release\n    uses: ./.github/workflows/partial-builder.yml\n    needs:\n      - frontend-tests\n      - backend-tests\n    with:\n      tag: nightly\n    secrets:\n      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}\n      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}\n\n  notify-discord:\n    name: Notify Discord\n    needs:\n      - build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        env:\n          DISCORD_WEBHOOK: ${{ secrets.DISCORD_NIGHTLY_WEBHOOK }}\n        uses: Ilshidur/action-discord@0.3.2\n        with:\n          args: \"\ud83d\ude80  A New build of mealie:api-nightly and mealie:frontend-nightly is available\"\n\n  deploy-demo:\n    runs-on: ubuntu-latest\n    name: Deploy Demo\n    needs:\n      - build-release\n    steps:\n      - name: Clean and Deploy Demo\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.DEMO_SERVER_IP }}\n          username: ${{ secrets.DEMO_SERVER_USER }}\n          key: ${{ secrets.DEMO_SERVER_SSH_KEY }}\n          port: ${{ secrets.DEMO_SERVER_PORT }}\n          script_stop: true\n          script: |\n            cd ~/docker/mealie-next\n            docker-compose pull\n            docker-compose down -v\n            docker-compose up -d\n```", "prompt": "Generate a GitHub Workflow named `Docker Nightly Production` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named mealie-next. Only a single workflow using the nightly-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 5 jobs. The 1st job is named `Backend Server Tests` and its job id is `backend-tests`. The 2nd job is named `Frontend and End-to-End Tests` and its job id is `frontend-tests`. The 3rd job is named `Build Tagged Release` and its job id is `build-release`. The 4th job is named `Notify Discord` and its job id is `notify-discord`. The 5th job is named `Deploy Demo` and its job id is `deploy-demo`. "}
{"id": "63c494037843b612699fe649", "level": "level1", "llm_response": "```yaml\nname: Tag\n\non:\n  workflow_dispatch:\n\ninputs:\n  version:\n    description: 'version'\n    required: true\n  tag:\n    description: 'tag'\n    required: true\n    default: 'latest'\n\npermissions:\n  contents: write\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Tag version\n        run: git tag ${{ github.event.inputs.version }}\n\n      - name: Push tag\n        run: git push origin ${{ github.event.inputs.version }}\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: Version\n        required: true\n      tag:\n        description: Tag\n        default: latest\n        required: true\n\npermissions: {}\njobs:\n  build:\n    name: Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}\n    environment: release\n    runs-on: ubuntu-latest\n    steps:\n    - name: Setup Node\n      uses: actions/setup-node@v3\n    - name: Update tag\n      env:\n        \"npm_config_//registry.npmjs.org/:_authToken\": ${{ secrets.NPM_TOKEN }}\n      run: |\n        npm dist-tag add pnpm@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n        npm dist-tag add @pnpm/exe@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n```", "prompt": "Generate a GitHub Workflow named `Tag` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives 2 inputs: version-this input represents version and it must be supplied; tag-this input represents tag, its default value is latest and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: the workflow disables permissions for the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}` and its job id is `build`. "}
{"id": "63c4949a8052faa2781ac0b0", "level": "level1", "llm_response": "```yaml\nname: Node.js CI\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Use Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n    - run: npm install\n    - run: npm run build --if-present\n    - run: npm test\n```", "answer": "```yaml # This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Node.js CI\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: Cache pnpm modules\n        uses: actions/cache@v3\n        env:\n          cache-name: cache-pnpm-modules\n        with:\n          path: ~/.pnpm-store\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n      - uses: actions/cache@v3\n        with:\n          path: |\n            ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}\n          restore-keys: |\n            ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-\n      - uses: pnpm/action-setup@v2.2.4\n        with:\n          version: 7.x.x\n          run_install: true\n      - name: Build project\n        run: |\n          yarn build\n          yarn lint\n        env:\n          CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node.js CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c4967e1899db58864d33dd", "level": "level1", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    id: lint-commit-message\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Check commit message\n        run: |\n          commit_message=$(git log -1 --pretty=%B)\n          if [[ $commit_message =~ ^[A-Z]+[a-z\\s]*[.!?]$ ]]; then\n            echo \"Commit message is valid.\"\n          else\n            echo \"Commit message is invalid.\"\n            exit 1\n          fi\n\n  lint-go:\n    id: lint-go\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Run Go lint\n        run: go vet ./...\n```", "answer": "```yaml #\n# DO NOT EDIT THIS FILE\n#\n# It is automatically copied from https://github.com/pion/.goassets repository.\n# If this repository should have package specific CI config,\n# remove the repository name from .goassets/.github/workflows/assets-sync.yml.\n#\n# If you want to update the shared CI config, send a PR to\n# https://github.com/pion/.goassets instead of this repository.\n#\n\nname: Lint\non:\n  pull_request:\n    types:\n      - opened\n      - edited\n      - synchronize\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    name: Metadata\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n        - uses: actions/checkout@v3\n          with:\n            fetch-depth: 0\n\n        - name: Commit Message\n          run: .github/lint-commit-message.sh\n\n        - name: File names\n          run: .github/lint-filename.sh\n\n        - name: Functions\n          run: .github/lint-disallowed-functions-in-library.sh\n\n        - name: Logging messages should not have trailing newlines\n          run: .github/lint-no-trailing-newline-in-log-messages.sh\n\n  lint-go:\n    name: Go\n    permissions:\n      contents: read\n      pull-requests: read\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: golangci-lint\n        uses: golangci/golangci-lint-action@v3\n        with:\n          version: v1.45.2\n          args: $GOLANGCI_LINT_EXRA_ARGS\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created, the title or body of a pull request is edited or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `Metadata` and its job id is `lint-commit-message`. The 2nd job is named `Go` and its job id is `lint-go`. "}
{"id": "63c4947b8052faa2781ab631", "level": "level1", "llm_response": "```yaml\nname: Publish Test Results\n\non:\n  workflow_run:\n    workflows: [CI]\n    types: [completed]\n\njobs:\n  test-results:\n    id: test-results\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up JDK\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Run tests\n        run: ./mvnw test\n\n      - name: Publish test results\n        uses: actions/upload-artifact@v2\n        with:\n          name: test-results\n          path: target/surefire-reports\n```", "answer": "```yaml # Publishing of unit test results has to be a separate workflow in order to support forked PRs\n# See https://github.com/EnricoMi/publish-unit-test-result-action#support-fork-repositories-and-dependabot-branches\nname: Publish Test Results\non:\n  workflow_run:\n    workflows: [CI]\n    types:\n      - completed\njobs:\n  test-results:\n    name: Test Results\n    runs-on: ubuntu-latest\n    if: github.event.workflow_run.conclusion != 'skipped'\n\n    steps:\n      - name: Download and Extract Artifacts\n        env:\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n        run: |\n          mkdir -p artifacts && cd artifacts\n\n          artifacts_url=${{ github.event.workflow_run.artifacts_url }}\n\n          gh api \"$artifacts_url\" -q '.artifacts[] | [.name, .archive_download_url] | @tsv' | while read artifact\n          do\n            IFS=$'\\t' read name url <<< \"$artifact\"\n            gh api $url > \"$name.zip\"\n            unzip -d \"$name\" \"$name.zip\"\n          done\n\n      - name: Publish Test Results\n        uses: EnricoMi/publish-unit-test-result-action@v2\n        with:\n          commit: ${{ github.event.workflow_run.head_sha }}\n          event_file: artifacts/Event File/event.json\n          event_name: ${{ github.event.workflow_run.event }}\n          junit_files: |\n            artifacts/**/surefire-reports/*.xml\n            artifacts/**/failsafe-reports/TEST-*.xml\n```", "prompt": "Generate a GitHub Workflow named `Publish Test Results` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: the workflow named CI is completed. The workflow has one job. The 1st job is named `Test Results` and its job id is `test-results`. "}
{"id": "63c4964a1e33648075779a84", "level": "level1", "llm_response": "```yaml\nname: Publish Terminal.Gui\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  publish:\n    id: publish\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up .NET\n        uses: actions/setup-dotnet@v2\n        with:\n          dotnet-version: '6.0'\n\n      - name: Build and publish\n        run: dotnet publish Terminal.Gui.csproj -c Release -o ./publish\n        working-directory: src\n\n      - name: Publish to NuGet\n        run: dotnet nuget push ./publish/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json\n        working-directory: src\n```", "answer": "```yaml name: Publish Terminal.Gui\non:\n  push:\n    tags:\n      - v*\n\njobs:\n\n  publish:\n    name: Build and Publish to Nuget.org\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0 #fetch-depth is needed for GitVersion\n\n    - name: Install and calculate the new version with GitVersion \n      uses: gittools/actions/gitversion/setup@v0.9.13\n      with:\n        versionSpec: 5.x\n\n    - name: Determine Version\n      uses: gittools/actions/gitversion/execute@v0.9.13\n      id: gitversion # step id used as reference for output values\n\n    - name: Display GitVersion outputs\n      run: |\n        echo \"Version: ${{ steps.gitversion.outputs.SemVer }}\"\n        echo \"CommitsSinceVersionSource: ${{ steps.gitversion.outputs.CommitsSinceVersionSource }}\"\n\n    - name: Setup dotnet\n      uses: actions/setup-dotnet@v3.0.1\n      with:\n        dotnet-version: 6.0.100\n\n    - name: Install dependencies\n      run: dotnet restore\n\n    - name: Build Release\n      run: |\n        dotnet-gitversion /updateprojectfiles\n        dotnet build --no-restore -c Release\n\n    - name: Pack\n      run: dotnet pack -c Release --include-symbols -p:Version='${{ steps.gitversion.outputs.SemVer }}' \n\n    - name: Test to generate Code Coverage Report\n      run: |\n        dotnet test --verbosity normal --collect:\"XPlat Code Coverage\" --settings UnitTests/coverlet.runsettings\n        mv -v UnitTests/TestResults/*/*.* UnitTests/TestResults/\n\n    - name: Create Test Coverage Badge\n      uses: simon-k/dotnet-code-coverage-badge@v1.0.0\n      id: create_coverage_badge\n      with:\n        label: Unit Test Coverage\n        color: brightgreen\n        path: UnitTests/TestResults/coverage.opencover.xml\n        gist-filename: code-coverage.json\n        # https://gist.github.com/migueldeicaza/90ef67a684cb71db1817921a970f8d27\n        gist-id: 90ef67a684cb71db1817921a970f8d27\n        gist-auth-token: ${{ secrets.GIST_AUTH_TOKEN }}   \n\n    - name: Print Code Coverage\n      run: |\n        echo \"Code coverage percentage: ${{steps.create_coverage_badge.outputs.percentage}}%\"\n        echo \"Badge data: ${{steps.create_coverage_badge.outputs.badge}}\"\n        \n    #- name: Prep GitHub Packages\n    #  run: dotnet nuget add source --username tig --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/tig/index.json\"\n\n    #- name: Publish to GitHub packages \n    #  run: dotnet nuget push NStack/bin/Release/*.nupkg --api-key ${{ secrets.GITHUB_TOKEN }}  --source \"github\"\n\n    - name: Publish to NuGet.org\n      run: dotnet nuget push Terminal.Gui/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json\n```", "prompt": "Generate a GitHub Workflow named `Publish Terminal.Gui` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Build and Publish to Nuget.org` and its job id is `publish`. "}
{"id": "63c4950a7843b61269a0501c", "level": "level1", "llm_response": "```yaml\nname: Integration test on schedule (minimal)\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  start-integration-test-minimal:\n    id: start-integration-test-minimal\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run integration tests\n        run: npm test integration\n```", "answer": "```yaml name: Integration test on schedule (minimal)\nconcurrency: ${{ github.workflow }}-${{ github.ref }}\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  start-integration-test-minimal:\n    name: Start integration test (minimal)\n    uses: ./.github/workflows/integration.yml\n    secrets: inherit\n    with:\n      install_profile: minimal\n      cluster_region: ams3\n      kubernetes_versions: \"['1.22', '1.23']\"\n```", "prompt": "Generate a GitHub Workflow named `Integration test on schedule (minimal)` for a GitHub repository whose primary programming language is Mustache. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Start integration test (minimal)` and its job id is `start-integration-test-minimal`. "}
{"id": "63c494b08052faa2781aca76", "level": "level1", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Set up Objective-C environment\n        uses: actions/setup-xcode@v2\n        with:\n          xcode-version: '12.4'\n      - name: Install dependencies\n        run: |\n          pod install\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v1\n        with:\n          languages: objective-c\n      - name: Perform CodeQL analysis\n        uses: github/codeql-action/analyze@v1\n```", "answer": "```yaml name: 'CodeQL'\n\non:\n  push:\n    branches: [master]\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: macos-11\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: ['cpp']\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n        with:\n          languages: ${{ matrix.language }}\n\n      - run: >-\n          env NSUnbufferedIO=YES\n          xcodebuild\n          -workspace Sentry.xcworkspace\n          -scheme Sentry\n          -configuration Release\n          -destination platform=\"iOS Simulator,OS=latest,name=iPhone 11 Pro\"\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 04:40 am, only on saturday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. "}
{"id": "63c496891e3364807577b43d", "level": "level1", "llm_response": "```yaml\nname: Check Actions rate limit\n\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Check Actions rate limit\n        run: |\n          echo \"Actions rate limit: $(curl -s -H \"Authorization: token ${{ github.token }}\" https://api.github.com/rate_limit | jq '.rate.remaining')\"\n```", "answer": "```yaml name: Check Actions rate limit\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    name: Check Actions rate limit\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check rate limit\n        env:\n          TOKEN: ${{ github.token }}\n        run: |\n          curl -v --no-progress-meter --header \"Authorization: Bearer $TOKEN\" https://api.github.com/rate_limit\n```", "prompt": "Generate a GitHub Workflow named `Check Actions rate limit` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Check Actions rate limit` and its job id is `check`. "}
{"id": "63c4969e1899db58864d41ee", "level": "level1", "llm_response": "```yaml\nname: Auto message on Creating Issue\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Create auto message\n      run: echo \"Thank you for opening an issue! We will get back to you soon.\" > issue-auto-message.txt\n\n    - name: Commit and push auto message\n      run: |\n        git config --global user.name 'GitHub Actions'\n        git config --global user.email 'actions@github.com'\n        git add issue-auto-message.txt\n        git commit -m \"Add auto message for new issues\"\n        git push\n```", "answer": "```yaml name: Auto message on Creating Issue.\n\non:\n\n  issues:\n\n    types: [opened]\n\njobs:\n\n  greeting:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - name: Create comment for issue\n\n      if: github.event_name =='issues' \n\n      uses: peter-evans/create-or-update-comment@v1\n\n      with:\n\n        issue-number: ${{tojson(github.event.issue.number)}}\n\n        body: |\n\n            Hi \ud83d\ude04, @${{ github.actor }} Thanks for creating an issue at FunwithPhysics. We request you to follow the contributing guidelines. \n```", "prompt": "Generate a GitHub Workflow named `Auto message on Creating Issue.` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `greeting`. "}
{"id": "63c496941899db58864d3d85", "level": "level1", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Swift\n        uses: apple/swift-action@v1\n\n      - name: Run release-please\n        run: npx release-please --language=swift --owner=<your-github-username> --repo=<your-repo-name>\n```", "answer": "```yaml name: release-please\non:\n   push:\n      branches:\n         - master\njobs:\n   release-please:\n      runs-on: ubuntu-latest\n      steps:\n         - uses: GoogleCloudPlatform/release-please-action@v2\n           with:\n            token: ${{ secrets.GITHUB_TOKEN }}\n            release-type: simple\n            version-file: \"./version.txt\"\n            package-name: release-please-action\n            default-branch: master\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is Swift. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. "}
{"id": "63c496486fc19abdf9c9b0d5", "level": "level1", "llm_response": "```yaml\nname: Dependencies\n\non:\n  schedule:\n    - cron: '0 12 * * 1'\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    id: upgrade\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Upgrade dependencies\n        run: npm update\n```", "answer": "```yaml name: Dependencies\n\non:\n  schedule:\n    - cron: \"0 12 * * 1\"\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    name: Upgrade dependencies\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2\n        with:\n          version: latest\n      - uses: actions/setup-node@v3\n        with:\n          cache: \"pnpm\"\n          node-version-file: \".nvmrc\"\n          registry-url: \"https://npm.pkg.github.com\"\n      - run: rm -rf pnpm-lock.yaml **/node_modules/\n      - run: pnpm install\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_GITHUB_TOKEN }}\n      - uses: EndBug/add-and-commit@v9\n        with:\n          message: \"chore(deps): upgrade versions\"\n```", "prompt": "Generate a GitHub Workflow named `Dependencies` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 pm, only on monday. 2) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Upgrade dependencies` and its job id is `upgrade`. "}
{"id": "63c4954d8052faa2781b0e83", "level": "level1", "llm_response": "```yaml\nname: xgo\n\non:\n  push:\n    branches:\n      - master\n    tags:\n      - v*\n    paths-ignore:\n      - '**/*.md'\n  pull_request:\n    branches:\n      - master\n    paths-ignore:\n      - '**/*.md'\n\nconcurrency:\n  group: 'xgo-${{ github.ref }}'\n  cancel-in-progress: true\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run build commands\n        run: |\n          # Add your build commands here\n```", "answer": "```yaml name: xgo\n\nconcurrency:\n  group: xgo-${{ github.ref }}\n  cancel-in-progress: true\n\non:\n  push:\n    branches:\n      - 'master'\n    tags:\n      - 'v*'\n    paths-ignore:\n      - '**.md'\n  pull_request:\n    branches:\n      - 'master'\n    paths-ignore:\n      - '**.md'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n      -\n        name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      -\n        name: Build artifacts\n        uses: docker/bake-action@v2\n        with:\n          targets: artifact-all\n      -\n        name: Move artifacts\n        run: |\n          mv ./dist/**/* ./dist/\n      -\n        name: Upload artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: xgo\n          path: ./dist/*\n          if-no-files-found: error\n      -\n        name: GitHub Release\n        uses: softprops/action-gh-release@v1\n        if: startsWith(github.ref, 'refs/tags/v')\n        with:\n          draft: true\n          files: |\n            dist/*.tar.gz\n            dist/*.zip\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `xgo` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a tag whose name matches v*. When all the path names of push event match patterns in the paths-ignore filter(**.md), the workflow will not run. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. When all the path names of pull_request event match patterns in the paths-ignore filter(**.md), the workflow will not run. Only a single workflow using the xgo-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c494a48052faa2781ac54e", "level": "level1", "llm_response": "```yaml\nname: lint\n\non:\n  pull_request:\n    branches:\n      - main\n    paths-ignore:\n      - docs/**\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - docs/**\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install cspell\n        run: npm install -g cspell\n      - name: Run cspell\n        run: cspell .\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Run lint\n        run: npm run lint\n```", "answer": "```yaml name: lint\non: # rebuild any PRs and main branch changes\n  pull_request:\n    paths-ignore:\n      - \"docs/**\"\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - \"docs/**\"\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx cspell \"**\" --dot --no-progress\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: yarn\n      - run: yarn lint\n```", "prompt": "Generate a GitHub Workflow named `lint` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) When all the path names of pull_request event match patterns in the paths-ignore filter(docs/**), the workflow will not run. 2) The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**), the workflow will not run. The workflow has 2 jobs. The job id of the 1st job is `cspell`. The job id of the 2nd job is `lint`. "}
{"id": "63c4957d8052faa2781b229c", "level": "level1", "llm_response": "```yaml\nname: Build site nightly\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  dot-release:\n    id: dot-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build the site\n        run: npm run build\n```", "answer": "```yaml # Copyright 2022 The Knative Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nname: Build site nightly\n\non:\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  dot-release:\n    name: dot-release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: curl\n        env:\n          NETLIFY_BUILD_HOOK: ${{ secrets.NETLIFY_BUILD_HOOK }}\n        uses: wei/curl@v1\n        with:\n          args: -X POST -d '{}' \"$NETLIFY_BUILD_HOOK\"\n```", "prompt": "Generate a GitHub Workflow named `Build site nightly` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `dot-release` and its job id is `dot-release`. "}
{"id": "63c496891e3364807577b43a", "level": "level1", "llm_response": "```yaml\nname: Jetpack block performance\n\non:\n  schedule:\n    - cron: '0 */12 * * *'\n\njobs:\n  block-performance:\n    id: performance-tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up PHP\n        uses: shivammathur/setup-php@v2\n        with:\n          php-version: '7.4'\n      - name: Run performance tests\n        run: php vendor/bin/phpunit --group performance\n\n  test-reports:\n    id: trigger-test-report-workflow\n    runs-on: ubuntu-latest\n    needs: block-performance\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Trigger test report workflow\n        run: gh workflow run test-report.yml --ref ${{ github.ref }}\n\n  slack-notification:\n    id: slack-notification\n    runs-on: ubuntu-latest\n    needs: test-reports\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Send Slack notification\n        run: echo \"Performance tests completed. Check the test reports.\" | slack-notify\n```", "answer": "```yaml name: Jetpack block performance\n\non:\n  schedule:\n    - cron:  '0 */12 * * *'\n\njobs:\n  block-performance:\n    name: \"Performance tests\"\n    runs-on: ubuntu-latest\n    timeout-minutes: 50  # 2021-12-13: Successful runs seem to take 40 minutes\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n\n      - uses: actions/checkout@v3\n        with:\n          repository: 'WordPress/gutenberg'\n          path: 'gutenberg'\n\n      - name: Build Gutenberg\n        working-directory: gutenberg\n        run: |\n          npm ci\n          npm run build\n\n      - uses: actions/cache@v3\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('gutenberg/**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - name: Setup tools for J\n        uses: ./.github/actions/tool-setup\n\n      - name: Build Production Jetpack\n        run: |\n          pnpm install\n          pnpm jetpack build plugins/jetpack -v --production\n\n      - name: Environment set-up\n        working-directory: tools/e2e-commons\n        env:\n          CONFIG_KEY: ${{ secrets.E2E_CONFIG_KEY }}\n        run: |\n          # Gutenberg Performance tests require disable-animations.php test plugin to be available on a site. Below we inject the mapping for that plugin into a Docker config file\n\n          echo \"e2e:\" >> ../docker/jetpack-docker-config.yml\n          echo \"  volumeMappings:\" >> ../docker/jetpack-docker-config.yml\n          echo \"    gutenberg/packages/e2e-tests/plugins/disable-animations.php: /var/www/html/wp-content/plugins/disable-animations.php\" >> ../docker/jetpack-docker-config.yml\n\n          mkdir results\n          pnpm config:decrypt\n          pnpm env:start\n\n      - name: Run performance tests\n        working-directory: tools/e2e-commons\n        run: |\n          node ./bin/performance.js\n\n      - name: Environment tear-down\n        if: ${{ always() }}\n        working-directory: tools/e2e-commons\n        continue-on-error: true\n        run: |\n          pnpm run tunnel:off\n          # Update permissions to workaround https://github.com/actions/cache/issues/753\n          sudo chown -R runner:docker \"$GITHUB_WORKSPACE/tools/docker\"\n\n      - name: Upload test artifacts\n        if: ${{ always() }}\n        continue-on-error: true\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-output-block-perf\n          path: tools/e2e-commons/results\n\n  test-reports:\n    name: \"Trigger test report workflow\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: block-performance\n\n    steps:\n      - name: Repository Dispatch\n        uses: peter-evans/repository-dispatch@v2\n        with:\n          token: ${{ secrets.E2E_TEST_REPORTS_TOKEN }}\n          repository: automattic/jetpack-e2e-reports\n          event-type: block-perf\n          client-payload: '{\"run_id\": \"${{github.run_id}}\", \"repository\": \"${{github.repository}}\"}'\n\n  slack-notification:\n    name: \"Slack notification\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: [block-performance]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up tools\n        uses: ./.github/actions/tool-setup\n\n      - name: Build action\n        env:\n          COMPOSER_ROOT_VERSION: dev-trunk\n        run: |\n          pnpm install\n          composer install\n          composer build-development\n        working-directory: ./projects/github-actions/test-results-to-slack\n\n      - name: \"Send notification\"\n        uses: ./projects/github-actions/test-results-to-slack\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          slack_token: ${{ secrets.SLACK_TOKEN }}\n          slack_channel: ${{ secrets.SLACK_E2E_CHANNEL }}\n          slack_icon_emoji: \":jetpack:\"\n          suite_name: \"blocks performance\"\n```", "prompt": "Generate a GitHub Workflow named `Jetpack block performance` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: the scheduled time has come: every 12 hours. The workflow has 3 jobs. The 1st job is named `Performance tests` and its job id is `block-performance`. The 2nd job is named `Trigger test report workflow` and its job id is `test-reports`. The 3rd job is named `Slack notification` and its job id is `slack-notification`. "}
{"id": "63c4968633b087f6bde2c8ea", "level": "level1", "llm_response": "```yaml\nname: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - '[0-9]+.[0-9]+.[0-9]+'\n      - '[0-9]+.[0-9]+.[0-9]+rc[0-9]+'\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install tox\n      - name: Run tox\n        run: tox\n```", "answer": "```yaml name: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - \"[0-9]+.[0-9]+.[0-9]+\"\n      - \"[0-9]+.[0-9]+.[0-9]+rc[0-9]+\"\n\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment:\n          - \"py36\"\n          - \"py37\"\n          - \"flake8\"\n\n        include:\n          - environment: \"py36\"\n            python: \"3.6\"\n          - environment: \"py37\"\n            python: \"3.7\"\n          - environment: \"flake8\"\n            python: \"3.7\"\n\n    container:\n      image: python:${{ matrix.python }}\n\n    steps:\n      - uses: actions/checkout@master\n      - name: Install tox\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install tox\n      - name: Run tox\n        run: |\n          tox -e ${{ matrix.environment }}\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a tag whose name matches [0-9]+.[0-9]+.[0-9]+ or a tag whose name matches [0-9]+.[0-9]+.[0-9]+rc[0-9]+. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `tox`. "}
{"id": "63c494187843b612699fef56", "level": "level1", "llm_response": "```yaml\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Enable debug mode'\n        required: false\n        type: boolean\n        default: false\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: false\n\njobs:\n  fork_update_pr:\n    id: fork_update_pr\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Run debug commands\n        if: ${{ github.event.inputs.debug-the }}\n        run: echo \"Debug mode is enabled\"\n\n      - name: Update PR\n        run: echo \"Updating PR\"\n```", "answer": "```yaml #\n#  Author: Hari Sekhon\n#  Date: Tue Feb 4 09:53:28 2020 +0000\n#\n#  vim:ts=2:sts=2:sw=2:et\n#\n#  https://github.com/HariSekhon/Kubernetes-configs\n#\n#  If you're using my code you're welcome to connect with me on LinkedIn and optionally send me feedback\n#\n#  https://www.linkedin.com/in/HariSekhon\n#\n\n---\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        required: false\n        default: false\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: false\n\njobs:\n  fork_update_pr:\n    # github.event.repository context not available in scheduled workflows\n    #if: github.event.repository.fork == true\n    if: github.repository_owner != 'HariSekhon'\n    name: Fork Update PR\n    uses: HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master\n    with:\n      debug: ${{ github.event.inputs.debug }}\n```", "prompt": "Generate a GitHub Workflow named `Fork Update PR` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, it is optional and its default value is False. 2) the scheduled time has come: at 10:00 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.ref }}-${{ github.workflow }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Fork Update PR` and its job id is `fork_update_pr`. "}
{"id": "63c494e67843b61269a04123", "level": "level1", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n    branches:\n      - '**'\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Dart\n        uses: subosito/flutter-action@v2\n        with:\n          channel: 'stable'\n\n      - name: Run tests\n        run: flutter test\n```", "answer": "```yaml name: CI\non:\n  pull_request:\n    branches:\n      - '**'\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '2.10.4'\n          channel: 'stable'\n\n      - name: Checkout OneSignal-Flutter-SDK\n        uses: actions/checkout@v3\n\n      - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n        run: flutter pub get\n\n      - name: Static Analysis\n        run: flutter analyze\n\n      - name: Ensure the Dart code is formatted correctly\n        run: flutter format --set-exit-if-changed --dry-run .\n\n      - name: Run Flutter unit tests\n        run: flutter test\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch whose name matches **. When all the path names of pull_request event match patterns in the paths-ignore filter(.github/**, .vscode/** or README.md), the workflow will not run. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c4957b8052faa2781b219f", "level": "level1", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - '**.go'\n  pull_request:\n    branches:\n      - main\n    paths:\n      - '**.go'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Run tests\n        run: go test ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - '**.go'\n  pull_request:\n    branches: [ main ]\n    paths:\n      - '**.go'\n\njobs:\n\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: 1.18\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -cover -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(**.go), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. Only if at least one path of pull_request event matches a pattern in the paths filter(**.go), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c495928052faa2781b2bc1", "level": "level1", "llm_response": "```yaml\nname: Create Release\n\non:\n  push:\n    tags:\n      - v*\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Erlang\n        uses: erlang/actions/setup@v1\n        with:\n          otp-version: 24.0\n\n      - name: Build project\n        run: make\n\n      - name: Create release\n        id: create_release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          draft: false\n          prerelease: false\n```", "answer": "```yaml \n# https://github.com/actions/create-release\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    name: Create Release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Create Release\n        id: create_release\n        uses: actions/create-release@latest\n        env:\n          GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: ${{ github.ref }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Create Release` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Create Release` and its job id is `build`. "}
{"id": "63c496686fc19abdf9c9bea4", "level": "level1", "llm_response": "```yaml\nname: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Scala\n        uses: scala-steward/scala-steward-action@v1\n        with:\n          scala-version: \"2.13.6\"\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.ADMIN_GITHUB_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Drafts/updates the next repository release` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. "}
{"id": "63c494768052faa2781ab616", "level": "level1", "llm_response": "```yaml\nname: Static analysis\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  static-psalm-analysis:\n    id: static-psalm-analysis\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ocp-version: [7.3, 8.0, 8.1]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run static analysis with Psalm\n        run: vendor/bin/psalm --show-info=false --show-progress=false --report=report.xml\n```", "answer": "```yaml name: Static analysis\n\non: [pull_request]\n\njobs:\n  static-psalm-analysis:\n      runs-on: ubuntu-latest\n      strategy:\n          matrix:\n              ocp-version: [ 'v20.0.7', 'v21.0.0', 'dev-stable22', 'dev-stable23', 'dev-master' ]\n      name: Nextcloud ${{ matrix.ocp-version }}\n      steps:\n          - name: Checkout\n            uses: actions/checkout@master\n          - name: Set up php\n            uses: shivammathur/setup-php@master\n            with:\n                php-version: 7.4\n                tools: composer:v1\n                coverage: none\n          - name: Install dependencies\n            run: composer i\n          - name: Install dependencies\n            run: composer require --dev christophwurst/nextcloud:${{ matrix.ocp-version }}\n          - name: Run coding standards check\n            run: composer run psalm\n```", "prompt": "Generate a GitHub Workflow named `Static analysis` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Nextcloud ${{ matrix.ocp-version }}` and its job id is `static-psalm-analysis`. "}
{"id": "63c4951f8052faa2781af9e5", "level": "level1", "llm_response": "```yaml\nname: IRC Notification\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n    - name: Install dependencies\n      run: npm install\n    - name: Run tests\n      run: npm test\n```", "answer": "```yaml name: \"IRC Notification\"\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: irc push\n        uses: vmiklos/notify-irc@bfd6f632b683859f6cd074e2ee9db68bef204f7d\n        if: github.event_name == 'push' && github.event.ref == 'refs/heads/master' && github.repository == 'CollaboraOnline/online'\n        with:\n          channel: \"#cool-dev\"\n          nickname: github-online\n          message: |\n            ${{ toJson(github.event) }}\n```", "prompt": "Generate a GitHub Workflow named `IRC Notification` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `test`. "}
{"id": "63c493ee7843b612699fde0c", "level": "level1", "llm_response": "```yaml\nname: nf-core AWS test\n\non:\n  workflow_dispatch:\n\njobs:\n  run-tower:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Nextflow\n        uses: nextflow/setup-nextflow@v1\n        with:\n          version: latest\n\n      - name: Run AWS tests\n        run: nextflow run nf-core/rnaseq -profile aws\n```", "answer": "```yaml name: nf-core AWS test\n# This workflow can be triggered manually with the GitHub actions workflow dispatch button.\n# It runs the -profile 'test' on AWS batch\n\non:\n  workflow_dispatch:\njobs:\n  run-tower:\n    name: Run AWS tests\n    if: github.repository == 'nf-core/mag'\n    runs-on: ubuntu-latest\n    steps:\n      # Launch workflow using Tower CLI tool action\n      - name: Launch workflow via tower\n        uses: nf-core/tower-action@v3\n        with:\n          workspace_id: ${{ secrets.TOWER_WORKSPACE_ID }}\n          access_token: ${{ secrets.TOWER_ACCESS_TOKEN }}\n          compute_env: ${{ secrets.TOWER_COMPUTE_ENV }}\n          workdir: s3://${{ secrets.AWS_S3_BUCKET }}/work/mag/work-${{ github.sha }}\n          parameters: |\n            {\n              \"outdir\": \"s3://${{ secrets.AWS_S3_BUCKET }}/mag/results-test-${{ github.sha }}\"\n            }\n          profiles: test,aws_tower\n```", "prompt": "Generate a GitHub Workflow named `nf-core AWS test` for a GitHub repository whose primary programming language is Nextflow. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Run AWS tests` and its job id is `run-tower`. "}
{"id": "63c496981899db58864d3f73", "level": "level1", "llm_response": "```yaml\nname: Triage tasks\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: triage-${{ github.event.number }}\n  cancel-in-progress: true\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: Triage tasks\n\non: pull_request_target\n\nconcurrency:\n  group: \"triage-${{ github.event.number }}\"\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check commit format\n        uses: Homebrew/actions/check-commit-format@master\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n      - name: Label pull request\n        uses: Homebrew/actions/label-pull-requests@master\n        if: always()\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n          def: |\n            - label: new cask\n              status: added\n              path: Casks/.+\n\n            - label: marked for removal/rejection\n              status: removed\n              path: Casks/.+\n\n            - label: documentation\n              path: (.*\\.md|\\.github/ISSUE_TEMPLATE/.*\\.yml)\n\n            - label: bump-cask-pr\n              pr_body_content: Created with `brew bump-cask-pr`\n\n            - label: missing description\n              path: Casks/.+\n              missing_content: \\n  desc .+\\n\n\n            - label: appcast migration needed\n              path: Casks/.+\n              content: \\n  appcast .+\\n\n```", "prompt": "Generate a GitHub Workflow named `Triage tasks` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the triage-${{ github.event.number }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `triage`. "}
{"id": "63c494a27843b61269a02781", "level": "level1", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 8 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up Dart\n        uses: subosito/flutter-action@v1\n        with:\n          channel: 'stable'\n\n      - name: Mark stale issues and pull requests\n        run: |\n          dart pub global activate github_stale_issues\n          github_stale_issues --repo . --stale-label \"stale\" --days 30\n```", "answer": "```yaml # This workflow warns and then closes issues and PRs that have had no activity for a specified amount of time.\n#\n# You can adjust the behavior by modifying this file.\n# For more information, see:\n# https://github.com/actions/stale\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '16 8 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v5\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        ascending: true\n        stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-pr-message: 'This PR has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-issue-label: 'no-issue-activity'\n        stale-pr-label: 'no-pr-activity'\n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by an event: the scheduled time has come: at 08:16 am. The workflow has one job. The job id of the 1st job is `stale`. "}
{"id": "63c4963d6fc19abdf9c9abf2", "level": "level1", "llm_response": "```yaml\nname: Submit to Web Store\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build project\n        run: npm run build\n```", "answer": "```yaml name: \"Submit to Web Store\"\r\non:\r\n  workflow_dispatch:\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Cache pnpm modules\r\n        uses: actions/cache@v3\r\n        with:\r\n          path: ~/.pnpm-store\r\n          key: ${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}\r\n          restore-keys: |\r\n            ${{ runner.os }}-\r\n      - uses: pnpm/action-setup@v2.2.1\r\n        with:\r\n          version: 7.1.0\r\n          run_install: true\r\n      - name: Build and zip extension artifact\r\n        run: pnpm build -- --zip\r\n      - name: Browser Platform Publish\r\n        uses: PlasmoHQ/bpp@v2\r\n        with:\r\n          keys: ${{ secrets.SUBMIT_KEYS }}\r\n          artifact: build/chrome-mv3-prod.zip\r\n```", "prompt": "Generate a GitHub Workflow named `Submit to Web Store` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c494a97843b61269a02a50", "level": "level2", "llm_response": "```yaml\nname: pytorch1_7_1-cuda11_0\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Build project\n        run: make build\n```", "answer": "```yaml name: pytorch1_7_1-cuda11_0\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu110\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.7.1-cu110\n      develop_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_7_1-cuda11_0` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c496986fc19abdf9c9cf90", "level": "level2", "llm_response": "```yaml\nname: Issue Check\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Close Issue\n      run: |\n        gh issue close ${{ github.event.issue.number }}\n\n    - name: Create comment\n      run: |\n        gh issue comment ${{ github.event.issue.number }} --body \"Please provide more details.\"\n```", "answer": "```yaml name: 'Issue Check'\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n    steps:\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == false\n        name: Close Issue\n        uses: peter-evans/close-issue@v1\n        with:\n          comment: |\n            Hello, Please use the Github template to report an issue. If this is a feature request, please take a look at the readme. <br/> Thanks, <br/> Ombi Bot\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == true\n        name: Create comment\n        uses: peter-evans/create-or-update-comment@v1\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            Hi!\n            <br/>Thanks for the issue report. Before a real human comes by, please make sure you used our bug report format.\n            <br/>Have you looked at the wiki yet? https://docs.ombi.app/\n            <br/>Before posting make sure you also read our [FAQ](https://docs.ombi.app/info/faq/).\n            <br/> Make the title describe your issue. Having 'not working' or 'I get this bug' for 100 issues, isn't really helpful.\n            <br/> If we need more information or there is some progress we tag the issue or update the tag and keep you updated.\n            <br/> Thanks!\n            <br/> Ombi Bot.\n```", "prompt": "Generate a GitHub Workflow named `Issue Check` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `issueCheck`. The job `issueCheck` has 2 steps. The 1st step is named `Close Issue`. The 2nd step is named `Create comment`. "}
{"id": "63c494da7843b61269a03d4f", "level": "level2", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout \ud83d\udece\ufe0f\n      uses: actions/checkout@v2\n\n    - name: Install \ud83c\udf31\n      run: |\n        # Add installation commands here\n\n    - name: Build \ud83d\udd27\n      run: |\n        # Add build commands here\n\n    - name: Deploy \ud83d\ude80\n      run: |\n        # Add deploy commands here\n```", "answer": "```yaml name: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\njobs:\n  build-and-deploy:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n      - name: Install \ud83c\udf31\n        run: |\n          sudo apt-get install -y pandoc\n      - name: Build \ud83d\udd27\n        run: |\n          ./run build itch\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4\n        with:\n          folder: build\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is GDScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets 3 environment variables to use: `BUTLER_API_KEY` is set to `${{ secrets.BUTLER_API_KEY }}`, `ITCHIO_USERNAME` is set to `${{ secrets.ITCHIO_USERNAME }}` and `ITCHIO_GAME` is set to `${{ secrets.ITCHIO_GAME }}`. The workflow has one job. The job id of the 1st job is `build-and-deploy`. The job `build-and-deploy` has 4 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install \ud83c\udf31`. The 3rd step is named `Build \ud83d\udd27`. The 4th step is named `Deploy \ud83d\ude80`. "}
{"id": "63c4968933b087f6bde2ca3a", "level": "level2", "llm_response": "```yaml\nname: Nightly Smoketest\n\non:\n  schedule:\n    - cron: '0 3 * * 1-5'\n  workflow_dispatch:\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n    steps:\n      - name: ''\n        run: echo \"Running smoketest...\"\n      - name: Mount bazel cache\n        run: echo \"Mounting bazel cache...\"\n      - name: Bank Workload\n        run: echo \"Running bank workload...\"\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# This workflow tests that we can stand up a CRDB cluster with the operator and execute SQL in the cluster. It uses the\n# steps that are outlined in our public docs to ensure that the flow we're recommending always works.\nname: Nightly Smoketest\n\non:\n  schedule:\n    # runs at 3am UTC Mon-Fri\n    # ref: <min> <hr> <month-day> <month> <weekday>\n    - cron: '0 3 * * 1-5'\n\n  # allows running from the actions tab in GitHub\n  workflow_dispatch: ~\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        # supported Kubenetes versions\n        NODE_VERSION: [1.19.16, 1.20.15, 1.21.9, 1.22.6, 1.23.3]\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: Bank Workload\n        env:\n          NODE_VERSION: ${{ matrix.NODE_VERSION }}\n        run: make test/smoketest\n```", "prompt": "Generate a GitHub Workflow named `Nightly Smoketest` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am, monday through friday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `smoketest`. The job `smoketest` has 3 steps. The 1st step is named ``. The 2nd step is named `Mount bazel cache`. The 3rd step is named `Bank Workload`. "}
{"id": "63c496686fc19abdf9c9be9c", "level": "level2", "llm_response": "```yaml\nname: Unit testing (Ubuntu)\n\non:\n  push:\n    branches:\n      - main\n      - 'ver_*'\n      - dev\n    paths:\n      - '**.py'\n  pull_request:\n    branches:\n      - main\n      - 'ver_*'\n      - dev\n    paths:\n      - '**.py'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Test with pytest\n        run: pytest\n```", "answer": "```yaml name: Unit testing (Ubuntu)\non:\n  push:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n  pull_request:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n\njobs:\n  build:\n    strategy:\n      matrix:\n        # os: [macos-latest, windows-latest, ubuntu-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10']  # , '3.11-dev'\n    # runs-on: ${{ matrix.os }}\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        python -m pip install pytest coverage\n        pip install -r requirements.txt\n    - name: Test with pytest\n      env:\n        DEBUG_API_ID: ${{ secrets.DEBUG_API_ID }}\n        DEBUG_API_SECRET: ${{ secrets.DEBUG_API_SECRET }}\n        CROSS_DEBUG_KEY: ${{ secrets.CROSS_DEBUG_KEY }}\n        CROSS_DEBUG_SECRET: ${{ secrets.CROSS_DEBUG_SECRET }}\n      run: |\n        coverage run --source=src --omit=src/falconpy/debug.py -m pytest -s --ignore-glob=**/manual/*\n        coverage report\n```", "prompt": "Generate a GitHub Workflow named `Unit testing (Ubuntu)` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of push event matches a pattern in the paths filter(**.py), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of pull_request event matches a pattern in the paths filter(**.py), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python ${{ matrix.python-version }}`. The 3rd step is named `Install dependencies`. The 4th step is named `Test with pytest`. "}
{"id": "63c49698b008460c1df15628", "level": "level2", "llm_response": "```yaml\nname: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\npermissions:\n  contents: read\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\njobs:\n  add_to_gh_projects:\n    id: add_to_gh_projects\n    runs-on: ubuntu-latest\n    steps:\n      - name: Add labeled issues to GH projects\n        run: |\n          # Add your script here to handle the logic for adding labeled issues to GH projects\n```", "answer": "```yaml name: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\npermissions:\n  contents: read\n\njobs:\n  add_to_gh_projects:\n    name: Adds issues to GH projects\n    runs-on: ubuntu-latest\n    steps:\n      - name: Add labeled issues to GH projects\n        uses: gradle/build-tool-issue-automation-actions/add-labeled-issues@v1\n```", "prompt": "Generate a GitHub Workflow named `add-to-gh-projects` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by multiple events: 1) an issue is opened or a label is added to an issue. 2) a pull request is created or a label is added to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}`. The workflow has one job. The 1st job is named `Adds issues to GH projects` and its job id is `add_to_gh_projects`. The job `add_to_gh_projects` has one step. The 1st step is named `Add labeled issues to GH projects`. "}
{"id": "63c494f67843b61269a0479e", "level": "level2", "llm_response": "```yaml\nname: Sync-To-Gitlab\n\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request:\n    branches:\n      - master\n      - master-template\n    types: [closed]\n  workflow_dispatch:\n\njobs:\n  sync:\n    id: sync\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n      \n      - name: Mirror\n        run: |\n          # Add your mirror logic here\n```", "answer": "```yaml name: Sync-To-Gitlab\nrun-name: Sync-To-Gitlab ${{ github.sha }}\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request_target:\n    types:\n      - closed\n    branches:\n      - master\n      - master-template\n  workflow_dispatch:\n\n\njobs:\n  sync:\n    concurrency:\n      group: ${{ github.workflow }}-${{ github.ref_name }}\n      cancel-in-progress: true\n    name: \"Sync To Gitlab\"\n    if: github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Mirror\n        env:\n          input_git_config_user_name: ${{ secrets.GITLAB_USERNAME }}\n          input_git_config_user_email: ${{ secrets.GITLAB_EMAIL }}\n          input_git_remote_url: ${{ secrets.GITLAB_URL }}\n          input_git_push_options: --force\n        run: |\n          git config --global user.name \"${{ env.input_git_config_user_name }}\"\n          git config --global user.email \"${{ env.input_git_config_user_email }}\"\n          git clone \"https://github.com/${{ github.repository }}.git\" \"git\"\n          cd git\n          git remote set-url origin \"${{ env.input_git_remote_url }}\"\n          git push ${{ env.input_git_push_options }} origin ${{ github.ref_name }}:${{ github.ref_name }}\n#      - name: Mirror + trigger CI\n#        uses: SvanBoxel/gitlab-mirror-and-ci-action@master\n#        with:\n#          args: \"https://gitlab.com/Zerek-Cheng/Simple-Assets-Platform\"\n#        env:\n#          FORCE_PUSH: \"true\"\n#          GITLAB_HOSTNAME: \"gitlab.com\"\n#          GITLAB_USERNAME: \"Zerek-Cheng\"\n#          GITLAB_PASSWORD: ${{ secrets.GITLAB_PASSWORD }}\n#          GITLAB_PROJECT_ID: \"40146411\"\n#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Sync-To-Gitlab` for a GitHub repository whose primary programming language is Java. The name for workflow runs is set to `Sync-To-Gitlab ${{ github.sha }}`. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named master-template. 2) a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named master-template. 3) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Sync To Gitlab` and its job id is `sync`. The job `sync` has 2 steps. The 1st step is named `Checkout`. The 2nd step is named `Mirror`. "}
{"id": "63c496561899db58864d23de", "level": "level2", "llm_response": "```yaml\nname: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  sqlite:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule docker\n      - name: Run Molecule\n        run: |\n          molecule test --debug-the ${{ github.event.inputs.debug-the }}\n```", "answer": "```yaml name: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  sqlite:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: sqlite\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Sqlite` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.sqlite.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/sqlite/** or roles/sqlite/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `sqlite`. "}
{"id": "63c494078052faa2781a8a1f", "level": "level2", "llm_response": "```yaml\nname: CLA Assistant\n\non:\n  issues:\n    types: [created]\n  pull_request:\n    types: [opened, closed, edited, synchronize]\n  comment:\n    types: [created]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: CLA Assistant\n      run: echo \"Running CLA Assistant...\"\n```", "answer": "```yaml name: \"CLA Assistant\"\non:\n  issue_comment:\n    types: [ created ]\n  pull_request_target:\n    types: [ opened,closed,synchronize ]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        uses: cla-assistant/github-action@v2.1.3-beta\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # the below token should have repo scope and must be manually added by you in the repository's secret\n          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: '.cla/v1/signatures.json'\n          path-to-document: 'https://github.com/christian-schlichtherle/truelicense/blob/develop/CLA.md'\n          branch: 'develop'\n          allowlist: bot*\n\n          #below are the optional inputs - If the optional inputs are not given, then default values will be taken\n          #remote-organization-name: enter the remote organization name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #remote-repository-name:  enter the  remote repository name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #create-file-commit-message: 'For example: Creating file for storing CLA Signatures'\n          #signed-commit-message: 'For example: $contributorName has signed the CLA in #$pullRequestNo'\n          #custom-notsigned-prcomment: 'pull request comment with Introductory message to ask new contributors to sign'\n          #custom-pr-sign-comment: 'The signature to be committed in order to sign the CLA'\n          #custom-allsigned-prcomment: 'pull request comment when all contributors has signed, defaults to **CLA Assistant Lite bot** All Contributors have signed the CLA.'\n          #lock-pullrequest-aftermerge: false - if you don't want this bot to automatically lock the pull request after merging (default - true)\n          #use-dco-flag: true - If you are using DCO instead of CLA\n```", "prompt": "Generate a GitHub Workflow named `CLA Assistant` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `CLAssistant`. The job `CLAssistant` has one step. The 1st step is named `CLA Assistant`. "}
{"id": "63c494298052faa2781a98f8", "level": "level2", "llm_response": "```yaml\nname: Linux build with address sanitizer enabled\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Compiler version\n        run: |\n          g++ --version\n\n      - name: Build\n        run: |\n          g++ -fsanitize=address -o my_program my_program.cpp\n\n      - name: Run tests\n        run: |\n          ./my_program\n\n      - name: Run examples\n        run: |\n          ./my_program_example\n```", "answer": "```yaml name: Linux build with address sanitizer enabled\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n    container: ghcr.io/lballabio/quantlib-devenv:rolling\n    steps:\n    - uses: actions/checkout@v3\n    - name: Compiler version\n      run: |\n        gcc --version\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"gcc\" CXX=\"g++\" CXXFLAGS=\"-O2 -g0 -fsanitize=address,undefined -fno-sanitize-recover=all -fno-omit-frame-pointer -Wall -Wno-unknown-pragmas -Werror\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --log_level=message\n    - name: Run examples\n      run: |\n        make check-examples\n```", "prompt": "Generate a GitHub Workflow named `Linux build with address sanitizer enabled` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `sanitize`. The job `sanitize` has 5 steps. The 1st step is named ``. The 2nd step is named `Compiler version`. The 3rd step is named `Build`. The 4th step is named `Run tests`. The 5th step is named `Run examples`. "}
{"id": "63c493cd7843b612699fd710", "level": "level2", "llm_response": "```yaml\nname: Clean\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  delete-artifacts:\n    id: delete-artifacts\n    runs-on: ubuntu-latest\n    steps:\n    - name: Delete artifacts\n      run: |\n        rm -rf target\n```", "answer": "```yaml # This file was automatically generated by sbt-github-actions using the\n# githubWorkflowGenerate task. You should add and commit this file to\n# your git repository. It goes without saying that you shouldn't edit\n# this file by hand! Instead, if you wish to make changes, you should\n# change your sbt build configuration to revise the workflow description\n# to meet your needs, then regenerate this file.\n\nname: Clean\n\non: push\n\njobs:\n  delete-artifacts:\n    name: Delete Artifacts\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Delete artifacts\n        run: |\n          # Customize those three lines with your repository and credentials:\n          REPO=${GITHUB_API_URL}/repos/${{ github.repository }}\n\n          # A shortcut to call GitHub API.\n          ghapi() { curl --silent --location --user _:$GITHUB_TOKEN \"$@\"; }\n\n          # A temporary file which receives HTTP response headers.\n          TMPFILE=/tmp/tmp.$$\n\n          # An associative array, key: artifact name, value: number of artifacts of that name.\n          declare -A ARTCOUNT\n\n          # Process all artifacts on this repository, loop on returned \"pages\".\n          URL=$REPO/actions/artifacts\n          while [[ -n \"$URL\" ]]; do\n\n            # Get current page, get response headers in a temporary file.\n            JSON=$(ghapi --dump-header $TMPFILE \"$URL\")\n\n            # Get URL of next page. Will be empty if we are at the last page.\n            URL=$(grep '^Link:' \"$TMPFILE\" | tr ',' '\\n' | grep 'rel=\"next\"' | head -1 | sed -e 's/.*<//' -e 's/>.*//')\n            rm -f $TMPFILE\n\n            # Number of artifacts on this page:\n            COUNT=$(( $(jq <<<$JSON -r '.artifacts | length') ))\n\n            # Loop on all artifacts on this page.\n            for ((i=0; $i < $COUNT; i++)); do\n\n              # Get name of artifact and count instances of this name.\n              name=$(jq <<<$JSON -r \".artifacts[$i].name?\")\n              ARTCOUNT[$name]=$(( $(( ${ARTCOUNT[$name]} )) + 1))\n\n              id=$(jq <<<$JSON -r \".artifacts[$i].id?\")\n              size=$(( $(jq <<<$JSON -r \".artifacts[$i].size_in_bytes?\") ))\n              printf \"Deleting '%s' #%d, %'d bytes\\n\" $name ${ARTCOUNT[$name]} $size\n              ghapi -X DELETE $REPO/actions/artifacts/$id\n            done\n          done\n```", "prompt": "Generate a GitHub Workflow named `Clean` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The 1st job is named `Delete Artifacts` and its job id is `delete-artifacts`. The job `delete-artifacts` has one step. The 1st step is named `Delete artifacts`. "}
{"id": "63c494167843b612699fee3f", "level": "level2", "llm_response": "```yaml\nname: Dead Link Check\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Run dead link check\n      run: ./check-links.sh\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\n\nname: Dead Link Check\n\non: [push, pull_request]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    if: (github.repository == 'apache/incubator-linkis')\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gaurav-nelson/github-action-markdown-link-check@v1\n        with:\n          use-quiet-mode: 'no'\n          use-verbose-mode: 'yes'\n          folder-path: '../'\n          config-file: '.github/workflows/dlc.json'\n```", "prompt": "Generate a GitHub Workflow named `Dead Link Check` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `dead-links-check`. The job `dead-links-check` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c4964b33b087f6bde2aead", "level": "level2", "llm_response": "```yaml\nname: Build release\n\non:\n  push:\n    tags:\n      - 'v**'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: ''\n        run: echo \"Hello, World!\"\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n      - name: Set up ruby env\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '2.7'\n      - name: Decode Service Account Key JSON File\n        id: service_account_json_file\n        run: echo ${{ secrets.SERVICE_ACCOUNT_JSON_FILE }} | base64 --decode > service-account.json\n      - name: Grant execute permission for gradlew\n        run: chmod +x gradlew\n      - name: Create local properties\n        run: echo \"api.key=${{ secrets.MAPS_API_KEY }}\" > local.properties\n      - name: Create maps api key\n        run: echo \"maps.api.key=${{ secrets.MAPS_API_KEY }}\" > maps-api-key.properties\n      - name: Decode Keystore\n        run: echo ${{ secrets.KEYSTORE }} | base64 --decode > keystore.jks\n      - name: Decode Google Services json\n        run: echo ${{ secrets.GOOGLE_SERVICES_JSON }} | base64 --decode > google-services.json\n      - name: Build & deploy Android release\n        run: ./gradlew assembleRelease\n```", "answer": "```yaml name: Build release\n\non:\n  push:\n    tags:\n      - v**\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: set up JDK 11\n      uses: actions/setup-java@v3\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n        cache: gradle\n\n    - name: Set up ruby env\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: 2.7.2\n        bundler-cache: true\n\n    - name: Decode Service Account Key JSON File\n      uses: timheuer/base64-to-file@v1\n      id: service_account_json_file\n      with:\n        fileName: \"serviceAccount.json\"\n        encodedString: ${{ secrets.GOOGLE_JSON }}\n\n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n\n    - name: Create local properties\n      run: touch local.properties\n\n    - name: Create maps api key\n      run: echo \"MAPS_API_KEY=${{ secrets.MAPS_API_KEY }}\" > secrets.properties\n\n    - name: Decode Keystore\n      env:\n        ENCODED_STRING: ${{ secrets.KEYSTORE }}\n      run: |\n        mkdir app/keystore\n        echo $ENCODED_STRING | base64 -di > app/keystore/keystore.jks\n    - name: Decode Google Services json\n      env:\n        ENCODED_STRING: ${{ secrets.GOOGLE_SERVICES }}\n      run: |\n        echo $ENCODED_STRING | base64 -di > app/google-services.json\n        \n\n    - name: Build & deploy Android release\n      run: bundle exec fastlane android deploy\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n        ANDROID_JSON_KEY_FILE: ${{ steps.service_account_json_file.outputs.filePath }}\n\n#    - name: Build with Gradle\n#      run: ./gradlew app:bundleRelease\n#      env:\n#        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n#        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n#        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n#\n#    - name: Archive release bundle\n#      uses: actions/upload-artifact@v3\n#      with:\n#        name: bundle\n#        path: |\n#          app/build/outputs/bundle/release\n```", "prompt": "Generate a GitHub Workflow named `Build release` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v**. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 10 steps. The 1st step is named ``. The 2nd step is named `set up JDK 11`. The 3rd step is named `Set up ruby env`. The 4th step is named `Decode Service Account Key JSON File` and its id is `service_account_json_file`. The 5th step is named `Grant execute permission for gradlew`. The 6th step is named `Create local properties`. The 7th step is named `Create maps api key`. The 8th step is named `Decode Keystore`. The 9th step is named `Decode Google Services json`. The 10th step is named `Build & deploy Android release`. "}
{"id": "63c4956e8052faa2781b1ca5", "level": "level2", "llm_response": "```yaml\nname: Conventional PR\n\non:\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: semantic-pull-request\n        uses: sematic-pull-request/sematic-pull-request-action@v2\n```", "answer": "```yaml name: Conventional PR\n\n# Controls when the action will run. \non:\n  pull_request:\n    branches:\n    - develop\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n      - name: semantic-pull-request\n        # Internal Unity mirror available at jesseo/action-semantic-pull-request, but actions from private repos aren't supported, so continue to use the public one below\n        uses: amannn/action-semantic-pull-request@b7a9a97cb10fa6e1ae02647e718798175f6b1f1d\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          # Provide custom types if you don't want the default ones from https://www.conventionalcommits.org\n          types: # optional\n          # Configure which scopes are allowed.\n          #scopes: # optional\n          # Configure that a scope must always be provided.\n          #requireScope: # optional\n          # Configure additional validation for the subject based on a regex. E.g. '^(?![A-Z]).+$' ensures the subject doesn't start with an uppercase character.\n          #subjectPattern: # optional\n          # If `subjectPattern` is configured, you can use this property to override the default error message that is shown when the pattern doesn't match. The variables `subject` and `title` can be used within the message.\n          #subjectPatternError: # optional\n          # For work-in-progress PRs you can typically use draft pull requests from Github. However, private repositories on the free plan don't have this option and therefore this action allows you to opt-in to using the special '[WIP]' prefix to indicate this state. This will avoid the validation of the PR title and the pull request checks remain pending. Note that a second check will be reported if this is enabled.\n          #wip: # optional\n          # When using \"Squash and merge\" on a PR with only one commit, GitHub will suggest using that commit message instead of the PR title for the merge commit, and it's easy to commit this by mistake. Enable this option to also validate the commit message for one commit PRs.\n          validateSingleCommit: true # optional\n```", "prompt": "Generate a GitHub Workflow named `Conventional PR` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `build`. The job `build` has one step. The 1st step is named `semantic-pull-request`. "}
{"id": "63c4965b33b087f6bde2b689", "level": "level2", "llm_response": "```yaml\nname: fortran-format-check\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  fortran-format-check:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Install Conda environment from environment.yml\n        run: |\n          conda env create -f environment.yml\n          conda activate myenv\n\n      - name: Install gfortran\n        run: sudo apt-get install gfortran\n\n      - name: Print python package versions\n        run: |\n          python -m pip list\n\n      - name: Set and print branch name\n        run: echo \"Branch name is ${{ github.ref }}\"\n\n      - name: Fortran source format check\n        run: |\n          fprettify --check --write src/*.f90\n```", "answer": "```yaml name: fortran-format-check\n\non:\n  push:\n    branches: [ master, develop ]\n  pull_request:\n    branches: [ develop ]\n\njobs:\n  fortan-format-check:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash -l {0}\n\n    steps:\n      - uses: actions/checkout@v2.3.4\n\n      - name: Install Conda environment from environment.yml\n        uses: mamba-org/provision-with-micromamba@main\n        with:\n            cache-downloads: true\n            cache-env: true\n\n      - name: Install gfortran\n        uses: modflowpy/install-gfortran-action@v1\n\n      - name: Print python package versions\n        run: |\n          pip list\n\n      - name: Set and print branch name\n        run: |\n          .github/common/git-branch-export.sh\n\n      - name: Fortran source format check\n        run: |\n          .github/common/fortran-format-check.sh\n```", "prompt": "Generate a GitHub Workflow named `fortran-format-check` for a GitHub repository whose primary programming language is Fortran. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `fortan-format-check`. The job `fortan-format-check` has 6 steps. The 1st step is named ``. The 2nd step is named `Install Conda environment from environment.yml`. The 3rd step is named `Install gfortran`. The 4th step is named `Print python package versions`. The 5th step is named `Set and print branch name`. The 6th step is named `Fortran source format check`. "}
{"id": "63c494c88052faa2781ad4bd", "level": "level2", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ros_distro: [noetic, melodic]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Own /github/home\n      run: echo \"Hello, GitHub Actions!\"\n\n    - name: Install apt dependencies\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y python3-pip\n\n    - name: Tests\n      run: npm test\n\n    - name: Clean up\n      run: echo \"Cleaning up...\"\n```", "answer": "```yaml name: CI\n\non: [push, pull_request]\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  ci:\n    name: ${{ matrix.ros_distro }}\n    if: ${{ github.actor != 'RWT-bot' }}\n    runs-on: ubuntu-latest\n    container: ros:${{ matrix.ros_distro }}-ros-core\n    strategy:\n      fail-fast: false\n      matrix:\n        ros_distro: [melodic, noetic]\n        node_version: [14]\n    env:\n      ROS_DISTRO: ${{ matrix.ros_distro }}\n    steps:\n      - uses: actions/checkout@v3\n        env:\n          TOKEN: \"${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' && secrets.RWT_BOT_PAT || github.token }}\"\n        with:\n          token: ${{ env.TOKEN }}\n      - uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node_version }}\n      - name: Own /github/home\n        run: |\n          chown -hR $(whoami):$(whoami) /github/home\n      - name: Install apt dependencies\n        run: |\n          apt-get update\n          apt-get install -y firefox ros-$ROS_DISTRO-rosbridge-server ros-$ROS_DISTRO-tf2-web-republisher ros-$ROS_DISTRO-common-tutorials ros-$ROS_DISTRO-rospy-tutorials ros-$ROS_DISTRO-actionlib-tutorials\n      - name: Tests\n        run: |\n          bash -c \"source /opt/ros/$ROS_DISTRO/setup.bash && bash test/build.bash\"\n      - uses: stefanzweifel/git-auto-commit-action@v4\n        if: ${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' }}\n        with:\n          commit_message: Update Build\n          file_pattern: 'build/*.js'\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The 1st job is named `${{ matrix.ros_distro }}` and its job id is `ci`. The job `ci` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Own /github/home`. The 4th step is named `Install apt dependencies`. The 5th step is named `Tests`. The 6th step is named ``. "}
{"id": "63c494287843b612699ff643", "level": "level2", "llm_response": "```yaml\nname: README to PDF\n\non:\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    id: converttopdf\n    runs-on: ubuntu-latest\n    steps:\n    - name: Step 1\n      run: |\n        # Add your step 1 commands here\n    - name: Step 2\n      run: |\n        # Add your step 2 commands here\n    - name: Step 3\n      run: |\n        # Add your step 3 commands here\n    - name: Commit files\n      run: |\n        git add README.pdf\n        git commit -m \"Update README to PDF\"\n    - name: Push changes\n      run: |\n        git push origin main\n```", "answer": "```yaml name: README to PDF\n# This workflow is triggered on pushes to the repository.\non:\n#   push:\n#     branches:\n#       - main\n#     paths:\n#       - 'README.md'\n    \n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    name: Build PDF\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: baileyjm02/markdown-to-pdf@v1.1.0\n        with:\n          input_dir: .\n          output_dir: .\n          build_html: false\n          table_of_contents: false\n      - uses: actions/upload-artifact@v3\n        with:\n          name: python-engineer-roadmap\n          path: README.pdf\n      - name: Commit files\n        run: |\n          git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n          git config --local user.name \"github-actions[bot]\"\n          git add README.pdf\n          if ! git diff-index --quiet HEAD; then\n            git commit -m \"Generate PDF file\"\n          fi\n      - name: Push changes\n        uses: ad-m/github-push-action@master\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          branch: ${{ github.ref }}\n#       - name: Commit changes\n#         uses: EndBug/add-and-commit@v9\n#         with:\n#           default_author: github_actions\n#           add: 'README.pdf'\n#           new_branch: generate-pdf\n#           push: origin generate-pdf --set-upstream --force\n```", "prompt": "Generate a GitHub Workflow named `README to PDF` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Build PDF` and its job id is `converttopdf`. The job `converttopdf` has 5 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Commit files`. The 5th step is named `Push changes`. "}
{"id": "63c494578052faa2781aa8bb", "level": "level2", "llm_response": "```yaml\nname: Build\n\non: [push, pull_request]\n\nenv:\n  CODECOV_TOKEN: 2fc0d617-8e9a-47d7-ab58-52fa92b23741\n  MAIN_GO_VER: 1.16\n  MAIN_HOST_OS: ubuntu-latest\n\njobs:\n  go_test_and_coverage:\n    runs-on: ${{ env.MAIN_HOST_OS }}\n\n    steps:\n    - name: Checkout Repository\n      uses: actions/checkout@v2\n\n    - name: Setup Go\n      id: go\n      uses: actions/setup-go@v2\n      with:\n        go-version: ${{ env.MAIN_GO_VER }}\n\n    - name: Get Dependencies\n      run: go get -v -t -d ./...\n\n    - name: Show Environments\n      run: env\n\n    - name: Test and Generate Coverage Report\n      run: go test -v -coverprofile=coverage.out ./...\n\n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        token: ${{ env.CODECOV_TOKEN }}\n        file: coverage.out\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branchs:\n    - 'master'\n    - 'feature/**'\n    - 'dev/**'\n\nenv:\n  CODECOV_TOKEN: '2fc0d617-8e9a-47d7-ab58-52fa92b23741'\n  MAIN_GO_VER: '1.16'\n  MAIN_HOST_OS: 'ubuntu-latest'\n\njobs:\n  go_test_and_coverage:\n    strategy:\n      max-parallel: 6\n      matrix:\n        GO_VER: ['1.16']\n        HOST_OS: ['ubuntu-latest']\n\n    runs-on: ${{ matrix.HOST_OS }}\n\n    steps:\n\n    - name: Checkout Repositary\n      uses: actions/checkout@v3\n\n    - name: Setup Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.GO_VER }}\n      id: go\n\n    - name: Get Dependencies\n      run: |\n        echo GO_VER = ${{ matrix.GO_VER }}\n        go get golang.org/x/tools/cmd/cover\n        go install github.com/mattn/goveralls || go get github.com/mattn/goveralls\n        go get .\n\n    - name: Show Environments\n      run: |\n        echo repo status ======== && git status\n        echo GITHUB_REF = ${{ env.GITHUB_REF }}\n        echo GITHUB_REF_NAME = ${{ env.GITHUB_REF_NAME }}\n        echo GO_VER = ${{ matrix.GO_VER }}\n        echo HOST_OS = ${{ matrix.HOST_OS }}\n        which goveralls\n        echo envs ======== && printenv\n\n    - name: Test and Generate Coverage Report\n      run: |\n        go test -v -failfast -cover -covermode=atomic -coverprofile=coverage.out\n\n    # - name: Upload Coverage to Goveralls\n    #   run: |\n    #     goveralls -coverprofile=coverage.out -repotoken ${{ env.COVERALLS_TOKEN }}\n\n    # - name: Upload Coverage to Codecov\n    #   if: ${{ matrix.GO_VER }} == ${{ env.MAIN_GO_VER }}\n    #   run: |\n    #     bash <(curl -s https://codecov.io/bash) -t ${{ env.CODECOV_TOKEN }}\n\n    # - name: Convert Coverage file to lcov format\n    #   uses: jandelgado/gcov2lcov-action@v1.0.8\n    #   with:\n    #     infile: ./coverage.out\n    #     outfile: ./coverage.lcov\n\n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        files: ./coverage.out\n        fail_ci_if_error: true\n        flags: unittests\n        name: codecov-umbrella\n        path_to_write_report: ./coverage/codecov_report.txt\n        verbose: true\n\n    # - name: Coveralls GitHub Action\n    #   uses: coverallsapp/github-action@1.1.3\n    #   with:\n    #     path-to-lcov: ./coverage.lcov\n    #     github-token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow sets 3 environment variables to use: `CODECOV_TOKEN` is set to `2fc0d617-8e9a-47d7-ab58-52fa92b23741`, `MAIN_GO_VER` is set to `1.16` and `MAIN_HOST_OS` is set to `ubuntu-latest`. The workflow has one job. The job id of the 1st job is `go_test_and_coverage`. The job `go_test_and_coverage` has 6 steps. The 1st step is named `Checkout Repositary`. The 2nd step is named `Setup Go` and its id is `go`. The 3rd step is named `Get Dependencies`. The 4th step is named `Show Environments`. The 5th step is named `Test and Generate Coverage Report`. The 6th step is named `Upload Coverage to Codecov`. "}
{"id": "63c495297843b61269a05d37", "level": "level2", "llm_response": "```yaml\nname: pr\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Build project\n        run: npm run build\n\n  algolia:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Deploy to Algolia\n        run: npm run deploy:algolia\n```", "answer": "```yaml name: pr\non:\n  pull_request:\n\njobs:\n  release:\n    uses: the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main\n    with:\n      npmTag: alpha\n      buildScript: build\n      nodeVersion: 18\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n      npmToken: ${{ secrets.NPM_TOKEN }}\n\n\n  algolia:\n    uses: the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main\n    with:\n      domain: https://www.the-guild.dev/graphql/shield/\n      source: 'Shield'\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `pr` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The job id of the 1st job is `release`. The job id of the 2nd job is `algolia`. "}
{"id": "63c4959c7843b61269a08c2d", "level": "level2", "llm_response": "```yaml\nname: Rust Workflow\n\non:\n  push:\n    paths:\n      - .github/workflows/install.yml\n  schedule:\n    - cron: '17 0 * * 1'\n\npermissions:\n  contents: read\n\njobs:\n  cargo-install:\n    id: cargo-install\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: cargo install\n```", "answer": "```yaml permissions:\n  contents: read\n\non:\n  push:\n    paths:\n      - \".github/workflows/install.yml\"\n  schedule:\n    - cron: \"17 0 * * 1\"\n\njobs:\n  cargo-install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: |\n          cargo install cargo-mutants\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/install.yml), the workflow runs. 2) the scheduled time has come: at 12:17 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `cargo-install`. The job `cargo-install` has one step. The 1st step is named `cargo-install`. "}
{"id": "63c4968e1899db58864d3b1c", "level": "level2", "llm_response": "```yaml\nname: HTML5 check\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\njobs:\n  HTML5-check:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run HTML5 validation\n        run: |\n          # Add your HTML5 validation command here\n          echo \"Running HTML5 validation...\"\n          # Example command: html5validator --recursive .\n```", "answer": "```yaml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n\nname: HTML5 check\n\njobs:\n  HTML5-check:\n    uses: easystats/workflows/.github/workflows/html-5-check.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `HTML5 check` for a GitHub repository whose primary programming language is R. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch named master. The workflow has one job. The job id of the 1st job is `HTML5-check`. "}
{"id": "63c496861e3364807577b31b", "level": "level2", "llm_response": "```yaml\nname: license-check\n\non:\n  pull_request:\n\njobs:\n  license:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Check License Header\n      run: |\n        cargo install cargo-license\n        cargo license -v\n```", "answer": "```yaml name: license-check\non: pull_request\njobs:\n  license:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Check License Header\n      uses: apache/skywalking-eyes/header@501a28d2fb4a9b962661987e50cf0219631b32ff\n```", "prompt": "Generate a GitHub Workflow named `license-check` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `license`. The job `license` has 2 steps. The 1st step is named ``. The 2nd step is named `Check License Header`. "}
{"id": "63c4962c6fc19abdf9c9a4e3", "level": "level2", "llm_response": "```yaml\nname: Continuous integration\n\non:\n  push:\n    branches: [ main ]\n    tags: [ '*' ]\n  pull_request:\n    branches: [ main ]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '2.7'\n\n      - name: Lint with RuboCop\n        run: bundle exec rubocop\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install Node modules\n        run: npm install\n\n      - name: Run ESLint\n        run: npm run lint\n\n      - name: Run Tests\n        run: bundle exec rspec\n\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Login to GitHub Container Registry\n        run: echo \"${{ secrets.GITHUB_TOKEN }}\" | docker login -u ${{ github.actor }} --password-stdin ghcr.io\n\n      - name: Build, push and deploy the LATEST image\n        run: docker build -t ghcr.io/${{ github.repository }}/latest . && docker push ghcr.io/${{ github.repository }}/latest\n\n      - name: Build and push the STABLE image\n        run: docker build -t ghcr.io/${{ github.repository }}/stable . && docker push ghcr.io/${{ github.repository }}/stable\n```", "answer": "```yaml name: Continuous integration\non: push\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:14-alpine\n        ports: [\"5432:5432\"]\n        env:\n          POSTGRES_PASSWORD: postgres\n\n      redis:\n        image: redis:alpine\n        ports: [\"6379:6379\"]\n\n      opensearch:\n        image: opensearchproject/opensearch:latest\n        ports: [\"9200:9200\"]\n        env:\n          discovery.type: single-node\n          plugins.security.disabled: true\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          bundler-cache: true\n\n      - name: Lint with RuboCop\n        run: bundle exec rubocop --parallel\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3.5.1\n        with:\n          cache: yarn\n\n      - name: Install Node modules\n        run: bin/yarn install --frozen-lockfile\n\n      - name: Run ESLint\n        run: bin/yarn lint\n\n      - name: Run Tests\n        env:\n          DB_HOST: localhost\n          DB_USER: postgres\n          DB_PASSWORD: postgres\n          RAILS_ENV: test\n          SECRET_KEY_BASE: we-dont-need-a-secret-here\n          APP_ADMIN_EMAIL: admin@example.org\n          APP_ADMIN_PASSWORD: secret\n          APP_EMAIL: reply@example.org\n          APP_HOST: example.org\n          AWS_ACCESS_KEY_ID: my-access-key\n          AWS_SECRET_ACCESS_KEY: my-secret\n          AWS_BUCKET: my-bucket\n          AWS_REGION: eu-central-1\n          CI: true\n        run: |\n          bundle exec rake assets:precompile\n          bundle exec rake db:create db:schema:load\n          bundle exec rake spec\n\n  deploy:\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'\n    needs: test\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build, push and deploy the LATEST image\n        if: github.ref == 'refs/heads/develop'\n        run: |\n          export COMMIT_TIME=$(git show -s --format=%cD ${GITHUB_SHA})\n          export COMMIT_SHA=${GITHUB_SHA}\n          docker buildx build --build-arg COMMIT_TIME --build-arg COMMIT_SHA -t ghcr.io/ledermann/docker-rails/docker-rails:latest .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:latest\n          curl -X POST ${{ secrets.DEPLOY_HOOK_APP }}\n          curl -X POST ${{ secrets.DEPLOY_HOOK_WORKER }}\n\n      - name: Build and push the STABLE image\n        if: github.ref == 'refs/heads/master'\n        run: |\n          docker buildx build -t ghcr.io/ledermann/docker-rails/docker-rails:stable .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:stable\n```", "prompt": "Generate a GitHub Workflow named `Continuous integration` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The job id of the 1st job is `test`. The job `test` has 7 steps. The 1st step is named ``. The 2nd step is named `Set up Ruby`. The 3rd step is named `Lint with RuboCop`. The 4th step is named `Setup Node.js`. The 5th step is named `Install Node modules`. The 6th step is named `Run ESLint`. The 7th step is named `Run Tests`. The job id of the 2nd job is `deploy`. The job `deploy` has 4 steps. The 1st step is named ``. The 2nd step is named `Login to GitHub Container Registry`. The 3rd step is named `Build, push and deploy the LATEST image`. The 4th step is named `Build and push the STABLE image`. "}
{"id": "63c495707843b61269a07a00", "level": "level2", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '23 20 * * 1'\n  push:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run analysis\n        run: npm run scorecards\n      - name: Upload artifact\n        uses: actions/upload-artifact@v2\n        with:\n          name: scorecards-report\n          path: scorecards-report.json\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@v1\n        with:\n          sarif_file: scorecards-report.sarif\n```", "answer": "```yaml name: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '43 20 * * 1'\n  push:\n    branches: [ master ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      # Used to receive a badge. (Upcoming feature)\n      id-token: write\n      actions: read\n      contents: read\n    \n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@a12a3943b4bdde767164f792f33f40b04645d846 # v3.0.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@3e15ea8318eee9b333819ec77a36aca8d39df13e # v1.1.1\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # (Optional) Read-only PAT token. Uncomment the `repo_token` line below if:\n          # - you want to enable the Branch-Protection check on a *public* repository, or\n          # - you are installing Scorecards on a *private* repository\n          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action#authentication-with-pat.\n          # repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n\n          # Publish the results for public repositories to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results. \n          # For private repositories, `publish_results` will automatically be set to `false`, regardless \n          # of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF\n      # format to the repository Actions tab.\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8 # v3.1.0\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n      \n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 08:43 pm, only on monday. 3) The workflow would run whenever there is a push event to: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. "}
{"id": "63c495c68052faa2781b4231", "level": "level2", "llm_response": "```yaml\nname: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n    repositories:\n      - your-repository-name\n\njobs:\n  pullRequestHandler:\n    id: pullRequestHandler\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Pull Request Validation\n        run: |\n          # Add your PowerShell validation script here\n```", "answer": "```yaml name: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pullRequestHandler:\n    name: Pull Request Validator\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Pull Request Validation\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: startsWith(github.event.comment.body, '/verify')\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          SKIP_UPDATED: '1'\n```", "prompt": "Generate a GitHub Workflow named `Commented Pull Request` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The 1st job is named `Pull Request Validator` and its job id is `pullRequestHandler`. The job `pullRequestHandler` has 2 steps. The 1st step is named ``. The 2nd step is named `Pull Request Validation`. "}
{"id": "63c4969e1899db58864d41ef", "level": "level2", "llm_response": "```yaml\nname: Auto message on pr merge\n\non:\n  pull_request:\n    types: [closed]\n\njobs:\n  auto-response:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Respond to PR merge\n        run: echo \"Thank you for merging the PR! \ud83c\udf89\"\n```", "answer": "```yaml name: Auto message on pr merge\n\non:\n\n  pull_request_target:\n\n    types: [closed]\n\njobs:\n\n  auto-response:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - uses: derekprior/add-autoresponse@master\n\n      env:\n\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      with:\n\n        respondableId: ${{ github.event.pull_request.node_id }}\n\n        response: \"Thank you @${{ github.event.pull_request.user.login }} for taking out your valuable time in order to contribute to our project. Looking forward for more such amazing contributions :).\"\n\n        author: ${{ github.event.pull_request.user.login }}\n\n        exemptedAuthors: \"Amit366\"\n```", "prompt": "Generate a GitHub Workflow named `Auto message on pr merge` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a pull request is closed. The workflow has one job. The job id of the 1st job is `auto-response`. The job `auto-response` has one step. The 1st step is named ``. "}
{"id": "63c4966b33b087f6bde2bde4", "level": "level2", "llm_response": "```yaml\nname: tests\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    id: tests\n    strategy:\n      matrix:\n        name: [python3.6, python3.7, python3.8, python3.9]\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install system dependencies\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y libssl-dev libffi-dev\n\n      - name: Update pip\n        run: python -m pip install --upgrade pip\n\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n\n      - name: Run tests\n        run: pytest\n```", "answer": "```yaml name: tests\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    name: ${{ matrix.name }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - {name: '3.11-dev', python: '3.11-dev', os: ubuntu-latest, tox: py311}\n          - {name: Linux, python: '3.10', os: ubuntu-latest, tox: py310}\n          - {name: Windows, python: '3.10', os: windows-latest, tox: py310}\n          - {name: Mac, python: '3.10', os: macos-latest, tox: py310}\n          - {name: '3.9', python: '3.9', os: ubuntu-latest, tox: py39}\n          - {name: 'PyPy', python: 'pypy-3.9', os: ubuntu-latest, tox: pypy39}\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python }}\n      - name: install system dependencies\n        run: sudo apt-get install libxml2-dev libxslt1-dev --yes\n        if: ${{ matrix.python == '3.11-dev' }}\n      - name: update pip\n        run: |\n          pip install -U wheel\n          pip install -U setuptools\n          python -m pip install -U pip\n      - run: pip install tox\n      - run: tox -e ${{ matrix.tox }}\n```", "prompt": "Generate a GitHub Workflow named `tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named develop. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `tests`. The job `tests` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `install system dependencies`. The 4th step is named `update pip`. The 5th step is named ``. The 6th step is named ``. "}
{"id": "63c495c88052faa2781b42d4", "level": "level2", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: java\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        queries: security-and-quality,security-extended\n\n    # Autobuild failed (OOM)\n    # Hence, supply memory args for gradle build\n    - run: |\n        JAVA_OPTS=\"-Xmx1000M\" ./gradlew --no-scan compileJava\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. When all the path names of pull_request event match patterns in the paths-ignore filter(**/*.json, **/*.md, **/*.properties or **/*.txt), the workflow will not run. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named ``. The 4th step is named `Perform CodeQL Analysis`. "}
{"id": "63c495e48052faa2781b4f0b", "level": "level2", "llm_response": "```yaml\nname: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n\ninputs:\n  from-this:\n    description: 'Generate from this release/commit'\n    required: false\n    default: ''\n  to-this:\n    description: 'Generate until this release/commit'\n    required: false\n    default: 'HEAD'\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v2\n\n    - name: Install Lua 5.1.5\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y lua5.1\n\n    - name: Install Luarocks\n      run: |\n        sudo apt-get install -y luarocks\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install lua-argparse\n        luarocks install lua-cjson\n\n    - name: Calculate from and to releases\n      run: |\n        echo \"Calculating from and to releases...\"\n        # Add your logic here to calculate from and to releases\n\n    - name: Generate changelog\n      run: |\n        echo \"Generating changelog...\"\n        # Add your logic here to generate changelog\n\n    - name: Upload changelog as html\n      run: |\n        echo \"Uploading changelog as html...\"\n        # Add your logic here to upload changelog as html\n```", "answer": "```yaml name: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n    inputs:\n      from:\n        description: 'Generate from this release/commit (defaults to the latest release)'\n        required: false\n        # default is calculated dynamically\n      to:\n        description: 'Generate until this release/commit (defaults to latest development)'\n        required: false\n        default: 'HEAD'\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n    if: ${{ github.repository_owner == 'Mudlet' }}\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Install Lua 5.1.5\n      uses: leafo/gh-actions-lua@v9\n      with:\n        luaVersion: \"5.1.5\"\n\n    - name: Install Luarocks\n      uses: leafo/gh-actions-luarocks@v4\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install argparse\n        luarocks install lunajson\n\n    - name: Calculate from and to releases\n      run: |\n        if [[ -z \"${{ github.event.inputs.from }}\" ]] ; then\n            FROM_RELEASE=$(git tag --sort=committerdate | tail -1)\n        else\n            FROM_RELEASE=${{ github.event.inputs.from }}\n        fi\n\n        if [[ -z \"${{ github.event.inputs.to }}\" ]] ; then\n            TO_RELEASE=\"HEAD\"\n        else\n            TO_RELEASE=${{ github.event.inputs.to }}\n        fi\n\n        echo \"Generating a changelog from $FROM_RELEASE until $TO_RELEASE\"\n\n        echo \"FROM_RELEASE=$FROM_RELEASE\" >> $GITHUB_ENV\n        echo \"TO_RELEASE=$TO_RELEASE\" >> $GITHUB_ENV\n\n    - name: Generate changelog\n      run: |\n        changelog=$(lua CI/generate-changelog.lua -m release --start-commit $FROM_RELEASE --end-commit $TO_RELEASE)\n        echo \"$changelog\" >> changelog.html\n\n        echo \"[INFO] Changelog generated (from $FROM_RELEASE to $TO_RELEASE). If it's too big, Github won't show it, so it's available as an artifact as well at: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts\"\n        echo \"[INFO] Changelog is:\"\n        echo $changelog\n\n    - name: Upload changelog as html\n      uses: actions/upload-artifact@v3\n      with:\n        name: changelog.html\n        path: changelog.html\n```", "prompt": "Generate a GitHub Workflow named `Generate a changelog` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am. 2) someone manually triggers the workflow. This workflow receives 2 inputs: from-this input represents generate from this release/commit (defaults to the latest release) and it is optional; to-this input represents generate until this release/commit (defaults to latest development), it is optional and its default value is HEAD. The workflow has one job. The job id of the 1st job is `generate-changelog`. The job `generate-changelog` has 7 steps. The 1st step is named `Checkout Mudlet repository`. The 2nd step is named `Install Lua 5.1.5`. The 3rd step is named `Install Luarocks`. The 4th step is named `Install Lua dependencies`. The 5th step is named `Calculate from and to releases`. The 6th step is named `Generate changelog`. The 7th step is named `Upload changelog as html`. "}
{"id": "63c494347843b612699ffa9f", "level": "level2", "llm_response": "```yaml\nname: Release Charts\n\non:\n  push:\n    tags:\n      - 'chart-v*'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Set up Helm\n        uses: helm/helm@v3\n\n      - name: Check chart version\n        run: helm version --short\n\n      - name: Packaging the chart\n        run: helm package .\n\n      - name: Publish charts on GitHub Pages\n\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set up Helm\n        uses: helm/helm@v3\n\n      - name: Update charts index\n        run: helm repo index .\n\n      - name: Check diffs\n        run: git diff --name-only\n\n      - name: Commit changes\n        run: git commit -am \"Update charts index\"\n\n      - name: Push to gh-pages\n        run: git push origin gh-pages\n```", "answer": "```yaml name: Release Charts\n\non:\n  push:\n    tags:\n      - 'chart-v*'\n\njobs:\n  build:\n    runs-on: ubuntu-20.04\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - name: Check chart version\n        run: |\n          tag_version=${GITHUB_REF##*/chart-v}\n          chart_version=$(cat charts/moco/Chart.yaml | grep 'version:' | sed 's/version:\\s//')\n          if [ \"$tag_version\" != \"$chart_version\" ]; then\n            echo \"Different versions: tag \\\"$tag_version\\\", chart \\\"$chart_version\\\"\"\n            exit 1\n          fi\n      - name: Packaging the chart\n        run: helm package ./charts/moco/\n\n      - uses: actions/upload-artifact@v3\n        with:\n          name: helm-charts\n          path: ./moco-*.tgz\n          retention-days: 1\n\n  publish:\n    name: Publish charts on GitHub Pages\n    runs-on: ubuntu-20.04\n    needs: build\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: gh-pages\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - uses: actions/download-artifact@v3\n        with:\n          name: helm-charts\n\n      - name: Update charts index\n        run: helm repo index --url https://cybozu-go.github.io/moco/ --merge index.yaml .\n\n      - run: git add .\n\n      - name: Check diffs\n        run: |\n          diffs=$(git status -s)\n          if [ \"$diffs\" = \"\" ]; then\n            echo \"NO_DIFF=1\" >> $GITHUB_ENV\n          else\n            printf \"%s\\n\" \"$diffs\"\n          fi\n      - name: Commit changes\n        if: env.NO_DIFF != '1'\n        run: |\n          git config --global user.name 'Cybozu Neco'\n          git config --global user.email 'cybozu-neco@users.noreply.github.com'\n          git commit -m 'update'\n      - name: Push to gh-pages\n        if: env.NO_DIFF != '1'\n        run: git push origin gh-pages\n```", "prompt": "Generate a GitHub Workflow named `Release Charts` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches chart-v*. The workflow has 2 jobs. The job id of the 1st job is `build`. The job `build` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Helm`. The 3rd step is named `Check chart version`. The 4th step is named `Packaging the chart`. The 5th step is named ``. The 2nd job is named `Publish charts on GitHub Pages` and its job id is `publish`. The job `publish` has 8 steps. The 1st step is named ``. The 2nd step is named `Set up Helm`. The 3rd step is named ``. The 4th step is named `Update charts index`. The 5th step is named ``. The 6th step is named `Check diffs`. The 7th step is named `Commit changes`. The 8th step is named `Push to gh-pages`. "}
{"id": "63c495ca8052faa2781b43be", "level": "level2", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Bump version and push tag\n        id: tagging\n        uses: anatolii-botsun/action-semantic-versioning@v2\n        with:\n          bump: patch\n          tag_prefix: v\n          tag_name: ${{ steps.tagging.outputs.tag_name }}\n\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v1\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n\n      - name: Login to DockerHub\n        uses: docker/login-action@v1\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_PASSWORD }}\n\n      - name: Login to Quay.io\n        uses: quay-io/quay-action@v1\n        with:\n          quay_user: ${{ secrets.QUAY_USERNAME }}\n          quay_token: ${{ secrets.QUAY_TOKEN }}\n\n      - name: Build and push\n        id: docker_build\n        run: |\n          docker build -t your-docker-image-name:${{ steps.tagging.outputs.tag_name }} .\n          docker push your-docker-image-name:${{ steps.tagging.outputs.tag_name }}\n\n      - name: Build Changelog\n        id: build_changelog\n        run: |\n          # Add your changelog generation command here\n\n      - name: Create Github Release\n        run: |\n          # Add your GitHub release creation command here\n```", "answer": "```yaml name: Release\non:\n  push:\n    branches:\n      - master\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: '0'\n      - name: Bump version and push tag\n        id: tagging\n        uses: anothrNick/github-tag-action@1.52.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          INITIAL_VERSION: 1.0.0\n          DEFAULT_BUMP: none\n      -\n        name: \"Set up QEMU\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-qemu-action@v2\n      -\n        name: \"Set up Docker Buildx\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-buildx-action@v2\n      -\n        name: \"Login to DockerHub\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      -\n        name: \"Login to Quay.io\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          registry: quay.io\n          username: ${{ secrets.QUAY_BOT_USERNAME }}\n          password: ${{ secrets.QUAY_BOT_PASSWORD }}\n      -\n        name: \"Build and push\"\n        if: steps.tagging.outputs.part\n        id: docker_build\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          platforms: linux/amd64,linux/arm64,linux/arm/v7,linux/ppc64le,linux/s390x\n          tags: |\n            docker.io/kiwigrid/k8s-sidecar:latest\n            docker.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n            quay.io/kiwigrid/k8s-sidecar:latest\n            quay.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n      - name: \"Build Changelog\"\n        if: steps.tagging.outputs.part\n        id: build_changelog\n        uses: mikepenz/release-changelog-builder-action@v3\n        with:\n          configuration: \".github/workflows/release-notes-config.json\"\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      - name: \"Create Github Release\"\n        if: steps.tagging.outputs.part\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token\n        with:\n          tag_name: ${{ steps.tagging.outputs.tag }}\n          release_name: v${{ steps.tagging.outputs.tag }}\n          body: ${{ steps.build_changelog.outputs.changelog }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 9 steps. The 1st step is named ``. The 2nd step is named `Bump version and push tag` and its id is `tagging`. The 3rd step is named `Set up QEMU`. The 4th step is named `Set up Docker Buildx`. The 5th step is named `Login to DockerHub`. The 6th step is named `Login to Quay.io`. The 7th step is named `Build and push` and its id is `docker_build`. The 8th step is named `Build Changelog` and its id is `build_changelog`. The 9th step is named `Create Github Release`. "}
{"id": "63c494007843b612699fe516", "level": "level2", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n\n    - name: Install pylint\n      run: pip install pylint\n\n    - name: pylint\n      run: pylint your_code_directory\n\n    - name: \n      run: echo \"Step 5\"\n\n    - name: \n      run: echo \"Step 6\"\n\n    - name: make all\n      run: make all\n\n    - name: darwin build\n      run: ./build_darwin.sh\n\n    - name: Integration tests\n      run: ./run_integration_tests.sh\n\n  bazel:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n\n    - name: Setup bazel\n      id: setup_bazel\n      run: ./setup_bazel.sh\n\n    - name: Show bazel variables\n      run: bazel info\n\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v2\n      with:\n        path: bazel-bin\n        key: ${{ runner.os }}-bazel-${{ hashFiles('**/WORKSPACE', '**/BUILD') }}\n        restore-keys: |\n          ${{ runner.os }}-bazel-\n\n    - name: Cache bazel external repositories\n      uses: actions/cache@v2\n      with:\n        path: .bazelrc\n        key: ${{ runner.os }}-bazel-${{ hashFiles('**/WORKSPACE', '**/BUILD') }}\n        restore-keys: |\n          ${{ runner.os }}-bazel-\n\n    - name: test\n      run: bazel test //...\n\n    - name: Show build timing summary\n      run: bazel build --build_event_text_file=bazel_build.log && bazel info build_event_text_file\n```", "answer": "```yaml name:\n  Test\n\non:\n  push\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-20.04\n    strategy:\n      matrix:\n        py: [\"3.7\"]\n        pylint: [\"==2.9.6\"]\n        go: [ \"1.18\", \"1.19\" ]\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.py }}\n    - name: Install pylint\n      run: pip install --user pylint${{ matrix.pylint }}\n    - name: pylint\n      run: |\n        pylint adapters/python/martian_shell.py\n        pylint adapters/python/martian.py\n        pylint test/martian_test.py\n    - uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n    - uses: actions/setup-node@v3\n      with:\n        node-version: \"lts/*\"\n        cache: \"npm\"\n        cache-dependency-path: |\n          web/martian/yarn.lock\n          tools/syntax/vscode/yarn.lock\n    - name: make all\n      run: make all tarball\n    - name: darwin build\n      run: GOOS=darwin go build ./cmd/...\n    - name: Integration tests\n      run: make longtests\n\n  bazel:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: \"3.x\"\n    - uses: actions/setup-go@v3\n      id: setup_go\n      with:\n        go-version: \">=1.19\"\n    - name: Show bazel variables\n      run: |\n        bazel info\n        echo \"bazel_repository_cache=$(bazel info repository_cache)\" >> $GITHUB_ENV\n        echo \"bazel_output_base=$(bazel info output_base)\" >> $GITHUB_ENV\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_output_base }}/external\n        key: bazel-build-cache-${{steps.setup_go.outputs.go-version}}-${{hashFiles('deps.bzl', 'WORKSPACE')}}\n        restore-keys: |\n          bazel-build-cache-${{steps.setup_go.outputs.go-version}}\n          bazel-build-cache-\n    - name: Cache bazel external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_repository_cache }}\n        key: bazel-repo-cache-${{hashFiles('deps.bzl', 'WORKSPACE', 'web/martian/yarn.lock')}}\n        restore-keys: |\n          bazel-repo-cache-\n    - name: test\n      run: |\n        bazel test --nobuild_tests_only \\\n                   --verbose_failures \\\n                   --discard_analysis_cache \\\n                   --notrack_incremental_state \\\n                   --nokeep_state_after_build \\\n                   //...\n    - name: Show build timing summary\n      run: bazel analyze-profile ${{ env.bazel_output_base }}/command.profile.gz\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `make`. The job `make` has 9 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Install pylint`. The 4th step is named `pylint`. The 5th step is named ``. The 6th step is named ``. The 7th step is named `make all`. The 8th step is named `darwin build`. The 9th step is named `Integration tests`. The job id of the 2nd job is `bazel`. The job `bazel` has 8 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `` and its id is `setup_go`. The 4th step is named `Show bazel variables`. The 5th step is named `Cache bazel build of external repositories`. The 6th step is named `Cache bazel external repositories`. The 7th step is named `test`. The 8th step is named `Show build timing summary`. "}
{"id": "63c494257843b612699ff4b7", "level": "level2", "llm_response": "```yaml\nname: functional-identity\n\non:\n  pull_request:\n    paths:\n      - 'identity/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-identity:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        name: [devstack]\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v2\n        with:\n          path: 'gophercloud'\n      - name: Deploy devstack\n        run: |\n          # Commands to deploy devstack\n          echo \"Deploying devstack...\"\n      - name: Checkout go\n        uses: actions/checkout@v2\n        with:\n          path: 'go'\n      - name: Run Gophercloud acceptance tests\n        run: |\n          # Commands to run Gophercloud acceptance tests\n          echo \"Running Gophercloud acceptance tests...\"\n      - name: Generate logs on failure\n        if: failure()\n        run: |\n          # Commands to generate logs on failure\n          echo \"Generating logs...\"\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v2\n        with:\n          name: logs\n          path: 'logs'\n```", "answer": "```yaml name: functional-identity\non:\n  pull_request:\n    paths:\n      - '**identity**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-identity:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: \"^.*identity.*$\"\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-identity-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-identity` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**identity**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests` and its job id is `functional-identity`. The job `functional-identity` has 6 steps. The 1st step is named `Checkout Gophercloud`. The 2nd step is named `Deploy devstack`. The 3rd step is named `Checkout go`. The 4th step is named `Run Gophercloud acceptance tests`. The 5th step is named `Generate logs on failure`. The 6th step is named `Upload logs artifacts on failure`. "}
{"id": "63c495038052faa2781aede6", "level": "level2", "llm_response": "```yaml\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Setup Miniconda\n      uses: conda-incubator/setup-miniconda@v2\n      with:\n        miniconda-version: '4.10.3'\n        python-version: '3.8'\n        channels: 'defaults'\n\n    - name: Create Conda environment with the right deps\n      run: conda create -n testenv python=3.8 -y\n\n    - name: Install dependencies\n      run: conda activate testenv && pip install -r requirements.txt\n\n    - name: Tests\n      run: conda activate testenv && pytest\n\n    - name: Cleanup\n      run: conda deactivate\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n        numpy_version: ['>=1.22.0', '==1.20.*']\n        exclude:\n          - python-version: '3.10'\n            numpy_version: '==1.20.*'\n    services:\n      redis:\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n      mongodb:\n        image: mongo:4.4.11\n        ports:\n          - 27017:27017\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Setup Miniconda\n      uses: conda-incubator/setup-miniconda@master\n      with:\n          channels: conda-forge\n          python-version: ${{ matrix.python-version }}\n      env:\n        ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n    # Runs a set of commands using the runners shell\n    - name: Create Conda environment with the rights deps\n      shell: \"bash -l {0}\"\n      run: |\n        conda create -n zarr-env python==${{matrix.python-version}} bsddb3 numcodecs lmdb pip nodejs flake8 mypy\n        conda activate zarr-env\n        npm install -g azurite\n    - name: Install dependencies\n      shell: \"bash -l {0}\"\n      run: |\n        conda activate zarr-env\n        python -m pip install --upgrade pip\n        python -m pip install -U pip setuptools wheel codecov line_profiler\n        python -m pip install -rrequirements_dev_minimal.txt numpy${{matrix.numpy_version}} -rrequirements_dev_optional.txt pymongo redis\n        python -m pip install .\n        python -m pip freeze\n    - name: Tests\n      shell: \"bash -l {0}\"\n      env:\n        COVERAGE_FILE: .coverage.${{matrix.python-version}}.${{matrix.numpy_version}}\n        ZARR_TEST_ABS: 1\n        ZARR_TEST_MONGO: 1\n        ZARR_TEST_REDIS: 1\n        ZARR_V3_EXPERIMENTAL_API: 1\n      run: |\n        conda activate zarr-env\n        mkdir ~/blob_emulator\n        azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n        pytest --cov=zarr --cov-config=.coveragerc --doctest-plus --cov-report xml --cov=./ --timeout=300\n    - uses: codecov/codecov-action@v3\n      with:\n        #token: ${{ secrets.CODECOV_TOKEN }} # not required for public repos\n          #files: ./coverage1.xml,./coverage2.xml # optional\n          #flags: unittests # optional\n          #name: codecov-umbrella # optional\n          #fail_ci_if_error: true # optional (default = false)\n        verbose: true # optional (default = false)\n```", "prompt": "Generate a GitHub Workflow named `Linux Testing` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named `Setup Miniconda`. The 3rd step is named `Create Conda environment with the rights deps`. The 4th step is named `Install dependencies`. The 5th step is named `Tests`. The 6th step is named ``. "}
{"id": "63c4967e33b087f6bde2c5c4", "level": "level2", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2\n\n      - name: Install and Build \ud83d\udd27\n        run: |\n          npm install\n          npm run build\n\n      - name: Deploy \ud83d\ude80\n        run: echo \"Deploying to production...\"\n```", "answer": "```yaml name: Build and Deploy\non:\n  push:\n    branches:\n    - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n        \n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install\n          npm run build\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.0.0\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist #  The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build-and-deploy`. The job `build-and-deploy` has 3 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install and Build \ud83d\udd27`. The 3rd step is named `Deploy \ud83d\ude80`. "}
{"id": "63c496926fc19abdf9c9cd93", "level": "level2", "llm_response": "```yaml\nname: Contributor License Agreement (CLA)\n\non:\n  pull_request:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check CLA\n        run: |\n          # Add your CLA check logic here\n          echo \"Checking Contributor License Agreement...\"\n```", "answer": "```yaml name: Contributor License Agreement (CLA)\n\non:\n  pull_request_target:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    if: |\n      (github.event.issue.pull_request \n        && !github.event.issue.pull_request.merged_at\n        && contains(github.event.comment.body, 'signed')\n      ) \n      || (github.event.pull_request && !github.event.pull_request.merged)\n    steps:\n      - uses: Shopify/shopify-cla-action@v1\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          cla-token: ${{ secrets.CLA_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Contributor License Agreement (CLA)` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) a pull request is created or a pull request's head branch is updated. 2) a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `cla`. The job `cla` has one step. The 1st step is named ``. "}
{"id": "63c496836fc19abdf9c9c720", "level": "level2", "llm_response": "```yaml\nname: TagBot\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: TagBot\non:\n  schedule:\n    - cron: 0 0 * * *\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `TagBot`. The job `TagBot` has one step. The 1st step is named ``. "}
{"id": "63c496741e3364807577abc2", "level": "level2", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [created]\n  pull_request:\n    types: [created]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. The job `TagBot` has one step. The 1st step is named ``. "}
{"id": "63c495f37843b61269a0b108", "level": "level2", "llm_response": "```yaml\nname: PR Approval Bypass Notifier\n\non:\n  pull_request:\n    branches:\n      - main\n    types: [closed]\n\npermissions:\n  pull-requests: read\n\njobs:\n  approval:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Fail If No Approval\n        run: |\n          if [ \"${github.event.pull_request.merged}\" = \"false\" ]; then\n            echo \"Pull request was not merged, failing the job.\"\n            exit 1\n          fi\n\n      - name: Slack Notification\n        run: |\n          echo \"Sending Slack notification for PR approval bypass.\"\n          # Add Slack notification logic here\n```", "answer": "```yaml name: PR Approval Bypass Notifier\non:\n  pull_request:\n    types:\n      - closed\n    branches:\n      - main\npermissions:\n  pull-requests: read\njobs:\n  approval:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Fail If No Approval\n        if: ${{ github.event.pull_request.merged }}\n        env:\n          AUTH_HEADER: 'Authorization: token ${{ secrets.GITHUB_TOKEN }}'\n          JSON_HEADER: 'Content-Type: application/json'\n          REVIEWS_URL: 'https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews'\n        run: |\n          curl -sSL -H \"${JSON_HEADER}\" -H \"${AUTH_HEADER}\" \"${REVIEWS_URL}\" \\\n            | jq -e '. | map({user: .user.login, state: .state})\n                       | reduce .[] as $x ({}; .[$x.user] = $x.state)\n                       | to_entries | map(.value)\n                       | contains([\"APPROVED\"]) and (contains([\"CHANGES_REQUESTED\"]) | not)'\n      - name: Slack Notification\n        if: ${{ failure() }}\n        run: |\n          jq --null-input '{ text: \"Oh no! The following PR was merged without approval: w${{github.event.pull_request.html_url}}\" }' \\\n          | curl -sSL -X POST -H 'Content-Type: application/json' -d @- '${{ secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK }}'\n```", "prompt": "Generate a GitHub Workflow named `PR Approval Bypass Notifier` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `approval`. The job `approval` has 2 steps. The 1st step is named `Fail If No Approval`. The 2nd step is named `Slack Notification`. "}
{"id": "63c496561e3364807577a06a", "level": "level2", "llm_response": "```yaml\nname: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '30 17 * * *'\n\nenv:\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: |\n          # Step 1 commands\n      - name: Step 2\n        run: |\n          # Step 2 commands\n      - name: Step 3\n        run: |\n          # Step 3 commands\n      - name: Step 4\n        run: |\n          # Step 4 commands\n```", "answer": "```yaml name: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"30 17 * * *\"\n#  push:\n#    branches:\n#      - main\n\nenv:\n  # please change to your own config.\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    name: Gather RQ statistical data and write it to google sheet\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n      - run: yarn\n      - run: yarn rq\n```", "prompt": "Generate a GitHub Workflow named `Gather RQ statistical data and write it to google sheet` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 05:30 pm. The workflow sets 11 environment variables to use: `RQ_COOKIE` is set to `${{ secrets.RQ_COOKIE }}`, `RQ_CSRF_TOKEN` is set to `${{ secrets.RQ_CSRF_TOKEN }}`, `RQ_USERID` is set to `${{ secrets.RQ_USERID }}`, `GOOGLE_SHEET_ID` is set to `${{ secrets.GOOGLE_SHEET_ID }}`, `GOOGLE_API_CLIENT_EMAIL` is set to `${{ secrets.GOOGLE_API_CLIENT_EMAIL }}`, `GOOGLE_API_PRIVATE_KEY` is set to `${{ secrets.GOOGLE_API_PRIVATE_KEY }}`, `BARK_KEY` is set to `${{ secrets.BARK_KEY }}`, `GARMIN_USERNAME` is set to `${{ secrets.GARMIN_USERNAME }}`, `GARMIN_PASSWORD` is set to `${{ secrets.GARMIN_PASSWORD }}`, `GARMIN_GLOBAL_USERNAME` is set to `${{ secrets.GARMIN_GLOBAL_USERNAME }}` and `GARMIN_GLOBAL_PASSWORD` is set to `${{ secrets.GARMIN_GLOBAL_PASSWORD }}`. The workflow has one job. The 1st job is named `Gather RQ statistical data and write it to google sheet` and its job id is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c4957d8052faa2781b22a0", "level": "level2", "llm_response": "```yaml\nname: Close stale\n\non:\n  schedule:\n    - cron: '0 1 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      \n      - name: Close stale issues and pull requests\n        run: |\n          gh issue list --state open --limit 100 --json number,state | jq -r '.[] | select(.state == \"open\") | .number' | xargs -I {} gh issue edit {} --state closed\n          gh pr list --state open --limit 100 --json number,state | jq -r '.[] | select(.state == \"open\") | .number' | xargs -I {} gh pr edit {} --state closed\n```", "answer": "```yaml # Copyright 2020 The Knative Authors.\n# SPDX-License-Identifier: Apache-2.0\n\n# This file is automagically synced here from github.com/knative-sandbox/knobots\nname: 'Close stale'\n\non:\n  schedule:\n  - cron: '0 1 * * *'\n\njobs:\n\n  stale:\n    uses: knative/actions/.github/workflows/stale.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `Close stale` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 01:00 am. The workflow has one job. The job id of the 1st job is `stale`. "}
{"id": "63c4959f7843b61269a08d83", "level": "level2", "llm_response": "```yaml\nname: CompatHelper\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n      - name: CompatHelper.main()\n        run: julia -e 'using CompatHelper; CompatHelper.main()'\n```", "answer": "```yaml name: CompatHelper\n\non:\n  schedule:\n    - cron: '00 00 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: [1.2.0]\n        julia-arch: [x86]\n        os: [ubuntu-latest]\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n      - name: CompatHelper.main()\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          COMPATHELPER_PRIV: ${{ secrets.TAGBOT }}\n        run: julia -e 'using CompatHelper; CompatHelper.main()'\n```", "prompt": "Generate a GitHub Workflow named `CompatHelper` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `CompatHelper`. The job `CompatHelper` has 2 steps. The 1st step is named `Pkg.add(\"CompatHelper\")`. The 2nd step is named `CompatHelper.main()`. "}
{"id": "63c494358052faa2781a9de3", "level": "level2", "llm_response": "```yaml\nname: JumpServer repos generic handler\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  release:\n    types: [ published ]\n\njobs:\n  generic_handler:\n    id: generic_handler\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml on: [push, pull_request, release]\n\nname: JumpServer repos generic handler\n\njobs:\n  generic_handler:\n    name: Run generic handler\n    runs-on: ubuntu-latest\n    steps:\n      - uses: jumpserver/action-generic-handler@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.PRIVATE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `JumpServer repos generic handler` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. 3) release activity in the repository occurs. The workflow has one job. The 1st job is named `Run generic handler` and its job id is `generic_handler`. The job `generic_handler` has one step. The 1st step is named ``. "}
{"id": "63c494998052faa2781ac05b", "level": "level2", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - dev\n  pull_request:\n    branches:\n      - dev\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ dev ]\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java', 'javascript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://git.io/codeql-language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      run: |\n        cd etc/build\n        npm install workbox-cli@6.3.0 --global\n        ant\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 01:06 pm. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named `Perform CodeQL Analysis`. "}
{"id": "63c494298052faa2781a98fa", "level": "level2", "llm_response": "```yaml\nname: Check test times\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository:\n    types: [created]\n\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Cache\n      uses: actions/cache@v2\n      with:\n        path: ~/.cache\n        key: ${{ runner.os }}-cpp-${{ hashFiles('**/CMakeLists.txt') }}\n        restore-keys: |\n          ${{ runner.os }}-cpp-\n\n    - name: Setup\n      uses: actions/setup-cpp@v2\n      with:\n        cpp-version: '10'\n\n    - name: Build\n      run: cmake --build .\n\n    - name: Run tests\n      run: ctest --output-on-failure\n\n    - name: Save test times\n      run: |\n        echo \"::set-output name=test_times::$(cat test_times.txt)\"\n\n    - name: Check test times\n      run: |\n        test_times=$(cat test_times.txt)\n        if [ \"$test_times\" -gt 60 ]; then\n          echo \"Test times are too long: $test_times\"\n          exit 1\n        fi\n```", "answer": "```yaml name: Check test times\non: [push, pull_request]\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Cache\n      uses: hendrikmuhs/ccache-action@v1.2\n      with:\n        key: linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-${{ hashFiles('**/*.hpp', '**/*.cpp') }}\n        restore-keys: |\n          linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-\n          linux-ci-build-times-${{ github.ref }}-\n          linux-ci-build-times-refs/heads/master-\n          linux-ci-build-times-\n    - name: Setup\n      run: |\n        sudo apt update\n        sudo apt install -y libboost-dev autoconf automake libtool ccache\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"ccache gcc\" CXX=\"ccache g++\" CXXFLAGS=\"-O2 -g0\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,faster.xml:HRF,message -- --faster\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,fast.xml:HRF,message -- --fast\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,all.xml:HRF,message\n    - name: Save test times\n      uses: actions/upload-artifact@v3\n      with:\n        name: test-reports\n        path: ./all.xml\n    - name: Check test times\n      run: |\n        python ./tools/check_test_times.py\n```", "prompt": "Generate a GitHub Workflow named `Check test times` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check-test-times`. The job `check-test-times` has 7 steps. The 1st step is named ``. The 2nd step is named `Cache`. The 3rd step is named `Setup`. The 4th step is named `Build`. The 5th step is named `Run tests`. The 6th step is named `Save test times`. The 7th step is named `Check test times`. "}
{"id": "63c496981899db58864d3f6f", "level": "level2", "llm_response": "```yaml\nname: Re-run Workflow\n\non:\n  workflow_run:\n    workflows: [CI]\n    types: [completed]\n  pull_request:\n    types: [closed, labeled, unlabeled]\n  schedule:\n    - cron: '30 */3 * * *'\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Re-run CI workflow\n        run: |\n          gh workflow run CI --ref ${{ github.ref }}\n```", "answer": "```yaml name: Re-run Workflow\n\non:\n  workflow_run:\n    workflows:\n      - CI\n    types:\n      - completed\n  pull_request_target:\n    types:\n      - closed\n      - labeled\n      - unlabeled\n  schedule:\n    - cron: '30 */3 * * *' # every 3 hours (30 minutes past the hour)\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    if: >\n      startsWith(github.repository, 'Homebrew/') &&\n      (\n        github.event.label.name == 'ci-requeue' ||\n        github.event.label.name == 'ci-retry' ||\n        github.event.label.name == 'ci-skip-appcast' ||\n        github.event.label.name == 'ci-skip-install' ||\n        github.event.label.name == 'ci-syntax-only' ||\n        !github.event.label.name\n      )\n    runs-on: ubuntu-latest\n    steps:\n      - name: Re-run CI workflow\n        uses: reitermarkus/rerun-workflow@c8d5bc3526acb50c12004f31c0dcb1598c87e32d\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n          once-label: ci-requeue\n          continuous-label: ci-retry\n          trigger-labels: ci-skip-appcast,ci-skip-install,ci-syntax-only\n          workflow: ci.yml\n```", "prompt": "Generate a GitHub Workflow named `Re-run Workflow` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) the workflow named CI is completed. 2) a pull request is closed, a label is added to a pull request or a label is removed from a pull request. 3) the scheduled time has come: at 30 minutes past the hour, every 3 hours. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `rerun-workflow`. The job `rerun-workflow` has one step. The 1st step is named `Re-run CI workflow`. "}
{"id": "63c493bc7843b612699fd432", "level": "level2", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n  push:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n    - name: Install dependencies\n      run: npm install\n    - name: Run XO\n      run: npx xo\n\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n    - name: Install dependencies\n      run: npm install\n    - name: Build project\n      run: npm run build\n```", "answer": "```yaml env: {}\n\n# FILE GENERATED WITH: npx ghat fregante/ghatemplates/node\n# SOURCE: https://github.com/fregante/ghatemplates\n# OPTIONS: {\"exclude\":[\"jobs.Test\"]}\n\nname: CI\non:\n  - pull_request\n  - push\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n      - name: install\n        run: npm ci || npm install\n      - name: XO\n        run: npx xo\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: install\n        run: npm ci || npm install\n      - name: build\n        run: npm run build\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) a commit or tag is pushed, or a repository is cloned. The workflow has 2 jobs. The job id of the 1st job is `Lint`. The job `Lint` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `install`. The 4th step is named `XO`. The job id of the 2nd job is `Build`. The job `Build` has 3 steps. The 1st step is named ``. The 2nd step is named `install`. The 3rd step is named `build`. "}
{"id": "63c493f47843b612699fe037", "level": "level2", "llm_response": "```yaml\nname: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  update:\n    id: update\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n      \n      - name: Update image list\n        run: python update_images.py\n      \n      - name: Create pull request\n        uses: peter-evans/create-pull-request@v3\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          commit-message: Update image list\n          branch: update-images\n          title: Update image list\n          body: Automatically updated image list at 10:00 am UTC\n```", "answer": "```yaml name: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"0 10 * * *\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        include:\n          - { branch: master, channel: latest/edge }\n          - { branch: 1.24, channel: 1.24 }\n          - { branch: 1.23, channel: 1.23 }\n          - { branch: 1.22, channel: 1.22 }\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ matrix.branch }}\n      - name: Update image list\n        run: |\n          ./build-scripts/update-images.sh ${{ matrix.channel }} build-scripts/images.txt\n      - name: Create pull request\n        uses: peter-evans/create-pull-request@v4\n        with:\n          commit-message: update list of images used by ${{ matrix.channel }}\n          title: \"[${{ matrix.channel }}] Update MicroK8s images\"\n          body: update list of images used by ${{ matrix.channel }}\n          reviewers: neoaggelos,ktsakalozos\n          branch: auto-update-images/${{ matrix.branch }}\n          delete-branch: true\n          base: ${{ matrix.branch }}\n```", "prompt": "Generate a GitHub Workflow named `Update list of images` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `update`. The job `update` has 3 steps. The 1st step is named `Checkout`. The 2nd step is named `Update image list`. The 3rd step is named `Create pull request`. "}
{"id": "63c494368052faa2781a9e20", "level": "level2", "llm_response": "```yaml\nname: build\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - v*\n  pull_request:\n\npermissions:\n  contents: write\n  id-token: write\n  packages: write\n\njobs:\n  build:\n    id: build\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Cache Go modules\n        uses: actions/cache@v2\n        with:\n          path: ~/.cache/go-build\n          key: ${{ runner.os }}-go-${{ hashFiles('**/go.mod') }}\n          restore-keys: |\n            ${{ runner.os }}-go-\n\n      - name: CI\n        run: go test -v ./...\n\n      - name: Run GoReleaser\n        uses: goreleaser/goreleaser-action@v2\n        with:\n          release-type: draft\n```", "answer": "```yaml name: build\n\non:\n  push:\n    branches:\n      - 'main'\n    tags:\n      - 'v*'\n  pull_request:\n\npermissions:\n   contents: write\n   id-token: write\n   packages: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      -\n        name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: 1.17\n      -\n        name: Cache Go modules\n        uses: actions/cache@v3\n        with:\n          path: ~/go/pkg/mod\n          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}\n          restore-keys: |\n            ${{ runner.os }}-go-\n      -\n        name: CI\n        run: |\n          go mod tidy\n          go test -v ./...\n          go build -o tt .\n      - uses: sigstore/cosign-installer@v2.8.1\n      -\n        name: Run GoReleaser\n        uses: goreleaser/goreleaser-action@v3\n        if: success() && startsWith(github.ref, 'refs/tags/')\n        with:\n          distribution: goreleaser-pro\n          version: latest\n          args: release --rm-dist\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n          FURY_TOKEN: ${{ secrets.FURY_TOKEN }}\n          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}\n          TWITTER_CONSUMER_KEY: ${{ secrets.TWITTER_CONSUMER_KEY }}\n          TWITTER_CONSUMER_SECRET: ${{ secrets.TWITTER_CONSUMER_SECRET }}\n          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}\n          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}\n          COSIGN_PWD: ${{ secrets.COSIGN_PWD }}\n          AUR_KEY: ${{ secrets.AUR_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a tag whose name matches v*. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope, write access is granted to the GITHUB_TOKEN in the `id-token` scope and write access is granted to the GITHUB_TOKEN in the `packages` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Go`. The 3rd step is named `Cache Go modules`. The 4th step is named `CI`. The 5th step is named ``. The 6th step is named `Run GoReleaser`. "}
{"id": "63c493b77843b612699fd355", "level": "level2", "llm_response": "```yaml\nname: docs\n\non:\n  push:\n    branches:\n      - develop\n      - release\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n\nconcurrency:\n  group: docs\n  cancel-in-progress: true\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Track Docs Branch\n        run: echo \"Docs branch is ${{ github.ref }}\"\n\n      - name: Update pip\n        run: python -m pip install --upgrade pip\n\n      - name: Set Git author\n        run: git config --global user.email \"github-actions[bot]@users.noreply.github.com\" && git config --global user.name \"GitHub Actions\"\n\n      - name: Install native dependencies\n        run: sudo apt-get update && sudo apt-get install -y libssl-dev\n\n      - name: Install wheel\n        run: pip install wheel\n\n      - name: Install Material for MkDocs Insiders\n        run: pip install mkdocs-material-insiders\n\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n\n      - name: Update from Remote\n        run: git pull origin ${{ github.ref }}\n\n      - name: Build docs (latest)\n        run: mkdocs build --config-file docs/mkdocs.yml\n\n      - name: Build docs (develop)\n        run: mkdocs build --config-file docs/mkdocs.yml --theme-dir docs/material\n\n      - name: Build docs\n        run: mkdocs build --config-file docs/mkdocs.yml --theme-dir docs/material\n```", "answer": "```yaml name: docs\n\nconcurrency: docs\n\non:\n  push:\n    branches: [ develop, release ]\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Track Docs Branch\n      run: git branch docs -t origin/docs\n    - uses: actions/setup-python@v4\n      with:\n        python-version: 3.x\n    - uses: actions/cache@v3\n      with:\n        key: ${{ github.ref }}\n        path: .cache\n    - uses: pnpm/action-setup@v2.2.2\n      with:\n        version: 7\n    - name: Lint Docs\n      run: |\n        pnpm i\n        pnpm lint\n    - name: Update pip\n      run: python -m pip install -U pip setuptools\n    - name: Set Git author\n      run: |\n        git config user.name \"github-actions[bot]\"\n        git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n    - name: Install native dependencies\n      run: sudo apt-get install libcairo2-dev libfreetype6-dev libffi-dev libjpeg-dev libpng-dev libz-dev\n    - name: Install wheel\n      run: pip install wheel\n    - name: Install Material for MkDocs Insiders\n      run: pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git\n      if: ${{ github.repository_owner == 'mastercomfig' && github.event_name != 'pull_request' }}\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Install dependencies\n      run: pip install -r docs/requirements.txt\n    - name: Update from Remote\n      run: git fetch --tags -f\n    - name: Build docs (latest)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/release' }}\n      run: mike deploy --alias-type copy -b docs -up $(git describe --tags --abbrev=0) latest page\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs (develop)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/develop' }}\n      run: mike deploy --alias-type copy -b docs -p dev\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs\n      if: ${{ github.event_name == 'pull_request' }}\n      run: mike deploy --config-file mkdocs.base.yml -u $(git describe --tags) latest\n```", "prompt": "Generate a GitHub Workflow named `docs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named develop or a branch named release. Only if at least one path of push event matches a pattern in the paths filter(docs/**, mkdocs.yml or .github/workflows/docs.yml), the workflow runs. 2) there is activity relating to a pull request. Only a single workflow using the docs concurrency group will run at a time. The workflow has one job. The job id of the 1st job is `deploy`. The job `deploy` has 16 steps. The 1st step is named ``. The 2nd step is named `Track Docs Branch`. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named `Lint Docs`. The 7th step is named `Update pip`. The 8th step is named `Set Git author`. The 9th step is named `Install native dependencies`. The 10th step is named `Install wheel`. The 11th step is named `Install Material for MkDocs Insiders`. The 12th step is named `Install dependencies`. The 13th step is named `Update from Remote`. The 14th step is named `Build docs (latest)`. The 15th step is named `Build docs (develop)`. The 16th step is named `Build docs`. "}
{"id": "63c495a68052faa2781b342a", "level": "level2", "llm_response": "```yaml\nname: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches:\n      - master\n      - '1.x'\n      - release\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Maven Central Repository\n        run: |\n          echo \"M2_USERNAME=${{ secrets.MAVEN_CENTRAL_USERNAME }}\" >> $GITHUB_ENV\n          echo \"M2_PASSWORD=${{ secrets.MAVEN_CENTRAL_PASSWORD }}\" >> $GITHUB_ENV\n\n      - name: Publish package\n        run: mvn deploy\n        env:\n          MAVEN_USERNAME: ${{ env.M2_USERNAME }}\n          MAVEN_PASSWORD: ${{ env.M2_PASSWORD }}\n```", "answer": "```yaml name: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches: [master, 1.x, release]\n\njobs:\n  release:\n    if: github.repository == 'jdbc-observations/datasource-proxy'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Maven Central Repository\n        uses: actions/setup-java@v3\n        with:\n          java-version: 8\n          distribution: temurin\n          server-id: ossrh\n          server-username: MAVEN_USERNAME\n          server-password: MAVEN_PASSWORD\n          gpg-private-key: ${{ secrets.MAVEN_GPG_PRIVATE_KEY }}\n          gpg-passphrase: MAVEN_GPG_PASSPHRASE\n      - name: Publish package\n        run: ./mvnw --batch-mode deploy -DskipTests=true -Pgithub-ossrh\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}\n          MAVEN_GPG_PASSPHRASE: ${{ secrets.MAVEN_GPG_PASSPHRASE }}\n\n```", "prompt": "Generate a GitHub Workflow named `Release to Maven Central (Deploy Snapshot or Stage Release)` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master, a branch named 1.x or a branch named release. The workflow has one job. The job id of the 1st job is `release`. The job `release` has 3 steps. The 1st step is named ``. The 2nd step is named `Set up Maven Central Repository`. The 3rd step is named `Publish package`. "}
{"id": "63c494257843b612699ff4be", "level": "level2", "llm_response": "```yaml\nname: functional-orchestration\n\non:\n  pull_request:\n    paths:\n      - 'orchestration/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-orchestration:\n    id: functional-orchestration\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        name: [devstack]\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v2\n        with:\n          path: gophercloud\n\n      - name: Deploy devstack\n        run: |\n          # Deployment commands for devstack\n          echo \"Deploying devstack...\"\n\n      - name: Checkout go\n        uses: actions/checkout@v2\n        with:\n          path: go\n\n      - name: Run Gophercloud acceptance tests\n        run: |\n          # Test commands for Gophercloud acceptance tests\n          echo \"Running Gophercloud acceptance tests...\"\n\n      - name: Generate logs on failure\n        if: failure()\n        run: |\n          # Log generation commands\n          echo \"Generating logs...\"\n\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v2\n        with:\n          name: logs\n          path: logs\n```", "answer": "```yaml name: functional-orchestration\non:\n  pull_request:\n    paths:\n      - '**orchestration**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-orchestration:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n          conf_overrides: |\n            enable_plugin heat https://opendev.org/openstack/heat ${{ matrix.openstack_version }}\n          enabled_services: 'h-eng,h-api,h-api-cfn,h-api-cw'\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: ^.*orchestration.*$\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-orchestration-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-orchestration` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**orchestration**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests` and its job id is `functional-orchestration`. The job `functional-orchestration` has 6 steps. The 1st step is named `Checkout Gophercloud`. The 2nd step is named `Deploy devstack`. The 3rd step is named `Checkout go`. The 4th step is named `Run Gophercloud acceptance tests`. The 5th step is named `Generate logs on failure`. The 6th step is named `Upload logs artifacts on failure`. "}
{"id": "63c495167843b61269a0553c", "level": "level2", "llm_response": "```yaml\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Set up JDK 11\n      uses: actions/setup-java@v2\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n\n    - name: Add issue to DEPR project board\n      run: |\n        gh issue edit ${{ github.event.issue.number }} --project DEPR\n```", "answer": "```yaml # Run the workflow that adds new tickets that are either:\n# - labelled \"DEPR\"\n# - title starts with \"[DEPR]\"\n# - body starts with \"Proposal Date\" (this is the first template field)\n# to the org-wide DEPR project board\n\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    uses: openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master\n    secrets:\n      GITHUB_APP_ID: ${{ secrets.GRAPHQL_AUTH_APP_ID }}\n      GITHUB_APP_PRIVATE_KEY: ${{ secrets.GRAPHQL_AUTH_APP_PEM }}\n      SLACK_BOT_TOKEN: ${{ secrets.SLACK_ISSUE_BOT_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Add newly created DEPR issues to the DEPR project board` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `routeissue`. "}
{"id": "63c495e88052faa2781b50cc", "level": "level2", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [labeled]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. The job `TagBot` has one step. The 1st step is named ``. "}
{"id": "63c496876fc19abdf9c9c8bb", "level": "level2", "llm_response": "```yaml\nname: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: '*/30 * * * *'\n\njobs:\n  build-feeds:\n    id: build-feeds\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Repo\n      uses: actions/checkout@v2\n\n    - name: Install Dependencies\n      run: npm install\n\n    - name: Checkout Data Source Repo\n      uses: actions/checkout@v2\n      with:\n        repository: 'username/data-source-repo'\n        path: 'data-source'\n\n    - name: Process Data\n      run: node process-data.js\n\n    - name: Deploy to Firebase\n      uses: w9jds/firebase-action@v2\n      with:\n        serviceAccountKey: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY }}\n        projectId: 'your-project-id'\n        bucket: 'gs://your-bucket-name'\n```", "answer": "```yaml name: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: \"*/30 * * * *\"\n\njobs:\n  build-feeds:\n    name: Update latest feed data from source repo\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n      - name: Install Dependencies\n        run: yarn\n      - name: Checkout Data Source Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n        with:\n          repository: smartcontractkit/reference-data-directory\n          path: data-source\n          token: ${{ secrets.GH_API_KEY }}\n      # - name: Read Data Source\n      #   run: cat data-source/package.json\n      - name: Process Data\n        run: yarn process\n      - name: Deploy to Firebase\n        uses: w9jds/firebase-action@94389a881adad57284e35860f5d258ab262dcd91\n        with:\n\n          args: -c firebase-addresses.json deploy --only hosting\n        env:\n          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n          PROJECT_ID: cl-docs-addresses\n```", "prompt": "Generate a GitHub Workflow named `Build and Publish Feed Resources` for a GitHub repository whose primary programming language is Solidity. This workflow will be triggered by an event: the scheduled time has come: every 30 minutes. The workflow has one job. The 1st job is named `Update latest feed data from source repo` and its job id is `build-feeds`. The job `build-feeds` has 5 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install Dependencies`. The 3rd step is named `Checkout Data Source Repo`. The 4th step is named `Process Data`. The 5th step is named `Deploy to Firebase`. "}
{"id": "63c494298052faa2781a98f7", "level": "level2", "llm_response": "```yaml\nname: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  build: ${{ github.workspace }}/build\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Setup\n        run: |\n          # Setup steps go here\n          echo \"Setup completed\"\n\n      - name: Configure CMake\n        run: |\n          # Configure CMake steps go here\n          echo \"CMake configured\"\n\n      - name: Initialize MSVC Code Analysis\n        id: run-analysis\n        run: |\n          # Initialize MSVC Code Analysis steps go here\n          echo \"Code analysis initialized\"\n\n      - name: Upload SARIF to GitHub\n        run: |\n          # Upload SARIF to GitHub steps go here\n          echo \"SARIF uploaded to GitHub\"\n\n      - name: Upload SARIF as an Artifact\n        uses: actions/upload-artifact@v2\n        with:\n          name: sarif-report\n          path: ${{ github.workspace }}/path/to/sarif/file.sarif\n```", "answer": "```yaml name: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  # Path to the CMake build directory.\n  build: '${{ github.workspace }}/build'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: windows-2022\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup\n        run: |\n          $Url = \"https://boostorg.jfrog.io/artifactory/main/release/1.75.0/binaries/boost_1_75_0-msvc-14.2-64.exe\"\n          (New-Object System.Net.WebClient).DownloadFile($Url, \"$env:TEMP\\boost.exe\")\n          Start-Process -Wait -FilePath \"$env:TEMP\\boost.exe\" \"/SILENT\",\"/SP-\",\"/SUPPRESSMSGBOXES\",\"/DIR=C:\\local\\boost-1.75.0\"\n\n      - name: Configure CMake\n        env:\n          BOOST_ROOT: C:\\local\\boost-1.75.0\n        run: cmake -B ${{ env.build }} -DQL_USE_STD_CLASSES=ON\n\n      - name: Initialize MSVC Code Analysis\n        uses: microsoft/msvc-code-analysis-action@v0.1.1\n        # Provide a unique ID to access the sarif output path\n        id: run-analysis\n        env:\n          CAExcludePath: C:\\local\\boost-1.75.0\n        with:\n          cmakeBuildDirectory: ${{ env.build }}\n          buildConfiguration: Release\n          ruleset: '${{ github.workspace }}/.msvc-analysis.ruleset'\n\n      - name: Upload SARIF to GitHub\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: ${{ steps.run-analysis.outputs.sarif }}\n\n      - name: Upload SARIF as an Artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: sarif-file\n          path: ${{ steps.run-analysis.outputs.sarif }}\n\n```", "prompt": "Generate a GitHub Workflow named `Microsoft C++ Code Analysis` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow sets an environment variable to use: `build` is set to `${{ github.workspace }}/build`. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 6 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Setup`. The 3rd step is named `Configure CMake`. The 4th step is named `Initialize MSVC Code Analysis` and its id is `run-analysis`. The 5th step is named `Upload SARIF to GitHub`. The 6th step is named `Upload SARIF as an Artifact`. "}
{"id": "63c494a48052faa2781ac54a", "level": "level2", "llm_response": "```yaml\nname: cspell-action\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    id: cspell\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run cspell\n        uses: cspell/cspell-action@v2\n```", "answer": "```yaml name: cspell-action\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: streetsidesoftware/cspell-action@v2\n```", "prompt": "Generate a GitHub Workflow named `cspell-action` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `cspell`. The job `cspell` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c495197843b61269a056bc", "level": "level2", "llm_response": "```yaml\nname: Code Scanning - Action\n\non:\n  pull_request:\n    branches:\n      - dev\n      - master\n\njobs:\n  CodeQL-Build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v1\n        with:\n          languages: go\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v1\n```", "answer": "```yaml name: \"Code Scanning - Action\"\n\non:\n  pull_request:\n    branches: [dev, master]\n    types: [opened, synchronize]\n\njobs:\n  CodeQL-Build:\n    # CodeQL runs on ubuntu-latest, windows-latest, and macos-latest\n    runs-on: ubuntu-latest\n\n    permissions:\n      # required for all workflows\n      security-events: write\n\n      # only required for workflows in private repositories\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      # Initializes the CodeQL tools for scanning.\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n        # Override language selection by uncommenting this and choosing your languages\n        # with:\n        #   languages: go, javascript, csharp, python, cpp, java\n\n      # Autobuild attempts to build any compiled languages (C/C++, C#, or Java).\n      # If this step fails, then you should remove it and run the build manually (see below).\n      # - name: Autobuild\n      #   uses: github/codeql-action/autobuild@v2\n\n      # \u2139\ufe0f Command-line programs to run using the OS shell.\n      # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n      # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following\n      #    three lines and modify them (or add more) to build your code if your\n      #    project uses a compiled language\n\n      #- run: |\n      #     make bootstrap\n      #     make release\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `Code Scanning - Action` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created or a pull request's head branch is updated. The workflow would run whenever there is a pull_request event targeting: a branch named dev or a branch named master. The workflow has one job. The job id of the 1st job is `CodeQL-Build`. The job `CodeQL-Build` has 3 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Perform CodeQL Analysis`. "}
{"id": "63c495547843b61269a06e8e", "level": "level2", "llm_response": "```yaml\nname: Build and Release [Manual]\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: checkout\n      uses: actions/checkout@v2\n\n    - name: Enable PNPM\n      run: npm install -g pnpm\n\n    - name: Set node version to 16\n      uses: actions/setup-node@v2\n      with:\n        node-version: '16'\n\n    - name: Install\n      run: pnpm install\n\n    - name: Install\n      run: pnpm install --frozen-lockfile\n\n    - name: Fetch API\n      run: pnpm run fetch-api\n\n    - name: Parse API\n      run: pnpm run parse-api\n\n    - name: Build fonts\n      run: pnpm run build-fonts\n\n    - name: Generate fontlist\n      run: pnpm run generate-fontlist\n\n    - name: Generate Algolia index\n      run: pnpm run generate-algolia-index\n\n    - name: Lint files\n      run: pnpm run lint\n\n    - name: Format files\n      run: pnpm run format\n\n    - name: Stage, commit and push files\n      run: |\n        git add .\n        git commit -m \"Automated commit\"\n        git push\n\n    - name: Check font files\n      run: pnpm run check-font-files\n\n    - name: If error, commit again before publishing\n      if: ${{ failure() }}\n      run: |\n        git add .\n        git commit -m \"Automated commit after error\"\n        git push\n\n    - name: Configure CI Git\n      run: |\n        git config --global user.name \"GitHub Actions\"\n        git config --global user.email \"actions@github.com\"\n\n    - name: Publish package\n      run: pnpm run publish\n```", "answer": "```yaml name: Build and Release [Manual]\n\non: [workflow_dispatch]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    if: github.actor == 'ayuhito'\n\n    steps:\n      - name: checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: \"0\"\n\n      - name: Enable PNPM\n        uses: pnpm/action-setup@v2\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"16\"\n          cache: \"pnpm\"\n\n      - name: Install\n        run: pnpm install --frozen-lockfile\n\n      - name: Install\n        run: pnpm i\n\n      - name: Fetch API # Calls Google Font Metadata to fetch the latest data from Google's Developer API\n        run: pnpm --filter scripts exec gfm generate $GOOGLE_API_KEY\n        env:\n          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}\n\n      - name: Parse API # Process generated API data\n        run: pnpm --filter scripts exec gfm parse\n\n      - name: Build fonts # Build all updated Google Fonts in repository\n        run: pnpm run build:google\n\n      - name: Generate fontlist # Generate FONTLIST.json and FONTLIST.md\n        run: pnpm run util:fontlist\n\n      - name: Generate Algolia index # Generate Algolia search index for website\n        run: pnpm run util:algolia\n        env:\n          ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }}\n\n      - name: Lint files\n        run: pnpm run lint\n\n      - name: Format files\n        run: pnpm run format\n\n      - name: Stage, commit and push files\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): update packages [Manual]\"\n        continue-on-error: true\n\n      - name: Check font files # Detects if all binaries are downloaded successfully and in the right place\n        run: pnpm run util:run-check\n\n      - name: If error, commit again before publishing\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): resolve file check errors [Manual]\"\n        continue-on-error: true\n\n      - name: Configure CI Git\n        run: |\n          git config --global user.email \"83556432+fontsource-bot@users.noreply.github.com\"\n          git config --global user.name \"fontsource-bot\"\n\n      - name: Publish package # Call mass-publish\n        run: pnpm run deploy:ci\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build and Release [Manual]` for a GitHub repository whose primary programming language is CSS. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 17 steps. The 1st step is named `checkout`. The 2nd step is named `Enable PNPM`. The 3rd step is named `Set node version to 16`. The 4th step is named `Install`. The 5th step is named `Install`. The 6th step is named `Fetch API`. The 7th step is named `Parse API`. The 8th step is named `Build fonts`. The 9th step is named `Generate fontlist`. The 10th step is named `Generate Algolia index`. The 11th step is named `Lint files`. The 12th step is named `Format files`. The 13th step is named `Stage, commit and push files`. The 14th step is named `Check font files`. The 15th step is named `If error, commit again before publishing`. The 16th step is named `Configure CI Git`. The 17th step is named `Publish package`. "}
{"id": "63c494ee8052faa2781ae44b", "level": "level2", "llm_response": "```yaml\nname: Add PR Deploy Badge\n\non:\n  deployment_status:\n    types: [created]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Kb Pull Request Deployment Badges\n        run: echo \"Adding PR deploy badge\"\n```", "answer": "```yaml name: Add PR Deploy Badge\n# https://docs.github.com/en/actions/reference/events-that-trigger-workflows\non: [deployment_status]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    permissions:\n      pull-requests: write\n    # only runs this job on successful deploy\n    if: github.event.deployment_status.state == 'success'\n    steps:\n    - name: Kb Pull Request Deployment Badges\n      uses: kibibit/kb-badger-action@v2\n      with:\n        github-token: ${{secrets.GITHUB_TOKEN}}\n        badge-left: demo\n        badge-right: application\n        badge-logo: heroku\n        badge-path: api\n        badge2-left: demo\n        badge2-right: api-docs\n        badge2-color: 85EA2D\n        badge2-logo: swagger\n        badge2-path: api/docs\n```", "prompt": "Generate a GitHub Workflow named `Add PR Deploy Badge` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a new deployment status is created. The workflow has one job. The job id of the 1st job is `badge`. The job `badge` has one step. The 1st step is named `Kb Pull Request Deployment Badges`. "}
{"id": "63c4968b33b087f6bde2caaa", "level": "level2", "llm_response": "```yaml\nname: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\nenv:\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  publish:\n    runs-on: windows-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --version\n\n    - name: Restore packages in preparation for ASFEnhance publishing\n      run: dotnet restore\n\n    - name: Publish ASFEnhance on Windows\n      run: dotnet publish -c Release -o ./publish\n\n    - name: Upload ASFEnhance-zh-Hans\n      uses: actions/upload-artifact@v2\n      with:\n        name: ASFEnhance-zh-Hans\n        path: ./publish/ASFEnhance-zh-Hans\n\n    - name: Upload ASFEnhance-en-US\n      uses: actions/upload-artifact@v2\n      with:\n        name: ASFEnhance-en-US\n        path: ./publish/ASFEnhance-en-US\n```", "answer": "```yaml name: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n\nenv:\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  publish:\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.0.2\n        with:\n          submodules: recursive\n\n      - name: Setup .NET Core\n        uses: actions/setup-dotnet@v2.1.0\n        with:\n          dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n      - name: Verify .NET Core\n        run: dotnet --info\n\n      - name: Restore packages in preparation for ASFEnhance publishing\n        run: dotnet restore ASFEnhance -p:ContinuousIntegrationBuild=true --nologo\n\n      - name: Publish ASFEnhance on Windows\n        shell: pwsh\n        run: |\n          $script = \"./build.ps1\";\n          Set-Location ${{ github.workspace }};\n          powershell $script;\n\n      - name: Upload ASFEnhance-zh-Hans\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-zh-Hans\n          path: dist/ASFEnhance-zh-Hans.zip\n\n      - name: Upload ASFEnhance-en-US\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-en-US\n          path: dist/ASFEnhance-en-US.zip\n```", "prompt": "Generate a GitHub Workflow named `AutoBuild-Dev` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) a commit or tag is pushed, or a repository is cloned. The workflow sets an environment variable to use: `DOTNET_SDK_VERSION` is set to `6.0.x`. The workflow has one job. The job id of the 1st job is `publish`. The job `publish` has 7 steps. The 1st step is named `Checkout code`. The 2nd step is named `Setup .NET Core`. The 3rd step is named `Verify .NET Core`. The 4th step is named `Restore packages in preparation for ASFEnhance publishing`. The 5th step is named `Publish ASFEnhance on Windows`. The 6th step is named `Upload ASFEnhance-zh-Hans`. The 7th step is named `Upload ASFEnhance-en-US`. "}
{"id": "63c494b78052faa2781acd9d", "level": "level2", "llm_response": "```yaml\nname: Merge me!\n\non:\n  workflow_run:\n    workflows: [Continuous Integration]\n    types: [completed]\n\njobs:\n  merge-me:\n    id: merge-me\n    runs-on: ubuntu-latest\n    steps:\n      - name: Merge me!\n        run: echo \"Merging PRs...\"\n```", "answer": "```yaml name: Merge me!\n\non:\n  workflow_run:\n    types:\n      - completed\n    workflows:\n      - 'Continuous Integration'\n\njobs:\n  merge-me:\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    name: Merge me!\n    runs-on: ubuntu-latest\n    steps:\n      - name: Merge me!\n        uses: ridedott/merge-me-action@master\n        with:\n          GITHUB_TOKEN: ${{ secrets.DOTTBOTT_TOKEN }}\n    timeout-minutes: 5\n```", "prompt": "Generate a GitHub Workflow named `Merge me!` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: the workflow named Continuous Integration is completed. The workflow has one job. The 1st job is named `Merge me!` and its job id is `merge-me`. The job `merge-me` has one step. The 1st step is named `Merge me!`. "}
{"id": "63c494a37843b61269a027ed", "level": "level2", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Install Go\n      run: |\n        wget https://golang.org/dl/go1.17.linux-amd64.tar.gz\n        sudo tar -C /usr/local -xzf go1.17.linux-amd64.tar.gz\n        export PATH=$PATH:/usr/local/go/bin\n        go version\n\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -v ./...\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\n\nname: CI\n\njobs:\n  test:\n    ## We want to define a strategy for our job\n    strategy:\n      ## this will contain a matrix of all the combinations\n      ## we wish to test again:\n      matrix:\n        go-version: [1.17.x]\n        platform: [ubuntu-latest, macos-latest, windows-latest]\n\n    ## Defines the platform for each test run\n    runs-on: ${{ matrix.platform }}\n\n    ## the steps that will be run through for each version and platform\n    ## combination\n    steps:\n    ## sets up go based on the version\n    - name: Install Go\n      uses: actions/setup-go@v3.3.0\n      with:\n        go-version: ${{ matrix.go-version }}\n\n    ## checks out our code locally, so we can work with the files\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n\n    ## runs go test ./...\n    - name: Build\n      run: go build ./...\n\n    ## runs go test ./...\n    - name: Test\n      run: go test ./...\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `test`. The job `test` has 4 steps. The 1st step is named `Install Go`. The 2nd step is named `Checkout code`. The 3rd step is named `Build`. The 4th step is named `Test`. "}
{"id": "63c493b87843b612699fd399", "level": "level2", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Run Release Please\n        uses: google-github-actions/release-please-action@v3\n        with:\n          language: javascript\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\nname: release-please\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: GoogleCloudPlatform/release-please-action@v2\n        with:\n          release-type: node\n          package-name: release-please-action\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. The job `release-please` has one step. The 1st step is named ``. "}
{"id": "63c4941e7843b612699ff1f7", "level": "level2", "llm_response": "```yaml\nname: Demo link\n\non:\n  pull_request:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    id: add_demo_link\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update PR description\n        run: |\n          echo \"This is a demo link: https://example.com\" >> $GITHUB_EVENT_PATH\n```", "answer": "```yaml name: Demo link\n\non:\n  pull_request_target:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    name: Add demo link to PR description\n    runs-on: ubuntu-latest\n    env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    permissions:\n      pull-requests: write\n    steps:\n      - name: Update PR description\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const pullRequestId = context.payload.pull_request.number\n            const pullRequestBranch = context.payload.pull_request.head.ref\n\n            github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: pullRequestId,\n              body: `\ud83d\udc40 [Visit Preview](https://${pullRequestBranch}--welcome-ui.netlify.app)`\n            });\n```", "prompt": "Generate a GitHub Workflow named `Demo link` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a pull request is created. The workflow has one job. The 1st job is named `Add demo link to PR description` and its job id is `add_demo_link`. The job `add_demo_link` has one step. The 1st step is named `Update PR description`. "}
{"id": "63c494608052faa2781aabf4", "level": "level2", "llm_response": "```yaml\nname: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n\n    - name: Check go.mod files\n      run: go mod tidy\n```", "answer": "```yaml name: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    name: go.mod check\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - uses: actions/setup-go@c4a742cab115ed795e34d4513e2cf7d472deb55f\n        with:\n          go-version: 1.17\n\n      - name: Check go.mod files\n        shell: bash\n        run: |\n          cd gomod-sync\n          go run main.go check\n```", "prompt": "Generate a GitHub Workflow named `go.mod check` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) there is activity relating to a pull request. The workflow has one job. The 1st job is named `go.mod check` and its job id is `check`. The job `check` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Check go.mod files`. "}
{"id": "63c494be7843b61269a0325c", "level": "level2", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"main\" ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'javascript', 'typescript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 02:25 am, only on thursday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named `Perform CodeQL Analysis`. "}
{"id": "63c494228052faa2781a95a5", "level": "level2", "llm_response": "```yaml\nname: snyk-pr\n\non:\n  pull_request:\n    branches:\n      - master\n\njobs:\n  whitesource:\n    id: whitesource\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v2\n      - name: checkout action\n        uses: actions/checkout@v2\n      - name: PR\n        run: echo \"Running PR step\"\n```", "answer": "```yaml name: snyk-pr\non:\n  pull_request:\n    branches:\n      - master\njobs:\n  whitesource:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa' }}\n    steps:\n    - name: checkout\n      uses: actions/checkout@v3\n      with:\n        ref: ${{ github.event.pull_request.head.ref }}\n        fetch-depth: 0\n\n    - name: checkout action\n      uses: actions/checkout@v3\n      with:\n        repository: snowflakedb/whitesource-actions\n        token: ${{ secrets.WHITESOURCE_ACTION_TOKEN }}\n        path: whitesource-actions\n\n    - name: PR\n      uses: ./whitesource-actions/snyk-pr\n      env:\n        PR_TITLE: ${{ github.event.pull_request.title }}\n      with:\n        jira_token: ${{ secrets.JIRA_TOKEN_PUBLIC_REPO }}\n        gh_token: ${{ secrets.GITHUB_TOKEN }}\n        amend: false # true if you want the commit to be amended with the JIRA number\n```", "prompt": "Generate a GitHub Workflow named `snyk-pr` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `whitesource`. The job `whitesource` has 3 steps. The 1st step is named `checkout`. The 2nd step is named `checkout action`. The 3rd step is named `PR`. "}
{"id": "63c493c37843b612699fd587", "level": "level2", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Draft Release\n      run: echo \"Drafting release...\"\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    # branches to consider in the event; optional, defaults to all\n    branches:\n      - main\n  # pull_request event is required only for autolabeler\n  pull_request:\n    # Only following types are handled by the action, but one can default to all as well\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Draft Release\n        uses: release-drafter/release-drafter@v5\n        with:\n          tag_name: vNext\n          release_name: vNext\n          draft: true\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is TSQL. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created, a previously closed pull request is reopened or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `update_release_draft`. The job `update_release_draft` has one step. The 1st step is named `Draft Release`. "}
{"id": "63c495238052faa2781afbf5", "level": "level2", "llm_response": "```yaml\nname: Greetings\n\non:\n  pull_request:\n  issues:\n\njobs:\n  greeting:\n    runs-on: macos-latest\n\n    steps:\n    - name: Print greeting message\n      run: echo \"Hello, world!\"\n```", "answer": "```yaml name: Greetings\n\non: [pull_request, issues]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/first-interaction@v1\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        issue-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to fix your issue ASAP. Make sure that you have read about issue format in the docs'\n        pr-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to review your PR ASAP. Make sure that you have read about requirements to pull requests in the docs'\n```", "prompt": "Generate a GitHub Workflow named `Greetings` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) activity related to an issue occurs. The workflow has one job. The job id of the 1st job is `greeting`. The job `greeting` has one step. The 1st step is named ``. "}
{"id": "63c496956fc19abdf9c9ce1c", "level": "level2", "llm_response": "```yaml\nname: Licensed\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    id: test\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set Node.js 16.x\n      uses: actions/setup-node@v2\n      with:\n        node-version: '16'\n\n    - name: Install licensed\n      run: npm install -g licensed\n\n    - name: Check licenses\n      run: licensed check\n```", "answer": "```yaml name: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    name: Check licenses\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set Node.js 16.x\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16.x\n          cache: npm\n      - run: npm ci\n      - name: Install licensed\n        run: |\n          cd $RUNNER_TEMP\n          curl -Lfs -o licensed.tar.gz https://github.com/github/licensed/releases/download/3.4.4/licensed-3.4.4-linux-x64.tar.gz\n          sudo tar -xzf licensed.tar.gz\n          sudo mv licensed /usr/local/bin/licensed\n      - run: licensed status\n```", "prompt": "Generate a GitHub Workflow named `Licensed` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Check licenses` and its job id is `test`. The job `test` has 5 steps. The 1st step is named ``. The 2nd step is named `Set Node.js 16.x`. The 3rd step is named ``. The 4th step is named `Install licensed`. The 5th step is named ``. "}
{"id": "63c494937843b61269a02136", "level": "level2", "llm_response": "```yaml\nname: e2e melange bootstrap + build\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Fetch dependencies\n      run: go mod download\n\n    - name: Mark workspace as a safe repository\n      run: git config --global --add safe.directory $GITHUB_WORKSPACE\n\n    - name: Build bootstrap melange tool (stage1)\n      run: go build -o bootstrap-melange-stage1\n\n    - name: Generate a package signing keypair\n      run: gpg --batch --gen-key --passphrase '' --key-type RSA --key-length 4096 --name 'melange@example.com' --armor --output melange-key.gpg\n\n    - name: Prepare build workspace for stage2\n      run: mkdir stage2\n\n    - name: Build stage2 melange package with bootstrap melange\n      run: ./bootstrap-melange-stage1 build stage2\n\n    - name: Install stage2 melange package\n      run: ./stage2/melange install\n\n    - name: Move stage2 artifacts to stage2 directory\n      run: mv stage2/* stage2/\n\n    - name: Verify operation of stage2 melange\n      run: ./stage2/melange verify\n\n    - name: Prepare build workspace for stage3\n      run: mkdir stage3\n\n    - name: Build stage3 melange package with stage2 melange\n      run: ./stage2/melange build stage3\n\n    - name: Install stage3 melange package\n      run: ./stage3/melange install\n\n    - name: Move stage3 artifacts to stage3 directory\n      run: mv stage3/* stage3/\n\n    - name: Ensure melange package is reproducible\n      run: ./stage3/melange reproducible\n\n    - name: Verify operation of stage3 melange\n      run: ./stage3/melange verify\n```", "answer": "```yaml name: e2e melange bootstrap + build\n\non:\n  push:\n  pull_request:\n\njobs:\n  build:\n    name: bootstrap package\n    runs-on: ubuntu-latest\n    container:\n      image: alpine:latest\n      options: |\n        --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n\n    steps:\n    - name: Fetch dependencies\n      run: |\n        cat >/etc/apk/repositories <<_EOF_\n        https://dl-cdn.alpinelinux.org/alpine/edge/main\n        https://dl-cdn.alpinelinux.org/alpine/edge/community\n        https://dl-cdn.alpinelinux.org/alpine/edge/testing\n        _EOF_\n\n        apk upgrade -Ua\n        apk add go cosign build-base git bubblewrap\n    - uses: actions/checkout@2541b1294d2704b0964813337f33b291d3f8596b\n    - name: Mark workspace as a safe repository\n      run: git config --global --add safe.directory ${GITHUB_WORKSPACE}\n    - name: Build bootstrap melange tool (stage1)\n      run: make melange\n    - name: Generate a package signing keypair\n      run: |\n        ./melange keygen\n        mv melange.rsa.pub /etc/apk/keys\n    - name: Prepare build workspace for stage2\n      run: |\n        git clone . workspace-stage2/x86_64\n    - name: Build stage2 melange package with bootstrap melange\n      run: ./melange build --pipeline-dir=pipelines/ --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage2/\n    - name: Install stage2 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage2 artifacts to stage2 directory\n      run: |\n        mv packages stage2\n    - name: Verify operation of stage2 melange\n      run: melange version\n    - name: Prepare build workspace for stage3\n      run: |\n        git clone . workspace-stage3/x86_64\n    - name: Build stage3 melange package with stage2 melange\n      run: melange build --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage3/\n    - name: Install stage3 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage3 artifacts to stage3 directory\n      run: |\n        mv packages stage3\n    - name: Ensure melange package is reproducible\n      run: |\n        sha256sum stage2/x86_64/*.apk | sed -e 's:stage2/:stage3/:g' | sha256sum -c\n    - name: Verify operation of stage3 melange\n      run: melange version\n```", "prompt": "Generate a GitHub Workflow named `e2e melange bootstrap + build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `bootstrap package` and its job id is `build`. The job `build` has 16 steps. The 1st step is named `Fetch dependencies`. The 2nd step is named ``. The 3rd step is named `Mark workspace as a safe repository`. The 4th step is named `Build bootstrap melange tool (stage1)`. The 5th step is named `Generate a package signing keypair`. The 6th step is named `Prepare build workspace for stage2`. The 7th step is named `Build stage2 melange package with bootstrap melange`. The 8th step is named `Install stage2 melange package`. The 9th step is named `Move stage2 artifacts to stage2 directory`. The 10th step is named `Verify operation of stage2 melange`. The 11th step is named `Prepare build workspace for stage3`. The 12th step is named `Build stage3 melange package with stage2 melange`. The 13th step is named `Install stage3 melange package`. The 14th step is named `Move stage3 artifacts to stage3 directory`. The 15th step is named `Ensure melange package is reproducible`. The 16th step is named `Verify operation of stage3 melange`. "}
{"id": "63c495e58052faa2781b4f4c", "level": "level2", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 */6 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Mark stale issues and pull requests\n        run: |\n          gh issue edit --label \"stale\" --state closed --if \"labels contains 'stale' and state is open and days since last update > 30\"\n          gh pr edit --label \"stale\" --state closed --if \"labels contains 'stale' and state is open and days since last update > 30\"\n```", "answer": "```yaml name: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '0 */6 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v6\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        days-before-pr-stale: 14\n        days-before-pr-close: 14\n        stale-pr-label: 'inactive'\n        close-pr-label: 'auto-close'\n        exempt-pr-labels: 'keep-open'\n        stale-pr-message: >\n          This pull request has been inactive for 14 days. \n          If you are finished with your changes, don't forget to sign off. See the [contributor guide](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-write-pull-request-automation?branch=main) for instructions. \n          If this PR is inactive for 14 more days, it will be closed automatically. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n        close-pr-message: >\n          This pull request has been inactive for 28 days. At this time, we are closing the PR.  \n          If you decide to continue working on your change, you can reopen the PR and continue working. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n          \n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: every 6 hours. The workflow has one job. The job id of the 1st job is `stale`. The job `stale` has one step. The 1st step is named ``. "}
{"id": "63c4951f7843b61269a0593c", "level": "level2", "llm_response": "```yaml\nname: docker-push\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build-and-push:\n    id: build-and-push\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Docker meta\n        id: meta\n        uses: docker/metadata-action@v3\n        with:\n          images: my-dockerhub-username/my-repository\n\n      - name: Setup QEMU\n        uses: docker/setup-qemu-action@v2\n\n      - name: Setup Buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Build and push\n        run: |\n          docker buildx build --platform linux/amd64,linux/arm64 -t my-dockerhub-username/my-repository:$GITHUB_REF_NAME --push .\n```", "answer": "```yaml name: docker-push\non:\n  push:\n    tags:\n      - \"v*\"\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n\n      - name: docker meta\n        id: meta\n        uses: docker/metadata-action@v4.1.0\n        with:\n          images: fsouza/fake-gcs-server\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n\n      - name: setup qemu\n        uses: docker/setup-qemu-action@v2.1.0\n\n      - name: setup buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2.1.0\n\n      - name: login to docker hub\n        uses: docker/login-action@v2.1.0\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: build and push\n        uses: docker/build-push-action@v3.2.0\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          platforms: linux/amd64,linux/arm64\n```", "prompt": "Generate a GitHub Workflow named `docker-push` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The job id of the 1st job is `build-and-push`. The job `build-and-push` has 6 steps. The 1st step is named ``. The 2nd step is named `docker meta` and its id is `meta`. The 3rd step is named `setup qemu`. The 4th step is named `setup buildx` and its id is `buildx`. The 5th step is named `login to docker hub`. The 6th step is named `build and push`. "}
{"id": "63c495407843b61269a06679", "level": "level2", "llm_response": "```yaml\nname: Tests\n\non:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Install Linux packages for Qt 5 support\n      run: sudo apt-get update && sudo apt-get install -y libqt5gui5\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v2\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies and local packages\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n\n    - name: Create clean test directory\n      run: mkdir -p test_results\n\n    - name: Test Traits package\n      run: python -m unittest discover -s tests\n```", "answer": "```yaml name: Tests\n\non:\n- pull_request\n- workflow_dispatch\n\njobs:\n  tests:\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10', '3.11-dev']\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install Linux packages for Qt 5 support\n      run: |\n        sudo apt-get update\n        sudo apt-get install qt5-default\n        sudo apt-get install libxkbcommon-x11-0\n        sudo apt-get install libxcb-icccm4\n        sudo apt-get install libxcb-image0\n        sudo apt-get install libxcb-keysyms1\n        sudo apt-get install libxcb-randr0\n        sudo apt-get install libxcb-render-util0\n        sudo apt-get install libxcb-xinerama0\n      if: matrix.os == 'ubuntu-latest'\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies and local packages\n      run: |\n        python -m pip install .[test]\n    - name: Create clean test directory\n      run: |\n        mkdir testdir\n    - name: Test Traits package\n      uses: GabrielBB/xvfb-action@v1\n      with:\n        working-directory: testdir\n        run: python -m unittest discover -v traits\n```", "prompt": "Generate a GitHub Workflow named `Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `tests`. The job `tests` has 6 steps. The 1st step is named ``. The 2nd step is named `Install Linux packages for Qt 5 support`. The 3rd step is named `Set up Python ${{ matrix.python-version }}`. The 4th step is named `Install dependencies and local packages`. The 5th step is named `Create clean test directory`. The 6th step is named `Test Traits package`. "}
{"id": "63c495448052faa2781b0abc", "level": "level2", "llm_response": "```yaml\nname: Node Blog CI\n\non:\n  push:\n    branches:\n      - '!release'\n  pull_request:\n    branches:\n      - '!release'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x, 16.x]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Launch MongoDB\n        run: |\n          docker run -d --name mongo -p 27017:27017 mongo\n\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: yarn install, build, and test\n        run: |\n          yarn install\n          yarn build\n          yarn test\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v1\n        with:\n          token: ${{ secrets.CODECOV_TOKEN }}\n          file: ./coverage/lcov.info\n```", "answer": "```yaml name: Node Blog CI\n\non:\n  push:\n    branches-ignore:\n    - release\n  pull_request:\n    branches-ignore:\n    - release\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16.x]\n    steps:\n    - uses: actions/checkout@master\n    - name: Launch MongoDB\n      uses: wbari/start-mongoDB@master\n      with:\n        mongoDBVersion: 5\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@master\n      with:\n        node-version: ${{ matrix.node-version }}\n    - name: yarn install, build, and test\n      run: |\n        yarn install\n        yarn run build\n        yarn run test:cov\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@master\n      with:\n        token: ${{secrets.CODECOV_TOKEN}}\n      env:\n        CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node Blog CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event unless the push event is to: a branch named release. 2) The workflow would run whenever there is a pull_request event unless the pull request is targeting: a branch named release. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 5 steps. The 1st step is named ``. The 2nd step is named `Launch MongoDB`. The 3rd step is named `Use Node.js ${{ matrix.node-version }}`. The 4th step is named `yarn install, build, and test`. The 5th step is named `Upload coverage to Codecov`. "}
{"id": "63c496561899db58864d23cc", "level": "level2", "llm_response": "```yaml\nname: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  mysql:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule docker\n\n      - name: Run Molecule tests\n        run: |\n          molecule test --debug-the ${{ github.event.inputs.debug-the }}\n```", "answer": "```yaml name: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      # Plugins\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  mysql:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: mysql\n      versions: '[5.6, 5.7, \"8.0\", \"galera.3.mysql_wsrep.5.6\", \"galera.4.10.mysql_wsrep.8.0.26\", \"mariadb.10.3\", \"mariadb.10.4\", \"mariadb.10.5\", \"mariadb.10.6\"]'\n```", "prompt": "Generate a GitHub Workflow named `Molecule - MySQL` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.mysql.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/mysql.*/**, roles/mysql/**, plugins/filter/mysql_config.py, plugins/filter/staten.py or plugins/lookup/templates_exclusive.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `mysql`. "}
{"id": "63c495a88052faa2781b34fc", "level": "level2", "llm_response": "```yaml\nname: Build iso from elemental-iso-build as external user\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Install Docker\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y docker.io\n          sudo usermod -aG docker $USER\n\n      - name: Install deps\n        run: |\n          go mod download\n\n      - name: Build iso from script\n        run: |\n          ./build_iso.sh\n\n      - name: Check config was inserted\n        run: |\n          grep -q \"config inserted\" build.log\n\n      - name: Basic sanity checks for ISO\n        run: |\n          ./sanity_checks.sh\n```", "answer": "```yaml name: Build iso from elemental-iso-build as external user\n# Test building the iso from an external point of view\n# This tests doesn't clone the repo, just interacts with the script as an external user would do\n# Gets the script only and runs it to see if the building is done properly\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Install Docker\n        uses: docker-practice/actions-setup-docker@v1\n      - name: Install deps\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y mkisofs\n      - name: Build iso from script\n        run: |\n          # Just a simple run to test the build script, no need to upload the generated iso!\n          echo \"TEST\" > config.yaml\n          curl -fsSL https://raw.githubusercontent.com/rancher/elemental/main/.github/elemental-iso-build -o elemental-iso-build\n          chmod +x ./elemental-iso-build\n          ./elemental-iso-build config.yaml\n      - name: Check config was inserted\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Extract config and check against our config\n          isoinfo -x /livecd-cloud-config.yaml -R -i $ISO > livecd-cloud-config.yaml\n          # This checks that the files are the same content\n          cmp config.yaml livecd-cloud-config.yaml\n      - name: Basic sanity checks for ISO\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Check it has eltorito\n          isoinfo -d -i $ISO|grep -q Eltorito\n          # check bootable flag\n          isoinfo -d -i $ISO|grep -q bootable        \n```", "prompt": "Generate a GitHub Workflow named `Build iso from elemental-iso-build as external user` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `deploy`. The job `deploy` has 5 steps. The 1st step is named `Install Docker`. The 2nd step is named `Install deps`. The 3rd step is named `Build iso from script`. The 4th step is named `Check config was inserted`. The 5th step is named `Basic sanity checks for ISO`. "}
{"id": "63c495878052faa2781b26e9", "level": "level2", "llm_response": "```yaml\nname: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoclose issues\n        run: echo \"Autoclosing issues\"\n```", "answer": "```yaml name: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoclose issues\n        uses: arkon/issue-closer-action@v3.4\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          ignoreLabel: do-not-autoclose\n          rules: |\n            [\n              {\n                \"type\": \"title\",\n                \"regex\": \".*<(Source Name|short description)>*\",\n                \"message\": \"You did not fill out the description in the title\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*DELETE THIS SECTION IF YOU HAVE READ AND ACKNOWLEDGED IT.*\",\n                \"message\": \"The acknowledgment section was not removed\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*\\\\* (Aniyomi version|Android version|Device|Name|Link|Extension version): \\\\?.*\",\n                \"message\": \"The requested information was not filled out\"\n              }\n            ]\n```", "prompt": "Generate a GitHub Workflow named `Issue closer` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: an issue is opened, the title or body on an issue is edited or a closed issue is reopened. The workflow has one job. The job id of the 1st job is `autoclose`. The job `autoclose` has one step. The 1st step is named `Autoclose issues`. "}
{"id": "63c495257843b61269a05b78", "level": "level2", "llm_response": "```yaml\nname: Flatpak dependency updates\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Step 1\n      run: echo \"Step 1\"\n\n    - name: Step 2\n      run: echo \"Step 2\"\n```", "answer": "```yaml name: Flatpak dependency updates\non:\n  schedule: # for scheduling to work this file must be in the default branch\n  - cron: \"0 0 * * *\" # run every day\n  workflow_dispatch: # can be manually dispatched under GitHub's \"Actions\" tab \n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-20.04\n\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          # we can't push changes to a fork via a shallow update, we need to clone the full repo\n          fetch-depth: 0\n          # by default when persisting credentials the local git config will use the workflow provided GITHUB_TOKEN, not our own GITHUB_TOKEN env var for the container\n          # we must not use the provided GITHUB_TOKEN, as it will fail to push to the fork since the provided GITHUB_TOKEN is only for the repository where the workflow is running \n          persist-credentials: false\n\n      - uses: docker://ghcr.io/flathub/flatpak-external-data-checker:latest\n        env:\n          GIT_AUTHOR_NAME: EasyEffects Bot\n          GIT_COMMITTER_NAME: EasyEffects Bot\n          # email sets \"EasyEffects Bot\" user as commit author\n          GIT_AUTHOR_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GIT_COMMITTER_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GITHUB_TOKEN: ${{ secrets.EASYEFFECTS_BOT }}\n        with:\n          args: --update --always-fork util/flatpak/com.github.wwmm.easyeffects.Devel.json\n```", "prompt": "Generate a GitHub Workflow named `Flatpak dependency updates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `flatpak-external-data-checker`. The job `flatpak-external-data-checker` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c494a27843b61269a02770", "level": "level2", "llm_response": "```yaml\nname: Doc Site\n\non:\n  push:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  build-and-deploy-site:\n    id: build-and-deploy-site\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2\n\n      - name: Install and Build \ud83d\udd27\n        run: |\n          npm install\n          npm run build\n\n      - name: Deploy \ud83d\ude80\n        run: |\n          npm run deploy\n```", "answer": "```yaml # This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Doc Site\n\non:\n  push:\n    branches: [master]\n  workflow_dispatch:\n\njobs:\n  build-and-deploy-site:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n\n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install --legacy-peer-deps\n          npm run docs:build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4.2.5\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist/site # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Doc Site` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build-and-deploy-site`. The job `build-and-deploy-site` has 3 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install and Build \ud83d\udd27`. The 3rd step is named `Deploy \ud83d\ude80`. "}
{"id": "63c495bf8052faa2781b3ef6", "level": "level2", "llm_response": "```yaml\nname: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - master\n    paths:\n      - .github/workflows/mol_tree2_lib.yml\n      - tree2/**\n  pull_request:\n  schedule:\n    - cron: '0 7 * * *'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n      - name: Step 2\n```", "answer": "```yaml name: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches: \n      - master\n    paths:\n      - '.github/workflows/mol_tree2_lib.yml'\n      - 'tree2/**'\n  pull_request:\n  schedule:\n    - cron: \"0 7 * * *\"\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    \n    steps:\n    \n    - uses: hyoo-ru/mam_build@master2\n      with:\n        package: mol\n        modules: tree2/lib\n    \n    - uses: JS-DevTools/npm-publish@v1\n      if: ${{ github.ref == 'refs/heads/master' }}\n      with:\n        token: ${{ secrets.NPM_AUTH_TOKEN }}\n        package: ./mol/tree2/lib/-/package.json\n```", "prompt": "Generate a GitHub Workflow named `mol_tree2_lib` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/mol_tree2_lib.yml or tree2/**), the workflow runs. 3) there is activity relating to a pull request. 4) the scheduled time has come: at 07:00 am. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c496361e33648075779191", "level": "level2", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update Release Draft\n        uses: release-drafter/release-drafter@v5\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. The job `update_release_draft` has one step. The 1st step is named ``. "}
{"id": "63c496561899db58864d23d2", "level": "level2", "llm_response": "```yaml\nname: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  ntp:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule ansible\n\n      - name: Run Molecule tests\n        run: |\n          molecule test --all\n        env:\n          MOLECULE_DEBUG: ${{ github.event.inputs.debug-the }}\n```", "answer": "```yaml name: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  ntp:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: ntp\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Ntp` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.ntp.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/ntp/** or roles/ntp/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `ntp`. "}
{"id": "63c494847843b61269a01ad6", "level": "level2", "llm_response": "```yaml\nname: Release v1 NPM Package\n\non:\n  workflow_dispatch:\n    inputs:\n      tag-this:\n        description: 'Enter the version for the release tag (must be larger than last tag, use patch (0.0.x) for bug fixes, use minor (0.x.0) for new actions)'\n        required: true\n        type: string\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  merge-to-v1-branch:\n    id: merge-to-v1-branch\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Set git name, mail and origin\n        run: |\n          git config --global user.name \"github-actions[bot]\"\n          git config --global user.email \"github-actions[bot]@users.noreply.github.com\"\n          git config --global push.default simple\n\n      - name: Checkout v1 branch and merge\n        run: |\n          git checkout v1\n          git merge master\n\n      - name: Generate new tag, push tag and branch\n        run: |\n          NEW_TAG=$(echo ${{ github.event.inputs.tag-this }} | sed 's/v//')\n          git tag $NEW_TAG\n          git push origin v1\n          git push origin $NEW_TAG\n```", "answer": "```yaml name: \"Release v1 NPM Package\"\non:\n  workflow_dispatch:\n    inputs:\n      tag:\n        description: |\n          Enter the version for the release tag.\n          Must be larger than last tag.\n          Use patch (0.0.x) for bug fixes.\n          Use minor (0.x.0) for new actions.\n        type: string\n        required: true\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false\njobs:\n  merge-to-v1-branch:\n    name: Create release by rebasing master to v1 and create a new tag\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n          registry-url: 'https://registry.npmjs.org'\n      - run: yarn install\n      - name: Set git name, mail and origin\n        run: |\n          git config --global user.name \"Josef Fr\u00f6hle\"\n          git config --global user.email \"github@josef-froehle.de\"\n          git remote set-url origin https://${{ secrets.BOT_PIPELINE_TOKEN }}@github.com/${{ github.repository }}\n      - name: Checkout v1 branch and merge\n        run: |\n          git checkout v1\n          git merge --ff-only master\n      - name: Generate new tag, push tag and branch\n        run: |\n          yarn run build\n          yarn version --non-interactive --no-git-tag-version --new-version ${{ github.event.inputs.tag }}\n          yarn run changelog\n          yarn run documentation\n          git add -A\n          yarn version --non-interactive --no-git-tag-version --new-version 0.0.0\n          yarn version --non-interactive --new-version ${{ github.event.inputs.tag }}\n          git push\n          git push --tags\n          git checkout master\n          git merge --ff-only v1\n          git push\n          git subtree split --prefix docs -b gh-pages\n          git push -f origin gh-pages:gh-pages\n      - run: yarn publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release v1 NPM Package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: tag-this input represents enter the version for the release tag.\nmust be larger than last tag.\nuse patch (0.0.x) for bug fixes.\nuse minor (0.x.0) for new actions.\n, the data type is string and it must be supplied. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Create release by rebasing master to v1 and create a new tag` and its job id is `merge-to-v1-branch`. The job `merge-to-v1-branch` has 7 steps. The 1st step is named `Checkout`. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Set git name, mail and origin`. The 5th step is named `Checkout v1 branch and merge`. The 6th step is named `Generate new tag, push tag and branch`. The 7th step is named ``. "}
{"id": "63c4963f1e3364807577960f", "level": "level2", "llm_response": "```yaml\nname: Validate Gradle Wrapper\n\non:\n  pull_request:\n\njobs:\n  validation:\n    id: validation\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Validate Gradle Wrapper\n        run: ./gradlew wrapper --gradle-version=7.0\n```", "answer": "```yaml name: \"Validate Gradle Wrapper\"\n\non: [ pull_request ]\n\njobs:\n  validation:\n    name: \"Validation\"\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gradle/wrapper-validation-action@v1\n```", "prompt": "Generate a GitHub Workflow named `Validate Gradle Wrapper` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Validation` and its job id is `validation`. The job `validation` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c4969cb008460c1df157a0", "level": "level2", "llm_response": "```yaml\nname: Post-release\n\non:\n  release:\n    types: [published, prereleased, edited]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"This is the first step of the release job.\"\n```", "answer": "```yaml name: Post-release\non:\n  release:\n    types:\n      - published\n      - edited\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: apexskier/github-release-commenter@v1\n        with:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          comment-template: This is addressed by {release_link}.\n          label-template: released\n```", "prompt": "Generate a GitHub Workflow named `Post-release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published or the details of a release, pre-release, or draft release are edited. The workflow has one job. The job id of the 1st job is `release`. The job `release` has one step. The 1st step is named ``. "}
{"id": "63c4946e8052faa2781ab27f", "level": "level2", "llm_response": "```yaml\nname: test\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: 1.16\n      - name: Test\n        run: go test ./...\n\n  testacc:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Docker\n        uses: docker/setup-buildx-action@v1\n      - name: Build Docker image\n        run: docker build -t my-go-app .\n      - name: Test acceptance\n        run: terraform --version && go test -tags acceptance ./...\n```", "answer": "```yaml name: test\npermissions:\n  contents: read\n\non:\n  push:\n    branches:\n    - master\n  pull_request:\n    branches:\n    - master\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        os:\n        - ubuntu-latest\n        - macOS-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-go@v3\n      with:\n        go-version-file: '.go-version'\n        cache: true\n    - name: test\n      run: make test\n  testacc:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        terraform:\n        - 1.0.0\n        - 0.15.5\n        - 0.14.11\n        - 0.13.7\n        - 0.12.31\n    env:\n      TERRAFORM_VERSION: ${{ matrix.terraform }}\n    steps:\n    - uses: actions/checkout@v3\n    - name: docker build\n      run: docker-compose build\n    - name: terraform --version\n      run: docker-compose run --rm tfschema terraform --version\n    - name: testacc\n      run: docker-compose run --rm tfschema make testacc\n```", "prompt": "Generate a GitHub Workflow named `test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `test`. The job `test` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `test`. The job id of the 2nd job is `testacc`. The job `testacc` has 4 steps. The 1st step is named ``. The 2nd step is named `docker build`. The 3rd step is named `terraform --version`. The 4th step is named `testacc`. "}
{"id": "63c495297843b61269a05d16", "level": "level2", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  golangci:\n    id: golangci\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Install golangci-lint\n        run: |\n          go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.42.1\n\n      - name: Run golangci-lint\n        run: golangci-lint run\n```", "answer": "```yaml name: Lint\n# Lint runs golangci-lint over the entire cosmos-sdk repository\n# This workflow is run on every pull request and push to main\n# The `golangci` will pass without running if no *.{go, mod, sum} files have been changed.\non:\n  pull_request:\n  push:\n    branches:\n      - main\njobs:\n  golangci:\n    name: golangci-lint\n    runs-on: ubuntu-latest\n    timeout-minutes: 8\n    steps:\n      - uses: actions/setup-go@v3\n        with:\n          go-version: 1.18\n      - uses: actions/checkout@v3\n      - uses: technote-space/get-diff-action@v6.1.0\n        with:\n          PATTERNS: |\n            **/**.go\n            go.mod\n            go.sum\n      - uses: golangci/golangci-lint-action@v3.2.0\n        with:\n          version: v1.47.2\n          args: --timeout 10m\n          github-token: ${{ secrets.github_token }}\n        if: env.GIT_DIFF\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The 1st job is named `golangci-lint` and its job id is `golangci`. The job `golangci` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c4951f7843b61269a0593e", "level": "level2", "llm_response": "```yaml\nname: goreleaser\n\non:\n  push:\n    tags:\n      - '*'\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    id: release\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Fetch tags\n        run: git fetch --tags\n\n      - name: Build and release\n        run: goreleaser release --snapshot --rm-dist\n\n      - name: Upload assets\n        uses: actions/upload-artifact@v2\n        with:\n          name: goreleaser-artifacts\n          path: dist/\n```", "answer": "```yaml name: goreleaser\non:\n  push:\n    tags:\n      - \"*\"\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          fetch-depth: 0\n\n      - name: fetch tags\n        run: git fetch --tags --force\n\n      - uses: actions/setup-go@v3.3.0\n        with:\n          go-version: 1.19\n\n      - uses: goreleaser/goreleaser-action@v3.1.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          distribution: goreleaser\n          version: latest\n          args: release -f ci/.goreleaser.yml\n```", "prompt": "Generate a GitHub Workflow named `goreleaser` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches *. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `release`. The job `release` has 4 steps. The 1st step is named ``. The 2nd step is named `fetch tags`. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c4967e33b087f6bde2c5c1", "level": "level2", "llm_response": "```yaml\nname: Dependabot auto-merge\n\non:\n  pull_request:\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    id: dependabot\n    runs-on: ubuntu-latest\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        run: echo \"This step can be used to fetch metadata about Dependabot PRs\"\n      \n      - name: Enable auto-merge for Dependabot PRs\n        run: echo \"This step can be used to enable auto-merge for Dependabot PRs\"\n```", "answer": "```yaml ---\nname: Dependabot auto-merge\n\"on\": pull_request\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n    if: ${{ github.actor == 'dependabot[bot]' }}\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        uses: dependabot/fetch-metadata@v1.3.4\n        with:\n          github-token: \"${{ secrets.GITHUB_TOKEN }}\"\n      - name: Enable auto-merge for Dependabot PRs\n        if: >-\n          ${{\n          steps.metadata.outputs.update-type == 'version-update:semver-patch' ||\n          steps.metadata.outputs.update-type == 'version-update:semver-minor'\n          }}\n        run: gh pr merge --auto --merge \"$PR_URL\"\n        env:\n          PR_URL: ${{github.event.pull_request.html_url}}\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n```", "prompt": "Generate a GitHub Workflow named `Dependabot auto-merge` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope and write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `dependabot`. The job `dependabot` has 2 steps. The 1st step is named `Dependabot metadata` and its id is `metadata`. The 2nd step is named `Enable auto-merge for Dependabot PRs`. "}
{"id": "63c496326fc19abdf9c9a7c5", "level": "level2", "llm_response": "```yaml\nname: Test CI\n\non:\n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Install requirements\n      run: |\n        # Add commands to install requirements here\n\n    - name: Install Tangerine\n      run: |\n        # Add commands to install Tangerine here\n\n    - name: Build Runner\n      run: |\n        # Add commands to build runner here\n\n    - name: Run Tests\n      run: |\n        # Add commands to run tests here\n```", "answer": "```yaml name: Test CI\n\non: \n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on:   ubuntu-latest\n    container: alpine\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Install requirements\n      run: |\n        apk update && apk upgrade \n        apk add make bash coreutils neovim lua5.4\n        # links lua5.4 -> lua\n        ln -sv /usr/bin/lua5.4           /usr/bin/lua\n        ln -sv /usr/lib/lua5.4/liblua.so /usr/lib/liblua5.4.so\n\n    - name: Install Tangerine\n      run:  make install\n\n    - name: Build Runner\n      run:  make runner\n\n    - name: Run Tests\n      run:  yes | make test\n```", "prompt": "Generate a GitHub Workflow named `Test CI` for a GitHub repository whose primary programming language is Fennel. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) Only if at least one path of push event matches a pattern in the paths filter(lua/**, test/** or .github/**), the workflow runs. The workflow has one job. The job id of the 1st job is `test`. The job `test` has 5 steps. The 1st step is named ``. The 2nd step is named `Install requirements`. The 3rd step is named `Install Tangerine`. The 4th step is named `Build Runner`. The 5th step is named `Run Tests`. "}
{"id": "63c495207843b61269a059a2", "level": "level2", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Add label to PR\n      run: |\n        echo \"Adding label 'work-in-progress' to PR\"\n        gh pr edit ${{ github.event.pull_request.number }} --add-label \"work-in-progress\"\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler/blob/master/README.md\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/labeler@v4\n      with:\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. The job `label` has one step. The 1st step is named ``. "}
{"id": "63c494378052faa2781a9e70", "level": "level2", "llm_response": "```yaml\nname: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches:\n      - main\n    types: [opened, synchronize, reopened, ready_for_review]\n\njobs:\n  lint:\n    id: lint\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v2\n\n      - name: Protobuf format\n        run: cargo run --bin protoc-gen-validate -- --format\n\n      - name: Lint shell, Docker and protobuf\n        run: |\n          shellcheck .\n          docker run --rm -v $(pwd):/app -w /app rust:latest cargo fmt --all\n          cargo run --bin protoc-gen-validate -- --lint\n```", "answer": "```yaml name: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches: [ main ]\n    types: [opened, synchronize, reopened, ready_for_review]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v3\n        with:\n          # Full git history isn't needed to get a proper list of changed files within `super-linter`\n          fetch-depth: 0\n\n      - name: Protobuf format\n        uses: jidicula/clang-format-action@v4.9.0\n        with:\n          clang-format-version: '14'\n  \n      - name: Lint shell, Docker and protobuf\n        uses: github/super-linter/slim@v4\n        env:\n          VALIDATE_ALL_CODEBASE: false\n          DEFAULT_BRANCH: main\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # Select file types to lint. Python and Rust linters are configured separately.\n          VALIDATE_SHELL_SHFMT: true\n          #\n          # disable hadolint \n          # https://github.com/hadolint/hadolint/issues/821\n          # VALIDATE_DOCKERFILE_HADOLINT: true\n          # DOCKERFILE_HADOLINT_FILE_NAME: .github/config/.hadolint.yaml\n          #\n          # Enable after fixing proto lint issues.\n          # VALIDATE_PROTOBUF: true\n```", "prompt": "Generate a GitHub Workflow named `Miscellaneous Lint` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named devnet. 2) a pull request is created, a pull request's head branch is updated, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `lint`. The job `lint` has 3 steps. The 1st step is named `Checkout Code`. The 2nd step is named `Protobuf format`. The 3rd step is named `Lint shell, Docker and protobuf`. "}
{"id": "63c496561899db58864d23b6", "level": "level2", "llm_response": "```yaml\nname: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule docker\n\n      - name: Run Molecule tests\n        run: |\n          molecule test --debug-the ${{ github.event.inputs.debug-the }}\n```", "answer": "```yaml name: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      # Plugins\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  docker:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: docker\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Docker` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.docker.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/docker/**, roles/docker/**, plugins/filter/json.py, plugins/filter/staten.py or plugins/lookup/docker_applications.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `docker`. "}
{"id": "63c496851899db58864d36f3", "level": "level2", "llm_response": "```yaml\nname: Test with Pre-commit\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v2\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n\n    - name: Lint with pre-commit\n      run: |\n        pip install pre-commit\n        pre-commit run --all-files\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Test with Pre-commit\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.10\"]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pre-commit\n          pre-commit install-hooks\n      - name: Lint with pre-commit\n        run: pre-commit run --all-files\n```", "prompt": "Generate a GitHub Workflow named `Test with Pre-commit` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python ${{ matrix.python-version }}`. The 3rd step is named `Install dependencies`. The 4th step is named `Lint with pre-commit`. "}
{"id": "63c495e58052faa2781b4fae", "level": "level2", "llm_response": "```yaml\nname: Self-assign\n\non:\n  issue_comment:\n    types: [created]\n  pull_request_comment:\n    types: [created]\n\njobs:\n  one:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Self-assign issue or pull request\n        run: |\n          if [[ $GITHUB_EVENT_NAME == \"issue_comment\" ]]; then\n            issue_number=$GITHUB_EVENT_ISSUE_NUMBER\n          elif [[ $GITHUB_EVENT_NAME == \"pull_request_comment\" ]]; then\n            issue_number=$GITHUB_EVENT_PULL_REQUEST_NUMBER\n          fi\n          gh issue edit $issue_number --assignee @github-actions[bot]\n```", "answer": "```yaml # Allow users to automatically tag themselves to issues\n\nname: Self-assign\non:\n  issue_comment:\n    types: created\njobs:\n  one:\n    runs-on: ubuntu-latest\n    if: >-\n      (github.event.comment.body == '#take' ||\n       github.event.comment.body == '#self-assign') &&\n       (!github.event.issue.pull_request)\n    steps:\n      - run: |\n          echo \"Assigning issue ${{ github.event.issue.number }} to ${{ github.event.comment.user.login }}\"\n          curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -d '{\"assignees\": [\"${{ github.event.comment.user.login }}\"]}' https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/assignees\n```", "prompt": "Generate a GitHub Workflow named `Self-assign` for a GitHub repository whose primary programming language is Jupyter Notebook. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `one`. The job `one` has one step. The 1st step is named ``. "}
{"id": "63c496561899db58864d23c2", "level": "level2", "llm_response": "```yaml\nname: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        default: 'false'\n        type: boolean\n\njobs:\n  java:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Java\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Run Molecule\n        run: |\n          if [ \"${{ github.event_name }}\" == \"pull_request\" ]; then\n            molecule test --all\n          else\n            molecule test --all --debug\n          fi\n        env:\n          MOLECULE_DEBUG: ${{ github.event_name == 'pull_request' ? 'false' : 'true' }}\n```", "answer": "```yaml name: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  java:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: java\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Java` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.java.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/java/** or roles/java/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `java`. "}
{"id": "63c4957c8052faa2781b2239", "level": "level2", "llm_response": "```yaml\nname: Add Issues/PRs to TF Provider DevEx team board\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    id: add-content-to-project\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set Issue to 'Priority = Triage Next'\n        run: echo \"Setting issue priority to 'Triage Next'\"\n      - name: Set Pull Request to 'Priority = Triage Next'\n        run: echo \"Setting pull request priority to 'Triage Next'\"\n```", "answer": "```yaml # Based on https://github.com/leonsteinhaeuser/project-beta-automations\n\nname: \"Add Issues/PRs to TF Provider DevEx team board\"\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request_target:\n    # NOTE: The way content is added to project board is equivalent to an \"upsert\".\n    # Calling it multiple times will be idempotent.\n    #\n    # See https://securitylab.github.com/research/github-actions-preventing-pwn-requests/\n    #\u00a0to see the reasoning behind using `pull_request_target` instead of `pull_request`\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    name: \"Add Content to project\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Set Issue to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'issues'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.issue.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n      - name: \"Set Pull Request to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'pull_request_target'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.pull_request.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n```", "prompt": "Generate a GitHub Workflow named `Add Issues/PRs to TF Provider DevEx team board` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) an issue is opened or a closed issue is reopened. 2) a pull request is created, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow has one job. The 1st job is named `Add Content to project` and its job id is `add-content-to-project`. The job `add-content-to-project` has 2 steps. The 1st step is named `Set Issue to 'Priority = Triage Next'`. The 2nd step is named `Set Pull Request to 'Priority = Triage Next'`. "}
{"id": "63c49697b008460c1df15590", "level": "level2", "llm_response": "```yaml\nname: Release\n\non:\n  release:\n    types: [published, prereleased, drafted]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Build the file\n      run: npm run build\n\n    - name: Upload zip to release\n      uses: actions/upload-release-asset@v1\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      with:\n        upload_url: ${{ github.event.release.upload_url }}\n        asset_path: dist.zip\n        asset_name: dist.zip\n        asset_content_type: application/zip\n\n    - name: HACS Action\n      uses: hacs/action@v3\n      with:\n        token: ${{ secrets.GITHUB_TOKEN }}\n        repository: ${{ github.repository }}\n        tag: ${{ github.event.release.tag_name }}\n        files: dist.zip\n```", "answer": "```yaml name: Release\n\non:\n  release:\n    types: [published]\n\njobs:\n  release:\n    name: Prepare release\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n\n      # Build\n      - name: Build the file\n        run: |\n          cd /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card\n          npm install\n          npm run build\n\n      # Upload build file to the releas as an asset.\n      - name: Upload zip to release\n        uses: svenstaro/upload-release-action@v1-release\n\n        with:\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          file: /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card/dist/thermostat-dark-card.js\n          asset_name: thermostat-dark-card.js\n          tag: ${{ github.ref }}\n          overwrite: true\n      - name: HACS Action\n        uses: \"hacs/action@main\"\n        with:\n          category: \"plugin\"\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow has one job. The 1st job is named `Prepare release` and its job id is `release`. The job `release` has 4 steps. The 1st step is named ``. The 2nd step is named `Build the file`. The 3rd step is named `Upload zip to release`. The 4th step is named `HACS Action`. "}
{"id": "63c4955b8052faa2781b1498", "level": "level2", "llm_response": "```yaml\nname: CI v2\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Setup\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n\n    - name: Prerequisites\n      run: |\n        go env -w GOPROXY=https://proxy.golang.org,direct\n        go env -w GO11MODULE=on\n\n    - name: Checkout\n      uses: actions/checkout@v2\n\n    - name: Dependencies\n      run: go mod download\n\n    - name: Lint\n      run: go vet ./...\n\n    - name: Vet\n      run: go vet ./...\n\n    - name: Test\n      run: go test -v ./...\n\n    - name: Coverage\n      run: go test -coverprofile=coverage.out ./...\n      env:\n        COVERALLS_TOKEN: ${{ secrets.COVERALLS_TOKEN }}\n```", "answer": "```yaml name: CI v2\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go: ['1.16']\n    steps:\n    - name: Setup\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Prerequisites\n      run: |\n        sudo apt-get update\n        sudo apt-get -y install libvlc-dev vlc-plugin-base vlc-plugin-video-output vlc-plugin-access-extra\n\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Dependencies\n      working-directory: ./v2\n      run: |\n        go version\n        go get -v -t -d ./...\n        go install golang.org/x/lint/golint@latest\n\n    - name: Lint\n      working-directory: ./v2\n      run: golint -set_exit_status=1 ./...\n\n    - name: Vet\n      working-directory: ./v2\n      run: go vet -unsafeptr=false ./...\n\n    - name: Test\n      working-directory: ./v2\n      run: go test -v -coverprofile=coverage.txt -covermode=atomic ./...\n\n    - name: Coverage\n      uses: codecov/codecov-action@v3\n```", "prompt": "Generate a GitHub Workflow named `CI v2` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 8 steps. The 1st step is named `Setup`. The 2nd step is named `Prerequisites`. The 3rd step is named `Checkout`. The 4th step is named `Dependencies`. The 5th step is named `Lint`. The 6th step is named `Vet`. The 7th step is named `Test`. The 8th step is named `Coverage`. "}
{"id": "63c494b87843b61269a03054", "level": "level2", "llm_response": "```yaml\nname: autoupdate\n\non:\n  push:\n    branches:\n      - '*'\n    except:\n      - version-bump/**\n      - dependabot/**\n      - bot/**\n      - all-contributors/**\n\njobs:\n  autoupdate-for-bot:\n    id: autoupdate-for-bot\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoupdating\n        run: echo \"Autoupdating the repository...\"\n```", "answer": "```yaml # This action is centrally managed in https://github.com/asyncapi/.github/\r\n# Don't make changes to this file in this repo as they will be overwritten with changes made to the same file in above mentioned repo\r\n\r\n# This workflow is designed to work with:\r\n# - autoapprove and automerge workflows for dependabot and asyncapibot.\r\n# - special release branches that we from time to time create in upstream repos. If we open up PRs for them from the very beginning of the release, the release branch will constantly update with new things from the destination branch they are opened against\r\n\r\n# It uses GitHub Action that auto-updates pull requests branches, whenever changes are pushed to their destination branch.\r\n# Autoupdating to latest destination branch works only in the context of upstream repo and not forks\r\n\r\nname: autoupdate\r\n\r\non:\r\n  push:\r\n    branches-ignore:  \r\n      - 'version-bump/**'\r\n      - 'dependabot/**'\r\n      - 'bot/**'\r\n      - 'all-contributors/**'\r\n\r\njobs:\r\n  autoupdate-for-bot:\r\n    if: startsWith(github.repository, 'asyncapi/')\r\n    name: Autoupdate autoapproved PR created in the upstream\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - name: Autoupdating\r\n        uses: docker://chinthakagodawita/autoupdate-action:v1\r\n        env:\r\n          GITHUB_TOKEN: '${{ secrets.GH_TOKEN_BOT_EVE }}'\r\n          PR_FILTER: \"labelled\"\r\n          PR_LABELS: \"autoupdate\"\r\n          PR_READY_STATE: \"ready_for_review\"\r\n          MERGE_CONFLICT_ACTION: \"ignore\"\r\n```", "prompt": "Generate a GitHub Workflow named `autoupdate` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: The workflow would run whenever there is a push event unless the push event is to: a branch whose name matches version-bump/**, a branch whose name matches dependabot/**, a branch whose name matches bot/** or a branch whose name matches all-contributors/**. The workflow has one job. The 1st job is named `Autoupdate autoapproved PR created in the upstream` and its job id is `autoupdate-for-bot`. The job `autoupdate-for-bot` has one step. The 1st step is named `Autoupdating`. "}
{"id": "63c494877843b61269a01c1e", "level": "level2", "llm_response": "```yaml\nname: Prepare Release\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version number'\n        required: true\n        type: string\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Push Tag\n        run: git tag v$VERSION && git push origin v$VERSION\n        env:\n          VERSION: ${{ github.event.inputs.version }}\n```", "answer": "```yaml \nname: Prepare Release\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version Number'\n        required: true\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Push Tag\n      run: | \n            echo \"version is ${{ github.event.inputs.version }}\"\n            git config user.name \"GitHub Actions Bot\"\n            git config user.email \"<>\"\n            sed -i \"/is_master/d\" fxmanifest.lua\n            sed -i \"/^version/c\\version '${{ github.event.inputs.version }}'\" fxmanifest.lua\n            git add .\n            git commit -m \"${{ github.event.inputs.version }}\"\n            git tag -a ${{ github.event.inputs.version }} -m \"Version ${{ github.event.inputs.version }}\"\n            sed -i \"/^version/ais_master 'yes'\" fxmanifest.lua\n            git add .\n            git commit -m \"Update Version\"\n            git push --follow-tags\n```", "prompt": "Generate a GitHub Workflow named `Prepare Release` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: version-this input represents version number and it must be supplied. The workflow has one job. The job id of the 1st job is `create`. The job `create` has 2 steps. The 1st step is named ``. The 2nd step is named `Push Tag`. "}
{"id": "63c4966d33b087f6bde2bebf", "level": "level2", "llm_response": "```yaml\nname: CodeQL\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    id: analyse\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n\n      - name: Autobuild\n        run: go build -v ./...\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml name: \"CodeQL\"\n\non:\n  workflow_dispatch:\n  push:\n    branches: [main]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [main]\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    name: Analyse\n    runs-on: ubuntu-20.04\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n      with:\n        # We must fetch at least the immediate parents so that if this is\n        # a pull request then we can checkout the head.\n        fetch-depth: 2\n\n    # If this run was triggered by a pull request event, then checkout\n    # the head of the pull request instead of the merge commit.\n    - run: git checkout HEAD^2\n      if: ${{ github.event_name == 'pull_request' }}\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      # Override language selection by uncommenting this and choosing your languages\n      with:\n        languages: go\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) The workflow would run whenever there is a pull_request event targeting: a branch named main. 4) the scheduled time has come: at 05:00 am, only on sunday. The workflow has one job. The 1st job is named `Analyse` and its job id is `analyse`. The job `analyse` has 5 steps. The 1st step is named `Checkout repository`. The 2nd step is named ``. The 3rd step is named `Initialize CodeQL`. The 4th step is named `Autobuild`. The 5th step is named `Perform CodeQL Analysis`. "}
{"id": "63c496581e3364807577a144", "level": "level2", "llm_response": "```yaml\nname: Remove ALL artifacts\n\non:\n  workflow_dispatch:\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Remove ALL artifacts\n      run: |\n        rm -rf ./artifacts\n```", "answer": "```yaml name: Remove ALL artifacts\n\non:\n  workflow_dispatch: # only manually\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - name: Remove ALL artifacts\n        uses: c-hive/gha-remove-artifacts@v1\n        with:\n          age: '0 days'\n          skip-tags: true\n          skip-recent: 0\n```", "prompt": "Generate a GitHub Workflow named `Remove ALL artifacts` for a GitHub repository whose primary programming language is C. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `remove-all-artifacts`. The job `remove-all-artifacts` has one step. The 1st step is named `Remove ALL artifacts`. "}
{"id": "63c494e18052faa2781adf45", "level": "level2", "llm_response": "```yaml\nname: Deploy to GH Pages\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - docs/**\n      - !.github/workflows/deploy-storybook.yml\n      - .storybook/**\n      - .wordpress-org/**\n      - __mocks__/**\n      - __static__/**\n      - bin/**\n      - tests/**\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    id: build-storybook\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build storybook\n        run: npm run build-storybook -- -s build\n\n      - name: Upload storybook\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./storybook-static\n\n  deploy-gh-pages:\n    id: deploy-gh-pages\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Harden Runner\n        run: chmod +x .github/scripts/harden-runner.sh && .github/scripts/harden-runner.sh\n\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Download storybook files\n        uses: actions/download-artifact@v2\n        with:\n          name: storybook-static\n\n      - name: Move storybook assets\n        run: mv storybook-static/. public/\n\n      - name: Commit updates\n        run: |\n          git config --global user.name 'GitHub Actions'\n          git config --global user.email 'github-actions@github.com'\n          git add public\n          git commit -m \"Deploy storybook to GitHub Pages\"\n          git push origin main\n```", "answer": "```yaml name: Deploy to GH Pages\n\non:\n  push:\n    # Don't run for irrelevant changes.\n    paths-ignore:\n      - 'docs/**'\n      - '!.github/workflows/deploy-storybook.yml'\n      - '.storybook/**'\n      - '.wordpress-org/**'\n      - '__mocks__/**'\n      - '__static__/**'\n      - 'bin/**'\n      - 'tests/**'\n    branches:\n      - main\n\npermissions:\n  contents: read\n\n# Cancels all previous workflow runs for pull requests that have not completed.\nconcurrency:\n  # The concurrency group contains the workflow name and the (target) branch name.\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    name: Build storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Setup Node\n        uses: actions/setup-node@8c91899e586c5b171469028077307d293428b516\n        with:\n          node-version-file: '.nvmrc'\n          cache: npm\n\n      - name: Install dependencies\n        run: npm ci\n        env:\n          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true\n\n      - name: Build storyook\n        run: npm run storybook:build\n\n      - name: Upload storybook\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: storybook-files\n          path: build/storybook\n\n  deploy-gh-pages:\n    name: Deploy storybook\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write # for Git to git push\n    timeout-minutes: 10\n    needs: [build-storybook]\n    steps:\n      - name: Harden Runner\n        uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n        with:\n          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs\n\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n        with:\n          ref: gh-pages\n          token: ${{ secrets.GOOGLEFORCREATORS_BOT_TOKEN }}\n\n      - name: Download storybook files\n        uses: actions/download-artifact@fb598a63ae348fa914e94cd0ff38f362e927b741\n        with:\n          name: storybook-files\n          path: storybook-files\n\n      - name: Move storybook assets\n        run: |\n          mkdir -p storybook\n          rm -rf storybook/*\n          mv storybook-files/* storybook/\n\n      - name: Commit updates\n        run: |\n          git add .\n          git status\n          git diff --staged --quiet && echo 'No changes to commit; exiting!' && exit 0\n          git commit -m \"Deploy storybook for ${{ github.sha }}\"\n          git pull --rebase --no-edit --quiet\n          git push origin gh-pages\n        env:\n          GIT_AUTHOR_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_AUTHOR_NAME: googleforcreators-bot\n          GIT_COMMITTER_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_COMMITTER_NAME: googleforcreators-bot\n```", "prompt": "Generate a GitHub Workflow named `Deploy to GH Pages` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**, !.github/workflows/deploy-storybook.yml, .storybook/**, .wordpress-org/**, __mocks__/**, __static__/**, bin/** or tests/**), the workflow will not run. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.head_ref || github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `Build storybook` and its job id is `build-storybook`. The job `build-storybook` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Setup Node`. The 3rd step is named `Install dependencies`. The 4th step is named `Build storyook`. The 5th step is named `Upload storybook`. The 2nd job is named `Deploy storybook` and its job id is `deploy-gh-pages`. The job `deploy-gh-pages` has 5 steps. The 1st step is named `Harden Runner`. The 2nd step is named `Checkout`. The 3rd step is named `Download storybook files`. The 4th step is named `Move storybook assets`. The 5th step is named `Commit updates`. "}
{"id": "63c496571899db58864d2453", "level": "level2", "llm_response": "```yaml\nname: Lint Checks\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  contents: read\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install flake8\n      - name: Run lint checks\n        run: flake8 .\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Rustfmt check\n        run: cargo fmt -- --check\n      - name: Cargo update check\n        run: cargo update --dry-run\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Check Cargo.lock\n        run: cargo check --locked\n      - name: Cargo update check\n        run: cargo update --dry-run\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Generate Cargo documentation\n        run: cargo doc --no-deps\n      - name: Cargo doc check\n        run: cargo doc --no-deps --open\n```", "answer": "```yaml # Syntax reference:\n# https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions\n\nname: Lint Checks\npermissions: read-all\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    types: [opened, synchronize]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          persist-credentials: false\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n      - run: pip install flake8\n      - run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude src/external\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Rustfmt check\n        run: (cd src && cargo fmt -- --check)\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Cargo update check\n        run: |\n          # This will return an error if any versions of local crates in the Cargo.lock\n          # are out of date compared to the crate versions in Cargo.toml. This can fail\n          # if the Shadow version is bumped without using Cargo to update the lock file.\n          (cd src && cargo update --locked --workspace)\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Cargo doc check\n        run: |\n          cmake -S . -B build\n          (cd src && RUSTDOCFLAGS='-D warnings' cargo doc)\n```", "prompt": "Generate a GitHub Workflow named `Lint Checks` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `CARGO_TERM_COLOR` is set to `always`. The workflow has 4 jobs. The job id of the 1st job is `lint-python`. The job `lint-python` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The job id of the 2nd job is `lint-rust`. The job `lint-rust` has 2 steps. The 1st step is named ``. The 2nd step is named `Rustfmt check`. The job id of the 3rd job is `lint-cargo-lock`. The job `lint-cargo-lock` has 2 steps. The 1st step is named ``. The 2nd step is named `Cargo update check`. The job id of the 4th job is `lint-cargo-doc`. The job `lint-cargo-doc` has 2 steps. The 1st step is named ``. The 2nd step is named `Cargo doc check`. "}
{"id": "63c4956e7843b61269a0794c", "level": "level2", "llm_response": "```yaml\nname: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\njobs:\n  black:\n    id: black\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Black\n        run: black .\n\n  flake8:\n    id: flake8\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: pip install flake8\n      - name: Lint examples\n        run: flake8 examples/\n      - name: Lint scripts\n        run: flake8 scripts/\n      - name: Lint tests\n        run: flake8 tests/\n      - name: Lint moviepy\n        run: flake8 moviepy/\n\n  isort:\n    id: isort\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: pip install isort\n      - name: Check imports\n        run: isort --check .\n```", "answer": "```yaml name: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\n\njobs:\n  black:\n    runs-on: ubuntu-latest\n    name: Black\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n      - name: Black\n        uses: psf/black@22.3.0  # already includes args \"--check --diff\"\n  flake8:\n    runs-on: ubuntu-latest\n    name: Flake8\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade wheel pip\n          pip install .[lint]\n      - name: Lint examples\n        run: flake8 examples --show-source\n      - name: Lint scripts\n        run: flake8 setup.py docs/conf.py scripts --show-source\n      - name: Lint tests\n        run: flake8 tests --show-source\n      - name: Lint moviepy\n        run: flake8 moviepy --show-source\n  isort:\n    runs-on: ubuntu-latest\n    name: isort\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Check imports\n        run: isort --check-only moviepy tests examples docs/conf.py scripts\n```", "prompt": "Generate a GitHub Workflow named `Code Format Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. The workflow has 3 jobs. The 1st job is named `Black` and its job id is `black`. The job `black` has 3 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Black`. The 2nd job is named `Flake8` and its job id is `flake8`. The job `flake8` has 7 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Install dependencies`. The 4th step is named `Lint examples`. The 5th step is named `Lint scripts`. The 6th step is named `Lint tests`. The 7th step is named `Lint moviepy`. The 3rd job is named `isort` and its job id is `isort`. The job `isort` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Install dependencies`. The 4th step is named `Check imports`. "}
{"id": "63c493ea8052faa2781a7e17", "level": "level2", "llm_response": "```yaml\nname: master\n\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  test:\n    id: test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: |\n          # Add step 1 commands here\n      - name: Step 2\n        run: |\n          # Add step 2 commands here\n      - name: Step 3\n        run: |\n          # Add step 3 commands here\n      - name: Step 4\n        run: |\n          # Add step 4 commands here\n```", "answer": "```yaml name: master\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0' # 00:00 Sunday\n\njobs:\n\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust: [1.31.0, stable]\n    steps:\n      - uses: actions/checkout@v3\n      - uses: dtolnay/rust-toolchain@master\n        with:\n          toolchain: ${{ matrix.rust }}\n      - run: cargo build\n      - run: ./ci/test_full.sh\n```", "prompt": "Generate a GitHub Workflow named `master` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The 1st job is named `Test` and its job id is `test`. The job `test` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c495668052faa2781b18dd", "level": "level2", "llm_response": "```yaml\nname: release management\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: release management\non:\n  push:\n    branches: [master]\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: toolmantim/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `release management` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `update-draft-release`. The job `update-draft-release` has one step. The 1st step is named ``. "}
{"id": "63c494608052faa2781aac1c", "level": "level2", "llm_response": "```yaml\nname: ASF-ci\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: True\n  DOTNET_NOLOGO: True\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        configuration: [Debug, Release]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --version\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build -c ${{ matrix.configuration }}\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test -c ${{ matrix.configuration }}\n\n    - name: Upload latest strings for translation on Crowdin\n      run: echo \"Uploading strings for translation\"\n```", "answer": "```yaml name: ASF-ci\n\non: [push, pull_request]\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: true\n  DOTNET_NOLOGO: true\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    strategy:\n      fail-fast: false\n      matrix:\n        configuration: [Debug, Release]\n        os: [macos-latest, ubuntu-latest, windows-latest]\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n      with:\n        submodules: recursive\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v3.0.2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --info\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test ArchiSteamFarm.Tests -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Upload latest strings for translation on Crowdin\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && matrix.configuration == 'Release' && startsWith(matrix.os, 'ubuntu-') }}\n      uses: crowdin/github-action@1.4.16\n      with:\n        crowdin_branch_name: main\n        config: '.github/crowdin.yml'\n        project_id: ${{ secrets.ASF_CROWDIN_PROJECT_ID }}\n        token: ${{ secrets.ASF_CROWDIN_API_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `ASF-ci` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow sets 3 environment variables to use: `DOTNET_CLI_TELEMETRY_OPTOUT` is set to `True`, `DOTNET_NOLOGO` is set to `True` and `DOTNET_SDK_VERSION` is set to `6.0.x`. The workflow has one job. The job id of the 1st job is `main`. The job `main` has 6 steps. The 1st step is named `Checkout code`. The 2nd step is named `Setup .NET Core`. The 3rd step is named `Verify .NET Core`. The 4th step is named `Build ${{ matrix.configuration }} ArchiSteamFarm and other projects`. The 5th step is named `Run ${{ matrix.configuration }} ArchiSteamFarm.Tests`. The 6th step is named `Upload latest strings for translation on Crowdin`. "}
{"id": "63c495da7843b61269a0a66e", "level": "level2", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    strategy:\n      matrix:\n        go:\n          - 1.19\n        os:\n          - ubuntu-20.04\n          - ubuntu-22.04\n          - macos-11\n          - macos-12\n          - windows-2019\n          - windows-2022\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: ${{ matrix.go }}\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `main`. The job `main` has 4 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Go`. The 3rd step is named `Build`. The 4th step is named `Test`. "}
{"id": "63c494247843b612699ff48a", "level": "level2", "llm_response": "```yaml\nname: Rust\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  clone:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Rust\n      uses: actions-rs/toolchain@v1\n      with:\n        toolchain: stable\n        profile: minimal\n        override: true\n\n    - name: Check Cargo availability\n      run: cargo --version\n\n    - name: Check Rustup default toolchain\n      run: rustup default\n\n    - name: Build without default features\n      run: cargo build --no-default-features\n\n    - name: Build with default features\n      run: cargo build\n```", "answer": "```yaml name: Rust\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@master\n      - uses: hecrj/setup-rust-action@master\n        with:\n          rust-version: stable\n      - name: Check Cargo availability\n        run: cargo --version\n      - name: Check Rustup default toolchain\n        run: rustup default | grep stable\n      - name: Build without default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check --no-default-features\n      - name: Build with default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check\n```", "prompt": "Generate a GitHub Workflow named `Rust` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Check Cargo availability`. The 4th step is named `Check Rustup default toolchain`. The 5th step is named `Build without default features`. The 6th step is named `Build with default features`. "}
{"id": "63c494fd7843b61269a04a9b", "level": "level2", "llm_response": "```yaml\nname: Automatic Releases\n\non:\n  milestone:\n    types: [closed]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up PHP\n      uses: shivammathur/setup-php@v2\n      with:\n        php-version: '7.4'\n\n    - name: Create Git tag\n      run: git tag -a v$(git describe --tags --abbrev=0) -m \"Release v$(git describe --tags --abbrev=0)\"\n\n    - name: Create release\n      uses: actions/create-release@v1\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      with:\n        tag_name: v$(git describe --tags --abbrev=0)\n        release_name: Release v$(git describe --tags --abbrev=0)\n        draft: false\n        prerelease: false\n\n    - name: Create merge-up PR\n      uses: peter-evans/create-pull-request@v3\n      with:\n        token: ${{ secrets.GITHUB_TOKEN }}\n        commit-message: \"chore: bump version to v$(git describe --tags --abbrev=0)\"\n        branch: \"release/v$(git describe --tags --abbrev=0)\"\n        title: \"Release v$(git describe --tags --abbrev=0)\"\n        body: \"Automatically created merge-up PR for release v$(git describe --tags --abbrev=0)\"\n        labels: \"release\"\n```", "answer": "```yaml name: \"Automatic Releases\"\n\non:\n  milestone:\n    types:\n      - \"closed\"\n\njobs:\n  release:\n    name: \"Git tag, release & create merge-up PR\"\n    uses: \"doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0\"\n    secrets:\n      GIT_AUTHOR_EMAIL: ${{ secrets.GIT_AUTHOR_EMAIL }}\n      GIT_AUTHOR_NAME: ${{ secrets.GIT_AUTHOR_NAME }}\n      ORGANIZATION_ADMIN_TOKEN: ${{ secrets.ORGANIZATION_ADMIN_TOKEN }}\n      SIGNING_SECRET_KEY: ${{ secrets.SIGNING_SECRET_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Automatic Releases` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: a milestone is closed. The workflow has one job. The 1st job is named `Git tag, release & create merge-up PR` and its job id is `release`. "}
{"id": "63c4957d8052faa2781b22ad", "level": "level2", "llm_response": "```yaml\nname: nix-build\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main, 'release-v**' ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Rust\n      uses: actions-rs/toolchain@v1\n      with:\n        toolchain: stable\n        profile: minimal\n        override: true\n\n    - name: Build project\n      run: cargo build --release\n\n    - name: Build centrifuge-chain\n      run: cargo build --release --package centrifuge-chain\n```", "answer": "```yaml name: nix-build\non:\n  pull_request:\n  push:\n    branches: [main, 'release-v**']\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Nix Flakes doesn't work on shallow clones\n          fetch-depth: 0\n      - uses: cachix/install-nix-action@v17\n        with:\n          install_url: https://releases.nixos.org/nix/nix-2.10.3/install\n      - uses: cachix/cachix-action@v10\n        with:\n          name: centrifuge-chain\n          authToken: \"${{ secrets.CACHIX_AUTH_TOKEN }}\"\n      - name: Build centrifuge-chain\n        run: nix build --no-allow-dirty -L```", "prompt": "Generate a GitHub Workflow named `nix-build` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches release-v**. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Build centrifuge-chain`. "}
{"id": "63c4968a6fc19abdf9c9ca16", "level": "level2", "llm_response": "```yaml\nname: conda builds\n\non:\n  pull_request:\n    paths:\n      - conda-environment.yml\n      - .github/workflows/test_conda-build.yml\n  schedule:\n    - cron: '17 22 * * 6'\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: checkout cylc-flow\n        uses: actions/checkout@v2\n\n      - name: build conda env\n        run: conda env create -f conda-environment.yml\n\n      - name: check for activate scripts\n        run: |\n          if [ -f \"conda-env.sh\" ]; then\n            echo \"Activate script found\"\n          else\n            echo \"Activate script not found\"\n          fi\n```", "answer": "```yaml name: conda builds\n\non:\n  pull_request:\n    paths:\n      - 'conda-environment.yml'\n      - '.github/workflows/test_conda-build.yml'\n  schedule:\n    - cron: '17 22 * * 6'  # Every Saturday at 22:17\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: checkout cylc-flow\n        uses: actions/checkout@v3\n\n      - name: build conda env\n        run: |\n          # write environment file\n          env_file='conda-environment.yml'\n          echo \"  - pip\"  >> \"$env_file\"  # list pip as a dependency\n          echo \"  - pip:\" >> \"$env_file\"  # add a pip section\n          echo \"    - .\"  >> \"$env_file\"  # install cylc-flow (pip install .)\n          cat \"$env_file\"\n          # install environment\n          conda env create \\\n            -f \"$env_file\" \\\n            --prefix cylc-dev\n          . /usr/share/miniconda/etc/profile.d/conda.sh\n          # check cylc-flow was installed correctly\n          conda run --prefix cylc-dev cylc version --long\n\n      - name: check for activate scripts\n        run: |\n          # https://github.com/cylc/cylc-flow/issues/3704#issuecomment-897442365\n          # locate all activate scripts\n          find ./cylc-dev/ -name \"activate.d\" | tee > activates.txt\n          # ignore the conda activate script itself\n          sed -i '/cylc-dev\\/etc\\/conda\\/activate.d/d' activates.txt\n          # check to make sure no packages have contributed new activate scripts\n          # (we rely on having a conda activate-less environment)\n          if [[ $(cat activates.txt | wc -l) -ne 0 ]]; then\n              echo '::error::Found activate scripts in installation.'\n              cat activates.txt >&2\n              exit 1\n          fi\n```", "prompt": "Generate a GitHub Workflow named `conda builds` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(conda-environment.yml or .github/workflows/test_conda-build.yml), the workflow runs. 2) the scheduled time has come: at 10:17 pm, only on saturday. 3) someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `test_conda_install`. The job `test_conda_install` has 3 steps. The 1st step is named `checkout cylc-flow`. The 2nd step is named `build conda env`. The 3rd step is named `check for activate scripts`. "}
{"id": "63c496411e3364807577968e", "level": "level2", "llm_response": "```yaml\nname: Add to project\n\non:\n  issues:\n    types: [opened, transferred]\n\njobs:\n  add-to-project:\n    id: add-to-project\n    runs-on: ubuntu-latest\n    steps:\n    - name: Add issue to project\n      id: add_project\n      run: |\n        # Add your code here to add the issue to the project\n    - name: Set Team\n      run: |\n        # Add your code here to set the team for the issue\n```", "answer": "```yaml name: Add to project\n\non:\n  issues:\n    types: [opened,transferred]\n\njobs:\n  add-to-project:\n    name: Add issue to project\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/add-to-project@main\n        id: add_project\n        with:\n          project-url: ${{ secrets.PROJECT_PLANNING }}\n          github-token: ${{ secrets.BOT_TOKEN_PROJECT }}\n      - name: Set Team\n        env:\n          GITHUB_TOKEN: ${{ secrets.BOT_TOKEN_PROJECT }}\n        run: |\n          gh api graphql -f query='\n          mutation(\n              $project: ID!\n              $item: ID!\n              $status_field: ID!\n              $status_value: String!\n            )  {\n            updateProjectV2ItemFieldValue(\n              input: {\n               projectId: $project\n                itemId: $item\n                fieldId: $status_field\n                value: { \n                  singleSelectOptionId: $status_value\n                  }\n              }\n            ) {\n              projectV2Item {\n                id\n              }\n            }\n          }' -f project=${{ secrets.PROJECT_PLANNING_ID }} -f item=${{ steps.add_project.outputs.itemId }} -f status_field=${{ secrets.PLANNING_TEAM_FIELD_ID }} -f status_value=ed46988b --silent```", "prompt": "Generate a GitHub Workflow named `Add to project` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: an issue is opened or an issue is transferred to another repository. The workflow has one job. The 1st job is named `Add issue to project` and its job id is `add-to-project`. The job `add-to-project` has 2 steps. The 1st step is named `` and its id is `add_project`. The 2nd step is named `Set Team`. "}
{"id": "63c494c17843b61269a0331c", "level": "level2", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    branches: [ dev ]\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n\n    - name: Autobuild\n      run: npm install && npm run build\n\n    - name: Run CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"dev\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"dev\" ]\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n    - run: ./mvnw -q -Dmaven.test.skip=true -Dscala.version=2.12.8 -Dscala.binary.version=2.12 clean install || ./mvnw -q -Dmaven.test.skip=true clean install\n  \n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Vue. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 04:20 pm, only on friday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 5 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named ``. The 5th step is named `Perform CodeQL Analysis`. "}
{"id": "63c496861e3364807577b319", "level": "level2", "llm_response": "```yaml\nname: documentation\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  skip_duplicate_jobs:\n    id: skip_duplicate_jobs\n    runs-on: ubuntu-latest\n    steps:\n      - id: skip_check\n        run: echo \"Skipping duplicate jobs\"\n\n  deploy:\n    id: deploy\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Starting deployment process\"\n      - name: Create output directories\n        run: mkdir -p output/html output/adoc\n      - name: Copy index.html\n        run: cp index.html output/html/\n      - name: Generate reference\n        id: adocbuild\n        run: cargo doc --document-private-items --output-dir output/adoc\n      - name: Deploy \ud83d\ude80\n        run: echo \"Deploying to production\"\n```", "answer": "```yaml # adapted from:\n#\n# * base code: https://peterevans.dev/posts/github-actions-how-to-automate-code-formatting-in-pull-requests/\n# * fix push auth: https://github.com/ad-m/github-push-action\n# * checkout PR head commit https://github.com/actions/checkout#checkout-pull-request-head-commit-instead-of-merge-commit\nname: documentation\non:\n  push:\n    branches:\n      - master\njobs:\n  skip_duplicate_jobs:\n    runs-on: ubuntu-latest\n    outputs:\n      should_skip: ${{ steps.skip_check.outputs.should_skip }}\n    steps:\n      - id: skip_check\n        uses: fkirc/skip-duplicate-actions@master\n        with:\n          concurrent_skipping: 'same_content'\n          skip_after_successful_duplicate: 'true'\n          paths: '[\"doc/**\"]'\n  deploy:\n    needs: skip_duplicate_jobs\n    if: ${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2.3.1\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Create output directories\n        run: mkdir -p output/reference\n\n      - name: Copy index.html\n        run: cp website/index.html output/index.html\n\n      - name: Generate reference\n        id: adocbuild\n        uses: tonynv/asciidoctor-action@master\n        with:\n            program: asciidoctor doc/index.adoc -o output/reference/index.html\n\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.1.7\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: output # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `documentation` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has 2 jobs. The job id of the 1st job is `skip_duplicate_jobs`. The job `skip_duplicate_jobs` has one step. The 1st step is named `` and its id is `skip_check`. The job id of the 2nd job is `deploy`. The job `deploy` has 5 steps. The 1st step is named ``. The 2nd step is named `Create output directories`. The 3rd step is named `Copy index.html`. The 4th step is named `Generate reference` and its id is `adocbuild`. The 5th step is named `Deploy \ud83d\ude80`. "}
{"id": "63c496496fc19abdf9c9b198", "level": "level2", "llm_response": "```yaml\nname: Run checks\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  go-checks:\n    id: go-checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Test Go Modules Vendor\n        run: go mod vendor\n      - name: Test Go Modules\n        run: go mod tidy\n      - name: Test Go Standard\n        run: go test ./...\n\n  action-checks:\n    id: action-checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install dockerfile_lint\n        run: go install github.com/hadolint/hadolint@latest\n      - name: Lint\n        run: dockerfile_lint .\n      - name: Test\n        run: make test\n      - name: Docker Build\n        run: docker build -t my-image .\n      - name: Check all versions\n        run: ./check-versions.sh\n```", "answer": "```yaml on: pull_request\nname: Run checks\njobs:\n  go-checks:\n    name: Run go checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Test Go Modules Vendor\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules_vendored\n    - name: Test Go Modules\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules\n    - name: Test Go Standard\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_standard\n  action-checks:\n    permissions:\n      contents: read\n    name: Run action checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Install dockerfile_lint\n      run: sudo npm i -g dockerfile_lint\n    - name: Lint\n      run: make lint\n    - name: Test\n      run: make test\n    - name: Docker Build\n      run: make build\n    - name: Check all versions\n      run: make docker-check\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Run go checks` and its job id is `go-checks`. The job `go-checks` has 4 steps. The 1st step is named ``. The 2nd step is named `Test Go Modules Vendor`. The 3rd step is named `Test Go Modules`. The 4th step is named `Test Go Standard`. The 2nd job is named `Run action checks` and its job id is `action-checks`. The job `action-checks` has 6 steps. The 1st step is named ``. The 2nd step is named `Install dockerfile_lint`. The 3rd step is named `Lint`. The 4th step is named `Test`. The 5th step is named `Docker Build`. The 6th step is named `Check all versions`. "}
{"id": "63c4964f6fc19abdf9c9b3d1", "level": "level2", "llm_response": "```yaml\nname: Package\n\non:\n  push:\n    branches: [ main ]\n    tags: [ '*' ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Setup Python Environment\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Build LabelImg\n        run: make build\n      - name: Package LabelImg\n        run: make package\n      - name: Archive macOS app\n        uses: actions/upload-artifact@v2\n        with:\n          name: labelimg-macos\n          path: labelimg.app\n\n  package-windows:\n    runs-on: windows-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Setup Python Environment\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Build LabelImg\n        run: make build\n      - name: Package LabelImg\n        run: make package\n\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Setup Python Environment\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Build LabelImg\n        run: make build\n      - name: Package LabelImg\n        run: make package\n```", "answer": "```yaml name: Package\non: [push, pull_request]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    env:\n      PIPENV_VENV_IN_PROJECT: 1\n      PIPENV_IGNORE_VIRTUALENVS: 1\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pipenv\n          pipenv install pyqt5 lxml\n          pipenv run pip install pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pipenv run make qt5py3\n          rm -rf build dist\n      - name: Package LabelImg\n        run: |\n          pipenv run python setup.py py2app\n          open dist/labelImg.app\n      - name: Archive macOS app\n        run: |\n          cd dist/\n          tar czf labelImg.tgz labelImg.app\n      - uses: actions/upload-artifact@v3\n        with:\n          name: macOS artifact\n          path: dist/labelImg.tgz\n  package-windows:\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Windows artifact\n          path: dist/labelImg.exe\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Linux artifact\n          path: dist/labelImg\n```", "prompt": "Generate a GitHub Workflow named `Package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has 3 jobs. The job id of the 1st job is `package-macos`. The job `package-macos` has 6 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named `Archive macOS app`. The 6th step is named ``. The job id of the 2nd job is `package-windows`. The job `package-windows` has 5 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named ``. The job id of the 3rd job is `package-linux`. The job `package-linux` has 5 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named ``. "}
{"id": "63c495c68052faa2781b4230", "level": "level2", "llm_response": "```yaml\nname: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n\njobs:\n  issueHandler:\n    id: issueHandler\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Issue Handler\n      run: |\n        # Add your PowerShell script here to handle the issue\n```", "answer": "```yaml name: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n\njobs:\n  issueHandler:\n    runs-on: windows-latest\n    name: Issue Handler\n    steps:\n      - uses: actions/checkout@v3\n      - name: Issue Handler\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: github.event.action == 'opened' || (github.event.action == 'labeled' && contains(github.event.issue.labels.*.name, 'verify'))\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Issues` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: an issue is opened or a label is added to an issue. The workflow has one job. The 1st job is named `Issue Handler` and its job id is `issueHandler`. The job `issueHandler` has 2 steps. The 1st step is named ``. The 2nd step is named `Issue Handler`. "}
{"id": "63c494c78052faa2781ad471", "level": "level2", "llm_response": "```yaml\nname: cla\n\non:\n  issue_comment:\n    types: [created]\n  pull_request:\n    types: [opened, closed, edited]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Get Team Members\n        id: team\n        run: echo \"Get team members\"\n\n      - name: CLA Assistant\n        run: echo \"Run CLA Assistant\"\n```", "answer": "```yaml name: \"cla\"\non:\n  issue_comment:\n    types: [created]\n  pull_request_target:\n    types: [opened, closed, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Get Team Members\"\n        id: team\n        # github-script, v6.1.0\n        uses: actions/github-script@7a5c598405937d486b0331594b5da2b14db670da\n        with:\n          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n          result-encoding: string\n          script: |\n            const members = await github.paginate(\n              github.rest.orgs.listMembers,\n              { org: \"skalenetwork\" },\n            );\n            return members.map(m => m.login).join(\",\");\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        # Beta Release, v2.1.3-beta\n        uses: cla-assistant/github-action@ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          PERSONAL_ACCESS_TOKEN : ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: 'signatures/version1/cla.json'\n          path-to-document: 'https://skale.network/cla.txt'\n          remote-organization-name: 'skalenetwork'\n          remote-repository-name: cla-sigs\n          allowlist: '${{ steps.team.outputs.result }},*[bot]'\n```", "prompt": "Generate a GitHub Workflow named `cla` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `cla`. The job `cla` has 2 steps. The 1st step is named `Get Team Members` and its id is `team`. The 2nd step is named `CLA Assistant`. "}
{"id": "63c495f07843b61269a0af74", "level": "level2", "llm_response": "```yaml\nname: Acquire activation file\n\non:\n  workflow_dispatch:\n\njobs:\n  activation:\n    runs-on: ubuntu-latest\n    id: activation\n\n    steps:\n    - name: Request manual activation file\n      id: getManualLicenseFile\n      run: echo \"Requesting manual activation file...\"\n\n    - name: Expose as artifact\n      uses: actions/upload-artifact@v2\n      with:\n        name: manual-activation-file\n        path: manual-activation-file.txt\n```", "answer": "```yaml \ufeffname: Acquire activation file\non:\n  workflow_dispatch: {}\njobs:\n  activation:\n    name: Request manual activation file\n    runs-on: ubuntu-latest\n    steps:\n      - name: Request manual activation file\n        id: getManualLicenseFile\n        uses: game-ci/unity-request-activation-file@v2\n      - name: Expose as artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: ${{ steps.getManualLicenseFile.outputs.filePath }}\n          path: ${{ steps.getManualLicenseFile.outputs.filePath }}\n```", "prompt": "Generate a GitHub Workflow named `Acquire activation file` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Request manual activation file` and its job id is `activation`. The job `activation` has 2 steps. The 1st step is named `Request manual activation file` and its id is `getManualLicenseFile`. The 2nd step is named `Expose as artifact`. "}
{"id": "63c4967d33b087f6bde2c593", "level": "level2", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n    paths-ignore:\n      - assets/**\n      - .vscode/**\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v2\n      - name: Install\n        run: npm install\n      - name: Check\n        run: npm run check\n      - name: Lint\n        run: npm run lint\n      - name: Test\n        run: npm run test\n\n  deploy-site:\n    id: deploy-site\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v2\n      - name: Install\n        run: npm install\n      - name: Build Site\n        run: npm run build\n      - name: Deploy Website\n        run: npm run deploy\n```", "answer": "```yaml name: Release\n\non:\n  push:\n    paths-ignore:\n      - 'assets/**'\n      - '.vscode/**'\n    branches:\n      - master\n\njobs:\n  check:\n    name: Run checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Check\n        run: yarn check\n\n      - name: Lint\n        run: yarn lint\n\n      - name: Test\n        run: yarn test\n\n  deploy-site:\n    name: Deploy site\n    runs-on: ubuntu-latest\n    environment: github-pages\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Build Site\n        shell: bash\n        run: |\n          yarn --cwd apps/site ci:build\n\n      - name: Deploy Website\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./apps/site/out\n          cname: tamagui.dev\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. When all the path names of push event match patterns in the paths-ignore filter(assets/** or .vscode/**), the workflow will not run. The workflow has 2 jobs. The 1st job is named `Run checks` and its job id is `check`. The job `check` has 5 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install`. The 3rd step is named `Check`. The 4th step is named `Lint`. The 5th step is named `Test`. The 2nd job is named `Deploy site` and its job id is `deploy-site`. The job `deploy-site` has 4 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install`. The 3rd step is named `Build Site`. The 4th step is named `Deploy Website`. "}
{"id": "63c495418052faa2781b099b", "level": "level2", "llm_response": "```yaml\nname: 60 Days Stale Check\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check for stale issues and pull requests\n        run: |\n          gh issue list --state open --days 60 --json number,title,state | jq '.[] | {number: .number, title: .title, state: .state}'\n```", "answer": "```yaml name: 60 Days Stale Check\non:\n  schedule:\n    - cron: '00 00 * * *' # Run each day at 00:00 UTC\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/stale@v3.0.14\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          stale-issue-message: 'This issue is stale because it has been open 60 days with no activity.'\n          stale-pr-message: 'This PR is stale because it has been open 60 days with no activity.'\n          days-before-stale: -1 # 60 days before marking anything stale - Turned off\n          days-before-close: -1 # Do not close anything automatically\n          stale-issue-label: 'stale'\n          stale-pr-label: 'stale'\n          exempt-pr-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n          exempt-issue-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n```", "prompt": "Generate a GitHub Workflow named `60 Days Stale Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `stale`. The job `stale` has one step. The 1st step is named ``. "}
{"id": "63c496731e3364807577abab", "level": "level2", "llm_response": "```yaml\nname: Automatically crawl CVEs\n\non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n  schedule:\n    - cron: '15 * * * *'\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Check out repo\n      uses: actions/checkout@v2\n\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n\n    - name: Configure pip caching\n      run: |\n        echo \"::add-path::~/.cache/pip\"\n\n    - name: Install Python dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n\n    - name: Crawl CVEs\n      run: |\n        python crawl_cves.py\n\n    - name: Commit and push Github page (if changed)\n      run: |\n        git add .\n        git commit -m \"Update CVE data\"\n        git push origin master\n```", "answer": "```yaml name: Automatically crawl CVEs \non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n    branches:\n      - master\n  schedule:\n    - cron: '15 * * * *'\n\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Check out repo\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.8\n      - uses: actions/cache@v2\n        name: Configure pip caching\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install Python dependencies\n        run: |\n          python -m pip install -r requirements.txt\n\n      - name: Crawl CVEs\n        run: |-\n          python main.py -g \"${{ secrets.CRAWL_PWD }}\" --gtk ${{ secrets.GRAPAQL_TOKEN }}\n\n      # \u82e5\u8be5\u65f6\u95f4\u6bb5\u6ca1\u6709 CVE\uff0c \u5219 file://cache/mail.dat \u6587\u4ef6\u4e0d\u4f1a\u751f\u6210\uff0c\u6b64\u65f6\u4e0d\u4f1a\u53d1\u9001\u90ae\u4ef6\n      # - name: Send mail\n      #   if: ${{ secrets.CRAWL_PWD != '' && github.event_name != 'pull_request' }}\n      #   uses: lyy289065406/action-send-mail@master\n      #   with:\n      #     server_address: ${{ secrets.MAIL_SMTP }}\n      #     server_port: 465\n      #     username: ${{ secrets.MAIL_USER }}\n      #     password: ${{ secrets.MAIL_PASS }}\n      #     from: ${{ secrets.MAIL_USER }}\n      #     to: file://cache/mail_recvs.dat\n      #     body: file://cache/mail_content.dat\n      #     content_type: text/html\n      #     subject: \u5a01\u80c1\u60c5\u62a5\u64ad\u62a5\n\n      # \u5982\u679c\u4e0d\u5e0c\u671b\u6c61\u67d3 commit \u8bb0\u5f55\uff0cuser.email \u548c user.name \u968f\u4fbf\u586b\u5373\u53ef\n      # Github Runner \u662f\u6709\u6743\u9650\u63d0\u4ea4\u5230\u4ed3\u5e93\u7684\uff0c\u53ea\u8981 user \u4e0d\u662f owner \uff0c\u5f53\u6b21 commit \u4e0d\u4f1a\u88ab\u8bb0\u5f55\n      - name: Commit and push Github page (if changed)\n        if: ${{ github.event_name != 'pull_request' }}\n        run: |-\n          git diff\n          git config --global user.email \"github-bot@example.com\"\n          git config --global user.name \"Github-Bot\"\n          git add -A\n          git commit -m \"Updated by Github Bot\" || exit 0\n          git push origin master\n\n```", "prompt": "Generate a GitHub Workflow named `Automatically crawl CVEs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch named master. 2) someone manually triggers the workflow. 3) the scheduled time has come: at 15 minutes past the hour. The workflow has one job. The job id of the 1st job is `build-and-deploy`. The job `build-and-deploy` has 6 steps. The 1st step is named `Check out repo`. The 2nd step is named `Set up Python`. The 3rd step is named `Configure pip caching`. The 4th step is named `Install Python dependencies`. The 5th step is named `Crawl CVEs`. The 6th step is named `Commit and push Github page (if changed)`. "}
{"id": "63c496891e3364807577b43b", "level": "level2", "llm_response": "```yaml\nname: Build Docker\n\non:\n  push:\n    branches:\n      - trunk\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n  pull_request:\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n\nconcurrency:\n  group: 'build-docker-${{ github.event_name }}-${{ github.ref }}'\n  cancel-in-progress: true\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n      - name: Set up qemu\n      - name: Set up Docker Buildx\n      - name: Log in to Docker Hub\n      - name: Log in to GitHub Packages\n      - name: Fetch build args\n        id: buildargs\n      - name: Extract Docker metadata\n        id: meta\n      - name: Build and push Docker image\n```", "answer": "```yaml name: Build Docker\non:\n  push:\n    branches: [ 'trunk' ]\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n  pull_request:\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\nconcurrency:\n  group: build-docker-${{ github.event_name }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    name: Build and publish Jetpack Dev Environment\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    timeout-minutes: 60  # 2021-10-26: Build for arm64 is S-L-O-W. Sigh.\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up qemu\n        uses: docker/setup-qemu-action@v2\n        with:\n          platforms: arm64\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: matticbot\n          password: ${{ secrets.DOCKER_HUB_MATTICBOT_TOKEN }}\n\n      - name: Log in to GitHub Packages\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Fetch build args\n        id: buildargs\n        run: |\n          source .github/versions.sh\n          source .github/files/gh-funcs.sh\n\n          gh_set_output php-version \"$PHP_VERSION\"\n          gh_set_output composer-version \"$COMPOSER_VERSION\"\n          gh_set_output node-version \"$NODE_VERSION\"\n          gh_set_output pnpm-version \"$PNPM_VERSION\"\n\n          # We're not git-tagging for the env. Just tag all trunk builds as latest.\n          if [[ \"$GITHUB_EVENT_NAME\" == \"push\" ]]; then\n            gh_set_output tags \"type=raw,latest\"\n            gh_set_output images $'automattic/jetpack-wordpress-dev\\nghcr.io/automattic/jetpack-wordpress-dev'\n          elif [[ \"$GITHUB_EVENT_NAME\" == \"pull_request\" ]]; then\n            gh_set_output tags \"type=ref,event=pr\"\n            gh_set_output images \"ghcr.io/automattic/jetpack-wordpress-dev\"\n          else\n            echo \"Unknown GITHUB_EVENT_NAME $GITHUB_EVENT_NAME\"\n            exit 1\n          fi\n\n      - name: Extract Docker metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          flavor: latest=false\n          tags: ${{ steps.buildargs.outputs.tags }}\n          images: ${{ steps.buildargs.outputs.images }}\n          labels: |\n            org.opencontainers.image.title=Jetpack Development Environment\n            org.opencontainers.image.description=Unified environment for developing in the Jetpack Monorepo using Docker containers.\n            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/trunk/tools/docker/README.md\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v3\n        with:\n          context: tools/docker\n          platforms: linux/amd64,linux/arm64\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          build-args: |\n            PHP_VERSION=${{ steps.buildargs.outputs.php-version }}\n            COMPOSER_VERSION=${{ steps.buildargs.outputs.composer-version }}\n            NODE_VERSION=${{ steps.buildargs.outputs.node-version }}\n            PNPM_VERSION=${{ steps.buildargs.outputs.pnpm-version }}\n```", "prompt": "Generate a GitHub Workflow named `Build Docker` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named trunk. Only if at least one path of push event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. 2) Only if at least one path of pull_request event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. Only a single workflow using the build-docker-${{ github.event_name }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Build and publish Jetpack Dev Environment` and its job id is `build`. The job `build` has 8 steps. The 1st step is named ``. The 2nd step is named `Set up qemu`. The 3rd step is named `Set up Docker Buildx`. The 4th step is named `Log in to Docker Hub`. The 5th step is named `Log in to GitHub Packages`. The 6th step is named `Fetch build args` and its id is `buildargs`. The 7th step is named `Extract Docker metadata` and its id is `meta`. The 8th step is named `Build and push Docker image`. "}
{"id": "63c494318052faa2781a9bf5", "level": "level2", "llm_response": "```yaml\nname: Test a branch on canary\n\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n        type: string\n\npermissions:\n  contents: read\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\n\njobs:\n  update_tag:\n    id: update_tag\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: pwsh\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Update the rc tag\n      run: |\n        # Add your commands here to update the rc tag\n\n    - name: Canary test\n      run: |\n        # Add your commands here to perform the canary test\n```", "answer": "```yaml name: Test a branch on canary\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\ndefaults:\n  run:\n    shell: pwsh\n\npermissions:  # added using https://github.com/step-security/secure-workflows\n  contents: read\n\njobs:\n  update_tag:\n    name: Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n    - uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34 # v1\n      with:\n        allowed-endpoints: \n          api.github.com:443\n          github.com:443\n\n    - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 # v2\n    - name: Update the rc tag\n      uses: step-security/publish-action@b438f840875fdcb7d1de4fc3d1d30e86cf6acb5d\n      with:\n        rc-sha: ${{ env.COMMIT_SHA }}\n        rc: true\n\n    - name: Canary test\n      uses: docker://ghcr.io/step-security/integration-test/int:latest\n      env:\n        PAT: ${{ secrets.PAT }}\n        canary: true\n```", "prompt": "Generate a GitHub Workflow named `Test a branch on canary` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: COMMIT_SHA-this input represents commit sha to be tested and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `COMMIT_SHA` is set to `${{ github.event.inputs.COMMIT_SHA }}`. For all run steps in the workflow, default shell is set to pwsh. The workflow has one job. The 1st job is named `Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit` and its job id is `update_tag`. The job `update_tag` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Update the rc tag`. The 4th step is named `Canary test`. "}
{"id": "63c4964733b087f6bde2ad41", "level": "level2", "llm_response": "```yaml\nname: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - 'py-*'\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [windows-latest, macos-latest]\n\n    defaults:\n      run:\n        shell: bash\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n\n      - name: Fix README symlink\n        run: |\n          if [ -L README ]; then\n            rm README\n            ln -s README.md README\n          fi\n\n      - name: Publish wheel\n        run: |\n          python setup.py bdist_wheel\n          twine upload dist/*\n```", "answer": "```yaml name: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - py-*\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, windows-latest]\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.7'\n\n      - name: Fix README symlink\n        run: |\n          rm py-polars/README.md\n          cp README.md py-polars/README.md\n\n      - name: Publish wheel\n        uses: messense/maturin-action@v1\n        env:\n          MATURIN_PASSWORD: ${{ secrets.PYPI_PASS }}\n          RUSTFLAGS: -C target-feature=+fxsr,+sse,+sse2,+sse3,+sse4.1,+sse4.2\n        with:\n          rust-toolchain: nightly-2022-10-06\n          maturin-version: '0.13.5'\n          command: publish\n          args: -m py-polars/Cargo.toml --no-sdist --skip-existing -o wheels -i python -u ritchie46\n```", "prompt": "Generate a GitHub Workflow named `Create Python release windows macos` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches py-*. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The job id of the 1st job is `win-macos`. The job `win-macos` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Fix README symlink`. The 4th step is named `Publish wheel`. "}
{"id": "63c496566fc19abdf9c9b6ef", "level": "level2", "llm_response": "```yaml\nname: automerge\n\non:\n  pull_request:\n    types: [labeled]\n\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: enable automerge\n      run: echo \"Automerge enabled\"\n```", "answer": "```yaml name: automerge\non:\n  pull_request_target:\n    types:\n      - labeled\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: enable automerge\n        if: contains( github.event.pull_request.labels.*.name, 'automerge')\n        uses: peter-evans/enable-pull-request-automerge@v2\n        with:\n          token: ${{ secrets.PAT }}\n          pull-request-number: ${{ github.event.pull_request.number }}\n          merge-method: rebase\n```", "prompt": "Generate a GitHub Workflow named `automerge` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: a label is added to a pull request. The workflow has one job. The job id of the 1st job is `automerge`. The job `automerge` has one step. The 1st step is named `enable automerge`. "}
{"id": "63c4941d8052faa2781a937b", "level": "level2", "llm_response": "```yaml\nname: update-flake-lock\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  lockfile:\n    id: lockfile\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Nix\n        run: |\n          sh <(curl -L https://nixos.org/nix/install) --daemon\n      - name: Update flake.lock\n        run: nix flake lock --update-inputs\n```", "answer": "```yaml name: update-flake-lock\non:\n  workflow_dispatch: # allows manual triggering\n  schedule:\n    - cron: '0 0 * * 0' # runs weekly on Sunday at 00:00\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Install Nix\n        uses: cachix/install-nix-action@v18\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n      - name: Update flake.lock\n        uses: DeterminateSystems/update-flake-lock@v14\n        with:\n          # we update nixos-common-styles manual\n          # and the rest of the inputs are content inputs\n          inputs: nixpkgs\n```", "prompt": "Generate a GitHub Workflow named `update-flake-lock` for a GitHub repository whose primary programming language is Less. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The job id of the 1st job is `lockfile`. The job `lockfile` has 3 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Install Nix`. The 3rd step is named `Update flake.lock`. "}
{"id": "63c4965533b087f6bde2b378", "level": "level2", "llm_response": "```yaml\nname: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    id: packagist\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update Packagist\n        run: echo \"Updating Packagist\"\n```", "answer": "```yaml name: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    name: Update Packagist\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update Packagist\n        run: |\n          curl -X POST \"https://packagist.org/api/update-package?username=svix&apiToken=$PACKAGIST_API_KEY\" \\\n            -H 'content-type: application/json' \\\n            -d '{\"repository\":{\"url\":\"https://packagist.org/packages/svix/svix\"}}'\n        env:\n          PACKAGIST_API_KEY: ${{ secrets.PACKAGIST_API_KEY }}```", "prompt": "Generate a GitHub Workflow named `PHP Release` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Update Packagist` and its job id is `packagist`. The job `packagist` has one step. The 1st step is named `Update Packagist`. "}
{"id": "63c4959c7843b61269a08c30", "level": "level2", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  workflow_dispatch:\n\npermissions:\n  contents: read\n  security-events: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Run analysis\n      run: cargo scorecard\n\n    - name: Upload artifact\n      uses: actions/upload-artifact@v2\n      with:\n        name: scorecard-report\n        path: target/scorecard-report.html\n\n    - name: Upload to code-scanning\n      uses: github/codeql-action/upload-sarif@v2\n      with:\n        sarif_file: target/sarif/scorecard-report.sarif\n```", "answer": "```yaml name: Scorecards supply-chain security\n# Run only manually, because the answers don't change often and the results have \n# many unhelpful positives.\n  \non:\n  workflow_dispatch: \n  # Only the default branch is supported.\n  # branch_protection_rule:\n  # schedule:\n  #   - cron: '38 17 * * 6'\n  # push:\n  #  branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c8416b0b2bf627c349ca92fc8e3de51a64b005cf # v1.0.2\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. "}
{"id": "63c495547843b61269a06e6c", "level": "level2", "llm_response": "```yaml\nname: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 1 * * *'\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\njobs:\n  recreate:\n    id: recreate\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Set up Cloud SDK\n      run: |\n        # Add steps to set up Cloud SDK\n        echo \"Setting up Cloud SDK...\"\n    \n    - name: Wait for idle runner\n      id: killable\n      run: |\n        # Add steps to wait for idle runner\n        echo \"Waiting for idle runner...\"\n    \n    - name: Kill runner and create a new one\n      run: |\n        # Add steps to kill runner and create a new one\n        echo \"Killing runner and creating a new one...\"\n```", "answer": "```yaml name: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    # Once each 24 hours, at 1 during the night\n    - cron: \"0 1 * * *\"\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  recreate:\n    if: github.repository == 'Homebrew/homebrew-core'\n    runs-on: ubuntu-22.04\n    env:\n      # TODO agree on one label for all runners\n      RUNNER_LABEL: TODO\n    strategy:\n      matrix:\n        runner_name:\n          - linux-self-hosted-1\n    steps:\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.2.1\n        with:\n          project_id: ${{ secrets.GCP_PROJECT_ID }}\n          service_account_key: ${{ secrets.GCP_SA_KEY }}\n          export_default_credentials: true\n\n      - name: Wait for idle runner\n        id: killable\n        uses: Homebrew/actions/wait-for-idle-runner@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n      - name: Kill runner and create a new one\n        if: ${{ steps.killable.outputs.runner-found == 'true' && steps.killable.outputs.runner-idle == 'true' }}\n        uses: Homebrew/actions/create-gcloud-instance@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          gcp_project_id: ${{ secrets.GCP_PROJECT_ID }}\n          gcp_service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n          gcp_sa_key: ${{ secrets.GCP_SA_KEY }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Recreate Linux self-hosted runners on schedule` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 01:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the recreate-linux-runners concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `recreate`. The job `recreate` has 3 steps. The 1st step is named `Set up Cloud SDK`. The 2nd step is named `Wait for idle runner` and its id is `killable`. The 3rd step is named `Kill runner and create a new one`. "}
{"id": "63c4942a8052faa2781a9911", "level": "level2", "llm_response": "```yaml\nname: Integration tests\n\non:\n  push:\n    branches:\n      - main\n      - dev\n  workflow_dispatch:\n\njobs:\n  integration_tests:\n    id: integration_tests\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n\n      - name: Run tests\n        run: go test -v ./...\n\n      - name: Upload test results\n        uses: actions/upload-artifact@v2\n        with:\n          name: test-results\n          path: ./test-results.xml\n```", "answer": "```yaml name: Integration tests\non:\n  workflow_dispatch: null\n  push:\n    branches:\n      - main\n      - dev\njobs:\n  integration_tests:\n    name: Run integration tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f # pin@v2\n      - uses: actions/setup-go@37335c7bb261b353407cff977110895fa0b4f7d8 # pin@v2\n        with:\n          go-version: '1.18'\n      - run: go version\n      - run: make testacc\n        env:\n          LINODE_TOKEN: ${{ secrets.DX_LINODE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Integration tests` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main or a branch named dev. The workflow has one job. The 1st job is named `Run integration tests` and its job id is `integration_tests`. The job `integration_tests` has 4 steps. The 1st step is named `Clone Repository`. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c4942a8052faa2781a9910", "level": "level2", "llm_response": "```yaml\nname: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n  pull_request_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Generate App Installation Token\n      id: generate_token\n      run: echo \"::set-output name=token::$(openssl rand -hex 20)\"\n\n    - name: Slash Command Dispatch\n      run: echo \"/acc-test token=${{ steps.generate_token.outputs.token }}\"\n```", "answer": "```yaml name: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.issue.pull_request }}\n    steps:\n      - name: Generate App Installation Token\n        id: generate_token\n        uses: tibdex/github-app-token@v1\n        with:\n          app_id: ${{ secrets.DX_ACCTEST_APP_ID }}\n          private_key: ${{ secrets.DX_ACCTEST_PRIV_KEY }}\n\n      - name: Slash Command Dispatch\n        uses: peter-evans/slash-command-dispatch@v1\n        env:\n          TOKEN: ${{ steps.generate_token.outputs.token }}\n        with:\n          token: ${{ env.TOKEN }}\n          reaction-token: ${{ secrets.GITHUB_TOKEN }}\n          issue-type: pull-request\n          commands: acctest\n          named-args: true\n          permission: write\n```", "prompt": "Generate a GitHub Workflow named `AccTest Command` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `acctest-command`. The job `acctest-command` has 2 steps. The 1st step is named `Generate App Installation Token` and its id is `generate_token`. The 2nd step is named `Slash Command Dispatch`. "}
{"id": "63c4940f7843b612699feb8d", "level": "level2", "llm_response": "```yaml\nname: Go Coverage\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: 1.17\n\n    - name: Run tests and generate coverage report\n      run: |\n        go test -v ./... -coverprofile=coverage.out\n        go tool cover -func=coverage.out\n```", "answer": "```yaml # add public code coverage reports\non:\n  push:\n    branches:\n    - main\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - run: \"make test-cover\"\n    - uses: codecov/codecov-action@v2\n    with:\n      file: ./coverage.out\n      fail_ci_if_error: true\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `coverage`. The job `coverage` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. "}
{"id": "63c496a06fc19abdf9c9d2e3", "level": "level2", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '18 09 * * 4'\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run analysis\n        run: cargo scorecard\n\n      - name: Upload artifact\n        uses: actions/upload-artifact@v2\n        with:\n          name: scorecard-report\n          path: target/scorecard-report.html\n\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: target/sarif/scorecard-report.sarif\n```", "answer": "```yaml # This file is part of ICU4X. For terms of use, please see the file\n# called LICENSE at the top level of the ICU4X source tree\n# (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).\n\nname: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '18 9 * * 4'\n  push:\n    branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c1aec4ac820532bab364f02a81873c555a0ba3a1 # v1.0.4\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 09:18 am, only on thursday. 3) The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. "}
{"id": "63c495257843b61269a05b79", "level": "level2", "llm_response": "```yaml\nname: Update translation templates\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-templates:\n    id: update-templates\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Install git\n        run: sudo apt-get update && sudo apt-get install -y git\n\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Install deps\n        run: sudo apt-get update && sudo apt-get install -y meson\n\n      - name: Change git permissions\n        run: chmod -R 755 .\n\n      - name: Run meson targets\n        run: meson setup builddir && meson compile -C builddir\n\n      - name: Check for non-timestamp diff\n        run: git diff --name-only --diff-filter=ACMRTUXB | grep -v 'translation\\.pot' && echo \"Translation template has been updated.\"\n\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v3\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          commit-message: \"Update translation templates\"\n          title: \"Update translation templates\"\n          body: \"This PR updates the translation templates.\"\n```", "answer": "```yaml on:\n  push:\n    branches: [ master ]\n\nname: Update translation templates\njobs:\n  update-templates:\n    name: Update translation templates\n    runs-on: ubuntu-20.04\n    container:\n      image: archlinux\n    steps:\n      # install git first otherwise checkout will not give us an actual git repo\n      - name: Install git\n        run: pacman -Syu --noconfirm git\n    \n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n\n      - name: Install deps\n        run: |\n          # install general build deps\n          pacman -Syu --noconfirm ninja gcc pkgconf python3 python-pip which\n          # install easyeffects deps\n          source ./PKGBUILD && pacman -Syu --noconfirm --needed --asdeps \"${makedepends[@]}\" \"${depends[@]}\"\n          \n      # workaround upstream permissions issue github.com/peter-evans/create-pull-request/issues/1170\n      - name: Change git permissions\n        run: git config --global --add safe.directory \"$GITHUB_WORKSPACE\"\n\n      - name: Run meson targets\n        run: |\n          meson build\n          cd build\n          ../util/update_translation_templates.sh\n          cd ..\n\n      - name: Check for non-timestamp diff\n        run: |\n          # see https://stackoverflow.com/a/26622262\n          DIFF_LINES=$(git diff --unified=0 | grep '^[+-]' | grep -Ev '^(--- a/|\\+\\+\\+ b/)')\n\n          if [[ $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\") != \"$DIFF_LINES\" ]]; then\n            echo \"The calculated diff includes modifications besides just timestamp changes (POT-Creation-Date).\"\n            echo \"Letting the PR continue as this is a valid reason to open a PR.\"\n          else\n            echo \"The calculated diff just has timestamp changes (POT-Creation-Date).\"\n            echo \"Restoring original files since this is not a valid reason to open a PR.\"\n            git restore .\n          fi\n\n          echo \"All diff lines count: $(echo \"$DIFF_LINES\" | wc -l)\"\n          echo \"Diff lines count where POT-Creation-Date was changed: $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\" | wc -l)\"\n\n      # TODO it would be ideal to refresh metainfo fully by copying release notes from the upcoming release in NEWS.yaml to metainfo, and then running the above update template script,\n      # however this is not possible without putting a dummy release in the metainfo with said upcoming release notes which would later have to be adjusted to the real release.\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4.1.3\n        with:\n          title: Update translation templates\n          body: Ensure to merge all other Pull Requests before merging this. Conflicts here will automatically be resolved in case of changes in master.\n          commit-message: Update translation templates\n          # email sets \"EasyEffects Bot\" user as commit author\n          committer: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          author: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          branch: automatically-update-translation-templates\n          # the easyeffects_bot secret/token is only valid for a fork\n          # note the machine user (easyeffects-bot) must have already forked the repository  where the action is running for this to work\n          push-to-fork: easyeffects-bot/easyeffects\n          token: ${{ secrets.EASYEFFECTS_BOT }}\n```", "prompt": "Generate a GitHub Workflow named `Update translation templates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The 1st job is named `Update translation templates` and its job id is `update-templates`. The job `update-templates` has 7 steps. The 1st step is named `Install git`. The 2nd step is named `Checkout`. The 3rd step is named `Install deps`. The 4th step is named `Change git permissions`. The 5th step is named `Run meson targets`. The 6th step is named `Check for non-timestamp diff`. The 7th step is named `Create Pull Request`. "}
{"id": "63c4967d1899db58864d33af", "level": "level2", "llm_response": "```yaml\nname: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      package_name:\n        description: 'Package name'\n        required: true\n        default: 'generateblocks'\n\njobs:\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: NPM install\n      run: npm install\n\n    - name: NPM build\n      run: npm run build\n\n    - name: Grunt action-package\n      run: grunt action-package\n\n    - name: Build zip file\n      run: zip -r ${{ github.event.inputs.package_name }}.zip .\n```", "answer": "```yaml name: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      name:\n        description: 'Package name'\n        default: 'generateblocks'\n        required: true\n\njobs:\n\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n          cache: 'npm'\n\n      - name: NPM install\n        run: npm install\n\n      - name: NPM build\n        run: npm run build\n\n      - name: Grunt action-package\n        run: npm run action-package\n\n      - name: Build zip file\n        uses: actions/upload-artifact@v3.1.0\n        with:\n          name: ${{ github.event.inputs.name }}\n          path: |\n            package/\n          retention-days: 1\n```", "prompt": "Generate a GitHub Workflow named `Build package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: name-this input represents package name, its default value is generateblocks and it must be supplied. The workflow has one job. The job id of the 1st job is `build-package`. The job `build-package` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `NPM install`. The 4th step is named `NPM build`. The 5th step is named `Grunt action-package`. The 6th step is named `Build zip file`. "}
{"id": "63c494637843b61269a00d3a", "level": "level2", "llm_response": "```yaml\nname: olm\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\n\nenv:\n  GO_VERSION: 1.19\n  KIND_IMG_TAG: v1.25.0\n\njobs:\n  main:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Download binaries\n      run: echo \"Downloading binaries...\"\n\n    - name: Install dependencies\n      run: echo \"Installing dependencies...\"\n\n    - name: Create and verify bundle\n      run: echo \"Creating and verifying bundle...\"\n\n    - name: Create and set up K8s KinD Cluster\n      run: echo \"Creating and setting up K8s KinD Cluster...\"\n\n    - name: Run the tests\n      run: echo \"Running the tests...\"\n```", "answer": "```yaml name: olm\non:\n  push:\n    branches:\n      - main\n  pull_request:\nenv:\n  GO_VERSION: '1.19'\n  KIND_IMG_TAG: v1.25.0\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\njobs:\n  main:\n    name: tests\n    runs-on: ubuntu-22.04\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Download binaries\n      run: |\n        mkdir -p ${GITHUB_WORKSPACE}/build\n        echo \"${GITHUB_WORKSPACE}/build\" >> ${GITHUB_PATH}\n        make operator-sdk\n        make opm\n\n    - uses: actions/setup-go@268d8c0ca0432bb2cf416faae41297df9d262d7f\n      with:\n        go-version: ${{ env.GO_VERSION }}\n    - name: Install dependencies\n      run: |\n        sudo apt update\n        sudo apt install -y libseccomp-dev libelf-dev libapparmor-dev\n        sudo hack/install-libbpf.sh\n\n    - name: Create and verify bundle\n      run: |\n        make verify-bundle\n\n    - name: Create and set up K8s KinD Cluster\n      run: |\n        ./hack/kind-with-registry.sh\n\n    - name: Run the tests\n      run: ./hack/ci/e2e-olm.sh\n```", "prompt": "Generate a GitHub Workflow named `olm` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: none access is granted to the GITHUB_TOKEN in the `actions` scope, none access is granted to the GITHUB_TOKEN in the `checks` scope, none access is granted to the GITHUB_TOKEN in the `contents` scope, none access is granted to the GITHUB_TOKEN in the `deployments` scope, none access is granted to the GITHUB_TOKEN in the `id-token` scope, none access is granted to the GITHUB_TOKEN in the `issues` scope, none access is granted to the GITHUB_TOKEN in the `discussions` scope, none access is granted to the GITHUB_TOKEN in the `packages` scope, none access is granted to the GITHUB_TOKEN in the `pull-requests` scope, none access is granted to the GITHUB_TOKEN in the `repository-projects` scope, none access is granted to the GITHUB_TOKEN in the `security-events` scope and none access is granted to the GITHUB_TOKEN in the `statuses` scope. This permission setting applies to all jobs in the workflow. The workflow sets 2 environment variables to use: `GO_VERSION` is set to `1.19` and `KIND_IMG_TAG` is set to `v1.25.0`. The workflow has one job. The 1st job is named `tests` and its job id is `main`. The job `main` has 7 steps. The 1st step is named ``. The 2nd step is named `Download binaries`. The 3rd step is named ``. The 4th step is named `Install dependencies`. The 5th step is named `Create and verify bundle`. The 6th step is named `Create and set up K8s KinD Cluster`. The 7th step is named `Run the tests`. "}
{"id": "63c494c78052faa2781ad49a", "level": "level2", "llm_response": "```yaml\nname: Pull Request Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Add label to pull request\n        run: |\n          echo \"Adding label 'in-review' to pull request\"\n          gh pr edit ${{ github.event.pull_request.number }} --add-label \"in-review\"\n```", "answer": "```yaml name: \"Pull Request Labeler\"\non:\n  - pull_request_target\n\njobs:\n  triage:\n    permissions:\n      contents: read\n      pull-requests: write\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/labeler@v4\n        with:\n          repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Pull Request Labeler` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `triage`. The job `triage` has one step. The 1st step is named ``. "}
{"id": "63c495928052faa2781b2bc0", "level": "level2", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Add label to pull request\n        uses: actions/add-label@v1\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          labels: \"erlang,pr\"\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n    - uses: rhysd/changelog-from-release/action@v2\n      with:\n        file: CHANGELOG.md\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. The job `label` has one step. The 1st step is named ``. "}
{"id": "63c494608052faa2781aabf2", "level": "level2", "llm_response": "```yaml\nname: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    uses: exercism/github-actions/.github/workflows/configlet.yml@main\n```", "prompt": "Generate a GitHub Workflow named `Configlet` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. 3) someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `configlet`. "}
{"id": "63c4949e7843b61269a025e6", "level": "level2", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [commented]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Hello, World!\"\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. The job `TagBot` has one step. The 1st step is named ``. "}
{"id": "63c495d98052faa2781b4aa8", "level": "level2", "llm_response": "```yaml\nname: NMake\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  nmake:\n    runs-on: windows-latest\n    strategy:\n      matrix:\n        name: [Debug, Release]\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Setup development environment\n      run: |\n        choco install nmake\n        choco install cmake\n        choco install visualstudio2019buildtools\n\n    - name: Compile source code\n      run: |\n        mkdir build\n        cd build\n        cmake .. -A x64 -DCMAKE_BUILD_TYPE=${{ matrix.name }}\n        nmake\n\n    - name: Run test cases\n      run: |\n        cd build\n        nmake test\n```", "answer": "```yaml name: NMake\non: [push, pull_request]\njobs:\n  nmake:\n    name: ${{ matrix.name }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - name: Windows NMake x86\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86\n\n          - name: Windows NMake x64 compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes\n\n          - name: Windows NMake x64 Symbol Prefix\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64 Symbol Prefix Compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n\n          - name: Windows NMake ARM No Test\n            os: windows-2022\n            makefile: win32/Makefile.arm\n            arch: x86_arm\n\n          - name: Windows NMake ARM64 No Test\n            os: windows-2022\n            makefile: win32/Makefile.a64\n            arch: x86_arm64\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Setup development environment\n      uses: ilammy/msvc-dev-cmd@v1.10.0\n      with:\n        arch: ${{ matrix.arch }}\n\n    - name: Compile source code\n      shell: cmd\n      run: nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}\n\n    - name: Run test cases\n      shell: cmd\n      # Don't run tests on Windows ARM\n      if: contains(matrix.arch, 'arm') == false\n      run: |\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} test\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} testdll\n```", "prompt": "Generate a GitHub Workflow named `NMake` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `nmake`. The job `nmake` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Setup development environment`. The 3rd step is named `Compile source code`. The 4th step is named `Run test cases`. "}
{"id": "63c493b77843b612699fd377", "level": "level2", "llm_response": "```yaml\nname: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - 'public/**'\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout \ud83d\udece\ufe0f\n      uses: actions/checkout@v2\n\n    - name: Install Nix\n      run: |\n        sh -c \"$(curl -L https://nixos.org/nix/install)\"\n        . \"$HOME/.nix-profile/etc/profile.d/nix.sh\"\n\n    - name: Build\n      run: |\n        cargo build --release\n\n    - name: Deploy \ud83d\ude80\n      run: |\n        # Add deployment steps here\n```", "answer": "```yaml name: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - \"public/**\"\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install Nix\n        uses: cachix/install-nix-action@v15\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build\n        run: nix build .#website\n\n      - name: Deploy \ud83d\ude80\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./result\n          cname: mdzk.app\n```", "prompt": "Generate a GitHub Workflow named `Publish website` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(public/**), the workflow runs. The workflow has one job. The job id of the 1st job is `deploy-website`. The job `deploy-website` has 4 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install Nix`. The 3rd step is named `Build`. The 4th step is named `Deploy \ud83d\ude80`. "}
{"id": "63c4946f7843b61269a011d1", "level": "level2", "llm_response": "```yaml\nname: I2::Dev::Nightly::Publish\n\non:\n  workflow_dispatch:\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n      - name: Build and push iroha2:dev-nightly image\n        uses: docker/build-push-action@v2\n        with:\n          context: .\n          push: true\n          tags: docker.io/iroha2/iroha2:dev-nightly\n```", "answer": "```yaml name: I2::Dev::Nightly::Publish\n\non: workflow_dispatch\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n    container:\n      image: 7272721/i2-ci:nightly\n    steps:\n      - uses: actions/checkout@v3\n      - uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push iroha2:dev-nightly image\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          tags: hyperledger/iroha2:dev-nightly-${{ github.sha }}\n          labels: commit=${{ github.sha }}\n          build-args: TAG=dev\n```", "prompt": "Generate a GitHub Workflow named `I2::Dev::Nightly::Publish` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `dockerhub`. The job `dockerhub` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Build and push iroha2:dev-nightly image`. "}
{"id": "63c4941b7843b612699ff0aa", "level": "level2", "llm_response": "```yaml\nname: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - zap/zap.gradle.kts\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Setup Java\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Build and Release\n        run: ./gradlew build\n```", "answer": "```yaml name: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - 'zap/zap.gradle.kts'\n\njobs:\n  release:\n    name: Build and Release\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n        persist-credentials: false\n    - name: Setup Java\n      uses: actions/setup-java@v3\n      with:\n        distribution: 'temurin'\n        java-version: 11\n    - name: Build and Release\n      env:\n        INSTALL4J_LICENSE: ${{ secrets.INSTALL4J_LICENSE }}\n        ZAPBOT_TOKEN: ${{ secrets.ZAPBOT_TOKEN }}\n        ZAP_RELEASE: 1\n        ZAP_JAVA_VERSION: 11\n      run: ./gradlew \"-Dorg.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m\" :zap:createMainRelease\n```", "prompt": "Generate a GitHub Workflow named `Release Main Version` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(zap/zap.gradle.kts), the workflow runs. The workflow has one job. The 1st job is named `Build and Release` and its job id is `release`. The job `release` has 3 steps. The 1st step is named ``. The 2nd step is named `Setup Java`. The 3rd step is named `Build and Release`. "}
{"id": "63c494a97843b61269a02a52", "level": "level2", "llm_response": "```yaml\nname: pytorch1_8_1-cuda11_1\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Python 3.8\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Build project\n        run: |\n          make build\n```", "answer": "```yaml name: pytorch1_8_1-cuda11_1\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu111\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.8.1-cu111\n      develop_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_8_1-cuda11_1` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. "}
{"id": "63c493ff8052faa2781a8681", "level": "level2", "llm_response": "```yaml\nname: Check License Lines\n\non:\n  push:\n    branches:\n      - '*'\n\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Check License Lines\n        run: |\n          # Add your license line checking script here\n          echo \"Checking license lines...\"\n```", "answer": "```yaml name: Check License Lines\non:\n  push:\n    branches: '**'\n#  pull_request:\n#    branches:\n#      - main\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Check License Lines\n        uses: kt3k/license_checker@v1.0.6```", "prompt": "Generate a GitHub Workflow named `Check License Lines` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch whose name matches * or a branch whose name matches *. The workflow has one job. The job id of the 1st job is `check-license-lines`. The job `check-license-lines` has 2 steps. The 1st step is named ``. The 2nd step is named `Check License Lines`. "}
{"id": "63c494888052faa2781abb68", "level": "level2", "llm_response": "```yaml\nname: MERGE_MASTER_TO_DEVELOP\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout develop\n        uses: actions/checkout@v2\n        with:\n          ref: develop\n\n      - name: Merge master to develop and push\n        run: |\n          git merge master\n          git push origin develop\n\n      - name: Notify failure on Slack\n        if: failure()\n        uses: rtCamp/slack-notify-action@v1\n        with:\n          slack_webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}\n          message: \"Merge from master to develop failed\"\n```", "answer": "```yaml name: MERGE_MASTER_TO_DEVELOP\non:\n  push:\n    branches:\n    - \"master\"\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n    - name: Checkout develop\n      uses: actions/checkout@v3\n      with:\n        ref: develop\n        fetch-depth: 0\n    - name: Merge master to develop and push\n      run: |\n        git config user.name '${{ secrets.BPMN_IO_USERNAME }}'\n        git config user.email '${{ secrets.BPMN_IO_EMAIL }}'\n        git merge -m 'Merge master to develop' --no-edit origin/master\n        git push\n\n    - name: Notify failure on Slack\n      if: failure()\n      uses: slackapi/slack-github-action@v1.15.0\n      with:\n        channel-id: ${{ secrets.SLACK_CHANNEL_ID }}\n        slack-message: \"Automatic merge of <https://github.com/${{ github.repository }}/tree/${{ github.ref }}|${{ github.ref }}> to <https://github.com/${{ github.repository }}/tree/develop|${{ github.repository }}#develop> failed.\"\n      env:\n        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `MERGE_MASTER_TO_DEVELOP` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `Merge_master_to_develop`. The job `Merge_master_to_develop` has 3 steps. The 1st step is named `Checkout develop`. The 2nd step is named `Merge master to develop and push`. The 3rd step is named `Notify failure on Slack`. "}
{"id": "63c494298052faa2781a987a", "level": "level2", "llm_response": "```yaml\nname: Hypothesis Tests\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 6 * * *'\n\npermissions:\n  issues: write\n\nenv:\n  python_version: 3.10\n\njobs:\n  hypothesis:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Install Linux Dependencies\n      run: sudo apt-get update && sudo apt-get install -y build-essential libssl-dev zlib1g-dev libncurses5-dev libncursesw5-dev libreadline-dev libsqlite3-dev libgdbm-dev libdb5.3-dev libbz2-dev libexpat1-dev liblzma-dev tk-dev libffi-dev\n\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: ${{ env.python_version }}\n\n    - name: Use Python Dependency Cache\n      uses: actions/cache@v2\n      with:\n        path: ~/.cache/pip\n        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n        restore-keys: |\n          ${{ runner.os }}-pip-\n\n    - name: Use Hypothesis Cache\n      uses: actions/cache@v2\n      with:\n        path: ~/.cache/hypothesis\n        key: ${{ runner.os }}-hypothesis\n\n    - name: Install Dependencies and Test\n      run: pip install -r requirements.txt\n\n    - name: Test with Hypothesis\n      run: pytest --hypothesis\n\n    - name: Create Issue on Failure\n      if: failure()\n      run: |\n        echo \"::add-mask::${{ secrets.GITHUB_TOKEN }}\"\n        echo \"Creating issue on failure\"\n        curl -X POST -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -H \"Content-Type: application/json\" -d '{\"title\": \"Test Failure\", \"body\": \"The hypothesis tests have failed. Please investigate.\"}' https://api.github.com/repos/${{ github.repository }}/issues\n```", "answer": "```yaml name: Hypothesis Tests\non:\n  workflow_dispatch:\n  schedule:\n    # min hour dom month dow\n    - cron:  '0 6 * * *'\nenv:\n  python_version: '3.10'\n\npermissions:\n  issues: write\n\njobs:\n\n  hypothesis:\n    runs-on: ubuntu-22.04\n    timeout-minutes: 90\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Install Linux Dependencies\n        uses: ./.github/actions/linux_dependencies\n      - name: Set up Python\n        uses: actions/setup-python@v4.3.0\n        with:\n          python-version: ${{ env.python_version }}\n      - name: Use Python Dependency Cache\n        uses: actions/cache@v3.0.11\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}-20.04\n      - name: Use Hypothesis Cache\n        uses: pat-s/always-upload-cache@v3.0.1\n        with:\n          path: .hypothesis\n          key: ${{ runner.os }}-hypothesis\n      - name: Install Dependencies and Test\n        uses: ./.github/actions/setup_and_test\n      - name: Test with Hypothesis\n        run: xvfb-run poetry run pytest -m hypothesis --hypothesis-profile=ci\n        shell: bash\n      - uses: nashmaniac/create-issue-action@v1.1\n        if: failure()\n        name: Create Issue on Failure\n        with:\n          title: Hypothesis tests failed\n          token: ${{secrets.GITHUB_TOKEN}}\n          labels: bug,hypothesis\n          body: |\n            Test run failed for commit ${{github.sha}}.\n            See https://github.com/gaphor/gaphor/actions/workflows/hypothesis-test.yml.\n```", "prompt": "Generate a GitHub Workflow named `Hypothesis Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 06:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `python_version` is set to `3.10`. The workflow has one job. The job id of the 1st job is `hypothesis`. The job `hypothesis` has 8 steps. The 1st step is named ``. The 2nd step is named `Install Linux Dependencies`. The 3rd step is named `Set up Python`. The 4th step is named `Use Python Dependency Cache`. The 5th step is named `Use Hypothesis Cache`. The 6th step is named `Install Dependencies and Test`. The 7th step is named `Test with Hypothesis`. The 8th step is named `Create Issue on Failure`. "}
{"id": "63c495038052faa2781aede8", "level": "level2", "llm_response": "```yaml\nname: Python package\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  windows:\n    id: windows\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Create Conda environment with the right deps\n        run: |\n          conda create -n testenv python=3.8\n          conda activate testenv\n          conda install -c conda-forge pytest\n\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n\n      - name: Run Tests\n        run: pytest\n\n      - name: Conda info\n        run: conda info\n\n      - name: Conda list\n        run: conda list\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Python package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  windows:\n    name: Windows Tests\n    runs-on: \"windows-latest\"\n    strategy:\n      fail-fast: True\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: conda-incubator/setup-miniconda@v2\n        with:\n          auto-update-conda: true\n          python-version: ${{ matrix.python-version }}\n          channels: conda-forge\n        env:\n          ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n      - name: Create Conda environment with the rights deps\n        shell: bash -l {0}\n        run: |\n          conda create -n zarr-env python==${{matrix.python-version}} numcodecs pip nodejs\n      - name: Install dependencies\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          python -m pip install --upgrade pip\n          python -m pip install -U pip setuptools wheel\n          python -m pip install -r requirements_dev_numpy.txt -r requirements_dev_minimal.txt -r requirements_dev_optional.txt\n          python -m pip install .\n          python -m pip freeze\n          npm install -g azurite\n      - name: Run Tests\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          mkdir ~/blob_emulator\n          azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n          pytest -sv --timeout=300\n        env:\n          ZARR_TEST_ABS: 1\n          ZARR_V3_EXPERIMENTAL_API: 1\n      - name: Conda info\n        shell: bash -l {0}\n        run: conda info\n      - name: Conda list\n        shell: pwsh\n        run: conda list\n```", "prompt": "Generate a GitHub Workflow named `Python package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Windows Tests` and its job id is `windows`. The job `windows` has 7 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Create Conda environment with the rights deps`. The 4th step is named `Install dependencies`. The 5th step is named `Run Tests`. The 6th step is named `Conda info`. The 7th step is named `Conda list`. "}
{"id": "63c494347843b612699ffaac", "level": "level2", "llm_response": "```yaml\nname: Monitor CI Scaler\n\non:\n  schedule:\n    - cron: '0 5 * * *'\n    - cron: '0 17 * * *'\n\njobs:\n  MonitorCI:\n    id: MonitorCI\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v2\n      - name: setup environment\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: check scaler\n        run: echo \"Checking CI scaler...\"\n```", "answer": "```yaml name: Monitor CI Scaler\n\non:\n  # workflow_dispatch:\n  schedule:\n    - cron: '0 5,17 * * *'\n\njobs:\n  MonitorCI:\n    name: monitor ci scaler\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v1\n        with:\n          submodules: recursive\n      - name: setup environment\n        run: bash ./scripts/dev_setup.sh  -b -t -y\n      - name: check scaler\n        run: python3 ./scripts/monitor_autoscaler_recreate.py\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Monitor CI Scaler` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: the scheduled time has come: at 05:00 am and 05:00 pm. The workflow has one job. The 1st job is named `monitor ci scaler` and its job id is `MonitorCI`. The job `MonitorCI` has 3 steps. The 1st step is named `checkout`. The 2nd step is named `setup environment`. The 3rd step is named `check scaler`. "}
{"id": "63c494cf8052faa2781ad80f", "level": "level2", "llm_response": "```yaml\nname: Release Documentation\n\non:\n  release:\n    types: [published, prereleased, drafted]\n\nenv:\n  GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  java-build:\n    id: java-build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Cache Gradle dependencies\n        uses: actions/cache@v2\n        with:\n          path: ~/.gradle/caches\n          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-\n\n      - name: Cache Gradle wrappers\n        uses: actions/cache@v2\n        with:\n          path: .gradle/wrapper\n          key: ${{ runner.os }}-gradle-wrapper-${{ hashFiles('gradle/wrapper/gradle-wrapper.properties') }}\n\n      - name: Setup java\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Build with Gradle\n        run: ./gradlew build\n```", "answer": "```yaml name: Release Documentation\non:\n  release:\n    types: [published]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  GRADLE_OPTS: '-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail'\n\njobs:\n  java-build:\n    name: Publish Release Documentation\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        java: [ '8' ]\n        os: ['ubuntu-22.04' ]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Cache Gradle dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/caches\n          key: ${{ runner.os }}-gradle-caches-${{ hashFiles('**/*.gradle') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-caches-\n      - name: Cache Gradle wrappers\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-wrapper\n      - name: Setup java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: ${{ matrix.java }}\n      - name: Build with Gradle\n        run: ./gradlew tutorialPublish -Paeron.ci.apiKey=${{ secrets.WIKI_PAGE_TOKEN }} --stacktrace\n```", "prompt": "Generate a GitHub Workflow named `Release Documentation` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow sets an environment variable to use: `GRADLE_OPTS` is set to `-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail`. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Publish Release Documentation` and its job id is `java-build`. The job `java-build` has 5 steps. The 1st step is named `Checkout code`. The 2nd step is named `Cache Gradle dependencies`. The 3rd step is named `Cache Gradle wrappers`. The 4th step is named `Setup java`. The 5th step is named `Build with Gradle`. "}
{"id": "63c4967d6fc19abdf9c9c492", "level": "level2", "llm_response": "```yaml\nname: gradio-ui\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\nenv:\n  CI: \"True\"\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: \"1\"\n  NODE_OPTIONS: \"--max-old-space-size=4096\"\n\nconcurrency:\n  group: \"deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}\"\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    id: static-checks\n    runs-on: ubuntu-latest\n    working-directory: ui\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: install dependencies\n        run: echo \"Installing dependencies\"\n      - name: formatting check\n        run: echo \"Formatting check\"\n      - name: typecheck\n        run: echo \"Typecheck\"\n      - name: unit tests\n        run: echo \"Unit tests\"\n\n  functional-test:\n    id: functional-test\n    runs-on: ubuntu-latest\n    working-directory: ui\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: Install Python\n        run: echo \"Installing Python\"\n      - name: Step 4\n        run: echo \"Step 4\"\n      - name: Step 5\n        run: echo \"Step 5\"\n      - name: Step 6\n        run: echo \"Step 6\"\n      - name: Step 7\n        run: echo \"Step 7\"\n      - name: Step 8\n        run: echo \"Step 8\"\n      - name: Step 9\n        run: echo \"Step 9\"\n      - name: Upload failed tests screenshots\n        run: echo \"Upload failed tests screenshots\"\n```", "answer": "```yaml name: gradio-ui\n\non:\n  push:\n    branches:\n      - \"main\"\n  pull_request:\n\ndefaults:\n  run:\n    working-directory: ui\n\nenv:\n  CI: true\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: \"1\"\n  NODE_OPTIONS: \"--max-old-space-size=4096\"\n\nconcurrency:\n  group: deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    name: static checks\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: install dependencies\n        run: pnpm i --frozen-lockfile\n      - name: formatting check\n        run: pnpm format:check\n      - name: typecheck\n        run: pnpm ts:check\n      - name: unit tests\n        run: pnpm test:run\n  functional-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: Install Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.x'\n      - run: cd .. && bash scripts/install_gradio.sh\n      - run: pip install -r ../demo/outbreak_forecast/requirements.txt\n      - run: pnpm install --frozen-lockfile\n      - run: pnpm exec playwright install chromium\n      - run: pnpm test:browser:full\n      - name: Upload failed tests screenshots\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          retention-days: 3\n          name: test-failure-${{ github.run_id }}\n          path: ui/packages/app/test-results\n```", "prompt": "Generate a GitHub Workflow named `gradio-ui` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow sets 3 environment variables to use: `CI` is set to `True`, `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` is set to `1` and `NODE_OPTIONS` is set to `--max-old-space-size=4096`. For all run steps in the workflow, default working directory is set to ui. Only a single workflow using the deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `static checks` and its job id is `quick-checks`. The job `quick-checks` has 7 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `install dependencies`. The 5th step is named `formatting check`. The 6th step is named `typecheck`. The 7th step is named `unit tests`. The job id of the 2nd job is `functional-test`. The job `functional-test` has 10 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Install Python`. The 5th step is named ``. The 6th step is named ``. The 7th step is named ``. The 8th step is named ``. The 9th step is named ``. The 10th step is named `Upload failed tests screenshots`. "}
{"id": "63c496851899db58864d368d", "level": "level2", "llm_response": "```yaml\nname: Bump repositories\n\non:\n  schedule:\n    - cron: '0 20 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Bump cos \ud83d\udd27\n        run: echo \"Bumping cos \ud83d\udd27\"\n      - name: Create Pull Request\n        run: echo \"Creating Pull Request\"\n```", "answer": "```yaml name: Bump repositories\non: \n schedule:\n   - cron: 0 20 * * *\n workflow_dispatch:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Bump cos \ud83d\udd27\n      run: |\n           docker run --name=yq -v \"${PWD}\":/workdir mikefarah/yq\n           docker cp yq:/usr/bin/yq ./\n           export YQ=$PWD/yq\n           sudo -E bash ./.github/bump_repositories.sh\n           rm -rf yq\n    - name: Create Pull Request\n      uses: peter-evans/create-pull-request@v4\n      with:\n        token: ${{ secrets.PAT_TOKEN }}\n        push-to-fork: ci-robbot/c3os\n        commit-message: \":arrow_up: Update repositories\"\n        title: \"Repositories bump\"\n        body: \"Bump of luet repositories\"\n```", "prompt": "Generate a GitHub Workflow named `Bump repositories` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 08:00 pm. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 3 steps. The 1st step is named ``. The 2nd step is named `Bump cos \ud83d\udd27`. The 3rd step is named `Create Pull Request`. "}
{"id": "63c4945a7843b61269a00a52", "level": "level2", "llm_response": "```yaml\nname: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    id: docker\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n      \n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n      \n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      \n      - name: Build and export to Docker\n        run: docker buildx build --push --platform linux/amd64,linux/arm64 -t $TEST_TAG .\n      \n      - name: Run\n        run: docker run --rm $TEST_TAG\n```", "answer": "```yaml name: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      - name: Build and export to Docker\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          load: true\n          push: false\n          tags: ${{ env.TEST_TAG }}\n      - name: Run\n        run: |\n          docker run --rm ${{ env.TEST_TAG }} ci\n```", "prompt": "Generate a GitHub Workflow named `ci` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow sets an environment variable to use: `TEST_TAG` is set to `protoc-gen-validate:${{ github.sha }}`. The workflow has one job. The job id of the 1st job is `docker`. The job `docker` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up QEMU`. The 3rd step is named `Set up Docker Buildx`. The 4th step is named `Build and export to Docker`. The 5th step is named `Run`. "}
{"id": "63c49698b008460c1df15629", "level": "level2", "llm_response": "```yaml\nname: Auto Assign PR to Author\n\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    id: add-reviews\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: 'Auto Assign PR to Author'\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    permissions:\n      contents: read  # for kentaro-m/auto-assign-action to fetch config file\n      pull-requests: write  # for kentaro-m/auto-assign-action to assign PR reviewers\n    runs-on: ubuntu-latest\n    steps:\n      - uses: kentaro-m/auto-assign-action@v1.2.1\n```", "prompt": "Generate a GitHub Workflow named `Auto Assign PR to Author` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by an event: a pull request is created. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `add-reviews`. The job `add-reviews` has one step. The 1st step is named ``. "}
{"id": "63c494a87843b61269a02a08", "level": "level2", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: Step 4\n        run: echo \"Step 4\"\n      - name: Step 5\n        run: echo \"Step 5\"\n```", "answer": "```yaml name: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-python@v4\n        with:\n          python-version: 3.x\n      - run: pip install -r requirements/build-docs.txt\n      - run: linkcheckMarkdown docs/ -v -r\n      - run: mkdocs build --verbose\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `docs`. The job `docs` has 5 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. "}
{"id": "63c4956d7843b61269a07890", "level": "level2", "llm_response": "```yaml\nname: Issue Comments for merge\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [commented]\n\njobs:\n  check_comments_merge:\n    id: check_comments_merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        run: echo \"Checking for /merge command\"\n\n  merge:\n    id: merge\n    runs-on: ubuntu-latest\n    needs: check_comments_merge\n    steps:\n      - name: Merge Pull Request\n        run: echo \"Merging pull request\"\n\n  commentFeedback:\n    id: commentFeedback\n    runs-on: ubuntu-latest\n    needs: merge\n    steps:\n      - name: Add reaction on success\n        run: echo \"Adding reaction on success\"\n```", "answer": "```yaml on: issue_comment\nname: Issue Comments for merge\njobs:\n  check_comments_merge:\n    name: Check comments for /merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        uses: xt0rted/slash-command-action@v1.1.0\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          command: merge\n          reaction: \"true\"\n          reaction-type: \"eyes\"\n          allow-edits: \"false\"\n          permission-level: admin\n  merge:\n    runs-on: ubuntu-latest\n    needs: [check_comments_merge]\n    steps:\n      - name: Merge Pull Request\n        uses: juliangruber/merge-pull-request-action@v1.1.0\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          number: ${{ github.event.issue.number }}\n          method: merge\n  commentFeedback:\n    runs-on: ubuntu-latest\n    needs: [merge]\n    steps:\n      - name: Add reaction on success\n        uses: peter-evans/create-or-update-comment@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}\n          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}\n          reaction-type: hooray\n```", "prompt": "Generate a GitHub Workflow named `Issue Comments for merge` for a GitHub repository whose primary programming language is HCL. This workflow will be triggered by an event: activity related to an issue or pull request comment occurs. The workflow has 3 jobs. The 1st job is named `Check comments for /merge` and its job id is `check_comments_merge`. The job `check_comments_merge` has one step. The 1st step is named `Check for Command`. The job id of the 2nd job is `merge`. The job `merge` has one step. The 1st step is named `Merge Pull Request`. The job id of the 3rd job is `commentFeedback`. The job `commentFeedback` has one step. The 1st step is named `Add reaction on success`. "}
{"id": "63c495888052faa2781b2739", "level": "level2", "llm_response": "```yaml\nname: \u2744\ufe0f Lint\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [clone]\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    id: misc\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v2\n      - name: spell check\n        run: echo \"Running spell check\"\n      - name: Merge conflict\n        run: echo \"Checking for merge conflicts\"\n      - name: Plugin Code\n        run: echo \"Running plugin code\"\n\n  ci-eclint:\n    id: ci-eclint\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v2\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install eclint\n        run: npm install -g eclint\n      - name: Run eclint\n        run: eclint check .\n```", "answer": "```yaml name: \u2744\ufe0f Lint\n\non: [push, pull_request]\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    name: misc checker\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v3.1.0\n      - name: spell check\n        run: |\n          pip install codespell==2.1.0\n          git grep --cached -l '' | xargs codespell --ignore-words=.ignore_words\n      - name: Merge conflict\n        run: |\n          bash ./utils/check-merge-conflict.sh\n      - name: Plugin Code\n        run: |\n          bash ./utils/check-plugins-code.sh\n\n  ci-eclint:\n    runs-on: ubuntu-latest\n    timeout-minutes: 5\n\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v3.1.0\n\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v3.5.1\n        with:\n          node-version: '12'\n\n      - name: Install eclint\n        run: |\n          sudo npm install -g eclint\n\n      - name: Run eclint\n        run: |\n          eclint check\n```", "prompt": "Generate a GitHub Workflow named `\u2744\ufe0f Lint` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `misc checker` and its job id is `misc`. The job `misc` has 4 steps. The 1st step is named `Check out code.`. The 2nd step is named `spell check`. The 3rd step is named `Merge conflict`. The 4th step is named `Plugin Code`. The job id of the 2nd job is `ci-eclint`. The job `ci-eclint` has 4 steps. The 1st step is named `Check out code`. The 2nd step is named `Setup Nodejs env`. The 3rd step is named `Install eclint`. The 4th step is named `Run eclint`. "}
{"id": "63c4951b8052faa2781af857", "level": "level2", "llm_response": "```yaml\nname: Docs Build\n\non:\n  push:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  docs-build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v2\n\n    - name: Set node version to 16\n      uses: actions/setup-node@v2\n      with:\n        node-version: '16'\n\n    - name: Install deps\n      run: npm install\n\n    - name: Build docs\n      run: npm run docs:build\n\n    - name: Deploy to GitHub Pages\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: ./docs/build\n```", "answer": "```yaml name: Docs Build\n\non:\n  # allows to manually run the job at any time\n  workflow_dispatch:\n  \n  # run on every push on the master branch\n  push:\n    branches:\n      - master\n\njobs:\n  docs-build:\n    timeout-minutes: 10\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Install deps\n        run: |\n          npm install vuepress -D\n          npm install macaca-ecosystem -D\n\n      - name: Build docs\n        run: npm run docs:build\n\n      - name: Deploy to GitHub Pages\n        if: success()\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs_dist\n```", "prompt": "Generate a GitHub Workflow named `Docs Build` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `docs-build`. The job `docs-build` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set node version to 16`. The 3rd step is named `Install deps`. The 4th step is named `Build docs`. The 5th step is named `Deploy to GitHub Pages`. "}
{"id": "63c494027843b612699fe5e4", "level": "level2", "llm_response": "```yaml\nname: CLA\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Run CLA check\n      run: echo \"Performing CLA check...\"\n```", "answer": "```yaml name: CLA\non: [pull_request]\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v1\n    - run: ./ci/check-cla.sh \"${{ github.event.pull_request.user.login }}\"\n```", "prompt": "Generate a GitHub Workflow named `CLA` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check`. The job `check` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c496831e3364807577b1f9", "level": "level2", "llm_response": "```yaml\nname: Fastlane Metadata\n\non:\n  push:\n    branches:\n      - main\n      - '[0-9]+\\.[0-9]+\\.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n  pull_request:\n    branches:\n      - main\n      - '[0-9]+\\.[0-9]+\\.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n\njobs:\n  validate:\n    id: validate\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n\n  play-store-upload:\n    id: play-store-upload\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: Step 4\n        run: echo \"Step 4\"\n      - name: Step 5\n        run: echo \"Step 5\"\n      - name: Step 6\n        run: echo \"Step 6\"\n```", "answer": "```yaml name: Fastlane Metadata\non:\n  push:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n  pull_request:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n\njobs:\n  validate:\n    name: Validate\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    steps:\n      - uses: actions/checkout@v3\n      - uses: ashutoshgngwr/validate-fastlane-supply-metadata@v2\n        with:\n          usePlayStoreLocales: true\n\n  play-store-upload:\n    name: Play Store Upload\n    needs: validate\n    if: github.event_name == 'push'\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    steps:\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n      - uses: actions/checkout@v3\n      - run: bundle install\n      - run: echo \"$SERVICE_ACCOUNT_KEY\" > service-account-key.json\n        env:\n          SERVICE_ACCOUNT_KEY: ${{ secrets.SERVICE_ACCOUNT_KEY }}\n      - run: bundle exec fastlane upload_metadata\n      - if: ${{ always() }}\n        run: rm -f service-account-key.json\n```", "prompt": "Generate a GitHub Workflow named `Fastlane Metadata` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of push event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of pull_request event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. The workflow has 2 jobs. The 1st job is named `Validate` and its job id is `validate`. The job `validate` has 2 steps. The 1st step is named ``. The 2nd step is named ``. The 2nd job is named `Play Store Upload` and its job id is `play-store-upload`. The job `play-store-upload` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named ``. "}
{"id": "63c496701e3364807577aa6c", "level": "level2", "llm_response": "```yaml\nname: dds-rtps\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  Linux:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: checkout OpenDDS\n      run: git clone https://github.com/objectcomputing/OpenDDS.git\n\n    - name: checkout dds-rtps\n      run: git clone https://github.com/objectcomputing/dds-rtps.git\n\n    - name: checkout ACE_TAO\n      run: git clone https://github.com/objectcomputing/ACE_TAO.git\n\n    - name: get ACE_TAO commit\n      run: echo \"ACE_TAO_COMMIT=$(git -C ACE_TAO rev-parse HEAD)\" >> $GITHUB_ENV\n\n    - name: get compiler version\n      run: echo \"COMPILER_VERSION=$(gcc --version | head -n 1)\" >> $GITHUB_ENV\n\n    - name: checkout MPC\n      run: git clone https://github.com/objectcomputing/MPC.git\n\n    - name: configure OpenDDS\n      run: cd OpenDDS && ./configure --prefix=/usr/local\n\n    - name: build OpenDDS\n      run: cd OpenDDS && make -j4\n\n    - name: build shape_main\n      run: cd dds-rtps && make shape_main\n\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v2\n      with:\n        name: shape_main\n        path: dds-rtps/shape_main\n```", "answer": "```yaml name: \"omg-dds/dds-rtps\"\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n\n  Linux:\n    runs-on: ubuntu-20.04\n    steps:\n    - name: checkout OpenDDS\n      uses: actions/checkout@v3\n      with:\n        path: OpenDDS\n        submodules: true\n    - name: checkout dds-rtps\n      uses: actions/checkout@v3\n      with:\n        repository: omg-dds/dds-rtps\n        path: dds-rtps\n    - name: checkout ACE_TAO\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/ACE_TAO\n        ref: Latest_Micro\n        path: OpenDDS/ACE_TAO\n    - name: get ACE_TAO commit\n      shell: bash\n      run: |\n        cd OpenDDS/ACE_TAO\n        export ACE_COMMIT=$(git rev-parse HEAD)\n        echo \"ACE_COMMIT=$ACE_COMMIT\" >> $GITHUB_ENV\n    - name: get compiler version\n      shell: bash\n      run: |\n        export COMPILER_VERSION=$(g++ --version 2>&1 | head -n 1)\n        echo \"COMPILER_VERSION=$COMPILER_VERSION\" >> $GITHUB_ENV\n    - name: checkout MPC\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/MPC\n        path: OpenDDS/ACE_TAO/ACE/MPC\n    - name: configure OpenDDS\n      run: |\n        cd OpenDDS\n        ./configure --optimize --no-debug --static --no-inline\n        tools/scripts/show_build_config.pl\n    - uses: ammaraskar/gcc-problem-matcher@0.1\n    - name: build OpenDDS\n      shell: bash\n      run: |\n        cd OpenDDS\n        make -j4 OpenDDS_Rtps_Udp\n    - name: build shape_main\n      shell: bash\n      run: |\n        cd dds-rtps/srcCxx\n        . ../../OpenDDS/setenv.sh\n        mwc.pl -type gnuace\n        make -sj4\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: ${{ github.job }}_artifact\n        path: dds-rtps/srcCxx/shape_main\n```", "prompt": "Generate a GitHub Workflow named `omg-dds/dds-rtps` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `Linux`. The job `Linux` has 11 steps. The 1st step is named `checkout OpenDDS`. The 2nd step is named `checkout dds-rtps`. The 3rd step is named `checkout ACE_TAO`. The 4th step is named `get ACE_TAO commit`. The 5th step is named `get compiler version`. The 6th step is named `checkout MPC`. The 7th step is named `configure OpenDDS`. The 8th step is named ``. The 9th step is named `build OpenDDS`. The 10th step is named `build shape_main`. The 11th step is named `upload shape_main artifact`. "}
{"id": "63c495277843b61269a05c66", "level": "level2", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Dart\n        uses: dart-lang/setup-dart@v1\n        with:\n          sdk-version: '2.12'\n\n      - name: Removing example folder\n        run: rm -rf example\n\n      - name: Install dependencies\n        run: dart pub get\n\n      - name: Check format\n        run: dart format --set-exit-if-changed .\n\n      - name: Generate\n        run: dart run build_runner build\n\n      - name: Analyze\n        run: dart analyze\n\n      - name: Run tests\n        run: dart test\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    # runs the CI everyday at 10AM\n    - cron: \"0 10 * * *\"\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        package:\n          - packages/freezed\n          - packages/freezed_annotation\n        channel:\n          - master\n          - stable\n        dependencies:\n          - get\n          - downgrade\n        exclude:\n          - channel: master\n            dependencies: downgrade\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: subosito/flutter-action@v2\n        with:\n          channel: ${{ matrix.channel }}\n          cache: ${{ matrix.channel == 'stable' }}\n\n      # It is executed separately\n      - name: Removing example folder\n        run: rm -rf example\n        working-directory: ${{ matrix.package }}\n\n      - name: Install dependencies\n        run: |\n          flutter pub ${{ matrix.dependencies }}\n        working-directory: ${{ matrix.package }}\n\n      - name: Check format\n        # Check format only on master\n        if: matrix.channel == 'master'\n        run: flutter format --set-exit-if-changed .\n        working-directory: ${{ matrix.package }}\n\n      - name: Generate\n        run: |\n          if grep -q build_runner \"pubspec.yaml\"; then\n            flutter pub run build_runner build --delete-conflicting-outputs\n          fi\n        working-directory: ${{ matrix.package }}\n\n      - name: Analyze\n        run: flutter analyze\n        working-directory: ${{ matrix.package }}\n\n      - name: Run tests\n        run: |\n          if grep -q \"name: example\" \"pubspec.yaml\"; then\n            flutter test\n          else\n            dart test\n          fi\n        working-directory: ${{ matrix.package }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `freezed`. The job `freezed` has 8 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Removing example folder`. The 4th step is named `Install dependencies`. The 5th step is named `Check format`. The 6th step is named `Generate`. The 7th step is named `Analyze`. The 8th step is named `Run tests`. "}
{"id": "63c4968933b087f6bde2ca37", "level": "level2", "llm_response": "```yaml\nname: e2e-kind-upgrades\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n    steps:\n    - name: ''\n      run: |\n        # Add your first step commands here\n    - name: Mount bazel cache\n      run: |\n        # Add your second step commands here\n    - name: End-to-end (k3d)\n      run: |\n        # Add your third step commands here\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: e2e-kind-upgrades\n\non:\n  # Triggers the workflow on push or pull request events but only for the master branch\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: End-to-end (k3d)\n        run: make test/e2e/k3d-upgrades\n```", "prompt": "Generate a GitHub Workflow named `e2e-kind-upgrades` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. 3) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `e2e-kind-upgrades`. The job `e2e-kind-upgrades` has 3 steps. The 1st step is named ``. The 2nd step is named `Mount bazel cache`. The 3rd step is named `End-to-end (k3d)`. "}
{"id": "63c494147843b612699fedb4", "level": "level2", "llm_response": "```yaml\nname: test-chart-testing-action\n\non:\n  pull_request:\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Install chart-testing\n      run: |\n        wget https://github.com/helm/chart-testing/releases/download/v3.3.0/chart-testing_3.3.0_linux_amd64.tar.gz\n        tar -zxvf chart-testing_3.3.0_linux_amd64.tar.gz\n        mv chart-testing /usr/local/bin/\n\n    - name: Check install!\n      run: ct version\n\n    - name: Check root directory\n      run: ls -la\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Install chart-testing\n      run: |\n        wget https://github.com/helm/chart-testing/releases/download/v3.3.0/chart-testing_3.3.0_linux_amd64.tar.gz\n        tar -zxvf chart-testing_3.3.0_linux_amd64.tar.gz\n        mv chart-testing /usr/local/bin/\n\n    - name: Check install!\n      run: ct version\n\n    - name: Check root directory\n      run: ls -la\n```", "answer": "```yaml name: test-chart-testing-action\n\non: [pull_request]\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n\n    name: Install chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.7.1' ]]; then\n          echo 'should be v3.7.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n\n    name: Install Custom chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n      with:\n        version: 'v3.5.1'\n        yamllint_version: '1.27.1'\n        yamale_version: '3.0.4'\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.5.1' ]]; then\n          echo 'should be v3.5.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n```", "prompt": "Generate a GitHub Workflow named `test-chart-testing-action` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Install chart-testing and test presence in path` and its job id is `test_ct_action`. The job `test_ct_action` has 4 steps. The 1st step is named ``. The 2nd step is named `Install chart-testing`. The 3rd step is named `Check install!`. The 4th step is named `Check root directory`. The 2nd job is named `Install Custom chart-testing and test presence in path` and its job id is `test_ct_action_custom`. The job `test_ct_action_custom` has 4 steps. The 1st step is named ``. The 2nd step is named `Install chart-testing`. The 3rd step is named `Check install!`. The 4th step is named `Check root directory`. "}
{"id": "63c494fc8052faa2781aead3", "level": "level2", "llm_response": "```yaml\nname: Update Release List\n\non:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [completed]\n    branches: [master]\n\npermissions:\n  contents: write\n\nenv:\n  USER_NAME: \"ctags-win32 CI\"\n  USER_EMAIL: \"ctags-win32-ci@users.noreply.github.com\"\n  COL_RED: \"\u001b[31m\"\n  COL_GREEN: \"\u001b[32m\"\n  COL_YELLOW: \"\u001b[33m\"\n  COL_RESET: \"\u001b[m\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Step 1\n      run: echo \"Step 1\"\n\n    - name: Step 2\n      run: echo \"Step 2\"\n\n    - name: Update Release List\n      run: echo \"Updating release list\"\n```", "answer": "```yaml name: Update Release List\n\non:\n  #release:\n  #  types: [published]\n  workflow_run:\n    workflows: [\"Build\"]\n    branches: [master]\n    types: [completed]\n\npermissions:\n  contents: write # to update wiki\n\nenv:\n  # Account for committing\n  USER_NAME: \"ctags-win32 CI\"\n  USER_EMAIL: \"ctags-win32-ci@users.noreply.github.com\"\n\n  # Escape sequences\n  COL_RED: \"\\x1b[31m\"\n  COL_GREEN: \"\\x1b[32m\"\n  COL_YELLOW: \"\\x1b[33m\"\n  COL_RESET: \"\\x1b[m\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        path: main\n\n    - uses: actions/checkout@v3\n      with:\n        repository: \"${{ github.repository }}.wiki\"\n        path: wiki\n\n    - name: Update Release List\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      run: |\n        cd main\n        latest=$(cat ctagsver.txt)\n        cd ../wiki\n        ../main/scripts/update-release-list.py\n        git add Releases-in-*.md\n        if git diff HEAD --quiet; then\n          echo ${COL_YELLOW}No updates.${COL_RESET}\n        else\n          git config --local user.name ${USER_NAME}\n          git config --local user.email ${USER_EMAIL}\n          git commit -a -m \"Update Release List to ${latest}\"\n          git push origin HEAD\n        fi\n```", "prompt": "Generate a GitHub Workflow named `Update Release List` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the workflow named Build is completed on a branch whose name matches master. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets 6 environment variables to use: `USER_NAME` is set to `ctags-win32 CI`, `USER_EMAIL` is set to `ctags-win32-ci@users.noreply.github.com`, `COL_RED` is set to `\u001b[31m`, `COL_GREEN` is set to `\u001b[32m`, `COL_YELLOW` is set to `\u001b[33m` and `COL_RESET` is set to `\u001b[m`. The workflow has one job. The job id of the 1st job is `update`. The job `update` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Update Release List`. "}
{"id": "63c4969c1899db58864d4153", "level": "level2", "llm_response": "```yaml\nname: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    id: backend-tests\n    runs-on: ubuntu-latest\n    steps:\n      # Add backend server tests steps here\n\n  frontend-tests:\n    id: frontend-tests\n    runs-on: ubuntu-latest\n    steps:\n      # Add frontend and end-to-end tests steps here\n\n  build-release:\n    id: build-release\n    runs-on: ubuntu-latest\n    steps:\n      # Add build tagged release steps here\n\n  notify-discord:\n    id: notify-discord\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        # Add Discord notification steps here\n\n  deploy-demo:\n    id: deploy-demo\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clean and Deploy Demo\n        # Add clean and deploy demo steps here\n```", "answer": "```yaml name: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    name: \"Backend Server Tests\"\n    uses: ./.github/workflows/partial-backend.yml\n\n  frontend-tests:\n    name: \"Frontend and End-to-End Tests\"\n    uses: ./.github/workflows/partial-frontend.yml\n\n  build-release:\n    name: Build Tagged Release\n    uses: ./.github/workflows/partial-builder.yml\n    needs:\n      - frontend-tests\n      - backend-tests\n    with:\n      tag: nightly\n    secrets:\n      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}\n      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}\n\n  notify-discord:\n    name: Notify Discord\n    needs:\n      - build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        env:\n          DISCORD_WEBHOOK: ${{ secrets.DISCORD_NIGHTLY_WEBHOOK }}\n        uses: Ilshidur/action-discord@0.3.2\n        with:\n          args: \"\ud83d\ude80  A New build of mealie:api-nightly and mealie:frontend-nightly is available\"\n\n  deploy-demo:\n    runs-on: ubuntu-latest\n    name: Deploy Demo\n    needs:\n      - build-release\n    steps:\n      - name: Clean and Deploy Demo\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.DEMO_SERVER_IP }}\n          username: ${{ secrets.DEMO_SERVER_USER }}\n          key: ${{ secrets.DEMO_SERVER_SSH_KEY }}\n          port: ${{ secrets.DEMO_SERVER_PORT }}\n          script_stop: true\n          script: |\n            cd ~/docker/mealie-next\n            docker-compose pull\n            docker-compose down -v\n            docker-compose up -d\n```", "prompt": "Generate a GitHub Workflow named `Docker Nightly Production` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named mealie-next. Only a single workflow using the nightly-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 5 jobs. The 1st job is named `Backend Server Tests` and its job id is `backend-tests`. The 2nd job is named `Frontend and End-to-End Tests` and its job id is `frontend-tests`. The 3rd job is named `Build Tagged Release` and its job id is `build-release`. The 4th job is named `Notify Discord` and its job id is `notify-discord`. The job `notify-discord` has one step. The 1st step is named `Discord notification`. The 5th job is named `Deploy Demo` and its job id is `deploy-demo`. The job `deploy-demo` has one step. The 1st step is named `Clean and Deploy Demo`. "}
{"id": "63c494037843b612699fe649", "level": "level2", "llm_response": "```yaml\nname: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version'\n        required: true\n      tag:\n        description: 'Tag'\n        required: true\n        default: 'latest'\n\npermissions:\n  contents: write\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Setup Node\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Update tag\n      run: echo \"Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}\"\n```", "answer": "```yaml name: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: Version\n        required: true\n      tag:\n        description: Tag\n        default: latest\n        required: true\n\npermissions: {}\njobs:\n  build:\n    name: Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}\n    environment: release\n    runs-on: ubuntu-latest\n    steps:\n    - name: Setup Node\n      uses: actions/setup-node@v3\n    - name: Update tag\n      env:\n        \"npm_config_//registry.npmjs.org/:_authToken\": ${{ secrets.NPM_TOKEN }}\n      run: |\n        npm dist-tag add pnpm@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n        npm dist-tag add @pnpm/exe@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n```", "prompt": "Generate a GitHub Workflow named `Tag` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives 2 inputs: version-this input represents version and it must be supplied; tag-this input represents tag, its default value is latest and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: the workflow disables permissions for the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}` and its job id is `build`. The job `build` has 2 steps. The 1st step is named `Setup Node`. The 2nd step is named `Update tag`. "}
{"id": "63c4949a8052faa2781ac0b0", "level": "level2", "llm_response": "```yaml\nname: Node.js CI\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [14.x, 16.x, 18.x]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v2\n      with:\n        node-version: ${{ matrix.node-version }}\n\n    - name: Cache pnpm modules\n      uses: actions/cache@v2\n      with:\n        path: ~/.pnpm-store\n        key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}\n        restore-keys: |\n          ${{ runner.os }}-pnpm-\n\n    - name: Install dependencies\n      run: pnpm install\n\n    - name: Run tests\n      run: pnpm test\n\n    - name: Build project\n      run: pnpm run build\n```", "answer": "```yaml # This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Node.js CI\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: Cache pnpm modules\n        uses: actions/cache@v3\n        env:\n          cache-name: cache-pnpm-modules\n        with:\n          path: ~/.pnpm-store\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n      - uses: actions/cache@v3\n        with:\n          path: |\n            ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}\n          restore-keys: |\n            ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-\n      - uses: pnpm/action-setup@v2.2.4\n        with:\n          version: 7.x.x\n          run_install: true\n      - name: Build project\n        run: |\n          yarn build\n          yarn lint\n        env:\n          CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node.js CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named `Use Node.js ${{ matrix.node-version }}`. The 3rd step is named `Cache pnpm modules`. The 4th step is named ``. The 5th step is named ``. The 6th step is named `Build project`. "}
{"id": "63c4967e1899db58864d33dd", "level": "level2", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n  pull_request_target:\n    types: [opened, edited, synchronize]\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    id: lint-commit-message\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Commit Message\n        run: echo \"Commit message check\"\n      - name: File names\n        run: echo \"File names check\"\n      - name: Functions\n        run: echo \"Functions check\"\n      - name: Logging messages should not have trailing newlines\n        run: echo \"Logging messages check\"\n\n  lint-go:\n    id: lint-go\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: golangci-lint\n        run: echo \"golangci-lint check\"\n```", "answer": "```yaml #\n# DO NOT EDIT THIS FILE\n#\n# It is automatically copied from https://github.com/pion/.goassets repository.\n# If this repository should have package specific CI config,\n# remove the repository name from .goassets/.github/workflows/assets-sync.yml.\n#\n# If you want to update the shared CI config, send a PR to\n# https://github.com/pion/.goassets instead of this repository.\n#\n\nname: Lint\non:\n  pull_request:\n    types:\n      - opened\n      - edited\n      - synchronize\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    name: Metadata\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n        - uses: actions/checkout@v3\n          with:\n            fetch-depth: 0\n\n        - name: Commit Message\n          run: .github/lint-commit-message.sh\n\n        - name: File names\n          run: .github/lint-filename.sh\n\n        - name: Functions\n          run: .github/lint-disallowed-functions-in-library.sh\n\n        - name: Logging messages should not have trailing newlines\n          run: .github/lint-no-trailing-newline-in-log-messages.sh\n\n  lint-go:\n    name: Go\n    permissions:\n      contents: read\n      pull-requests: read\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: golangci-lint\n        uses: golangci/golangci-lint-action@v3\n        with:\n          version: v1.45.2\n          args: $GOLANGCI_LINT_EXRA_ARGS\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created, the title or body of a pull request is edited or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `Metadata` and its job id is `lint-commit-message`. The job `lint-commit-message` has 5 steps. The 1st step is named ``. The 2nd step is named `Commit Message`. The 3rd step is named `File names`. The 4th step is named `Functions`. The 5th step is named `Logging messages should not have trailing newlines`. The 2nd job is named `Go` and its job id is `lint-go`. The job `lint-go` has 2 steps. The 1st step is named ``. The 2nd step is named `golangci-lint`. "}
{"id": "63c4947b8052faa2781ab631", "level": "level2", "llm_response": "```yaml\nname: Publish Test Results\n\non:\n  workflow_run:\n    workflows: [\"CI\"]\n    types: [completed]\n\njobs:\n  test-results:\n    id: test-results\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Download and Extract Artifacts\n      run: |\n        # Add your commands to download and extract artifacts here\n        echo \"Downloading and extracting artifacts...\"\n\n    - name: Publish Test Results\n      run: |\n        # Add your commands to publish test results here\n        echo \"Publishing test results...\"\n```", "answer": "```yaml # Publishing of unit test results has to be a separate workflow in order to support forked PRs\n# See https://github.com/EnricoMi/publish-unit-test-result-action#support-fork-repositories-and-dependabot-branches\nname: Publish Test Results\non:\n  workflow_run:\n    workflows: [CI]\n    types:\n      - completed\njobs:\n  test-results:\n    name: Test Results\n    runs-on: ubuntu-latest\n    if: github.event.workflow_run.conclusion != 'skipped'\n\n    steps:\n      - name: Download and Extract Artifacts\n        env:\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n        run: |\n          mkdir -p artifacts && cd artifacts\n\n          artifacts_url=${{ github.event.workflow_run.artifacts_url }}\n\n          gh api \"$artifacts_url\" -q '.artifacts[] | [.name, .archive_download_url] | @tsv' | while read artifact\n          do\n            IFS=$'\\t' read name url <<< \"$artifact\"\n            gh api $url > \"$name.zip\"\n            unzip -d \"$name\" \"$name.zip\"\n          done\n\n      - name: Publish Test Results\n        uses: EnricoMi/publish-unit-test-result-action@v2\n        with:\n          commit: ${{ github.event.workflow_run.head_sha }}\n          event_file: artifacts/Event File/event.json\n          event_name: ${{ github.event.workflow_run.event }}\n          junit_files: |\n            artifacts/**/surefire-reports/*.xml\n            artifacts/**/failsafe-reports/TEST-*.xml\n```", "prompt": "Generate a GitHub Workflow named `Publish Test Results` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: the workflow named CI is completed. The workflow has one job. The 1st job is named `Test Results` and its job id is `test-results`. The job `test-results` has 2 steps. The 1st step is named `Download and Extract Artifacts`. The 2nd step is named `Publish Test Results`. "}
{"id": "63c4964a1e33648075779a84", "level": "level2", "llm_response": "```yaml\nname: Publish Terminal.Gui\n\non:\n  push:\n    tags:\n      - v*\n\njobs:\n  publish:\n    id: publish\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Install and calculate the new version with GitVersion\n      uses: gittools/actions/gitversion@v0.9.8\n      with:\n        outputFormat: json\n\n    - name: Determine Version\n      id: gitversion\n      run: echo \"::set-output name=version::$(jq -r '.GitVersion.FullSemVer' $GITHUB_WORKSPACE/gitversion.json)\"\n\n    - name: Display GitVersion outputs\n      run: cat $GITHUB_WORKSPACE/gitversion.json\n\n    - name: Setup dotnet\n      uses: actions/setup-dotnet@v1\n      with:\n        dotnet-version: '3.1.100'\n\n    - name: Install dependencies\n      run: dotnet restore\n\n    - name: Build Release\n      run: dotnet build --configuration Release --no-restore\n\n    - name: Pack\n      run: dotnet pack --configuration Release --no-restore --no-build --output ./artifacts\n\n    - name: Test to generate Code Coverage Report\n      run: dotnet test --configuration Release --no-restore --no-build --logger \"coverlet;format=opencover;output=coverage.opencover.xml\"\n\n    - name: Create Test Coverage Badge\n      id: create_coverage_badge\n      run: |\n        bash <(curl -s https://codecov.io/bash) -f coverage.opencover.xml -o coverage.svg -t ${{ secrets.CODECOV_TOKEN }}\n\n    - name: Print Code Coverage\n      run: cat coverage.svg\n\n    - name: Publish to NuGet.org\n      run: dotnet nuget push ./artifacts/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json\n```", "answer": "```yaml name: Publish Terminal.Gui\non:\n  push:\n    tags:\n      - v*\n\njobs:\n\n  publish:\n    name: Build and Publish to Nuget.org\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0 #fetch-depth is needed for GitVersion\n\n    - name: Install and calculate the new version with GitVersion \n      uses: gittools/actions/gitversion/setup@v0.9.13\n      with:\n        versionSpec: 5.x\n\n    - name: Determine Version\n      uses: gittools/actions/gitversion/execute@v0.9.13\n      id: gitversion # step id used as reference for output values\n\n    - name: Display GitVersion outputs\n      run: |\n        echo \"Version: ${{ steps.gitversion.outputs.SemVer }}\"\n        echo \"CommitsSinceVersionSource: ${{ steps.gitversion.outputs.CommitsSinceVersionSource }}\"\n\n    - name: Setup dotnet\n      uses: actions/setup-dotnet@v3.0.1\n      with:\n        dotnet-version: 6.0.100\n\n    - name: Install dependencies\n      run: dotnet restore\n\n    - name: Build Release\n      run: |\n        dotnet-gitversion /updateprojectfiles\n        dotnet build --no-restore -c Release\n\n    - name: Pack\n      run: dotnet pack -c Release --include-symbols -p:Version='${{ steps.gitversion.outputs.SemVer }}' \n\n    - name: Test to generate Code Coverage Report\n      run: |\n        dotnet test --verbosity normal --collect:\"XPlat Code Coverage\" --settings UnitTests/coverlet.runsettings\n        mv -v UnitTests/TestResults/*/*.* UnitTests/TestResults/\n\n    - name: Create Test Coverage Badge\n      uses: simon-k/dotnet-code-coverage-badge@v1.0.0\n      id: create_coverage_badge\n      with:\n        label: Unit Test Coverage\n        color: brightgreen\n        path: UnitTests/TestResults/coverage.opencover.xml\n        gist-filename: code-coverage.json\n        # https://gist.github.com/migueldeicaza/90ef67a684cb71db1817921a970f8d27\n        gist-id: 90ef67a684cb71db1817921a970f8d27\n        gist-auth-token: ${{ secrets.GIST_AUTH_TOKEN }}   \n\n    - name: Print Code Coverage\n      run: |\n        echo \"Code coverage percentage: ${{steps.create_coverage_badge.outputs.percentage}}%\"\n        echo \"Badge data: ${{steps.create_coverage_badge.outputs.badge}}\"\n        \n    #- name: Prep GitHub Packages\n    #  run: dotnet nuget add source --username tig --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/tig/index.json\"\n\n    #- name: Publish to GitHub packages \n    #  run: dotnet nuget push NStack/bin/Release/*.nupkg --api-key ${{ secrets.GITHUB_TOKEN }}  --source \"github\"\n\n    - name: Publish to NuGet.org\n      run: dotnet nuget push Terminal.Gui/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json\n```", "prompt": "Generate a GitHub Workflow named `Publish Terminal.Gui` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Build and Publish to Nuget.org` and its job id is `publish`. The job `publish` has 12 steps. The 1st step is named ``. The 2nd step is named `Install and calculate the new version with GitVersion`. The 3rd step is named `Determine Version` and its id is `gitversion`. The 4th step is named `Display GitVersion outputs`. The 5th step is named `Setup dotnet`. The 6th step is named `Install dependencies`. The 7th step is named `Build Release`. The 8th step is named `Pack`. The 9th step is named `Test to generate Code Coverage Report`. The 10th step is named `Create Test Coverage Badge` and its id is `create_coverage_badge`. The 11th step is named `Print Code Coverage`. The 12th step is named `Publish to NuGet.org`. "}
{"id": "63c4950a7843b61269a0501c", "level": "level2", "llm_response": "```yaml\nname: Integration test on schedule (minimal)\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false\n\njobs:\n  start-integration-test-minimal:\n    id: start-integration-test-minimal\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Run integration tests\n        run: npm test integration\n```", "answer": "```yaml name: Integration test on schedule (minimal)\nconcurrency: ${{ github.workflow }}-${{ github.ref }}\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  start-integration-test-minimal:\n    name: Start integration test (minimal)\n    uses: ./.github/workflows/integration.yml\n    secrets: inherit\n    with:\n      install_profile: minimal\n      cluster_region: ams3\n      kubernetes_versions: \"['1.22', '1.23']\"\n```", "prompt": "Generate a GitHub Workflow named `Integration test on schedule (minimal)` for a GitHub repository whose primary programming language is Mustache. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Start integration test (minimal)` and its job id is `start-integration-test-minimal`. "}
{"id": "63c494b08052faa2781aca76", "level": "level2", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v1\n      with:\n        languages: objc\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v1\n```", "answer": "```yaml name: 'CodeQL'\n\non:\n  push:\n    branches: [master]\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: macos-11\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: ['cpp']\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n        with:\n          languages: ${{ matrix.language }}\n\n      - run: >-\n          env NSUnbufferedIO=YES\n          xcodebuild\n          -workspace Sentry.xcworkspace\n          -scheme Sentry\n          -configuration Release\n          -destination platform=\"iOS Simulator,OS=latest,name=iPhone 11 Pro\"\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 04:40 am, only on saturday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named ``. The 4th step is named `Perform CodeQL Analysis`. "}
{"id": "63c496891e3364807577b43d", "level": "level2", "llm_response": "```yaml\nname: Check Actions rate limit\n\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check rate limit\n        run: echo \"Rate limit check\"\n```", "answer": "```yaml name: Check Actions rate limit\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    name: Check Actions rate limit\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check rate limit\n        env:\n          TOKEN: ${{ github.token }}\n        run: |\n          curl -v --no-progress-meter --header \"Authorization: Bearer $TOKEN\" https://api.github.com/rate_limit\n```", "prompt": "Generate a GitHub Workflow named `Check Actions rate limit` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Check Actions rate limit` and its job id is `check`. The job `check` has one step. The 1st step is named `Check rate limit`. "}
{"id": "63c4969e1899db58864d41ee", "level": "level2", "llm_response": "```yaml\nname: Auto message on Creating Issue\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Create comment for issue\n      run: echo \"Hello! Thank you for opening this issue. We will get back to you soon.\" | gh issue comment ${{ github.event.issue.number }} --repo ${{ github.repository }}\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Auto message on Creating Issue.\n\non:\n\n  issues:\n\n    types: [opened]\n\njobs:\n\n  greeting:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - name: Create comment for issue\n\n      if: github.event_name =='issues' \n\n      uses: peter-evans/create-or-update-comment@v1\n\n      with:\n\n        issue-number: ${{tojson(github.event.issue.number)}}\n\n        body: |\n\n            Hi \ud83d\ude04, @${{ github.actor }} Thanks for creating an issue at FunwithPhysics. We request you to follow the contributing guidelines. \n```", "prompt": "Generate a GitHub Workflow named `Auto message on Creating Issue.` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `greeting`. The job `greeting` has one step. The 1st step is named `Create comment for issue`. "}
{"id": "63c496941899db58864d3d85", "level": "level2", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run release-please\n        run: npx release-please --language=swift --release-type=swift --bump-minor-prs=true --bump-patch-prs=true\n```", "answer": "```yaml name: release-please\non:\n   push:\n      branches:\n         - master\njobs:\n   release-please:\n      runs-on: ubuntu-latest\n      steps:\n         - uses: GoogleCloudPlatform/release-please-action@v2\n           with:\n            token: ${{ secrets.GITHUB_TOKEN }}\n            release-type: simple\n            version-file: \"./version.txt\"\n            package-name: release-please-action\n            default-branch: master\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is Swift. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. The job `release-please` has one step. The 1st step is named ``. "}
{"id": "63c496486fc19abdf9c9b0d5", "level": "level2", "llm_response": "```yaml\nname: Dependencies\n\non:\n  schedule:\n    - cron: '0 12 * * 1'\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    id: upgrade\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Upgrade dependencies\n        run: npm update\n      - name: Run tests\n        run: npm test\n      - name: Commit and push changes\n        run: |\n          git config --global user.name 'github-actions'\n          git config --global user.email 'github-actions@github.com'\n          git add package.json package-lock.json\n          git commit -m 'chore: upgrade dependencies'\n          git push\n```", "answer": "```yaml name: Dependencies\n\non:\n  schedule:\n    - cron: \"0 12 * * 1\"\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    name: Upgrade dependencies\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2\n        with:\n          version: latest\n      - uses: actions/setup-node@v3\n        with:\n          cache: \"pnpm\"\n          node-version-file: \".nvmrc\"\n          registry-url: \"https://npm.pkg.github.com\"\n      - run: rm -rf pnpm-lock.yaml **/node_modules/\n      - run: pnpm install\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_GITHUB_TOKEN }}\n      - uses: EndBug/add-and-commit@v9\n        with:\n          message: \"chore(deps): upgrade versions\"\n```", "prompt": "Generate a GitHub Workflow named `Dependencies` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 pm, only on monday. 2) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Upgrade dependencies` and its job id is `upgrade`. The job `upgrade` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named ``. "}
{"id": "63c4954d8052faa2781b0e83", "level": "level2", "llm_response": "```yaml\nname: xgo\n\non:\n  push:\n    branches:\n      - master\n    tags:\n      - 'v*'\n    paths-ignore:\n      - '**/*.md'\n  pull_request:\n    branches:\n      - master\n    paths-ignore:\n      - '**/*.md'\n\nconcurrency:\n  group: xgo-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v2\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v1\n\n    - name: Build artifacts\n      run: docker build -t my-image:latest .\n\n    - name: Move artifacts\n      run: mv /path/to/artifacts /path/to/new/location\n\n    - name: Upload artifacts\n      uses: actions/upload-artifact@v2\n      with:\n        name: my-artifact\n        path: /path/to/new/location\n\n    - name: GitHub Release\n      uses: actions/create-release@v1\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      with:\n        tag_name: ${{ github.ref }}\n        release_name: Release ${{ github.ref }}\n        draft: false\n        prerelease: false\n```", "answer": "```yaml name: xgo\n\nconcurrency:\n  group: xgo-${{ github.ref }}\n  cancel-in-progress: true\n\non:\n  push:\n    branches:\n      - 'master'\n    tags:\n      - 'v*'\n    paths-ignore:\n      - '**.md'\n  pull_request:\n    branches:\n      - 'master'\n    paths-ignore:\n      - '**.md'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n      -\n        name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      -\n        name: Build artifacts\n        uses: docker/bake-action@v2\n        with:\n          targets: artifact-all\n      -\n        name: Move artifacts\n        run: |\n          mv ./dist/**/* ./dist/\n      -\n        name: Upload artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: xgo\n          path: ./dist/*\n          if-no-files-found: error\n      -\n        name: GitHub Release\n        uses: softprops/action-gh-release@v1\n        if: startsWith(github.ref, 'refs/tags/v')\n        with:\n          draft: true\n          files: |\n            dist/*.tar.gz\n            dist/*.zip\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `xgo` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a tag whose name matches v*. When all the path names of push event match patterns in the paths-ignore filter(**.md), the workflow will not run. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. When all the path names of pull_request event match patterns in the paths-ignore filter(**.md), the workflow will not run. Only a single workflow using the xgo-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Docker Buildx`. The 3rd step is named `Build artifacts`. The 4th step is named `Move artifacts`. The 5th step is named `Upload artifacts`. The 6th step is named `GitHub Release`. "}
{"id": "63c494a48052faa2781ac54e", "level": "level2", "llm_response": "```yaml\nname: lint\n\non:\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - docs/**\n  push:\n    branches: [ main ]\n    paths-ignore:\n      - docs/**\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run cspell\n        run: npx cspell \"**/*\"\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install dependencies\n        run: npm install\n      - name: Run lint\n        run: npm run lint\n```", "answer": "```yaml name: lint\non: # rebuild any PRs and main branch changes\n  pull_request:\n    paths-ignore:\n      - \"docs/**\"\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - \"docs/**\"\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx cspell \"**\" --dot --no-progress\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: yarn\n      - run: yarn lint\n```", "prompt": "Generate a GitHub Workflow named `lint` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) When all the path names of pull_request event match patterns in the paths-ignore filter(docs/**), the workflow will not run. 2) The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**), the workflow will not run. The workflow has 2 jobs. The job id of the 1st job is `cspell`. The job `cspell` has 2 steps. The 1st step is named ``. The 2nd step is named ``. The job id of the 2nd job is `lint`. The job `lint` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. "}
{"id": "63c4957d8052faa2781b229c", "level": "level2", "llm_response": "```yaml\nname: Build site nightly\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  dot-release:\n    id: dot-release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: curl\n        run: curl -X POST https://api.github.com/repos/username/repository/dispatches/events/build-site\n```", "answer": "```yaml # Copyright 2022 The Knative Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nname: Build site nightly\n\non:\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  dot-release:\n    name: dot-release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: curl\n        env:\n          NETLIFY_BUILD_HOOK: ${{ secrets.NETLIFY_BUILD_HOOK }}\n        uses: wei/curl@v1\n        with:\n          args: -X POST -d '{}' \"$NETLIFY_BUILD_HOOK\"\n```", "prompt": "Generate a GitHub Workflow named `Build site nightly` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `dot-release` and its job id is `dot-release`. The job `dot-release` has one step. The 1st step is named `curl`. "}
{"id": "63c496891e3364807577b43a", "level": "level2", "llm_response": "```yaml\nname: Jetpack block performance\n\non:\n  schedule:\n    - cron: '0 */12 * * *'\n\njobs:\n  block-performance:\n    id: block-performance\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n      - name: Step 2\n      - name: Step 3\n      - name: Build Gutenberg\n      - name: Step 5\n      - name: Setup tools for J\n      - name: Build Production Jetpack\n      - name: Environment set-up\n      - name: Run performance tests\n      - name: Environment tear-down\n      - name: Upload test artifacts\n\n  test-reports:\n    id: test-reports\n    runs-on: ubuntu-latest\n    steps:\n      - name: Repository Dispatch\n\n  slack-notification:\n    id: slack-notification\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n      - name: Set up tools\n      - name: Build action\n      - name: Send notification\n```", "answer": "```yaml name: Jetpack block performance\n\non:\n  schedule:\n    - cron:  '0 */12 * * *'\n\njobs:\n  block-performance:\n    name: \"Performance tests\"\n    runs-on: ubuntu-latest\n    timeout-minutes: 50  # 2021-12-13: Successful runs seem to take 40 minutes\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n\n      - uses: actions/checkout@v3\n        with:\n          repository: 'WordPress/gutenberg'\n          path: 'gutenberg'\n\n      - name: Build Gutenberg\n        working-directory: gutenberg\n        run: |\n          npm ci\n          npm run build\n\n      - uses: actions/cache@v3\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('gutenberg/**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - name: Setup tools for J\n        uses: ./.github/actions/tool-setup\n\n      - name: Build Production Jetpack\n        run: |\n          pnpm install\n          pnpm jetpack build plugins/jetpack -v --production\n\n      - name: Environment set-up\n        working-directory: tools/e2e-commons\n        env:\n          CONFIG_KEY: ${{ secrets.E2E_CONFIG_KEY }}\n        run: |\n          # Gutenberg Performance tests require disable-animations.php test plugin to be available on a site. Below we inject the mapping for that plugin into a Docker config file\n\n          echo \"e2e:\" >> ../docker/jetpack-docker-config.yml\n          echo \"  volumeMappings:\" >> ../docker/jetpack-docker-config.yml\n          echo \"    gutenberg/packages/e2e-tests/plugins/disable-animations.php: /var/www/html/wp-content/plugins/disable-animations.php\" >> ../docker/jetpack-docker-config.yml\n\n          mkdir results\n          pnpm config:decrypt\n          pnpm env:start\n\n      - name: Run performance tests\n        working-directory: tools/e2e-commons\n        run: |\n          node ./bin/performance.js\n\n      - name: Environment tear-down\n        if: ${{ always() }}\n        working-directory: tools/e2e-commons\n        continue-on-error: true\n        run: |\n          pnpm run tunnel:off\n          # Update permissions to workaround https://github.com/actions/cache/issues/753\n          sudo chown -R runner:docker \"$GITHUB_WORKSPACE/tools/docker\"\n\n      - name: Upload test artifacts\n        if: ${{ always() }}\n        continue-on-error: true\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-output-block-perf\n          path: tools/e2e-commons/results\n\n  test-reports:\n    name: \"Trigger test report workflow\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: block-performance\n\n    steps:\n      - name: Repository Dispatch\n        uses: peter-evans/repository-dispatch@v2\n        with:\n          token: ${{ secrets.E2E_TEST_REPORTS_TOKEN }}\n          repository: automattic/jetpack-e2e-reports\n          event-type: block-perf\n          client-payload: '{\"run_id\": \"${{github.run_id}}\", \"repository\": \"${{github.repository}}\"}'\n\n  slack-notification:\n    name: \"Slack notification\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: [block-performance]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up tools\n        uses: ./.github/actions/tool-setup\n\n      - name: Build action\n        env:\n          COMPOSER_ROOT_VERSION: dev-trunk\n        run: |\n          pnpm install\n          composer install\n          composer build-development\n        working-directory: ./projects/github-actions/test-results-to-slack\n\n      - name: \"Send notification\"\n        uses: ./projects/github-actions/test-results-to-slack\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          slack_token: ${{ secrets.SLACK_TOKEN }}\n          slack_channel: ${{ secrets.SLACK_E2E_CHANNEL }}\n          slack_icon_emoji: \":jetpack:\"\n          suite_name: \"blocks performance\"\n```", "prompt": "Generate a GitHub Workflow named `Jetpack block performance` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: the scheduled time has come: every 12 hours. The workflow has 3 jobs. The 1st job is named `Performance tests` and its job id is `block-performance`. The job `block-performance` has 11 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Build Gutenberg`. The 5th step is named ``. The 6th step is named `Setup tools for J`. The 7th step is named `Build Production Jetpack`. The 8th step is named `Environment set-up`. The 9th step is named `Run performance tests`. The 10th step is named `Environment tear-down`. The 11th step is named `Upload test artifacts`. The 2nd job is named `Trigger test report workflow` and its job id is `test-reports`. The job `test-reports` has one step. The 1st step is named `Repository Dispatch`. The 3rd job is named `Slack notification` and its job id is `slack-notification`. The job `slack-notification` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up tools`. The 3rd step is named `Build action`. The 4th step is named `Send notification`. "}
{"id": "63c4968633b087f6bde2c8ea", "level": "level2", "llm_response": "```yaml\nname: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - '[0-9]+.[0-9]+.[0-9]+'\n      - '[0-9]+.[0-9]+.[0-9]+rc[0-9]+'\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Install tox\n        run: |\n          python -m pip install tox\n\n      - name: Run tox\n        run: tox\n```", "answer": "```yaml name: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - \"[0-9]+.[0-9]+.[0-9]+\"\n      - \"[0-9]+.[0-9]+.[0-9]+rc[0-9]+\"\n\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment:\n          - \"py36\"\n          - \"py37\"\n          - \"flake8\"\n\n        include:\n          - environment: \"py36\"\n            python: \"3.6\"\n          - environment: \"py37\"\n            python: \"3.7\"\n          - environment: \"flake8\"\n            python: \"3.7\"\n\n    container:\n      image: python:${{ matrix.python }}\n\n    steps:\n      - uses: actions/checkout@master\n      - name: Install tox\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install tox\n      - name: Run tox\n        run: |\n          tox -e ${{ matrix.environment }}\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a tag whose name matches [0-9]+.[0-9]+.[0-9]+ or a tag whose name matches [0-9]+.[0-9]+.[0-9]+rc[0-9]+. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `tox`. The job `tox` has 3 steps. The 1st step is named ``. The 2nd step is named `Install tox`. The 3rd step is named `Run tox`. "}
{"id": "63c494187843b612699fef56", "level": "level2", "llm_response": "```yaml\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Enable debug mode'\n        required: false\n        default: false\n        type: boolean\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: true\n\njobs:\n  fork_update_pr:\n    id: fork_update_pr\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up environment\n        run: |\n          if [ \"${{ github.event_name }}\" == \"workflow_dispatch\" ] && [ \"${{ github.event.inputs.debug-the }}\" == \"true\" ]; then\n            set -x\n          fi\n```", "answer": "```yaml #\n#  Author: Hari Sekhon\n#  Date: Tue Feb 4 09:53:28 2020 +0000\n#\n#  vim:ts=2:sts=2:sw=2:et\n#\n#  https://github.com/HariSekhon/Kubernetes-configs\n#\n#  If you're using my code you're welcome to connect with me on LinkedIn and optionally send me feedback\n#\n#  https://www.linkedin.com/in/HariSekhon\n#\n\n---\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        required: false\n        default: false\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: false\n\njobs:\n  fork_update_pr:\n    # github.event.repository context not available in scheduled workflows\n    #if: github.event.repository.fork == true\n    if: github.repository_owner != 'HariSekhon'\n    name: Fork Update PR\n    uses: HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master\n    with:\n      debug: ${{ github.event.inputs.debug }}\n```", "prompt": "Generate a GitHub Workflow named `Fork Update PR` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, it is optional and its default value is False. 2) the scheduled time has come: at 10:00 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.ref }}-${{ github.workflow }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Fork Update PR` and its job id is `fork_update_pr`. "}
{"id": "63c494e67843b61269a04123", "level": "level2", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n    branches: [ '**' ]\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '2.5.3'\n\n    - name: Checkout OneSignal-Flutter-SDK\n      uses: actions/checkout@v2\n\n    - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n      run: flutter pub get\n\n    - name: Static Analysis\n      run: flutter analyze\n\n    - name: Ensure the Dart code is formatted correctly\n      run: flutter format --set-exit-if-changed .\n\n    - name: Run Flutter unit tests\n      run: flutter test\n```", "answer": "```yaml name: CI\non:\n  pull_request:\n    branches:\n      - '**'\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '2.10.4'\n          channel: 'stable'\n\n      - name: Checkout OneSignal-Flutter-SDK\n        uses: actions/checkout@v3\n\n      - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n        run: flutter pub get\n\n      - name: Static Analysis\n        run: flutter analyze\n\n      - name: Ensure the Dart code is formatted correctly\n        run: flutter format --set-exit-if-changed --dry-run .\n\n      - name: Run Flutter unit tests\n        run: flutter test\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch whose name matches **. When all the path names of pull_request event match patterns in the paths-ignore filter(.github/**, .vscode/** or README.md), the workflow will not run. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named `Setup Flutter`. The 2nd step is named `Checkout OneSignal-Flutter-SDK`. The 3rd step is named `Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6`. The 4th step is named `Static Analysis`. The 5th step is named `Ensure the Dart code is formatted correctly`. The 6th step is named `Run Flutter unit tests`. "}
{"id": "63c4957b8052faa2781b219f", "level": "level2", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - '**.go'\n  pull_request:\n    branches:\n      - main\n    paths:\n      - '**.go'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.16'\n      - name: Build\n        run: go build -v ./...\n      - name: Test\n        run: go test -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - '**.go'\n  pull_request:\n    branches: [ main ]\n    paths:\n      - '**.go'\n\njobs:\n\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: 1.18\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -cover -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(**.go), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. Only if at least one path of pull_request event matches a pattern in the paths filter(**.go), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Go`. The 3rd step is named `Build`. The 4th step is named `Test`. "}
{"id": "63c495928052faa2781b2bc1", "level": "level2", "llm_response": "```yaml\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Create Release\n      id: create_release\n      uses: actions/create-release@v1\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      with:\n        tag_name: ${{ github.ref }}\n        release_name: Release ${{ github.ref }}\n        draft: false\n        prerelease: false\n```", "answer": "```yaml \n# https://github.com/actions/create-release\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    name: Create Release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Create Release\n        id: create_release\n        uses: actions/create-release@latest\n        env:\n          GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: ${{ github.ref }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Create Release` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Create Release` and its job id is `build`. The job `build` has 2 steps. The 1st step is named `Checkout code`. The 2nd step is named `Create Release` and its id is `create_release`. "}
{"id": "63c496686fc19abdf9c9bea4", "level": "level2", "llm_response": "```yaml\nname: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update release draft\n        run: |\n          # Add your Scala-specific release draft update script here\n```", "answer": "```yaml name: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.ADMIN_GITHUB_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Drafts/updates the next repository release` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. The job `update_release_draft` has one step. The 1st step is named ``. "}
{"id": "63c494768052faa2781ab616", "level": "level2", "llm_response": "```yaml\nname: Static analysis\n\non:\n  pull_request:\n\njobs:\n  static-psalm-analysis:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ocp-version: [8.0, 8.1, 8.2]\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v2\n\n    - name: Set up PHP\n      uses: shivammathur/setup-php@v2\n      with:\n        php-version: ${{ matrix.ocp-version }}\n\n    - name: Install dependencies\n      run: composer install --no-interaction --prefer-dist\n\n    - name: Install dependencies\n      run: composer install --no-interaction --prefer-dist\n\n    - name: Run coding standards check\n      run: vendor/bin/php-cs-fixer fix --dry-run --config=.php_cs.dist\n```", "answer": "```yaml name: Static analysis\n\non: [pull_request]\n\njobs:\n  static-psalm-analysis:\n      runs-on: ubuntu-latest\n      strategy:\n          matrix:\n              ocp-version: [ 'v20.0.7', 'v21.0.0', 'dev-stable22', 'dev-stable23', 'dev-master' ]\n      name: Nextcloud ${{ matrix.ocp-version }}\n      steps:\n          - name: Checkout\n            uses: actions/checkout@master\n          - name: Set up php\n            uses: shivammathur/setup-php@master\n            with:\n                php-version: 7.4\n                tools: composer:v1\n                coverage: none\n          - name: Install dependencies\n            run: composer i\n          - name: Install dependencies\n            run: composer require --dev christophwurst/nextcloud:${{ matrix.ocp-version }}\n          - name: Run coding standards check\n            run: composer run psalm\n```", "prompt": "Generate a GitHub Workflow named `Static analysis` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Nextcloud ${{ matrix.ocp-version }}` and its job id is `static-psalm-analysis`. The job `static-psalm-analysis` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up php`. The 3rd step is named `Install dependencies`. The 4th step is named `Install dependencies`. The 5th step is named `Run coding standards check`. "}
{"id": "63c4951f8052faa2781af9e5", "level": "level2", "llm_response": "```yaml\nname: IRC Notification\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: irc push\n      run: echo \"Sending IRC notification...\"\n```", "answer": "```yaml name: \"IRC Notification\"\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: irc push\n        uses: vmiklos/notify-irc@bfd6f632b683859f6cd074e2ee9db68bef204f7d\n        if: github.event_name == 'push' && github.event.ref == 'refs/heads/master' && github.repository == 'CollaboraOnline/online'\n        with:\n          channel: \"#cool-dev\"\n          nickname: github-online\n          message: |\n            ${{ toJson(github.event) }}\n```", "prompt": "Generate a GitHub Workflow named `IRC Notification` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `test`. The job `test` has one step. The 1st step is named `irc push`. "}
{"id": "63c493ee7843b612699fde0c", "level": "level2", "llm_response": "```yaml\nname: nf-core AWS test\n\non:\n  workflow_dispatch:\n\njobs:\n  run-tower:\n    id: run-tower\n    runs-on: ubuntu-latest\n    steps:\n      - name: Launch workflow via tower\n        run: |\n          # Add your commands here to launch the workflow via tower\n```", "answer": "```yaml name: nf-core AWS test\n# This workflow can be triggered manually with the GitHub actions workflow dispatch button.\n# It runs the -profile 'test' on AWS batch\n\non:\n  workflow_dispatch:\njobs:\n  run-tower:\n    name: Run AWS tests\n    if: github.repository == 'nf-core/mag'\n    runs-on: ubuntu-latest\n    steps:\n      # Launch workflow using Tower CLI tool action\n      - name: Launch workflow via tower\n        uses: nf-core/tower-action@v3\n        with:\n          workspace_id: ${{ secrets.TOWER_WORKSPACE_ID }}\n          access_token: ${{ secrets.TOWER_ACCESS_TOKEN }}\n          compute_env: ${{ secrets.TOWER_COMPUTE_ENV }}\n          workdir: s3://${{ secrets.AWS_S3_BUCKET }}/work/mag/work-${{ github.sha }}\n          parameters: |\n            {\n              \"outdir\": \"s3://${{ secrets.AWS_S3_BUCKET }}/mag/results-test-${{ github.sha }}\"\n            }\n          profiles: test,aws_tower\n```", "prompt": "Generate a GitHub Workflow named `nf-core AWS test` for a GitHub repository whose primary programming language is Nextflow. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Run AWS tests` and its job id is `run-tower`. The job `run-tower` has one step. The 1st step is named `Launch workflow via tower`. "}
{"id": "63c496981899db58864d3f73", "level": "level2", "llm_response": "```yaml\nname: Triage tasks\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: triage-${{ github.event.number }}\n  cancel-in-progress: true\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check commit format\n        run: echo \"Checking commit format...\"\n      - name: Label pull request\n        run: echo \"Labeling pull request...\"\n```", "answer": "```yaml name: Triage tasks\n\non: pull_request_target\n\nconcurrency:\n  group: \"triage-${{ github.event.number }}\"\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check commit format\n        uses: Homebrew/actions/check-commit-format@master\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n      - name: Label pull request\n        uses: Homebrew/actions/label-pull-requests@master\n        if: always()\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n          def: |\n            - label: new cask\n              status: added\n              path: Casks/.+\n\n            - label: marked for removal/rejection\n              status: removed\n              path: Casks/.+\n\n            - label: documentation\n              path: (.*\\.md|\\.github/ISSUE_TEMPLATE/.*\\.yml)\n\n            - label: bump-cask-pr\n              pr_body_content: Created with `brew bump-cask-pr`\n\n            - label: missing description\n              path: Casks/.+\n              missing_content: \\n  desc .+\\n\n\n            - label: appcast migration needed\n              path: Casks/.+\n              content: \\n  appcast .+\\n\n```", "prompt": "Generate a GitHub Workflow named `Triage tasks` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the triage-${{ github.event.number }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `triage`. The job `triage` has 2 steps. The 1st step is named `Check commit format`. The 2nd step is named `Label pull request`. "}
{"id": "63c494a27843b61269a02781", "level": "level2", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 8 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Mark stale issues and pull requests\n        uses: actions/stale@v4\n        with:\n          days-before-issue-stale: 90\n          days-before-pull-request-stale: 90\n          stale-issue-message: 'This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs within 7 days.'\n          stale-pull-request-message: 'This pull request has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs within 7 days.'\n          days-before-issue-close: 7\n          days-before-pull-request-close: 7\n          only-label: 'stale'\n          exempt-issue-labels: 'important, pinned'\n          exempt-pull-request-labels: 'important, pinned'\n```", "answer": "```yaml # This workflow warns and then closes issues and PRs that have had no activity for a specified amount of time.\n#\n# You can adjust the behavior by modifying this file.\n# For more information, see:\n# https://github.com/actions/stale\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '16 8 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v5\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        ascending: true\n        stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-pr-message: 'This PR has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-issue-label: 'no-issue-activity'\n        stale-pr-label: 'no-pr-activity'\n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by an event: the scheduled time has come: at 08:16 am. The workflow has one job. The job id of the 1st job is `stale`. The job `stale` has one step. The 1st step is named ``. "}
{"id": "63c4963d6fc19abdf9c9abf2", "level": "level2", "llm_response": "```yaml\nname: Submit to Web Store\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Cache pnpm modules\n      uses: actions/cache@v2\n      with:\n        path: ~/.pnpm-store\n        key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}\n        restore-keys: |\n          ${{ runner.os }}-pnpm-\n\n    - name: Install dependencies\n      run: pnpm install\n\n    - name: Build and zip extension artifact\n      run: |\n        pnpm run build\n        zip -r extension.zip dist\n\n    - name: Browser Platform Publish\n      run: pnpm run publish\n```", "answer": "```yaml name: \"Submit to Web Store\"\r\non:\r\n  workflow_dispatch:\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Cache pnpm modules\r\n        uses: actions/cache@v3\r\n        with:\r\n          path: ~/.pnpm-store\r\n          key: ${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}\r\n          restore-keys: |\r\n            ${{ runner.os }}-\r\n      - uses: pnpm/action-setup@v2.2.1\r\n        with:\r\n          version: 7.1.0\r\n          run_install: true\r\n      - name: Build and zip extension artifact\r\n        run: pnpm build -- --zip\r\n      - name: Browser Platform Publish\r\n        uses: PlasmoHQ/bpp@v2\r\n        with:\r\n          keys: ${{ secrets.SUBMIT_KEYS }}\r\n          artifact: build/chrome-mv3-prod.zip\r\n```", "prompt": "Generate a GitHub Workflow named `Submit to Web Store` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 5 steps. The 1st step is named ``. The 2nd step is named `Cache pnpm modules`. The 3rd step is named ``. The 4th step is named `Build and zip extension artifact`. The 5th step is named `Browser Platform Publish`. "}
{"id": "63c494a97843b61269a02a50", "level": "level3", "llm_response": "```yaml\nname: pytorch1_7_1-cuda11_0\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n```", "answer": "```yaml name: pytorch1_7_1-cuda11_0\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu110\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.7.1-cu110\n      develop_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_7_1-cuda11_0` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/resuable_gpu_build.yml'}. "}
{"id": "63c496986fc19abdf9c9cf90", "level": "level3", "llm_response": "```yaml\nname: Issue Check\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Close Issue\n      uses: peter-evans/close-issue@v1\n      with:\n        issue-number: ${{ github.event.issue.number }}\n        comment: \"This issue has been automatically closed.\"\n\n    - name: Create comment\n      uses: peter-evans/create-or-update-comment@v1\n      with:\n        issue-number: ${{ github.event.issue.number }}\n        body: \"Thank you for opening this issue. We will review it shortly.\"\n```", "answer": "```yaml name: 'Issue Check'\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n    steps:\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == false\n        name: Close Issue\n        uses: peter-evans/close-issue@v1\n        with:\n          comment: |\n            Hello, Please use the Github template to report an issue. If this is a feature request, please take a look at the readme. <br/> Thanks, <br/> Ombi Bot\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == true\n        name: Create comment\n        uses: peter-evans/create-or-update-comment@v1\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            Hi!\n            <br/>Thanks for the issue report. Before a real human comes by, please make sure you used our bug report format.\n            <br/>Have you looked at the wiki yet? https://docs.ombi.app/\n            <br/>Before posting make sure you also read our [FAQ](https://docs.ombi.app/info/faq/).\n            <br/> Make the title describe your issue. Having 'not working' or 'I get this bug' for 100 issues, isn't really helpful.\n            <br/> If we need more information or there is some progress we tag the issue or update the tag and keep you updated.\n            <br/> Thanks!\n            <br/> Ombi Bot.\n```", "prompt": "Generate a GitHub Workflow named `Issue Check` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `issueCheck`. The job `issueCheck` has 2 steps. The 1st step is named `Close Issue`. The 2nd step is named `Create comment`. Here are some Github Actions that might be used in the workflow: v1 version of peter-evans/close-issue and v1 version of peter-evans/create-or-update-comment. Here are some variables that might be used in the workflow: github.event.issue.number. "}
{"id": "63c494da7843b61269a03d4f", "level": "level3", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\njobs:\n  build-and-deploy:\n    id: build-and-deploy\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout \ud83d\udece\ufe0f\n      uses: actions/checkout@v3\n\n    - name: Install \ud83c\udf31\n      run: |\n        # Add installation steps here\n        # For example, installing dependencies using a package manager like pip or npm\n\n    - name: Build \ud83d\udd27\n      run: |\n        # Add build steps here\n        # For example, running a build script or compiling the code\n\n    - name: Deploy \ud83d\ude80\n      uses: JamesIves/github-pages-deploy-action@v4\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: ./output\n        publish_branch: gh-pages\n        commit_message: \"Deploy to GitHub Pages\"\n        user_name: github-actions[bot]\n        user_email: github-actions[bot]@users.noreply.github.com\n```", "answer": "```yaml name: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\njobs:\n  build-and-deploy:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n      - name: Install \ud83c\udf31\n        run: |\n          sudo apt-get install -y pandoc\n      - name: Build \ud83d\udd27\n        run: |\n          ./run build itch\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4\n        with:\n          folder: build\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is GDScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `build-and-deploy`. The job `build-and-deploy` has 4 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install \ud83c\udf31`. The 3rd step is named `Build \ud83d\udd27`. The 4th step is named `Deploy \ud83d\ude80`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v4 version of JamesIves/github-pages-deploy-action. Here are some variables that might be used in the workflow: secrets.BUTLER_API_KEY, secrets.ITCHIO_USERNAME and secrets.ITCHIO_GAME. "}
{"id": "63c4968933b087f6bde2ca3a", "level": "level3", "llm_response": "```yaml\nname: Nightly Smoketest\n\non:\n  schedule:\n    - cron: '0 3 * * 1-5'\n  workflow_dispatch:\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        NODE_VERSION: [14, 16, 18]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Mount bazel cache\n      uses: actions/cache@v3\n      with:\n        path: ~/.cache/bazel\n        key: ${{ runner.os }}-bazel-${{ hashFiles('**/WORKSPACE') }}\n        restore-keys: |\n          ${{ runner.os }}-bazel-\n\n    - name: Bank Workload\n      run: go test ./...\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# This workflow tests that we can stand up a CRDB cluster with the operator and execute SQL in the cluster. It uses the\n# steps that are outlined in our public docs to ensure that the flow we're recommending always works.\nname: Nightly Smoketest\n\non:\n  schedule:\n    # runs at 3am UTC Mon-Fri\n    # ref: <min> <hr> <month-day> <month> <weekday>\n    - cron: '0 3 * * 1-5'\n\n  # allows running from the actions tab in GitHub\n  workflow_dispatch: ~\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        # supported Kubenetes versions\n        NODE_VERSION: [1.19.16, 1.20.15, 1.21.9, 1.22.6, 1.23.3]\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: Bank Workload\n        env:\n          NODE_VERSION: ${{ matrix.NODE_VERSION }}\n        run: make test/smoketest\n```", "prompt": "Generate a GitHub Workflow named `Nightly Smoketest` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am, monday through friday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `smoketest`. The job `smoketest` has 3 steps. The 1st step is named ``. The 2nd step is named `Mount bazel cache`. The 3rd step is named `Bank Workload`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/cache. Here are some variables that might be used in the workflow: matrix.NODE_VERSION. "}
{"id": "63c496686fc19abdf9c9be9c", "level": "level3", "llm_response": "```yaml\nname: Unit testing (Ubuntu)\n\non:\n  push:\n    branches:\n      - main\n      - ver_*\n      - dev\n    paths:\n      - '**.py'\n  pull_request:\n    branches:\n      - main\n      - ver_*\n      - dev\n    paths:\n      - '**.py'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Test with pytest\n        run: pytest\n        env:\n          DEBUG_API_ID: ${{ secrets.DEBUG_API_ID }}\n          DEBUG_API_SECRET: ${{ secrets.DEBUG_API_SECRET }}\n          CROSS_DEBUG_KEY: ${{ secrets.CROSS_DEBUG_KEY }}\n          CROSS_DEBUG_SECRET: ${{ secrets.CROSS_DEBUG_SECRET }}\n```", "answer": "```yaml name: Unit testing (Ubuntu)\non:\n  push:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n  pull_request:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n\njobs:\n  build:\n    strategy:\n      matrix:\n        # os: [macos-latest, windows-latest, ubuntu-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10']  # , '3.11-dev'\n    # runs-on: ${{ matrix.os }}\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        python -m pip install pytest coverage\n        pip install -r requirements.txt\n    - name: Test with pytest\n      env:\n        DEBUG_API_ID: ${{ secrets.DEBUG_API_ID }}\n        DEBUG_API_SECRET: ${{ secrets.DEBUG_API_SECRET }}\n        CROSS_DEBUG_KEY: ${{ secrets.CROSS_DEBUG_KEY }}\n        CROSS_DEBUG_SECRET: ${{ secrets.CROSS_DEBUG_SECRET }}\n      run: |\n        coverage run --source=src --omit=src/falconpy/debug.py -m pytest -s --ignore-glob=**/manual/*\n        coverage report\n```", "prompt": "Generate a GitHub Workflow named `Unit testing (Ubuntu)` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of push event matches a pattern in the paths filter(**.py), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of pull_request event matches a pattern in the paths filter(**.py), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python ${{ matrix.python-version }}`. The 3rd step is named `Install dependencies`. The 4th step is named `Test with pytest`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v4 version of actions/setup-python. Here are some variables that might be used in the workflow: matrix.python-version, secrets.DEBUG_API_ID, secrets.DEBUG_API_SECRET, secrets.CROSS_DEBUG_KEY and secrets.CROSS_DEBUG_SECRET. "}
{"id": "63c49698b008460c1df15628", "level": "level3", "llm_response": "```yaml\nname: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\npermissions:\n  contents: read\n\njobs:\n  add_to_gh_projects:\n    id: add_to_gh_projects\n    runs-on: ubuntu-latest\n    steps:\n      - name: Add labeled issues to GH projects\n        uses: gradle/build-tool-issue-automation-actions/add-labeled-issues@v1\n        with:\n          board_access_token: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n```", "answer": "```yaml name: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\npermissions:\n  contents: read\n\njobs:\n  add_to_gh_projects:\n    name: Adds issues to GH projects\n    runs-on: ubuntu-latest\n    steps:\n      - name: Add labeled issues to GH projects\n        uses: gradle/build-tool-issue-automation-actions/add-labeled-issues@v1\n```", "prompt": "Generate a GitHub Workflow named `add-to-gh-projects` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by multiple events: 1) an issue is opened or a label is added to an issue. 2) a pull request is created or a label is added to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Adds issues to GH projects` and its job id is `add_to_gh_projects`. The job `add_to_gh_projects` has one step. The 1st step is named `Add labeled issues to GH projects`. Here are some Github Actions that might be used in the workflow: v1 version of gradle/build-tool-issue-automation-actions/add-labeled-issues. Here are some variables that might be used in the workflow: secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN. "}
{"id": "63c494f67843b61269a0479e", "level": "level3", "llm_response": "```yaml\nname: Sync-To-Gitlab ${{ github.sha }}\n\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request:\n    branches:\n      - master\n      - master-template\n    types: [closed]\n  workflow_dispatch:\n\njobs:\n  sync:\n    id: sync\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Mirror\n        run: |\n          git config --global user.name \"${{ env.input_git_config_user_name }}\"\n          git config --global user.email \"${{ env.input_git_config_user_email }}\"\n          git remote add gitlab \"${{ env.input_git_remote_url }}\"\n          git push gitlab ${github.ref_name} ${env.input_git_push_options}\n        env:\n          GITLAB_USERNAME: ${{ secrets.GITLAB_USERNAME }}\n          GITLAB_EMAIL: ${{ secrets.GITLAB_EMAIL }}\n          GITLAB_URL: ${{ secrets.GITLAB_URL }}\n          input_git_config_user_name: \"GitHub Actions\"\n          input_git_config_user_email: \"actions@github.com\"\n          input_git_remote_url: \"https://${{ secrets.GITLAB_USERNAME }}:${{ secrets.GITLAB_PASSWORD }}@${{ secrets.GITLAB_URL }}/${{ github.repository }}.git\"\n          input_git_push_options: \"--force\"\n```", "answer": "```yaml name: Sync-To-Gitlab\nrun-name: Sync-To-Gitlab ${{ github.sha }}\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request_target:\n    types:\n      - closed\n    branches:\n      - master\n      - master-template\n  workflow_dispatch:\n\n\njobs:\n  sync:\n    concurrency:\n      group: ${{ github.workflow }}-${{ github.ref_name }}\n      cancel-in-progress: true\n    name: \"Sync To Gitlab\"\n    if: github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Mirror\n        env:\n          input_git_config_user_name: ${{ secrets.GITLAB_USERNAME }}\n          input_git_config_user_email: ${{ secrets.GITLAB_EMAIL }}\n          input_git_remote_url: ${{ secrets.GITLAB_URL }}\n          input_git_push_options: --force\n        run: |\n          git config --global user.name \"${{ env.input_git_config_user_name }}\"\n          git config --global user.email \"${{ env.input_git_config_user_email }}\"\n          git clone \"https://github.com/${{ github.repository }}.git\" \"git\"\n          cd git\n          git remote set-url origin \"${{ env.input_git_remote_url }}\"\n          git push ${{ env.input_git_push_options }} origin ${{ github.ref_name }}:${{ github.ref_name }}\n#      - name: Mirror + trigger CI\n#        uses: SvanBoxel/gitlab-mirror-and-ci-action@master\n#        with:\n#          args: \"https://gitlab.com/Zerek-Cheng/Simple-Assets-Platform\"\n#        env:\n#          FORCE_PUSH: \"true\"\n#          GITLAB_HOSTNAME: \"gitlab.com\"\n#          GITLAB_USERNAME: \"Zerek-Cheng\"\n#          GITLAB_PASSWORD: ${{ secrets.GITLAB_PASSWORD }}\n#          GITLAB_PROJECT_ID: \"40146411\"\n#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Sync-To-Gitlab` for a GitHub repository whose primary programming language is Java. The name for workflow runs is set to `Sync-To-Gitlab ${{ github.sha }}`. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named master-template. 2) a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named master-template. 3) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Sync To Gitlab` and its job id is `sync`. The job `sync` has 2 steps. The 1st step is named `Checkout`. The 2nd step is named `Mirror`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout. Here are some variables that might be used in the workflow: secrets.GITLAB_USERNAME, secrets.GITLAB_EMAIL, secrets.GITLAB_URL, env.input_git_config_user_name, env.input_git_config_user_email, github.repository, env.input_git_remote_url, env.input_git_push_options and github.ref_name. "}
{"id": "63c496561899db58864d23de", "level": "level3", "llm_response": "```yaml\nname: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  sqlite:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule docker\n\n      - name: Run Molecule tests\n        run: |\n          molecule test --debug if inputs.debug == true else molecule test\n```", "answer": "```yaml name: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  sqlite:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: sqlite\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Sqlite` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.sqlite.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/sqlite/** or roles/sqlite/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `sqlite`. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/molecule.yaml'}. Here are some variables that might be used in the workflow: inputs.debug == true and inputs.debug. "}
{"id": "63c494078052faa2781a8a1f", "level": "level3", "llm_response": "```yaml\nname: CLA Assistant\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [opened, closed, synchronize]\n  comment:\n    types: [created]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: CLA Assistant\n      uses: cla-assistant/github-action@v2.1.3-beta\n      with:\n        token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: \"CLA Assistant\"\non:\n  issue_comment:\n    types: [ created ]\n  pull_request_target:\n    types: [ opened,closed,synchronize ]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        uses: cla-assistant/github-action@v2.1.3-beta\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # the below token should have repo scope and must be manually added by you in the repository's secret\n          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: '.cla/v1/signatures.json'\n          path-to-document: 'https://github.com/christian-schlichtherle/truelicense/blob/develop/CLA.md'\n          branch: 'develop'\n          allowlist: bot*\n\n          #below are the optional inputs - If the optional inputs are not given, then default values will be taken\n          #remote-organization-name: enter the remote organization name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #remote-repository-name:  enter the  remote repository name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #create-file-commit-message: 'For example: Creating file for storing CLA Signatures'\n          #signed-commit-message: 'For example: $contributorName has signed the CLA in #$pullRequestNo'\n          #custom-notsigned-prcomment: 'pull request comment with Introductory message to ask new contributors to sign'\n          #custom-pr-sign-comment: 'The signature to be committed in order to sign the CLA'\n          #custom-allsigned-prcomment: 'pull request comment when all contributors has signed, defaults to **CLA Assistant Lite bot** All Contributors have signed the CLA.'\n          #lock-pullrequest-aftermerge: false - if you don't want this bot to automatically lock the pull request after merging (default - true)\n          #use-dco-flag: true - If you are using DCO instead of CLA\n```", "prompt": "Generate a GitHub Workflow named `CLA Assistant` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `CLAssistant`. The job `CLAssistant` has one step. The 1st step is named `CLA Assistant`. Here are some Github Actions that might be used in the workflow: v2.1.3-beta version of cla-assistant/github-action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and secrets.PERSONAL_ACCESS_TOKEN. "}
{"id": "63c494298052faa2781a98f8", "level": "level3", "llm_response": "```yaml\nname: Linux build with address sanitizer enabled\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Compiler version\n        run: |\n          g++ --version\n\n      - name: Build\n        run: |\n          g++ -fsanitize=address -o my_program my_program.cpp\n\n      - name: Run tests\n        run: |\n          ./my_program\n\n      - name: Run examples\n        run: |\n          ./my_program_example\n```", "answer": "```yaml name: Linux build with address sanitizer enabled\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n    container: ghcr.io/lballabio/quantlib-devenv:rolling\n    steps:\n    - uses: actions/checkout@v3\n    - name: Compiler version\n      run: |\n        gcc --version\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"gcc\" CXX=\"g++\" CXXFLAGS=\"-O2 -g0 -fsanitize=address,undefined -fno-sanitize-recover=all -fno-omit-frame-pointer -Wall -Wno-unknown-pragmas -Werror\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --log_level=message\n    - name: Run examples\n      run: |\n        make check-examples\n```", "prompt": "Generate a GitHub Workflow named `Linux build with address sanitizer enabled` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `sanitize`. The job `sanitize` has 5 steps. The 1st step is named ``. The 2nd step is named `Compiler version`. The 3rd step is named `Build`. The 4th step is named `Run tests`. The 5th step is named `Run examples`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout. "}
{"id": "63c493cd7843b612699fd710", "level": "level3", "llm_response": "```yaml\nname: Clean\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  delete-artifacts:\n    id: delete-artifacts\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Delete artifacts\n      run: |\n        curl -X DELETE -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" \"$GITHUB_API_URL/repos/${{ github.repository }}/actions/artifacts\"\n```", "answer": "```yaml # This file was automatically generated by sbt-github-actions using the\n# githubWorkflowGenerate task. You should add and commit this file to\n# your git repository. It goes without saying that you shouldn't edit\n# this file by hand! Instead, if you wish to make changes, you should\n# change your sbt build configuration to revise the workflow description\n# to meet your needs, then regenerate this file.\n\nname: Clean\n\non: push\n\njobs:\n  delete-artifacts:\n    name: Delete Artifacts\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Delete artifacts\n        run: |\n          # Customize those three lines with your repository and credentials:\n          REPO=${GITHUB_API_URL}/repos/${{ github.repository }}\n\n          # A shortcut to call GitHub API.\n          ghapi() { curl --silent --location --user _:$GITHUB_TOKEN \"$@\"; }\n\n          # A temporary file which receives HTTP response headers.\n          TMPFILE=/tmp/tmp.$$\n\n          # An associative array, key: artifact name, value: number of artifacts of that name.\n          declare -A ARTCOUNT\n\n          # Process all artifacts on this repository, loop on returned \"pages\".\n          URL=$REPO/actions/artifacts\n          while [[ -n \"$URL\" ]]; do\n\n            # Get current page, get response headers in a temporary file.\n            JSON=$(ghapi --dump-header $TMPFILE \"$URL\")\n\n            # Get URL of next page. Will be empty if we are at the last page.\n            URL=$(grep '^Link:' \"$TMPFILE\" | tr ',' '\\n' | grep 'rel=\"next\"' | head -1 | sed -e 's/.*<//' -e 's/>.*//')\n            rm -f $TMPFILE\n\n            # Number of artifacts on this page:\n            COUNT=$(( $(jq <<<$JSON -r '.artifacts | length') ))\n\n            # Loop on all artifacts on this page.\n            for ((i=0; $i < $COUNT; i++)); do\n\n              # Get name of artifact and count instances of this name.\n              name=$(jq <<<$JSON -r \".artifacts[$i].name?\")\n              ARTCOUNT[$name]=$(( $(( ${ARTCOUNT[$name]} )) + 1))\n\n              id=$(jq <<<$JSON -r \".artifacts[$i].id?\")\n              size=$(( $(jq <<<$JSON -r \".artifacts[$i].size_in_bytes?\") ))\n              printf \"Deleting '%s' #%d, %'d bytes\\n\" $name ${ARTCOUNT[$name]} $size\n              ghapi -X DELETE $REPO/actions/artifacts/$id\n            done\n          done\n```", "prompt": "Generate a GitHub Workflow named `Clean` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The 1st job is named `Delete Artifacts` and its job id is `delete-artifacts`. The job `delete-artifacts` has one step. The 1st step is named `Delete artifacts`. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN, GITHUB_API_URL and github.repository. "}
{"id": "63c494167843b612699fee3f", "level": "level3", "llm_response": "```yaml\nname: Dead Link Check\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [clone]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Check for dead links\n      uses: gaurav-nelson/github-action-markdown-link-check@v1\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\n\nname: Dead Link Check\n\non: [push, pull_request]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    if: (github.repository == 'apache/incubator-linkis')\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gaurav-nelson/github-action-markdown-link-check@v1\n        with:\n          use-quiet-mode: 'no'\n          use-verbose-mode: 'yes'\n          folder-path: '../'\n          config-file: '.github/workflows/dlc.json'\n```", "prompt": "Generate a GitHub Workflow named `Dead Link Check` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `dead-links-check`. The job `dead-links-check` has 2 steps. The 1st step is named ``. The 2nd step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v1 version of gaurav-nelson/github-action-markdown-link-check. "}
{"id": "63c4964b33b087f6bde2aead", "level": "level3", "llm_response": "```yaml\nname: Build release\n\non:\n  push:\n    tags:\n      - 'v**'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up JDK 11\n        uses: actions/setup-java@v3\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Set up ruby env\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '2.7'\n\n      - name: Decode Service Account Key JSON File\n        id: service_account_json_file\n        uses: timheuer/base64-to-file@v1\n        with:\n          input: ${{ secrets.GOOGLE_JSON }}\n          output: service_account.json\n\n      - name: Grant execute permission for gradlew\n        run: chmod +x gradlew\n\n      - name: Create local properties\n        run: echo \"googleServicesJsonFilePath=service_account.json\" > local.properties\n\n      - name: Create maps api key\n        run: echo \"mapsApiKey=${{ secrets.MAPS_API_KEY }}\" >> local.properties\n\n      - name: Decode Keystore\n        run: echo ${{ secrets.KEYSTORE }} | base64 --decode > keystore.jks\n\n      - name: Decode Google Services json\n        run: echo ${{ secrets.GOOGLE_SERVICES }} | base64 --decode > google-services.json\n\n      - name: Build & deploy Android release\n        run: ./gradlew assembleRelease\n        env:\n          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASS }}\n          KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n          MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n```", "answer": "```yaml name: Build release\n\non:\n  push:\n    tags:\n      - v**\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: set up JDK 11\n      uses: actions/setup-java@v3\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n        cache: gradle\n\n    - name: Set up ruby env\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: 2.7.2\n        bundler-cache: true\n\n    - name: Decode Service Account Key JSON File\n      uses: timheuer/base64-to-file@v1\n      id: service_account_json_file\n      with:\n        fileName: \"serviceAccount.json\"\n        encodedString: ${{ secrets.GOOGLE_JSON }}\n\n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n\n    - name: Create local properties\n      run: touch local.properties\n\n    - name: Create maps api key\n      run: echo \"MAPS_API_KEY=${{ secrets.MAPS_API_KEY }}\" > secrets.properties\n\n    - name: Decode Keystore\n      env:\n        ENCODED_STRING: ${{ secrets.KEYSTORE }}\n      run: |\n        mkdir app/keystore\n        echo $ENCODED_STRING | base64 -di > app/keystore/keystore.jks\n    - name: Decode Google Services json\n      env:\n        ENCODED_STRING: ${{ secrets.GOOGLE_SERVICES }}\n      run: |\n        echo $ENCODED_STRING | base64 -di > app/google-services.json\n        \n\n    - name: Build & deploy Android release\n      run: bundle exec fastlane android deploy\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n        ANDROID_JSON_KEY_FILE: ${{ steps.service_account_json_file.outputs.filePath }}\n\n#    - name: Build with Gradle\n#      run: ./gradlew app:bundleRelease\n#      env:\n#        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n#        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n#        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n#\n#    - name: Archive release bundle\n#      uses: actions/upload-artifact@v3\n#      with:\n#        name: bundle\n#        path: |\n#          app/build/outputs/bundle/release\n```", "prompt": "Generate a GitHub Workflow named `Build release` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v**. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 10 steps. The 1st step is named ``. The 2nd step is named `set up JDK 11`. The 3rd step is named `Set up ruby env`. The 4th step is named `Decode Service Account Key JSON File` and its id is `service_account_json_file`. The 5th step is named `Grant execute permission for gradlew`. The 6th step is named `Create local properties`. The 7th step is named `Create maps api key`. The 8th step is named `Decode Keystore`. The 9th step is named `Decode Google Services json`. The 10th step is named `Build & deploy Android release`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-java, v1 version of ruby/setup-ruby and v1 version of timheuer/base64-to-file. Here are some variables that might be used in the workflow: secrets.GOOGLE_JSON, secrets.MAPS_API_KEY, secrets.KEYSTORE, secrets.GOOGLE_SERVICES, secrets.GITHUB_TOKEN, secrets.KEYSTORE_PASS, secrets.KEYSTORE_ALIAS, secrets.MAPBOX_DOWNLOADS_TOKEN and steps.service_account_json_file.outputs.filePath. "}
{"id": "63c4956e8052faa2781b1ca5", "level": "level3", "llm_response": "```yaml\nname: Conventional PR\n\non:\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: semantic-pull-request\n        uses: b7a9a97cb10fa6e1ae02647e718798175f6b1f1d/amannn-action-semantic-pull-request@v4\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Conventional PR\n\n# Controls when the action will run. \non:\n  pull_request:\n    branches:\n    - develop\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n      - name: semantic-pull-request\n        # Internal Unity mirror available at jesseo/action-semantic-pull-request, but actions from private repos aren't supported, so continue to use the public one below\n        uses: amannn/action-semantic-pull-request@b7a9a97cb10fa6e1ae02647e718798175f6b1f1d\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          # Provide custom types if you don't want the default ones from https://www.conventionalcommits.org\n          types: # optional\n          # Configure which scopes are allowed.\n          #scopes: # optional\n          # Configure that a scope must always be provided.\n          #requireScope: # optional\n          # Configure additional validation for the subject based on a regex. E.g. '^(?![A-Z]).+$' ensures the subject doesn't start with an uppercase character.\n          #subjectPattern: # optional\n          # If `subjectPattern` is configured, you can use this property to override the default error message that is shown when the pattern doesn't match. The variables `subject` and `title` can be used within the message.\n          #subjectPatternError: # optional\n          # For work-in-progress PRs you can typically use draft pull requests from Github. However, private repositories on the free plan don't have this option and therefore this action allows you to opt-in to using the special '[WIP]' prefix to indicate this state. This will avoid the validation of the PR title and the pull request checks remain pending. Note that a second check will be reported if this is enabled.\n          #wip: # optional\n          # When using \"Squash and merge\" on a PR with only one commit, GitHub will suggest using that commit message instead of the PR title for the merge commit, and it's easy to commit this by mistake. Enable this option to also validate the commit message for one commit PRs.\n          validateSingleCommit: true # optional\n```", "prompt": "Generate a GitHub Workflow named `Conventional PR` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `build`. The job `build` has one step. The 1st step is named `semantic-pull-request`. Here are some Github Actions that might be used in the workflow: b7a9a97cb10fa6e1ae02647e718798175f6b1f1d version of amannn/action-semantic-pull-request. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4965b33b087f6bde2b689", "level": "level3", "llm_response": "```yaml\nname: fortran-format-check\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  fortran-format-check:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2.3.4\n\n      - name: Install Conda environment from environment.yml\n        uses: mamba-org/provision-with-micromamba@main\n        with:\n          environment-file: environment.yml\n\n      - name: Install gfortran\n        uses: modflowpy/install-gfortran-action@v1\n\n      - name: Print python package versions\n        run: |\n          python -m pip list\n\n      - name: Set and print branch name\n        run: echo \"Branch: ${{ github.ref }}\"\n\n      - name: Fortran source format check\n        run: |\n          # Add your Fortran source format check command here\n          # For example: flake8 --config=.flake8 .\n```", "answer": "```yaml name: fortran-format-check\n\non:\n  push:\n    branches: [ master, develop ]\n  pull_request:\n    branches: [ develop ]\n\njobs:\n  fortan-format-check:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash -l {0}\n\n    steps:\n      - uses: actions/checkout@v2.3.4\n\n      - name: Install Conda environment from environment.yml\n        uses: mamba-org/provision-with-micromamba@main\n        with:\n            cache-downloads: true\n            cache-env: true\n\n      - name: Install gfortran\n        uses: modflowpy/install-gfortran-action@v1\n\n      - name: Print python package versions\n        run: |\n          pip list\n\n      - name: Set and print branch name\n        run: |\n          .github/common/git-branch-export.sh\n\n      - name: Fortran source format check\n        run: |\n          .github/common/fortran-format-check.sh\n```", "prompt": "Generate a GitHub Workflow named `fortran-format-check` for a GitHub repository whose primary programming language is Fortran. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `fortan-format-check`. The job `fortan-format-check` has 6 steps. The 1st step is named ``. The 2nd step is named `Install Conda environment from environment.yml`. The 3rd step is named `Install gfortran`. The 4th step is named `Print python package versions`. The 5th step is named `Set and print branch name`. The 6th step is named `Fortran source format check`. Here are some Github Actions that might be used in the workflow: v2.3.4 version of actions/checkout, main version of mamba-org/provision-with-micromamba and v1 version of modflowpy/install-gfortran-action. "}
{"id": "63c494c88052faa2781ad4bd", "level": "level3", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches: [ develop ]\n  pull_request:\n    branches: [ develop ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node_version: [14, 16]\n        ros_distro: [noetic, melodic]\n\n    defaults:\n      run:\n        shell: bash\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node_version }}\n\n    - name: Own /github/home\n      run: echo \"This step is a placeholder\"\n\n    - name: Install apt dependencies\n      run: echo \"This step is a placeholder\"\n\n    - name: Tests\n      run: echo \"This step is a placeholder\"\n\n    - name: Commit changes\n      uses: stefanzweifel/git-auto-commit-action@v4\n      with:\n        commit_message: \"Update dependencies\"\n        commit_user_name: \"github-actions[bot]\"\n        commit_user_email: \"github-actions[bot]@users.noreply.github.com\"\n        github_token: ${{ secrets.RWT_BOT_PAT }}\n```", "answer": "```yaml name: CI\n\non: [push, pull_request]\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  ci:\n    name: ${{ matrix.ros_distro }}\n    if: ${{ github.actor != 'RWT-bot' }}\n    runs-on: ubuntu-latest\n    container: ros:${{ matrix.ros_distro }}-ros-core\n    strategy:\n      fail-fast: false\n      matrix:\n        ros_distro: [melodic, noetic]\n        node_version: [14]\n    env:\n      ROS_DISTRO: ${{ matrix.ros_distro }}\n    steps:\n      - uses: actions/checkout@v3\n        env:\n          TOKEN: \"${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' && secrets.RWT_BOT_PAT || github.token }}\"\n        with:\n          token: ${{ env.TOKEN }}\n      - uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node_version }}\n      - name: Own /github/home\n        run: |\n          chown -hR $(whoami):$(whoami) /github/home\n      - name: Install apt dependencies\n        run: |\n          apt-get update\n          apt-get install -y firefox ros-$ROS_DISTRO-rosbridge-server ros-$ROS_DISTRO-tf2-web-republisher ros-$ROS_DISTRO-common-tutorials ros-$ROS_DISTRO-rospy-tutorials ros-$ROS_DISTRO-actionlib-tutorials\n      - name: Tests\n        run: |\n          bash -c \"source /opt/ros/$ROS_DISTRO/setup.bash && bash test/build.bash\"\n      - uses: stefanzweifel/git-auto-commit-action@v4\n        if: ${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' }}\n        with:\n          commit_message: Update Build\n          file_pattern: 'build/*.js'\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The 1st job is named `${{ matrix.ros_distro }}` and its job id is `ci`. The job `ci` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Own /github/home`. The 4th step is named `Install apt dependencies`. The 5th step is named `Tests`. The 6th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-node and v4 version of stefanzweifel/git-auto-commit-action. Here are some variables that might be used in the workflow: matrix.ros_distro, env.TOKEN, github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' && secrets.RWT_BOT_PAT || github.token, secrets.RWT_BOT_PAT, github.event_name, github.ref, github.token and matrix.node_version. "}
{"id": "63c494287843b612699ff643", "level": "level3", "llm_response": "```yaml\nname: README to PDF\n\non:\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Convert README to PDF\n      uses: baileyjm02/markdown-to-pdf@v1.1.0\n      with:\n        input: README.md\n        output: README.pdf\n\n    - name: Commit files\n      run: |\n        git config --global user.name 'github-actions[bot]'\n        git config --global user.email 'github-actions[bot]@users.noreply.github.com'\n        git add README.pdf\n        git commit -m \"Convert README to PDF\"\n\n    - name: Push changes\n      uses: ad-m/github-push-action@master\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        branch: ${{ github.ref }}\n```", "answer": "```yaml name: README to PDF\n# This workflow is triggered on pushes to the repository.\non:\n#   push:\n#     branches:\n#       - main\n#     paths:\n#       - 'README.md'\n    \n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    name: Build PDF\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: baileyjm02/markdown-to-pdf@v1.1.0\n        with:\n          input_dir: .\n          output_dir: .\n          build_html: false\n          table_of_contents: false\n      - uses: actions/upload-artifact@v3\n        with:\n          name: python-engineer-roadmap\n          path: README.pdf\n      - name: Commit files\n        run: |\n          git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n          git config --local user.name \"github-actions[bot]\"\n          git add README.pdf\n          if ! git diff-index --quiet HEAD; then\n            git commit -m \"Generate PDF file\"\n          fi\n      - name: Push changes\n        uses: ad-m/github-push-action@master\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          branch: ${{ github.ref }}\n#       - name: Commit changes\n#         uses: EndBug/add-and-commit@v9\n#         with:\n#           default_author: github_actions\n#           add: 'README.pdf'\n#           new_branch: generate-pdf\n#           push: origin generate-pdf --set-upstream --force\n```", "prompt": "Generate a GitHub Workflow named `README to PDF` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Build PDF` and its job id is `converttopdf`. The job `converttopdf` has 5 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Commit files`. The 5th step is named `Push changes`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v1.1.0 version of baileyjm02/markdown-to-pdf, v3 version of actions/upload-artifact and master version of ad-m/github-push-action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and github.ref. "}
{"id": "63c494578052faa2781aa8bb", "level": "level3", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  go_test_and_coverage:\n    runs-on: ${{ matrix.HOST_OS }}\n    strategy:\n      matrix:\n        GO_VER: [1.16, 1.17, 1.18]\n        HOST_OS: [ubuntu-latest, macos-latest, windows-latest]\n\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v3\n\n      - name: Setup Go\n        id: go\n        uses: actions/setup-go@v3\n        with:\n          go-version: ${{ matrix.GO_VER }}\n          check-latest: true\n\n      - name: Get Dependencies\n        run: go mod download\n\n      - name: Show Environments\n        run: |\n          echo \"Go Version: ${{ matrix.GO_VER }}\"\n          echo \"GitHub Ref: ${{ env.GITHUB_REF }}\"\n          echo \"GitHub Ref Name: ${{ env.GITHUB_REF_NAME }}\"\n          echo \"Host OS: ${{ matrix.HOST_OS }}\"\n\n      - name: Test and Generate Coverage Report\n        run: go test -v -coverprofile=coverage.out ./...\n\n      - name: Upload Coverage to Codecov\n        uses: codecov/codecov-action@v2\n        with:\n          file: coverage.out\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branchs:\n    - 'master'\n    - 'feature/**'\n    - 'dev/**'\n\nenv:\n  CODECOV_TOKEN: '2fc0d617-8e9a-47d7-ab58-52fa92b23741'\n  MAIN_GO_VER: '1.16'\n  MAIN_HOST_OS: 'ubuntu-latest'\n\njobs:\n  go_test_and_coverage:\n    strategy:\n      max-parallel: 6\n      matrix:\n        GO_VER: ['1.16']\n        HOST_OS: ['ubuntu-latest']\n\n    runs-on: ${{ matrix.HOST_OS }}\n\n    steps:\n\n    - name: Checkout Repositary\n      uses: actions/checkout@v3\n\n    - name: Setup Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.GO_VER }}\n      id: go\n\n    - name: Get Dependencies\n      run: |\n        echo GO_VER = ${{ matrix.GO_VER }}\n        go get golang.org/x/tools/cmd/cover\n        go install github.com/mattn/goveralls || go get github.com/mattn/goveralls\n        go get .\n\n    - name: Show Environments\n      run: |\n        echo repo status ======== && git status\n        echo GITHUB_REF = ${{ env.GITHUB_REF }}\n        echo GITHUB_REF_NAME = ${{ env.GITHUB_REF_NAME }}\n        echo GO_VER = ${{ matrix.GO_VER }}\n        echo HOST_OS = ${{ matrix.HOST_OS }}\n        which goveralls\n        echo envs ======== && printenv\n\n    - name: Test and Generate Coverage Report\n      run: |\n        go test -v -failfast -cover -covermode=atomic -coverprofile=coverage.out\n\n    # - name: Upload Coverage to Goveralls\n    #   run: |\n    #     goveralls -coverprofile=coverage.out -repotoken ${{ env.COVERALLS_TOKEN }}\n\n    # - name: Upload Coverage to Codecov\n    #   if: ${{ matrix.GO_VER }} == ${{ env.MAIN_GO_VER }}\n    #   run: |\n    #     bash <(curl -s https://codecov.io/bash) -t ${{ env.CODECOV_TOKEN }}\n\n    # - name: Convert Coverage file to lcov format\n    #   uses: jandelgado/gcov2lcov-action@v1.0.8\n    #   with:\n    #     infile: ./coverage.out\n    #     outfile: ./coverage.lcov\n\n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        files: ./coverage.out\n        fail_ci_if_error: true\n        flags: unittests\n        name: codecov-umbrella\n        path_to_write_report: ./coverage/codecov_report.txt\n        verbose: true\n\n    # - name: Coveralls GitHub Action\n    #   uses: coverallsapp/github-action@1.1.3\n    #   with:\n    #     path-to-lcov: ./coverage.lcov\n    #     github-token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow has one job. The job id of the 1st job is `go_test_and_coverage`. The job `go_test_and_coverage` has 6 steps. The 1st step is named `Checkout Repositary`. The 2nd step is named `Setup Go` and its id is `go`. The 3rd step is named `Get Dependencies`. The 4th step is named `Show Environments`. The 5th step is named `Test and Generate Coverage Report`. The 6th step is named `Upload Coverage to Codecov`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-go and v2 version of codecov/codecov-action. Here are some variables that might be used in the workflow: matrix.GO_VER, env.GITHUB_REF, env.GITHUB_REF_NAME and matrix.HOST_OS. "}
{"id": "63c495297843b61269a05d37", "level": "level3", "llm_response": "```yaml\nname: pr\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  release:\n    uses: the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main\n\n  algolia:\n    uses: the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main\n```", "answer": "```yaml name: pr\non:\n  pull_request:\n\njobs:\n  release:\n    uses: the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main\n    with:\n      npmTag: alpha\n      buildScript: build\n      nodeVersion: 18\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n      npmToken: ${{ secrets.NPM_TOKEN }}\n\n\n  algolia:\n    uses: the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main\n    with:\n      domain: https://www.the-guild.dev/graphql/shield/\n      source: 'Shield'\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `pr` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The job id of the 1st job is `release`. The job id of the 2nd job is `algolia`. Here are some reusable workflows that might be used in the workflow: {'version': 'main', 'name': 'the-guild-org/shared-config/.github/workflows/release-snapshot.yml'} and {'version': 'main', 'name': 'the-guild-org/shared-config/.github/workflows/algolia-integrity.yml'}. "}
{"id": "63c4959c7843b61269a08c2d", "level": "level3", "llm_response": "```yaml\nname: Rust CI\n\non:\n  push:\n    paths:\n      - '.github/workflows/install.yml'\n  schedule:\n    - cron: '17 0 * * 1'\n\npermissions:\n  contents: read\n\njobs:\n  cargo-install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: cargo install --force\n```", "answer": "```yaml permissions:\n  contents: read\n\non:\n  push:\n    paths:\n      - \".github/workflows/install.yml\"\n  schedule:\n    - cron: \"17 0 * * 1\"\n\njobs:\n  cargo-install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: |\n          cargo install cargo-mutants\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/install.yml), the workflow runs. 2) the scheduled time has come: at 12:17 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `cargo-install`. The job `cargo-install` has one step. The 1st step is named `cargo-install`. "}
{"id": "63c4968e1899db58864d3b1c", "level": "level3", "llm_response": "```yaml\nname: HTML5 check\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\njobs:\n  HTML5-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Run HTML5 check\n        uses: easystats/workflows/.github/workflows/html-5-check.yaml@main\n```", "answer": "```yaml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n\nname: HTML5 check\n\njobs:\n  HTML5-check:\n    uses: easystats/workflows/.github/workflows/html-5-check.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `HTML5 check` for a GitHub repository whose primary programming language is R. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch named master. The workflow has one job. The job id of the 1st job is `HTML5-check`. Here are some reusable workflows that might be used in the workflow: {'version': 'main', 'name': 'easystats/workflows/.github/workflows/html-5-check.yaml'}. "}
{"id": "63c496861e3364807577b31b", "level": "level3", "llm_response": "```yaml\nname: license-check\n\non:\n  pull_request:\n\njobs:\n  license:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@master\n\n      - name: Check License Header\n        uses: apache/skywalking-eyes/header@501a28d2fb4a9b962661987e50cf0219631b32ff\n```", "answer": "```yaml name: license-check\non: pull_request\njobs:\n  license:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Check License Header\n      uses: apache/skywalking-eyes/header@501a28d2fb4a9b962661987e50cf0219631b32ff\n```", "prompt": "Generate a GitHub Workflow named `license-check` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `license`. The job `license` has 2 steps. The 1st step is named ``. The 2nd step is named `Check License Header`. Here are some Github Actions that might be used in the workflow: master version of actions/checkout and 501a28d2fb4a9b962661987e50cf0219631b32ff version of apache/skywalking-eyes/header. "}
{"id": "63c4962c6fc19abdf9c9a4e3", "level": "level3", "llm_response": "```yaml\nname: Continuous integration\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  clone_repository:\n    types: [ pushed ]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '3.0'\n      - name: Lint with RuboCop\n        run: bundle exec rubocop\n      - name: Setup Node.js\n        uses: actions/setup-node@v3.5.1\n        with:\n          node-version: '14'\n      - name: Install Node modules\n        run: npm install\n      - name: Run ESLint\n        run: npm run lint\n      - name: Run Tests\n        run: bundle exec rspec\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: test\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      - name: Build, push and deploy the LATEST image\n        run: |\n          docker build -t ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:latest .\n          docker push ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:latest\n          curl -X POST -H \"Content-Type: application/json\" -d \"{\\\"sha\\\":\\\"${{ GITHUB_SHA }}\\\", \\\"app\\\":\\\"${{ secrets.DEPLOY_HOOK_APP }}\\\", \\\"worker\\\":\\\"${{ secrets.DEPLOY_HOOK_WORKER }}\\\"}\" ${{ secrets.DEPLOY_HOOK_URL }}\n      - name: Build and push the STABLE image\n        run: |\n          docker build -t ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:stable .\n          docker push ghcr.io/${{ github.repository_owner }}/${{ github.repository }}:stable\n```", "answer": "```yaml name: Continuous integration\non: push\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:14-alpine\n        ports: [\"5432:5432\"]\n        env:\n          POSTGRES_PASSWORD: postgres\n\n      redis:\n        image: redis:alpine\n        ports: [\"6379:6379\"]\n\n      opensearch:\n        image: opensearchproject/opensearch:latest\n        ports: [\"9200:9200\"]\n        env:\n          discovery.type: single-node\n          plugins.security.disabled: true\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          bundler-cache: true\n\n      - name: Lint with RuboCop\n        run: bundle exec rubocop --parallel\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3.5.1\n        with:\n          cache: yarn\n\n      - name: Install Node modules\n        run: bin/yarn install --frozen-lockfile\n\n      - name: Run ESLint\n        run: bin/yarn lint\n\n      - name: Run Tests\n        env:\n          DB_HOST: localhost\n          DB_USER: postgres\n          DB_PASSWORD: postgres\n          RAILS_ENV: test\n          SECRET_KEY_BASE: we-dont-need-a-secret-here\n          APP_ADMIN_EMAIL: admin@example.org\n          APP_ADMIN_PASSWORD: secret\n          APP_EMAIL: reply@example.org\n          APP_HOST: example.org\n          AWS_ACCESS_KEY_ID: my-access-key\n          AWS_SECRET_ACCESS_KEY: my-secret\n          AWS_BUCKET: my-bucket\n          AWS_REGION: eu-central-1\n          CI: true\n        run: |\n          bundle exec rake assets:precompile\n          bundle exec rake db:create db:schema:load\n          bundle exec rake spec\n\n  deploy:\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'\n    needs: test\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build, push and deploy the LATEST image\n        if: github.ref == 'refs/heads/develop'\n        run: |\n          export COMMIT_TIME=$(git show -s --format=%cD ${GITHUB_SHA})\n          export COMMIT_SHA=${GITHUB_SHA}\n          docker buildx build --build-arg COMMIT_TIME --build-arg COMMIT_SHA -t ghcr.io/ledermann/docker-rails/docker-rails:latest .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:latest\n          curl -X POST ${{ secrets.DEPLOY_HOOK_APP }}\n          curl -X POST ${{ secrets.DEPLOY_HOOK_WORKER }}\n\n      - name: Build and push the STABLE image\n        if: github.ref == 'refs/heads/master'\n        run: |\n          docker buildx build -t ghcr.io/ledermann/docker-rails/docker-rails:stable .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:stable\n```", "prompt": "Generate a GitHub Workflow named `Continuous integration` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The job id of the 1st job is `test`. The job `test` has 7 steps. The 1st step is named ``. The 2nd step is named `Set up Ruby`. The 3rd step is named `Lint with RuboCop`. The 4th step is named `Setup Node.js`. The 5th step is named `Install Node modules`. The 6th step is named `Run ESLint`. The 7th step is named `Run Tests`. The job id of the 2nd job is `deploy`. The job `deploy` has 4 steps. The 1st step is named ``. The 2nd step is named `Login to GitHub Container Registry`. The 3rd step is named `Build, push and deploy the LATEST image`. The 4th step is named `Build and push the STABLE image`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v1 version of ruby/setup-ruby, v3.5.1 version of actions/setup-node, v3 version of actions/checkout and v2 version of docker/login-action. Here are some variables that might be used in the workflow: github.repository_owner, secrets.GITHUB_TOKEN, GITHUB_SHA, secrets.DEPLOY_HOOK_APP and secrets.DEPLOY_HOOK_WORKER. "}
{"id": "63c495707843b61269a07a00", "level": "level3", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '23 20 * * 1'\n  push:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v12a3943b4bdde767164f792f33f40b04645d846\n\n      - name: Run analysis\n        uses: ossf/scorecard-action@3e15ea8318eee9b333819ec77a36aca8d39df13e\n\n      - name: Upload artifact\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: scorecard-results\n          path: scorecard-report\n\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5\n        with:\n          sarif_file: scorecard-report.sarif\n```", "answer": "```yaml name: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '43 20 * * 1'\n  push:\n    branches: [ master ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      # Used to receive a badge. (Upcoming feature)\n      id-token: write\n      actions: read\n      contents: read\n    \n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@a12a3943b4bdde767164f792f33f40b04645d846 # v3.0.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@3e15ea8318eee9b333819ec77a36aca8d39df13e # v1.1.1\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # (Optional) Read-only PAT token. Uncomment the `repo_token` line below if:\n          # - you want to enable the Branch-Protection check on a *public* repository, or\n          # - you are installing Scorecards on a *private* repository\n          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action#authentication-with-pat.\n          # repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n\n          # Publish the results for public repositories to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results. \n          # For private repositories, `publish_results` will automatically be set to `false`, regardless \n          # of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF\n      # format to the repository Actions tab.\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8 # v3.1.0\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n      \n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 08:43 pm, only on monday. 3) The workflow would run whenever there is a push event to: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. Here are some Github Actions that might be used in the workflow: a12a3943b4bdde767164f792f33f40b04645d846 version of actions/checkout, 3e15ea8318eee9b333819ec77a36aca8d39df13e version of ossf/scorecard-action, 3cea5372237819ed00197afe530f5a7ea3e805c8 version of actions/upload-artifact and 5f532563584d71fdef14ee64d17bafb34f751ce5 version of github/codeql-action/upload-sarif. "}
{"id": "63c495c68052faa2781b4231", "level": "level3", "llm_response": "```yaml\nname: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pullRequestHandler:\n    id: pullRequestHandler\n    runs-on: windows-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      \n      - name: Pull Request Validation\n        uses: Ash258/Scoop-GithubActions@stable-win\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pullRequestHandler:\n    name: Pull Request Validator\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Pull Request Validation\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: startsWith(github.event.comment.body, '/verify')\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          SKIP_UPDATED: '1'\n```", "prompt": "Generate a GitHub Workflow named `Commented Pull Request` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The 1st job is named `Pull Request Validator` and its job id is `pullRequestHandler`. The job `pullRequestHandler` has 2 steps. The 1st step is named ``. The 2nd step is named `Pull Request Validation`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and stable-win version of Ash258/Scoop-GithubActions. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4969e1899db58864d41ef", "level": "level3", "llm_response": "```yaml\nname: Auto message on pr merge\n\non:\n  pull_request:\n    types: [closed]\n\njobs:\n  auto-response:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Add autoresponse\n        uses: derekprior/add-autoresponse@master\n        with:\n          pr-node-id: ${{ github.event.pull_request.node_id }}\n          pr-user-login: ${{ github.event.pull_request.user.login }}\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Auto message on pr merge\n\non:\n\n  pull_request_target:\n\n    types: [closed]\n\njobs:\n\n  auto-response:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - uses: derekprior/add-autoresponse@master\n\n      env:\n\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      with:\n\n        respondableId: ${{ github.event.pull_request.node_id }}\n\n        response: \"Thank you @${{ github.event.pull_request.user.login }} for taking out your valuable time in order to contribute to our project. Looking forward for more such amazing contributions :).\"\n\n        author: ${{ github.event.pull_request.user.login }}\n\n        exemptedAuthors: \"Amit366\"\n```", "prompt": "Generate a GitHub Workflow named `Auto message on pr merge` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a pull request is closed. The workflow has one job. The job id of the 1st job is `auto-response`. The job `auto-response` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: master version of derekprior/add-autoresponse. Here are some variables that might be used in the workflow: github.event.pull_request.node_id, github.event.pull_request.user.login and secrets.GITHUB_TOKEN. "}
{"id": "63c4966b33b087f6bde2bde4", "level": "level3", "llm_response": "```yaml\nname: tests\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python: [3.8, 3.9, 3.10]\n        tox: [py38, py39, py310]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v3\n      with:\n        python-version: ${{ matrix.python }}\n\n    - name: Install system dependencies\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y build-essential libssl-dev libffi-dev python3-dev\n\n    - name: Update pip\n      run: python -m pip install --upgrade pip\n\n    - name: Install dependencies\n      run: pip install -r requirements.txt\n\n    - name: Run tests\n      run: tox -e ${{ matrix.tox }}\n```", "answer": "```yaml name: tests\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    name: ${{ matrix.name }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - {name: '3.11-dev', python: '3.11-dev', os: ubuntu-latest, tox: py311}\n          - {name: Linux, python: '3.10', os: ubuntu-latest, tox: py310}\n          - {name: Windows, python: '3.10', os: windows-latest, tox: py310}\n          - {name: Mac, python: '3.10', os: macos-latest, tox: py310}\n          - {name: '3.9', python: '3.9', os: ubuntu-latest, tox: py39}\n          - {name: 'PyPy', python: 'pypy-3.9', os: ubuntu-latest, tox: pypy39}\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python }}\n      - name: install system dependencies\n        run: sudo apt-get install libxml2-dev libxslt1-dev --yes\n        if: ${{ matrix.python == '3.11-dev' }}\n      - name: update pip\n        run: |\n          pip install -U wheel\n          pip install -U setuptools\n          python -m pip install -U pip\n      - run: pip install tox\n      - run: tox -e ${{ matrix.tox }}\n```", "prompt": "Generate a GitHub Workflow named `tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named develop. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `tests`. The job `tests` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `install system dependencies`. The 4th step is named `update pip`. The 5th step is named ``. The 6th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/setup-python. Here are some variables that might be used in the workflow: matrix.python and matrix.tox. "}
{"id": "63c495c88052faa2781b42d4", "level": "level3", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        language: [java]\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n\n    - name: CodeQL Generate BQL Queries (if needed)\n      run: echo \"Generate BQL queries here\"\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        queries: security-and-quality,security-extended\n\n    # Autobuild failed (OOM)\n    # Hence, supply memory args for gradle build\n    - run: |\n        JAVA_OPTS=\"-Xmx1000M\" ./gradlew --no-scan compileJava\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. When all the path names of pull_request event match patterns in the paths-ignore filter(**/*.json, **/*.md, **/*.properties or **/*.txt), the workflow will not run. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named ``. The 4th step is named `Perform CodeQL Analysis`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of github/codeql-action/init and v2 version of github/codeql-action/analyze. Here are some variables that might be used in the workflow: matrix.language. "}
{"id": "63c495e48052faa2781b4f0b", "level": "level3", "llm_response": "```yaml\nname: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v3\n\n    - name: Install Lua 5.1.5\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y lua5.1\n\n    - name: Install Luarocks\n      uses: leafo/gh-actions-luarocks@v4\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install luapack\n        luarocks install lume\n\n    - name: Calculate from and to releases\n      run: |\n        from=${{ github.event.inputs.from || 'latest' }}\n        to=${{ github.event.inputs.to || 'HEAD' }}\n        echo \"::set-output name=from::$from\"\n        echo \"::set-output name=to::$to\"\n\n    - name: Generate changelog\n      run: |\n        from=$(echo ${{ steps.calculate-from-to.outputs.from }})\n        to=$(echo ${{ steps.calculate-from-to.outputs.to }})\n        lua changelog.lua $from $to > changelog.html\n\n    - name: Upload changelog as html\n      uses: actions/upload-artifact@v3\n      with:\n        name: changelog\n        path: changelog.html\n```", "answer": "```yaml name: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n    inputs:\n      from:\n        description: 'Generate from this release/commit (defaults to the latest release)'\n        required: false\n        # default is calculated dynamically\n      to:\n        description: 'Generate until this release/commit (defaults to latest development)'\n        required: false\n        default: 'HEAD'\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n    if: ${{ github.repository_owner == 'Mudlet' }}\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Install Lua 5.1.5\n      uses: leafo/gh-actions-lua@v9\n      with:\n        luaVersion: \"5.1.5\"\n\n    - name: Install Luarocks\n      uses: leafo/gh-actions-luarocks@v4\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install argparse\n        luarocks install lunajson\n\n    - name: Calculate from and to releases\n      run: |\n        if [[ -z \"${{ github.event.inputs.from }}\" ]] ; then\n            FROM_RELEASE=$(git tag --sort=committerdate | tail -1)\n        else\n            FROM_RELEASE=${{ github.event.inputs.from }}\n        fi\n\n        if [[ -z \"${{ github.event.inputs.to }}\" ]] ; then\n            TO_RELEASE=\"HEAD\"\n        else\n            TO_RELEASE=${{ github.event.inputs.to }}\n        fi\n\n        echo \"Generating a changelog from $FROM_RELEASE until $TO_RELEASE\"\n\n        echo \"FROM_RELEASE=$FROM_RELEASE\" >> $GITHUB_ENV\n        echo \"TO_RELEASE=$TO_RELEASE\" >> $GITHUB_ENV\n\n    - name: Generate changelog\n      run: |\n        changelog=$(lua CI/generate-changelog.lua -m release --start-commit $FROM_RELEASE --end-commit $TO_RELEASE)\n        echo \"$changelog\" >> changelog.html\n\n        echo \"[INFO] Changelog generated (from $FROM_RELEASE to $TO_RELEASE). If it's too big, Github won't show it, so it's available as an artifact as well at: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts\"\n        echo \"[INFO] Changelog is:\"\n        echo $changelog\n\n    - name: Upload changelog as html\n      uses: actions/upload-artifact@v3\n      with:\n        name: changelog.html\n        path: changelog.html\n```", "prompt": "Generate a GitHub Workflow named `Generate a changelog` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am. 2) someone manually triggers the workflow. This workflow receives 2 inputs: from-this input represents generate from this release/commit (defaults to the latest release) and it is optional; to-this input represents generate until this release/commit (defaults to latest development), it is optional and its default value is HEAD. The workflow has one job. The job id of the 1st job is `generate-changelog`. The job `generate-changelog` has 7 steps. The 1st step is named `Checkout Mudlet repository`. The 2nd step is named `Install Lua 5.1.5`. The 3rd step is named `Install Luarocks`. The 4th step is named `Install Lua dependencies`. The 5th step is named `Calculate from and to releases`. The 6th step is named `Generate changelog`. The 7th step is named `Upload changelog as html`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v9 version of leafo/gh-actions-lua, v4 version of leafo/gh-actions-luarocks and v3 version of actions/upload-artifact. Here are some variables that might be used in the workflow: github.event.inputs.from, github.event.inputs.to, GITHUB_SERVER_URL, GITHUB_REPOSITORY and GITHUB_RUN_ID. "}
{"id": "63c494347843b612699ffa9f", "level": "level3", "llm_response": "```yaml\nname: Release Charts\n\non:\n  push:\n    tags:\n      - chart-v*\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n      - name: Check chart version\n        run: echo \"Chart version is $GITHUB_REF##*/chart-v\"\n      - name: Packaging the chart\n        run: helm package .\n      - name: Upload chart to GitHub Actions\n        uses: actions/upload-artifact@v3\n        with:\n          name: chart\n          path: *.tgz\n\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Download chart from GitHub Actions\n        uses: actions/download-artifact@v3\n        with:\n          name: chart\n          path: charts\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n      - name: Update charts index\n        run: helm repo index charts\n      - name: Check diffs\n        run: helm diff repo myrepo charts/mychart\n      - name: Commit changes\n        run: |\n          git config --global user.name 'github-actions'\n          git config --global user.email 'github-actions@github.com'\n          git add charts\n          git commit -m \"Update charts\"\n      - name: Push to gh-pages\n        run: git push origin gh-pages\n```", "answer": "```yaml name: Release Charts\n\non:\n  push:\n    tags:\n      - 'chart-v*'\n\njobs:\n  build:\n    runs-on: ubuntu-20.04\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - name: Check chart version\n        run: |\n          tag_version=${GITHUB_REF##*/chart-v}\n          chart_version=$(cat charts/moco/Chart.yaml | grep 'version:' | sed 's/version:\\s//')\n          if [ \"$tag_version\" != \"$chart_version\" ]; then\n            echo \"Different versions: tag \\\"$tag_version\\\", chart \\\"$chart_version\\\"\"\n            exit 1\n          fi\n      - name: Packaging the chart\n        run: helm package ./charts/moco/\n\n      - uses: actions/upload-artifact@v3\n        with:\n          name: helm-charts\n          path: ./moco-*.tgz\n          retention-days: 1\n\n  publish:\n    name: Publish charts on GitHub Pages\n    runs-on: ubuntu-20.04\n    needs: build\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: gh-pages\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - uses: actions/download-artifact@v3\n        with:\n          name: helm-charts\n\n      - name: Update charts index\n        run: helm repo index --url https://cybozu-go.github.io/moco/ --merge index.yaml .\n\n      - run: git add .\n\n      - name: Check diffs\n        run: |\n          diffs=$(git status -s)\n          if [ \"$diffs\" = \"\" ]; then\n            echo \"NO_DIFF=1\" >> $GITHUB_ENV\n          else\n            printf \"%s\\n\" \"$diffs\"\n          fi\n      - name: Commit changes\n        if: env.NO_DIFF != '1'\n        run: |\n          git config --global user.name 'Cybozu Neco'\n          git config --global user.email 'cybozu-neco@users.noreply.github.com'\n          git commit -m 'update'\n      - name: Push to gh-pages\n        if: env.NO_DIFF != '1'\n        run: git push origin gh-pages\n```", "prompt": "Generate a GitHub Workflow named `Release Charts` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches chart-v*. The workflow has 2 jobs. The job id of the 1st job is `build`. The job `build` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Helm`. The 3rd step is named `Check chart version`. The 4th step is named `Packaging the chart`. The 5th step is named ``. The 2nd job is named `Publish charts on GitHub Pages` and its job id is `publish`. The job `publish` has 8 steps. The 1st step is named ``. The 2nd step is named `Set up Helm`. The 3rd step is named ``. The 4th step is named `Update charts index`. The 5th step is named ``. The 6th step is named `Check diffs`. The 7th step is named `Commit changes`. The 8th step is named `Push to gh-pages`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v1 version of azure/setup-helm, v3 version of actions/upload-artifact, v3 version of actions/checkout, v1 version of azure/setup-helm and v3 version of actions/download-artifact. Here are some variables that might be used in the workflow: GITHUB_REF##*/chart-v and GITHUB_REF. "}
{"id": "63c495ca8052faa2781b43be", "level": "level3", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Bump version and push tag\n        id: tagging\n        uses: anothrNick/github-tag-action@1.52.0\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          tag_prefix: 'v'\n\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Login to DockerHub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Login to Quay.io\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.QUAY_BOT_USERNAME }}\n          password: ${{ secrets.QUAY_BOT_PASSWORD }}\n\n      - name: Build and push\n        id: docker_build\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          push: true\n          tags: |\n            docker.io/yourusername/yourimage:${{ steps.tagging.outputs.tag }}\n            quay.io/yourusername/yourimage:${{ steps.tagging.outputs.tag }}\n\n      - name: Build Changelog\n        id: build_changelog\n        uses: mikepenz/release-changelog-builder-action@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          repository: yourusername/yourrepository\n          tag_name: ${{ steps.tagging.outputs.tag }}\n          template: conventional_commits\n\n      - name: Create Github Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ steps.tagging.outputs.tag }}\n          release_name: Release ${{ steps.tagging.outputs.tag }}\n          body: ${{ steps.build_changelog.outputs.changelog }}\n          draft: false\n          prerelease: false\n```", "answer": "```yaml name: Release\non:\n  push:\n    branches:\n      - master\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: '0'\n      - name: Bump version and push tag\n        id: tagging\n        uses: anothrNick/github-tag-action@1.52.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          INITIAL_VERSION: 1.0.0\n          DEFAULT_BUMP: none\n      -\n        name: \"Set up QEMU\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-qemu-action@v2\n      -\n        name: \"Set up Docker Buildx\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-buildx-action@v2\n      -\n        name: \"Login to DockerHub\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      -\n        name: \"Login to Quay.io\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          registry: quay.io\n          username: ${{ secrets.QUAY_BOT_USERNAME }}\n          password: ${{ secrets.QUAY_BOT_PASSWORD }}\n      -\n        name: \"Build and push\"\n        if: steps.tagging.outputs.part\n        id: docker_build\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          platforms: linux/amd64,linux/arm64,linux/arm/v7,linux/ppc64le,linux/s390x\n          tags: |\n            docker.io/kiwigrid/k8s-sidecar:latest\n            docker.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n            quay.io/kiwigrid/k8s-sidecar:latest\n            quay.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n      - name: \"Build Changelog\"\n        if: steps.tagging.outputs.part\n        id: build_changelog\n        uses: mikepenz/release-changelog-builder-action@v3\n        with:\n          configuration: \".github/workflows/release-notes-config.json\"\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      - name: \"Create Github Release\"\n        if: steps.tagging.outputs.part\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token\n        with:\n          tag_name: ${{ steps.tagging.outputs.tag }}\n          release_name: v${{ steps.tagging.outputs.tag }}\n          body: ${{ steps.build_changelog.outputs.changelog }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 9 steps. The 1st step is named ``. The 2nd step is named `Bump version and push tag` and its id is `tagging`. The 3rd step is named `Set up QEMU`. The 4th step is named `Set up Docker Buildx`. The 5th step is named `Login to DockerHub`. The 6th step is named `Login to Quay.io`. The 7th step is named `Build and push` and its id is `docker_build`. The 8th step is named `Build Changelog` and its id is `build_changelog`. The 9th step is named `Create Github Release`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, 1.52.0 version of anothrNick/github-tag-action, v2 version of docker/setup-qemu-action, v2 version of docker/setup-buildx-action, v2 version of docker/login-action, v2 version of docker/login-action, v3 version of docker/build-push-action, v3 version of mikepenz/release-changelog-builder-action and v1 version of actions/create-release. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN, secrets.DOCKER_USERNAME, secrets.DOCKER_PASSWORD, secrets.QUAY_BOT_USERNAME, secrets.QUAY_BOT_PASSWORD, steps.tagging.outputs.tag and steps.build_changelog.outputs.changelog. "}
{"id": "63c494007843b612699fe516", "level": "level3", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    tags: [ 'v*' ]\n  clone:\n    branches: [ main ]\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Install pylint\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.x'\n\n    - name: pylint\n      run: pylint matrix.py\n\n    - name: Make all\n      run: make all\n\n    - name: Darwin build\n      run: ./build.sh darwin\n\n    - name: Integration tests\n      run: go test ./...\n\n  bazel:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Setup Go\n      id: setup_go\n      uses: actions/setup-go@v3\n      with:\n        go-version: '1.17'\n\n    - name: Show bazel variables\n      run: bazel info\n\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v3\n      with:\n        path: ${{ env.BAZEL_REPOSITORY_CACHE }}\n        key: ${{ runner.os }}-bazel-external-repositories-${{ hashFiles('**/WORKSPACE') }}\n        restore-keys: |\n          ${{ runner.os }}-bazel-external-repositories-\n\n    - name: Cache bazel external repositories\n      uses: actions/cache@v3\n      with:\n        path: ${{ env.BAZEL_REPOSITORY_CACHE }}\n        key: ${{ runner.os }}-bazel-external-repositories-${{ hashFiles('**/WORKSPACE') }}\n        restore-keys: |\n          ${{ runner.os }}-bazel-external-repositories-\n\n    - name: Test\n      run: bazel test //...\n\n    - name: Show build timing summary\n      run: bazel build --build_event_text_file=bazel_build_event.txt && bazel info build_event_text_file | xargs cat\n```", "answer": "```yaml name:\n  Test\n\non:\n  push\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-20.04\n    strategy:\n      matrix:\n        py: [\"3.7\"]\n        pylint: [\"==2.9.6\"]\n        go: [ \"1.18\", \"1.19\" ]\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.py }}\n    - name: Install pylint\n      run: pip install --user pylint${{ matrix.pylint }}\n    - name: pylint\n      run: |\n        pylint adapters/python/martian_shell.py\n        pylint adapters/python/martian.py\n        pylint test/martian_test.py\n    - uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n    - uses: actions/setup-node@v3\n      with:\n        node-version: \"lts/*\"\n        cache: \"npm\"\n        cache-dependency-path: |\n          web/martian/yarn.lock\n          tools/syntax/vscode/yarn.lock\n    - name: make all\n      run: make all tarball\n    - name: darwin build\n      run: GOOS=darwin go build ./cmd/...\n    - name: Integration tests\n      run: make longtests\n\n  bazel:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: \"3.x\"\n    - uses: actions/setup-go@v3\n      id: setup_go\n      with:\n        go-version: \">=1.19\"\n    - name: Show bazel variables\n      run: |\n        bazel info\n        echo \"bazel_repository_cache=$(bazel info repository_cache)\" >> $GITHUB_ENV\n        echo \"bazel_output_base=$(bazel info output_base)\" >> $GITHUB_ENV\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_output_base }}/external\n        key: bazel-build-cache-${{steps.setup_go.outputs.go-version}}-${{hashFiles('deps.bzl', 'WORKSPACE')}}\n        restore-keys: |\n          bazel-build-cache-${{steps.setup_go.outputs.go-version}}\n          bazel-build-cache-\n    - name: Cache bazel external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_repository_cache }}\n        key: bazel-repo-cache-${{hashFiles('deps.bzl', 'WORKSPACE', 'web/martian/yarn.lock')}}\n        restore-keys: |\n          bazel-repo-cache-\n    - name: test\n      run: |\n        bazel test --nobuild_tests_only \\\n                   --verbose_failures \\\n                   --discard_analysis_cache \\\n                   --notrack_incremental_state \\\n                   --nokeep_state_after_build \\\n                   //...\n    - name: Show build timing summary\n      run: bazel analyze-profile ${{ env.bazel_output_base }}/command.profile.gz\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `make`. The job `make` has 9 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Install pylint`. The 4th step is named `pylint`. The 5th step is named ``. The 6th step is named ``. The 7th step is named `make all`. The 8th step is named `darwin build`. The 9th step is named `Integration tests`. The job id of the 2nd job is `bazel`. The job `bazel` has 8 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `` and its id is `setup_go`. The 4th step is named `Show bazel variables`. The 5th step is named `Cache bazel build of external repositories`. The 6th step is named `Cache bazel external repositories`. The 7th step is named `test`. The 8th step is named `Show build timing summary`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v4 version of actions/setup-python, v3 version of actions/setup-go, v3 version of actions/setup-node, v3 version of actions/checkout, v4 version of actions/setup-python, v3 version of actions/setup-go, v3 version of actions/cache and v3 version of actions/cache. Here are some variables that might be used in the workflow: matrix.py, matrix.pylint, matrix.go, env.bazel_output_base, steps.setup_go.outputs.go-version and env.bazel_repository_cache. "}
{"id": "63c494257843b612699ff4b7", "level": "level3", "llm_response": "```yaml\nname: functional-identity\n\non:\n  pull_request:\n    paths:\n      - 'identity/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-identity:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        name: [openstack-victoria, openstack-wallaby]\n        openstack_version: [victoria, wallaby]\n\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          openstack_version: ${{ matrix.openstack_version }}\n\n      - name: Checkout go\n        uses: actions/checkout@v3\n        with:\n          path: go\n\n      - name: Run Gophercloud acceptance tests\n        run: |\n          cd go\n          go test -v ./...\n\n      - name: Generate logs on failure\n        if: failure()\n        run: |\n          echo \"Generating logs...\"\n          # Add your log generation commands here\n\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: logs\n          path: logs\n```", "answer": "```yaml name: functional-identity\non:\n  pull_request:\n    paths:\n      - '**identity**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-identity:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: \"^.*identity.*$\"\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-identity-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-identity` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**identity**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests` and its job id is `functional-identity`. The job `functional-identity` has 6 steps. The 1st step is named `Checkout Gophercloud`. The 2nd step is named `Deploy devstack`. The 3rd step is named `Checkout go`. The 4th step is named `Run Gophercloud acceptance tests`. The 5th step is named `Generate logs on failure`. The 6th step is named `Upload logs artifacts on failure`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v0.9 version of EmilienM/devstack-action, v3 version of actions/setup-go and v3 version of actions/upload-artifact. Here are some variables that might be used in the workflow: matrix.openstack_version, github.workspace and matrix.name. "}
{"id": "63c495038052faa2781aede6", "level": "level3", "llm_response": "```yaml\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n        numpy-version: [1.19, 1.20, 1.21]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Setup Miniconda\n      uses: conda-incubator/setup-miniconda@master\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Create Conda environment with the right deps\n      run: |\n        conda create -n test-env python=${{ matrix.python-version }}\n        conda activate test-env\n        conda install numpy=${{ matrix.numpy-version }}\n\n    - name: Install dependencies\n      run: |\n        pip install -r requirements.txt\n\n    - name: Tests\n      run: |\n        pytest\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n        numpy_version: ['>=1.22.0', '==1.20.*']\n        exclude:\n          - python-version: '3.10'\n            numpy_version: '==1.20.*'\n    services:\n      redis:\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n      mongodb:\n        image: mongo:4.4.11\n        ports:\n          - 27017:27017\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Setup Miniconda\n      uses: conda-incubator/setup-miniconda@master\n      with:\n          channels: conda-forge\n          python-version: ${{ matrix.python-version }}\n      env:\n        ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n    # Runs a set of commands using the runners shell\n    - name: Create Conda environment with the rights deps\n      shell: \"bash -l {0}\"\n      run: |\n        conda create -n zarr-env python==${{matrix.python-version}} bsddb3 numcodecs lmdb pip nodejs flake8 mypy\n        conda activate zarr-env\n        npm install -g azurite\n    - name: Install dependencies\n      shell: \"bash -l {0}\"\n      run: |\n        conda activate zarr-env\n        python -m pip install --upgrade pip\n        python -m pip install -U pip setuptools wheel codecov line_profiler\n        python -m pip install -rrequirements_dev_minimal.txt numpy${{matrix.numpy_version}} -rrequirements_dev_optional.txt pymongo redis\n        python -m pip install .\n        python -m pip freeze\n    - name: Tests\n      shell: \"bash -l {0}\"\n      env:\n        COVERAGE_FILE: .coverage.${{matrix.python-version}}.${{matrix.numpy_version}}\n        ZARR_TEST_ABS: 1\n        ZARR_TEST_MONGO: 1\n        ZARR_TEST_REDIS: 1\n        ZARR_V3_EXPERIMENTAL_API: 1\n      run: |\n        conda activate zarr-env\n        mkdir ~/blob_emulator\n        azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n        pytest --cov=zarr --cov-config=.coveragerc --doctest-plus --cov-report xml --cov=./ --timeout=300\n    - uses: codecov/codecov-action@v3\n      with:\n        #token: ${{ secrets.CODECOV_TOKEN }} # not required for public repos\n          #files: ./coverage1.xml,./coverage2.xml # optional\n          #flags: unittests # optional\n          #name: codecov-umbrella # optional\n          #fail_ci_if_error: true # optional (default = false)\n        verbose: true # optional (default = false)\n```", "prompt": "Generate a GitHub Workflow named `Linux Testing` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named `Setup Miniconda`. The 3rd step is named `Create Conda environment with the rights deps`. The 4th step is named `Install dependencies`. The 5th step is named `Tests`. The 6th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, master version of conda-incubator/setup-miniconda and v3 version of codecov/codecov-action. Here are some variables that might be used in the workflow: matrix.python-version and matrix.numpy_version. "}
{"id": "63c4967e33b087f6bde2c5c4", "level": "level3", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install and Build \ud83d\udd27\n        run: |\n          npm install\n          npm run build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.0.0\n        with:\n          branch: gh-pages\n          folder: dist\n```", "answer": "```yaml name: Build and Deploy\non:\n  push:\n    branches:\n    - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n        \n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install\n          npm run build\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.0.0\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist #  The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build-and-deploy`. The job `build-and-deploy` has 3 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install and Build \ud83d\udd27`. The 3rd step is named `Deploy \ud83d\ude80`. Here are some Github Actions that might be used in the workflow: v2.3.1 version of actions/checkout and 4.0.0 version of JamesIves/github-pages-deploy-action. "}
{"id": "63c496926fc19abdf9c9cd93", "level": "level3", "llm_response": "```yaml\nname: Contributor License Agreement (CLA)\n\non:\n  pull_request:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n  pull_request_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check CLA\n        uses: Shopify/shopify-cla-action@v1\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          cla_token: ${{ secrets.CLA_TOKEN }}\n```", "answer": "```yaml name: Contributor License Agreement (CLA)\n\non:\n  pull_request_target:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    if: |\n      (github.event.issue.pull_request \n        && !github.event.issue.pull_request.merged_at\n        && contains(github.event.comment.body, 'signed')\n      ) \n      || (github.event.pull_request && !github.event.pull_request.merged)\n    steps:\n      - uses: Shopify/shopify-cla-action@v1\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          cla-token: ${{ secrets.CLA_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Contributor License Agreement (CLA)` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) a pull request is created or a pull request's head branch is updated. 2) a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `cla`. The job `cla` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v1 version of Shopify/shopify-cla-action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and secrets.CLA_TOKEN. "}
{"id": "63c496836fc19abdf9c9c720", "level": "level3", "llm_response": "```yaml\nname: TagBot\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: TagBot\non:\n  schedule:\n    - cron: 0 0 * * *\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `TagBot`. The job `TagBot` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v1 version of JuliaRegistries/TagBot. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c496741e3364807577abc2", "level": "level3", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [created]\n  pull_request:\n    types: [created]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          documenter_key: ${{ secrets.DOCUMENTER_KEY }}\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. The job `TagBot` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v1 version of JuliaRegistries/TagBot. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and secrets.DOCUMENTER_KEY. "}
{"id": "63c495f37843b61269a0b108", "level": "level3", "llm_response": "```yaml\nname: PR Approval Bypass Notifier\n\non:\n  pull_request:\n    branches:\n      - main\n    types: [closed]\n\npermissions:\n  pull-requests: read\n\njobs:\n  approval:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Fail If No Approval\n        if: github.event.pull_request.merged == true && github.event.pull_request.merged_by == null\n        run: echo \"Pull request merged without approval\" && exit 1\n\n      - name: Slack Notification\n        if: github.event.pull_request.merged == true && github.event.pull_request.merged_by == null\n        uses: slackapi/slack-github-action@v1\n        with:\n          slack_token: ${{ secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK }}\n          channel: '#notifications'\n          message: \"Pull request #${{ github.event.pull_request.number }} merged without approval. [View PR](${{ github.event.pull_request.html_url }})\"\n```", "answer": "```yaml name: PR Approval Bypass Notifier\non:\n  pull_request:\n    types:\n      - closed\n    branches:\n      - main\npermissions:\n  pull-requests: read\njobs:\n  approval:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Fail If No Approval\n        if: ${{ github.event.pull_request.merged }}\n        env:\n          AUTH_HEADER: 'Authorization: token ${{ secrets.GITHUB_TOKEN }}'\n          JSON_HEADER: 'Content-Type: application/json'\n          REVIEWS_URL: 'https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews'\n        run: |\n          curl -sSL -H \"${JSON_HEADER}\" -H \"${AUTH_HEADER}\" \"${REVIEWS_URL}\" \\\n            | jq -e '. | map({user: .user.login, state: .state})\n                       | reduce .[] as $x ({}; .[$x.user] = $x.state)\n                       | to_entries | map(.value)\n                       | contains([\"APPROVED\"]) and (contains([\"CHANGES_REQUESTED\"]) | not)'\n      - name: Slack Notification\n        if: ${{ failure() }}\n        run: |\n          jq --null-input '{ text: \"Oh no! The following PR was merged without approval: w${{github.event.pull_request.html_url}}\" }' \\\n          | curl -sSL -X POST -H 'Content-Type: application/json' -d @- '${{ secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK }}'\n```", "prompt": "Generate a GitHub Workflow named `PR Approval Bypass Notifier` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `approval`. The job `approval` has 2 steps. The 1st step is named `Fail If No Approval`. The 2nd step is named `Slack Notification`. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN, github.repository, github.event.pull_request.number, github.event.pull_request.html_url and secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK. "}
{"id": "63c496561e3364807577a06a", "level": "level3", "llm_response": "```yaml\nname: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '30 17 * * *'\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Run script to gather RQ statistical data and write it to Google Sheet\n      run: npm run gather-rq-data\n      env:\n        RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n        RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n        RQ_USERID: ${{ secrets.RQ_USERID }}\n        GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n        GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n        GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n        BARK_KEY: ${{ secrets.BARK_KEY }}\n        GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n        GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n        GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n        GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n```", "answer": "```yaml name: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"30 17 * * *\"\n#  push:\n#    branches:\n#      - main\n\nenv:\n  # please change to your own config.\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    name: Gather RQ statistical data and write it to google sheet\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n      - run: yarn\n      - run: yarn rq\n```", "prompt": "Generate a GitHub Workflow named `Gather RQ statistical data and write it to google sheet` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 05:30 pm. The workflow has one job. The 1st job is named `Gather RQ statistical data and write it to google sheet` and its job id is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/setup-node. Here are some variables that might be used in the workflow: secrets.RQ_COOKIE, secrets.RQ_CSRF_TOKEN, secrets.RQ_USERID, secrets.GOOGLE_SHEET_ID, secrets.GOOGLE_API_CLIENT_EMAIL, secrets.GOOGLE_API_PRIVATE_KEY, secrets.BARK_KEY, secrets.GARMIN_USERNAME, secrets.GARMIN_PASSWORD, secrets.GARMIN_GLOBAL_USERNAME and secrets.GARMIN_GLOBAL_PASSWORD. "}
{"id": "63c4957d8052faa2781b22a0", "level": "level3", "llm_response": "```yaml\nname: Close stale\n\non:\n  schedule:\n    - cron: '0 1 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      \n      - name: Run stale action\n        uses: knative/actions/.github/workflows/stale.yaml@main\n```", "answer": "```yaml # Copyright 2020 The Knative Authors.\n# SPDX-License-Identifier: Apache-2.0\n\n# This file is automagically synced here from github.com/knative-sandbox/knobots\nname: 'Close stale'\n\non:\n  schedule:\n  - cron: '0 1 * * *'\n\njobs:\n\n  stale:\n    uses: knative/actions/.github/workflows/stale.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `Close stale` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 01:00 am. The workflow has one job. The job id of the 1st job is `stale`. Here are some reusable workflows that might be used in the workflow: {'version': 'main', 'name': 'knative/actions/.github/workflows/stale.yaml'}. "}
{"id": "63c4959f7843b61269a08d83", "level": "level3", "llm_response": "```yaml\nname: CompatHelper\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n      - name: CompatHelper.main()\n        run: julia -e 'using CompatHelper; CompatHelper.main()'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          TAGBOT: ${{ secrets.TAGBOT }}\n```", "answer": "```yaml name: CompatHelper\n\non:\n  schedule:\n    - cron: '00 00 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: [1.2.0]\n        julia-arch: [x86]\n        os: [ubuntu-latest]\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n      - name: CompatHelper.main()\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          COMPATHELPER_PRIV: ${{ secrets.TAGBOT }}\n        run: julia -e 'using CompatHelper; CompatHelper.main()'\n```", "prompt": "Generate a GitHub Workflow named `CompatHelper` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `CompatHelper`. The job `CompatHelper` has 2 steps. The 1st step is named `Pkg.add(\"CompatHelper\")`. The 2nd step is named `CompatHelper.main()`. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and secrets.TAGBOT. "}
{"id": "63c494358052faa2781a9de3", "level": "level3", "llm_response": "```yaml\nname: JumpServer repos generic handler\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  release:\n    types: [created]\n\njobs:\n  generic_handler:\n    id: generic_handler\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Run generic handler\n        uses: jumpserver/action-generic-handler@master\n        with:\n          private_token: ${{ secrets.PRIVATE_TOKEN }}\n```", "answer": "```yaml on: [push, pull_request, release]\n\nname: JumpServer repos generic handler\n\njobs:\n  generic_handler:\n    name: Run generic handler\n    runs-on: ubuntu-latest\n    steps:\n      - uses: jumpserver/action-generic-handler@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.PRIVATE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `JumpServer repos generic handler` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. 3) release activity in the repository occurs. The workflow has one job. The 1st job is named `Run generic handler` and its job id is `generic_handler`. The job `generic_handler` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: master version of jumpserver/action-generic-handler. Here are some variables that might be used in the workflow: secrets.PRIVATE_TOKEN. "}
{"id": "63c494998052faa2781ac05b", "level": "level3", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    branches: [ dev ]\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        language: [javascript]\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n\n    - name: Autobuild\n      run: npm install && npm run build\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ dev ]\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java', 'javascript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://git.io/codeql-language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      run: |\n        cd etc/build\n        npm install workbox-cli@6.3.0 --global\n        ant\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 01:06 pm. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named `Perform CodeQL Analysis`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of github/codeql-action/init and v2 version of github/codeql-action/analyze. Here are some variables that might be used in the workflow: matrix.language. "}
{"id": "63c494298052faa2781a98fa", "level": "level3", "llm_response": "```yaml\nname: Check test times\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Cache\n      uses: hendrikmuhs/ccache-action@v1.2\n\n    - name: Setup\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y build-essential\n\n    - name: Build\n      run: make\n\n    - name: Run tests\n      run: make test\n\n    - name: Save test times\n      run: |\n        test_times=$(make test-time)\n        echo \"::set-output name=test_times::$test_times\"\n\n    - name: Check test times\n      run: |\n        test_times=$(make test-time)\n        if [ \"$test_times\" -gt 10 ]; then\n          echo \"Test times are too high: $test_times\"\n          exit 1\n        else\n          echo \"Test times are acceptable: $test_times\"\n        fi\n```", "answer": "```yaml name: Check test times\non: [push, pull_request]\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Cache\n      uses: hendrikmuhs/ccache-action@v1.2\n      with:\n        key: linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-${{ hashFiles('**/*.hpp', '**/*.cpp') }}\n        restore-keys: |\n          linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-\n          linux-ci-build-times-${{ github.ref }}-\n          linux-ci-build-times-refs/heads/master-\n          linux-ci-build-times-\n    - name: Setup\n      run: |\n        sudo apt update\n        sudo apt install -y libboost-dev autoconf automake libtool ccache\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"ccache gcc\" CXX=\"ccache g++\" CXXFLAGS=\"-O2 -g0\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,faster.xml:HRF,message -- --faster\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,fast.xml:HRF,message -- --fast\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,all.xml:HRF,message\n    - name: Save test times\n      uses: actions/upload-artifact@v3\n      with:\n        name: test-reports\n        path: ./all.xml\n    - name: Check test times\n      run: |\n        python ./tools/check_test_times.py\n```", "prompt": "Generate a GitHub Workflow named `Check test times` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check-test-times`. The job `check-test-times` has 7 steps. The 1st step is named ``. The 2nd step is named `Cache`. The 3rd step is named `Setup`. The 4th step is named `Build`. The 5th step is named `Run tests`. The 6th step is named `Save test times`. The 7th step is named `Check test times`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v1.2 version of hendrikmuhs/ccache-action and v3 version of actions/upload-artifact. Here are some variables that might be used in the workflow: github.ref and github.head_ref. "}
{"id": "63c496981899db58864d3f6f", "level": "level3", "llm_response": "```yaml\nname: Re-run Workflow\n\non:\n  workflow_run:\n    workflows: [\"CI\"]\n    types: [completed]\n  pull_request:\n    types: [closed, labeled, unlabeled]\n  schedule:\n    - cron: '30 */3 * * *'\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Re-run CI workflow\n        uses: reitermarkus/rerun-workflow@v2.0.0\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "answer": "```yaml name: Re-run Workflow\n\non:\n  workflow_run:\n    workflows:\n      - CI\n    types:\n      - completed\n  pull_request_target:\n    types:\n      - closed\n      - labeled\n      - unlabeled\n  schedule:\n    - cron: '30 */3 * * *' # every 3 hours (30 minutes past the hour)\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    if: >\n      startsWith(github.repository, 'Homebrew/') &&\n      (\n        github.event.label.name == 'ci-requeue' ||\n        github.event.label.name == 'ci-retry' ||\n        github.event.label.name == 'ci-skip-appcast' ||\n        github.event.label.name == 'ci-skip-install' ||\n        github.event.label.name == 'ci-syntax-only' ||\n        !github.event.label.name\n      )\n    runs-on: ubuntu-latest\n    steps:\n      - name: Re-run CI workflow\n        uses: reitermarkus/rerun-workflow@c8d5bc3526acb50c12004f31c0dcb1598c87e32d\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n          once-label: ci-requeue\n          continuous-label: ci-retry\n          trigger-labels: ci-skip-appcast,ci-skip-install,ci-syntax-only\n          workflow: ci.yml\n```", "prompt": "Generate a GitHub Workflow named `Re-run Workflow` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) the workflow named CI is completed. 2) a pull request is closed, a label is added to a pull request or a label is removed from a pull request. 3) the scheduled time has come: at 30 minutes past the hour, every 3 hours. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `rerun-workflow`. The job `rerun-workflow` has one step. The 1st step is named `Re-run CI workflow`. Here are some Github Actions that might be used in the workflow: c8d5bc3526acb50c12004f31c0dcb1598c87e32d version of reitermarkus/rerun-workflow. Here are some variables that might be used in the workflow: secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN. "}
{"id": "63c493bc7843b612699fd432", "level": "level3", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n  push:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '14'\n    - name: Install dependencies\n      run: npm install\n    - name: Run linting\n      run: npx xo\n\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '14'\n    - name: Install dependencies\n      run: npm install\n    - name: Build project\n      run: npm run build\n```", "answer": "```yaml env: {}\n\n# FILE GENERATED WITH: npx ghat fregante/ghatemplates/node\n# SOURCE: https://github.com/fregante/ghatemplates\n# OPTIONS: {\"exclude\":[\"jobs.Test\"]}\n\nname: CI\non:\n  - pull_request\n  - push\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n      - name: install\n        run: npm ci || npm install\n      - name: XO\n        run: npx xo\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: install\n        run: npm ci || npm install\n      - name: build\n        run: npm run build\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) a commit or tag is pushed, or a repository is cloned. The workflow has 2 jobs. The job id of the 1st job is `Lint`. The job `Lint` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `install`. The 4th step is named `XO`. The job id of the 2nd job is `Build`. The job `Build` has 3 steps. The 1st step is named ``. The 2nd step is named `install`. The 3rd step is named `build`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-node and v3 version of actions/checkout. "}
{"id": "63c493f47843b612699fe037", "level": "level3", "llm_response": "```yaml\nname: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        branch: [main, develop]\n        channel: [stable, beta]\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3.1.0\n\n    - name: Update image list\n      run: |\n        # Add your script to update the image list here\n        echo \"Updating image list...\"\n\n    - name: Create pull request\n      uses: peter-evans/create-pull-request@v4\n      with:\n        branch: ${{ matrix.branch }}\n        title: Update image list for ${{ matrix.channel }}\n        commit-message: Update image list for ${{ matrix.channel }}\n        labels: [images, automation]\n```", "answer": "```yaml name: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"0 10 * * *\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        include:\n          - { branch: master, channel: latest/edge }\n          - { branch: 1.24, channel: 1.24 }\n          - { branch: 1.23, channel: 1.23 }\n          - { branch: 1.22, channel: 1.22 }\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ matrix.branch }}\n      - name: Update image list\n        run: |\n          ./build-scripts/update-images.sh ${{ matrix.channel }} build-scripts/images.txt\n      - name: Create pull request\n        uses: peter-evans/create-pull-request@v4\n        with:\n          commit-message: update list of images used by ${{ matrix.channel }}\n          title: \"[${{ matrix.channel }}] Update MicroK8s images\"\n          body: update list of images used by ${{ matrix.channel }}\n          reviewers: neoaggelos,ktsakalozos\n          branch: auto-update-images/${{ matrix.branch }}\n          delete-branch: true\n          base: ${{ matrix.branch }}\n```", "prompt": "Generate a GitHub Workflow named `Update list of images` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `update`. The job `update` has 3 steps. The 1st step is named `Checkout`. The 2nd step is named `Update image list`. The 3rd step is named `Create pull request`. Here are some Github Actions that might be used in the workflow: v3.1.0 version of actions/checkout and v4 version of peter-evans/create-pull-request. Here are some variables that might be used in the workflow: matrix.branch and matrix.channel. "}
{"id": "63c494368052faa2781a9e20", "level": "level3", "llm_response": "```yaml\nname: build\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - v*\n  pull_request:\n\npermissions:\n  contents: write\n  id-token: write\n  packages: write\n\njobs:\n  build:\n    runs-on: ${{ runner.os }}\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: 1.17\n\n      - name: Cache Go modules\n        uses: actions/cache@v3\n        with:\n          path: ~/.cache/go-build\n          key: ${{ runner.os }}-go-${{ hashFiles('**/go.mod') }}\n          restore-keys: |\n            ${{ runner.os }}-go-\n\n      - name: CI\n        run: go test ./...\n\n      - name: Run GoReleaser\n        uses: goreleaser/goreleaser-action@v2.8.1\n        with:\n          github_token: ${{ secrets.GH_PAT }}\n          goreleaser_token: ${{ secrets.GORELEASER_KEY }}\n          release_notes: ${{ github.event.pull_request.body }}\n          release_name: ${{ github.event.pull_request.title }}\n          release_tag: ${{ github.event.pull_request.head.sha }}\n          goreleaser_args: --rm-dist\n```", "answer": "```yaml name: build\n\non:\n  push:\n    branches:\n      - 'main'\n    tags:\n      - 'v*'\n  pull_request:\n\npermissions:\n   contents: write\n   id-token: write\n   packages: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      -\n        name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: 1.17\n      -\n        name: Cache Go modules\n        uses: actions/cache@v3\n        with:\n          path: ~/go/pkg/mod\n          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}\n          restore-keys: |\n            ${{ runner.os }}-go-\n      -\n        name: CI\n        run: |\n          go mod tidy\n          go test -v ./...\n          go build -o tt .\n      - uses: sigstore/cosign-installer@v2.8.1\n      -\n        name: Run GoReleaser\n        uses: goreleaser/goreleaser-action@v3\n        if: success() && startsWith(github.ref, 'refs/tags/')\n        with:\n          distribution: goreleaser-pro\n          version: latest\n          args: release --rm-dist\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n          FURY_TOKEN: ${{ secrets.FURY_TOKEN }}\n          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}\n          TWITTER_CONSUMER_KEY: ${{ secrets.TWITTER_CONSUMER_KEY }}\n          TWITTER_CONSUMER_SECRET: ${{ secrets.TWITTER_CONSUMER_SECRET }}\n          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}\n          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}\n          COSIGN_PWD: ${{ secrets.COSIGN_PWD }}\n          AUR_KEY: ${{ secrets.AUR_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a tag whose name matches v*. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope, write access is granted to the GITHUB_TOKEN in the `id-token` scope and write access is granted to the GITHUB_TOKEN in the `packages` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Go`. The 3rd step is named `Cache Go modules`. The 4th step is named `CI`. The 5th step is named ``. The 6th step is named `Run GoReleaser`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-go, v3 version of actions/cache, v2.8.1 version of sigstore/cosign-installer and v3 version of goreleaser/goreleaser-action. Here are some variables that might be used in the workflow: runner.os, secrets.GH_PAT, secrets.FURY_TOKEN, secrets.GORELEASER_KEY, secrets.TWITTER_CONSUMER_KEY, secrets.TWITTER_CONSUMER_SECRET, secrets.TWITTER_ACCESS_TOKEN, secrets.TWITTER_ACCESS_TOKEN_SECRET, secrets.COSIGN_PWD and secrets.AUR_KEY. "}
{"id": "63c493b77843b612699fd355", "level": "level3", "llm_response": "```yaml\nname: docs\n\non:\n  push:\n    branches:\n      - develop\n      - release\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n    branches:\n      - develop\n      - release\n\nconcurrency:\n  group: docs\n  cancel-in-progress: true\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Track Docs Branch\n        run: echo \"Docs branch is ${{ github.ref }}\"\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n\n      - name: Cache dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Update pip\n        run: python -m pip install --upgrade pip\n\n      - name: Set Git author\n        run: git config --global user.email \"github-actions[bot]@users.noreply.github.com\" && git config --global user.name \"GitHub Actions\"\n\n      - name: Install native dependencies\n        run: sudo apt-get update && sudo apt-get install -y build-essential libssl-dev libffi-dev\n\n      - name: Install wheel\n        run: pip install wheel\n\n      - name: Install Material for MkDocs Insiders\n        run: pip install mkdocs-material-insiders\n\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n\n      - name: Update from Remote\n        run: git pull origin ${{ github.ref }}\n\n      - name: Build docs (latest)\n        run: mkdocs build --site-dir site/latest\n\n      - name: Build docs (develop)\n        run: mkdocs build --site-dir site/develop\n\n      - name: Build docs\n        run: mkdocs build\n```", "answer": "```yaml name: docs\n\nconcurrency: docs\n\non:\n  push:\n    branches: [ develop, release ]\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Track Docs Branch\n      run: git branch docs -t origin/docs\n    - uses: actions/setup-python@v4\n      with:\n        python-version: 3.x\n    - uses: actions/cache@v3\n      with:\n        key: ${{ github.ref }}\n        path: .cache\n    - uses: pnpm/action-setup@v2.2.2\n      with:\n        version: 7\n    - name: Lint Docs\n      run: |\n        pnpm i\n        pnpm lint\n    - name: Update pip\n      run: python -m pip install -U pip setuptools\n    - name: Set Git author\n      run: |\n        git config user.name \"github-actions[bot]\"\n        git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n    - name: Install native dependencies\n      run: sudo apt-get install libcairo2-dev libfreetype6-dev libffi-dev libjpeg-dev libpng-dev libz-dev\n    - name: Install wheel\n      run: pip install wheel\n    - name: Install Material for MkDocs Insiders\n      run: pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git\n      if: ${{ github.repository_owner == 'mastercomfig' && github.event_name != 'pull_request' }}\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Install dependencies\n      run: pip install -r docs/requirements.txt\n    - name: Update from Remote\n      run: git fetch --tags -f\n    - name: Build docs (latest)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/release' }}\n      run: mike deploy --alias-type copy -b docs -up $(git describe --tags --abbrev=0) latest page\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs (develop)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/develop' }}\n      run: mike deploy --alias-type copy -b docs -p dev\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs\n      if: ${{ github.event_name == 'pull_request' }}\n      run: mike deploy --config-file mkdocs.base.yml -u $(git describe --tags) latest\n```", "prompt": "Generate a GitHub Workflow named `docs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named develop or a branch named release. Only if at least one path of push event matches a pattern in the paths filter(docs/**, mkdocs.yml or .github/workflows/docs.yml), the workflow runs. 2) there is activity relating to a pull request. Only a single workflow using the docs concurrency group will run at a time. The workflow has one job. The job id of the 1st job is `deploy`. The job `deploy` has 16 steps. The 1st step is named ``. The 2nd step is named `Track Docs Branch`. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named `Lint Docs`. The 7th step is named `Update pip`. The 8th step is named `Set Git author`. The 9th step is named `Install native dependencies`. The 10th step is named `Install wheel`. The 11th step is named `Install Material for MkDocs Insiders`. The 12th step is named `Install dependencies`. The 13th step is named `Update from Remote`. The 14th step is named `Build docs (latest)`. The 15th step is named `Build docs (develop)`. The 16th step is named `Build docs`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v4 version of actions/setup-python, v3 version of actions/cache and v2.2.2 version of pnpm/action-setup. Here are some variables that might be used in the workflow: github.ref and secrets.PRIVATE_REPO_TOKEN. "}
{"id": "63c495a68052faa2781b342a", "level": "level3", "llm_response": "```yaml\nname: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches:\n      - master\n      - 1.x\n      - release\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Maven Central Repository\n        run: |\n          echo \"OSSRH_USERNAME=${{ secrets.OSSRH_USERNAME }}\" >> $GITHUB_ENV\n          echo \"OSSRH_PASSWORD=${{ secrets.OSSRH_PASSWORD }}\" >> $GITHUB_ENV\n          echo \"MAVEN_GPG_PRIVATE_KEY=${{ secrets.MAVEN_GPG_PRIVATE_KEY }}\" >> $GITHUB_ENV\n          echo \"MAVEN_GPG_PASSPHRASE=${{ secrets.MAVEN_GPG_PASSPHRASE }}\" >> $GITHUB_ENV\n\n      - name: Publish package\n        run: mvn deploy -DskipTests=true\n```", "answer": "```yaml name: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches: [master, 1.x, release]\n\njobs:\n  release:\n    if: github.repository == 'jdbc-observations/datasource-proxy'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Maven Central Repository\n        uses: actions/setup-java@v3\n        with:\n          java-version: 8\n          distribution: temurin\n          server-id: ossrh\n          server-username: MAVEN_USERNAME\n          server-password: MAVEN_PASSWORD\n          gpg-private-key: ${{ secrets.MAVEN_GPG_PRIVATE_KEY }}\n          gpg-passphrase: MAVEN_GPG_PASSPHRASE\n      - name: Publish package\n        run: ./mvnw --batch-mode deploy -DskipTests=true -Pgithub-ossrh\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}\n          MAVEN_GPG_PASSPHRASE: ${{ secrets.MAVEN_GPG_PASSPHRASE }}\n\n```", "prompt": "Generate a GitHub Workflow named `Release to Maven Central (Deploy Snapshot or Stage Release)` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master, a branch named 1.x or a branch named release. The workflow has one job. The job id of the 1st job is `release`. The job `release` has 3 steps. The 1st step is named ``. The 2nd step is named `Set up Maven Central Repository`. The 3rd step is named `Publish package`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/setup-java. Here are some variables that might be used in the workflow: secrets.MAVEN_GPG_PRIVATE_KEY, secrets.OSSRH_USERNAME, secrets.OSSRH_PASSWORD and secrets.MAVEN_GPG_PASSPHRASE. "}
{"id": "63c494257843b612699ff4be", "level": "level3", "llm_response": "```yaml\nname: functional-orchestration\n\non:\n  pull_request:\n    paths:\n      - 'orchestration/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-orchestration:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        name: [openstack-16.1, openstack-17.1]\n        openstack_version: [16.1, 17.1]\n\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          openstack_version: ${{ matrix.openstack_version }}\n\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '1.17'\n\n      - name: Run Gophercloud acceptance tests\n        run: go test -v ./acceptance\n\n      - name: Generate logs on failure\n        if: failure()\n        run: echo \"Generating logs...\"\n\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: logs\n          path: logs/\n```", "answer": "```yaml name: functional-orchestration\non:\n  pull_request:\n    paths:\n      - '**orchestration**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-orchestration:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n          conf_overrides: |\n            enable_plugin heat https://opendev.org/openstack/heat ${{ matrix.openstack_version }}\n          enabled_services: 'h-eng,h-api,h-api-cfn,h-api-cw'\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: ^.*orchestration.*$\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-orchestration-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-orchestration` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**orchestration**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests` and its job id is `functional-orchestration`. The job `functional-orchestration` has 6 steps. The 1st step is named `Checkout Gophercloud`. The 2nd step is named `Deploy devstack`. The 3rd step is named `Checkout go`. The 4th step is named `Run Gophercloud acceptance tests`. The 5th step is named `Generate logs on failure`. The 6th step is named `Upload logs artifacts on failure`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v0.9 version of EmilienM/devstack-action, v3 version of actions/setup-go and v3 version of actions/upload-artifact. Here are some variables that might be used in the workflow: matrix.openstack_version, github.workspace and matrix.name. "}
{"id": "63c495167843b61269a0553c", "level": "level3", "llm_response": "```yaml\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Run reusable workflow\n        uses: openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master\n```", "answer": "```yaml # Run the workflow that adds new tickets that are either:\n# - labelled \"DEPR\"\n# - title starts with \"[DEPR]\"\n# - body starts with \"Proposal Date\" (this is the first template field)\n# to the org-wide DEPR project board\n\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    uses: openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master\n    secrets:\n      GITHUB_APP_ID: ${{ secrets.GRAPHQL_AUTH_APP_ID }}\n      GITHUB_APP_PRIVATE_KEY: ${{ secrets.GRAPHQL_AUTH_APP_PEM }}\n      SLACK_BOT_TOKEN: ${{ secrets.SLACK_ISSUE_BOT_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Add newly created DEPR issues to the DEPR project board` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `routeissue`. Here are some reusable workflows that might be used in the workflow: {'version': 'master', 'name': 'openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml'}. "}
{"id": "63c495e88052faa2781b50cc", "level": "level3", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [opened, synchronize]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          documenter_key: ${{ secrets.DOCUMENTER_KEY }}\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. The job `TagBot` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v1 version of JuliaRegistries/TagBot. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and secrets.DOCUMENTER_KEY. "}
{"id": "63c496876fc19abdf9c9c8bb", "level": "level3", "llm_response": "```yaml\nname: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: '*/30 * * * *'\n\njobs:\n  build-feeds:\n    id: build-feeds\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Repo\n      uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n\n    - name: Install Dependencies\n      run: npm install\n\n    - name: Checkout Data Source Repo\n      uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n\n    - name: Process Data\n      run: npm run process-data\n\n    - name: Deploy to Firebase\n      uses: w9jds/firebase-action@94389a881adad57284e35860f5d258ab262dcd91\n      with:\n        args: deploy --only functions\n      env:\n        FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n```", "answer": "```yaml name: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: \"*/30 * * * *\"\n\njobs:\n  build-feeds:\n    name: Update latest feed data from source repo\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n      - name: Install Dependencies\n        run: yarn\n      - name: Checkout Data Source Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n        with:\n          repository: smartcontractkit/reference-data-directory\n          path: data-source\n          token: ${{ secrets.GH_API_KEY }}\n      # - name: Read Data Source\n      #   run: cat data-source/package.json\n      - name: Process Data\n        run: yarn process\n      - name: Deploy to Firebase\n        uses: w9jds/firebase-action@94389a881adad57284e35860f5d258ab262dcd91\n        with:\n\n          args: -c firebase-addresses.json deploy --only hosting\n        env:\n          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n          PROJECT_ID: cl-docs-addresses\n```", "prompt": "Generate a GitHub Workflow named `Build and Publish Feed Resources` for a GitHub repository whose primary programming language is Solidity. This workflow will be triggered by an event: the scheduled time has come: every 30 minutes. The workflow has one job. The 1st job is named `Update latest feed data from source repo` and its job id is `build-feeds`. The job `build-feeds` has 5 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install Dependencies`. The 3rd step is named `Checkout Data Source Repo`. The 4th step is named `Process Data`. The 5th step is named `Deploy to Firebase`. Here are some Github Actions that might be used in the workflow: 5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f version of actions/checkout, 5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f version of actions/checkout and 94389a881adad57284e35860f5d258ab262dcd91 version of w9jds/firebase-action. Here are some variables that might be used in the workflow: secrets.GH_API_KEY and secrets.FIREBASE_TOKEN. "}
{"id": "63c494298052faa2781a98f7", "level": "level3", "llm_response": "```yaml\nname: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup\n        run: |\n          # Setup any necessary environment or dependencies\n          echo \"Setting up environment...\"\n\n      - name: Configure CMake\n        run: |\n          # Configure CMake project\n          echo \"Configuring CMake project...\"\n\n      - name: Initialize MSVC Code Analysis\n        id: run-analysis\n        uses: microsoft/msvc-code-analysis-action@v0.1.1\n        with:\n          build: ${{ env.build }}\n          args: /analyze\n\n      - name: Upload SARIF to GitHub\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: ${{ steps.run-analysis.outputs.sarif }}\n\n      - name: Upload SARIF as an Artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: code-analysis-report\n          path: ${{ steps.run-analysis.outputs.sarif }}\n```", "answer": "```yaml name: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  # Path to the CMake build directory.\n  build: '${{ github.workspace }}/build'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: windows-2022\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup\n        run: |\n          $Url = \"https://boostorg.jfrog.io/artifactory/main/release/1.75.0/binaries/boost_1_75_0-msvc-14.2-64.exe\"\n          (New-Object System.Net.WebClient).DownloadFile($Url, \"$env:TEMP\\boost.exe\")\n          Start-Process -Wait -FilePath \"$env:TEMP\\boost.exe\" \"/SILENT\",\"/SP-\",\"/SUPPRESSMSGBOXES\",\"/DIR=C:\\local\\boost-1.75.0\"\n\n      - name: Configure CMake\n        env:\n          BOOST_ROOT: C:\\local\\boost-1.75.0\n        run: cmake -B ${{ env.build }} -DQL_USE_STD_CLASSES=ON\n\n      - name: Initialize MSVC Code Analysis\n        uses: microsoft/msvc-code-analysis-action@v0.1.1\n        # Provide a unique ID to access the sarif output path\n        id: run-analysis\n        env:\n          CAExcludePath: C:\\local\\boost-1.75.0\n        with:\n          cmakeBuildDirectory: ${{ env.build }}\n          buildConfiguration: Release\n          ruleset: '${{ github.workspace }}/.msvc-analysis.ruleset'\n\n      - name: Upload SARIF to GitHub\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: ${{ steps.run-analysis.outputs.sarif }}\n\n      - name: Upload SARIF as an Artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: sarif-file\n          path: ${{ steps.run-analysis.outputs.sarif }}\n\n```", "prompt": "Generate a GitHub Workflow named `Microsoft C++ Code Analysis` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 6 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Setup`. The 3rd step is named `Configure CMake`. The 4th step is named `Initialize MSVC Code Analysis` and its id is `run-analysis`. The 5th step is named `Upload SARIF to GitHub`. The 6th step is named `Upload SARIF as an Artifact`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v0.1.1 version of microsoft/msvc-code-analysis-action, v2 version of github/codeql-action/upload-sarif and v3 version of actions/upload-artifact. Here are some variables that might be used in the workflow: github.workspace, env.build and steps.run-analysis.outputs.sarif. "}
{"id": "63c494a48052faa2781ac54a", "level": "level3", "llm_response": "```yaml\nname: cspell-action\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    id: cspell\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Run cspell\n        uses: streetsidesoftware/cspell-action@v2\n```", "answer": "```yaml name: cspell-action\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: streetsidesoftware/cspell-action@v2\n```", "prompt": "Generate a GitHub Workflow named `cspell-action` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `cspell`. The job `cspell` has 2 steps. The 1st step is named ``. The 2nd step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v2 version of streetsidesoftware/cspell-action. "}
{"id": "63c495197843b61269a056bc", "level": "level3", "llm_response": "```yaml\nname: Code Scanning - Action\n\non:\n  pull_request:\n    branches:\n      - dev\n      - master\n\njobs:\n  CodeQL-Build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml name: \"Code Scanning - Action\"\n\non:\n  pull_request:\n    branches: [dev, master]\n    types: [opened, synchronize]\n\njobs:\n  CodeQL-Build:\n    # CodeQL runs on ubuntu-latest, windows-latest, and macos-latest\n    runs-on: ubuntu-latest\n\n    permissions:\n      # required for all workflows\n      security-events: write\n\n      # only required for workflows in private repositories\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      # Initializes the CodeQL tools for scanning.\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n        # Override language selection by uncommenting this and choosing your languages\n        # with:\n        #   languages: go, javascript, csharp, python, cpp, java\n\n      # Autobuild attempts to build any compiled languages (C/C++, C#, or Java).\n      # If this step fails, then you should remove it and run the build manually (see below).\n      # - name: Autobuild\n      #   uses: github/codeql-action/autobuild@v2\n\n      # \u2139\ufe0f Command-line programs to run using the OS shell.\n      # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n      # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following\n      #    three lines and modify them (or add more) to build your code if your\n      #    project uses a compiled language\n\n      #- run: |\n      #     make bootstrap\n      #     make release\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `Code Scanning - Action` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created or a pull request's head branch is updated. The workflow would run whenever there is a pull_request event targeting: a branch named dev or a branch named master. The workflow has one job. The job id of the 1st job is `CodeQL-Build`. The job `CodeQL-Build` has 3 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Perform CodeQL Analysis`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of github/codeql-action/init and v2 version of github/codeql-action/analyze. "}
{"id": "63c495547843b61269a06e8e", "level": "level3", "llm_response": "```yaml\nname: Build and Release [Manual]\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: checkout\n        uses: actions/checkout@v3\n\n      - name: Enable PNPM\n        uses: pnpm/action-setup@v2\n        with:\n          version: 6\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Install\n        run: pnpm install\n\n      - name: Install\n        run: pnpm install\n\n      - name: Fetch API\n        run: pnpm run fetch-api\n\n      - name: Parse API\n        run: pnpm run parse-api\n\n      - name: Build fonts\n        run: pnpm run build-fonts\n\n      - name: Generate fontlist\n        run: pnpm run generate-fontlist\n\n      - name: Generate Algolia index\n        run: pnpm run generate-algolia-index\n\n      - name: Lint files\n        run: pnpm run lint\n\n      - name: Format files\n        run: pnpm run format\n\n      - name: Stage, commit and push files\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_message: \"chore: update files\"\n          commit_author: \"GitHub Actions <github-actions@github.com>\"\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Check font files\n        run: pnpm run check-font-files\n\n      - name: If error, commit again before publishing\n        if: failure()\n        run: pnpm run commit-again\n\n      - name: Configure CI Git\n        run: |\n          git config --global user.name \"GitHub Actions\"\n          git config --global user.email \"github-actions@github.com\"\n\n      - name: Publish package\n        run: pnpm publish\n        env:\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "answer": "```yaml name: Build and Release [Manual]\n\non: [workflow_dispatch]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    if: github.actor == 'ayuhito'\n\n    steps:\n      - name: checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: \"0\"\n\n      - name: Enable PNPM\n        uses: pnpm/action-setup@v2\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"16\"\n          cache: \"pnpm\"\n\n      - name: Install\n        run: pnpm install --frozen-lockfile\n\n      - name: Install\n        run: pnpm i\n\n      - name: Fetch API # Calls Google Font Metadata to fetch the latest data from Google's Developer API\n        run: pnpm --filter scripts exec gfm generate $GOOGLE_API_KEY\n        env:\n          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}\n\n      - name: Parse API # Process generated API data\n        run: pnpm --filter scripts exec gfm parse\n\n      - name: Build fonts # Build all updated Google Fonts in repository\n        run: pnpm run build:google\n\n      - name: Generate fontlist # Generate FONTLIST.json and FONTLIST.md\n        run: pnpm run util:fontlist\n\n      - name: Generate Algolia index # Generate Algolia search index for website\n        run: pnpm run util:algolia\n        env:\n          ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }}\n\n      - name: Lint files\n        run: pnpm run lint\n\n      - name: Format files\n        run: pnpm run format\n\n      - name: Stage, commit and push files\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): update packages [Manual]\"\n        continue-on-error: true\n\n      - name: Check font files # Detects if all binaries are downloaded successfully and in the right place\n        run: pnpm run util:run-check\n\n      - name: If error, commit again before publishing\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): resolve file check errors [Manual]\"\n        continue-on-error: true\n\n      - name: Configure CI Git\n        run: |\n          git config --global user.email \"83556432+fontsource-bot@users.noreply.github.com\"\n          git config --global user.name \"fontsource-bot\"\n\n      - name: Publish package # Call mass-publish\n        run: pnpm run deploy:ci\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build and Release [Manual]` for a GitHub repository whose primary programming language is CSS. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 17 steps. The 1st step is named `checkout`. The 2nd step is named `Enable PNPM`. The 3rd step is named `Set node version to 16`. The 4th step is named `Install`. The 5th step is named `Install`. The 6th step is named `Fetch API`. The 7th step is named `Parse API`. The 8th step is named `Build fonts`. The 9th step is named `Generate fontlist`. The 10th step is named `Generate Algolia index`. The 11th step is named `Lint files`. The 12th step is named `Format files`. The 13th step is named `Stage, commit and push files`. The 14th step is named `Check font files`. The 15th step is named `If error, commit again before publishing`. The 16th step is named `Configure CI Git`. The 17th step is named `Publish package`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of pnpm/action-setup, v3 version of actions/setup-node, v4 version of stefanzweifel/git-auto-commit-action and v4 version of stefanzweifel/git-auto-commit-action. Here are some variables that might be used in the workflow: secrets.GOOGLE_API_KEY, secrets.ALGOLIA_ADMIN_KEY, secrets.GITHUB_TOKEN and secrets.NPM_TOKEN. "}
{"id": "63c494ee8052faa2781ae44b", "level": "level3", "llm_response": "```yaml\nname: Add PR Deploy Badge\n\non:\n  deployment_status:\n    types: [created]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Kb Pull Request Deployment Badges\n        uses: kibibit/kb-badger-action@v2\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Add PR Deploy Badge\n# https://docs.github.com/en/actions/reference/events-that-trigger-workflows\non: [deployment_status]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    permissions:\n      pull-requests: write\n    # only runs this job on successful deploy\n    if: github.event.deployment_status.state == 'success'\n    steps:\n    - name: Kb Pull Request Deployment Badges\n      uses: kibibit/kb-badger-action@v2\n      with:\n        github-token: ${{secrets.GITHUB_TOKEN}}\n        badge-left: demo\n        badge-right: application\n        badge-logo: heroku\n        badge-path: api\n        badge2-left: demo\n        badge2-right: api-docs\n        badge2-color: 85EA2D\n        badge2-logo: swagger\n        badge2-path: api/docs\n```", "prompt": "Generate a GitHub Workflow named `Add PR Deploy Badge` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a new deployment status is created. The workflow has one job. The job id of the 1st job is `badge`. The job `badge` has one step. The 1st step is named `Kb Pull Request Deployment Badges`. Here are some Github Actions that might be used in the workflow: v2 version of kibibit/kb-badger-action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4968b33b087f6bde2caaa", "level": "level3", "llm_response": "```yaml\nname: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  publish:\n    runs-on: windows-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.0.2\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v2.1.0\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --version\n\n    - name: Restore packages in preparation for ASFEnhance publishing\n      run: dotnet restore\n\n    - name: Publish ASFEnhance on Windows\n      run: dotnet publish -c Release -o ${github.workspace}/publish\n\n    - name: Upload ASFEnhance-zh-Hans\n      uses: actions/upload-artifact@v3.0.0\n      with:\n        name: ASFEnhance-zh-Hans\n        path: ${github.workspace}/publish/zh-Hans\n\n    - name: Upload ASFEnhance-en-US\n      uses: actions/upload-artifact@v3.0.0\n      with:\n        name: ASFEnhance-en-US\n        path: ${github.workspace}/publish/en-US\n```", "answer": "```yaml name: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n\nenv:\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  publish:\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.0.2\n        with:\n          submodules: recursive\n\n      - name: Setup .NET Core\n        uses: actions/setup-dotnet@v2.1.0\n        with:\n          dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n      - name: Verify .NET Core\n        run: dotnet --info\n\n      - name: Restore packages in preparation for ASFEnhance publishing\n        run: dotnet restore ASFEnhance -p:ContinuousIntegrationBuild=true --nologo\n\n      - name: Publish ASFEnhance on Windows\n        shell: pwsh\n        run: |\n          $script = \"./build.ps1\";\n          Set-Location ${{ github.workspace }};\n          powershell $script;\n\n      - name: Upload ASFEnhance-zh-Hans\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-zh-Hans\n          path: dist/ASFEnhance-zh-Hans.zip\n\n      - name: Upload ASFEnhance-en-US\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-en-US\n          path: dist/ASFEnhance-en-US.zip\n```", "prompt": "Generate a GitHub Workflow named `AutoBuild-Dev` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `publish`. The job `publish` has 7 steps. The 1st step is named `Checkout code`. The 2nd step is named `Setup .NET Core`. The 3rd step is named `Verify .NET Core`. The 4th step is named `Restore packages in preparation for ASFEnhance publishing`. The 5th step is named `Publish ASFEnhance on Windows`. The 6th step is named `Upload ASFEnhance-zh-Hans`. The 7th step is named `Upload ASFEnhance-en-US`. Here are some Github Actions that might be used in the workflow: v3.0.2 version of actions/checkout, v2.1.0 version of actions/setup-dotnet, v3.0.0 version of actions/upload-artifact and v3.0.0 version of actions/upload-artifact. Here are some variables that might be used in the workflow: env.DOTNET_SDK_VERSION and github.workspace. "}
{"id": "63c494b78052faa2781acd9d", "level": "level3", "llm_response": "```yaml\nname: Merge me!\n\non:\n  workflow_run:\n    workflows: [\"Continuous Integration\"]\n    types: [completed]\n\njobs:\n  merge-me:\n    id: merge-me\n    runs-on: ubuntu-latest\n    steps:\n      - name: Merge me!\n        uses: ridedott/merge-me-action@master\n        with:\n          token: ${{ secrets.DOTTBOTT_TOKEN }}\n```", "answer": "```yaml name: Merge me!\n\non:\n  workflow_run:\n    types:\n      - completed\n    workflows:\n      - 'Continuous Integration'\n\njobs:\n  merge-me:\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    name: Merge me!\n    runs-on: ubuntu-latest\n    steps:\n      - name: Merge me!\n        uses: ridedott/merge-me-action@master\n        with:\n          GITHUB_TOKEN: ${{ secrets.DOTTBOTT_TOKEN }}\n    timeout-minutes: 5\n```", "prompt": "Generate a GitHub Workflow named `Merge me!` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: the workflow named Continuous Integration is completed. The workflow has one job. The 1st job is named `Merge me!` and its job id is `merge-me`. The job `merge-me` has one step. The 1st step is named `Merge me!`. Here are some Github Actions that might be used in the workflow: master version of ridedott/merge-me-action. Here are some variables that might be used in the workflow: secrets.DOTTBOTT_TOKEN. "}
{"id": "63c494a37843b61269a027ed", "level": "level3", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        go-version: [1.16, 1.17, 1.18]\n\n    steps:\n      - name: Install Go\n        uses: actions/setup-go@v3.3.0\n        with:\n          go-version: ${{ matrix.go-version }}\n\n      - name: Checkout code\n        uses: actions/checkout@v3.1.0\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\n\nname: CI\n\njobs:\n  test:\n    ## We want to define a strategy for our job\n    strategy:\n      ## this will contain a matrix of all the combinations\n      ## we wish to test again:\n      matrix:\n        go-version: [1.17.x]\n        platform: [ubuntu-latest, macos-latest, windows-latest]\n\n    ## Defines the platform for each test run\n    runs-on: ${{ matrix.platform }}\n\n    ## the steps that will be run through for each version and platform\n    ## combination\n    steps:\n    ## sets up go based on the version\n    - name: Install Go\n      uses: actions/setup-go@v3.3.0\n      with:\n        go-version: ${{ matrix.go-version }}\n\n    ## checks out our code locally, so we can work with the files\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n\n    ## runs go test ./...\n    - name: Build\n      run: go build ./...\n\n    ## runs go test ./...\n    - name: Test\n      run: go test ./...\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `test`. The job `test` has 4 steps. The 1st step is named `Install Go`. The 2nd step is named `Checkout code`. The 3rd step is named `Build`. The 4th step is named `Test`. Here are some Github Actions that might be used in the workflow: v3.3.0 version of actions/setup-go and v3.1.0 version of actions/checkout. Here are some variables that might be used in the workflow: matrix.go-version. "}
{"id": "63c493b87843b612699fd399", "level": "level3", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Release Please\n        uses: GoogleCloudPlatform/release-please-action@v2\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\nname: release-please\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: GoogleCloudPlatform/release-please-action@v2\n        with:\n          release-type: node\n          package-name: release-please-action\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. The job `release-please` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v2 version of GoogleCloudPlatform/release-please-action. "}
{"id": "63c4941e7843b612699ff1f7", "level": "level3", "llm_response": "```yaml\nname: Demo link\n\non:\n  pull_request:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    id: add_demo_link\n    runs-on: ubuntu-latest\n    steps:\n      - name: Update PR description\n        uses: actions/github-script@v6\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            const pr = await github.rest.pulls.get({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              pull_number: context.payload.pull_request.number,\n            });\n\n            if (!pr.data.body.includes('[Demo link]')) {\n              await github.rest.pulls.update({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                pull_number: context.payload.pull_request.number,\n                body: pr.data.body + '\\n\\n[Demo link]',\n              });\n            }\n```", "answer": "```yaml name: Demo link\n\non:\n  pull_request_target:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    name: Add demo link to PR description\n    runs-on: ubuntu-latest\n    env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    permissions:\n      pull-requests: write\n    steps:\n      - name: Update PR description\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const pullRequestId = context.payload.pull_request.number\n            const pullRequestBranch = context.payload.pull_request.head.ref\n\n            github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: pullRequestId,\n              body: `\ud83d\udc40 [Visit Preview](https://${pullRequestBranch}--welcome-ui.netlify.app)`\n            });\n```", "prompt": "Generate a GitHub Workflow named `Demo link` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a pull request is created. The workflow has one job. The 1st job is named `Add demo link to PR description` and its job id is `add_demo_link`. The job `add_demo_link` has one step. The 1st step is named `Update PR description`. Here are some Github Actions that might be used in the workflow: v6 version of actions/github-script. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c494608052faa2781aabf4", "level": "level3", "llm_response": "```yaml\nname: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n      - uses: actions/setup-go@c4a742cab115ed795e34d4513e2cf7d472deb55f\n      - name: Check go.mod files\n        run: go mod tidy\n```", "answer": "```yaml name: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    name: go.mod check\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - uses: actions/setup-go@c4a742cab115ed795e34d4513e2cf7d472deb55f\n        with:\n          go-version: 1.17\n\n      - name: Check go.mod files\n        shell: bash\n        run: |\n          cd gomod-sync\n          go run main.go check\n```", "prompt": "Generate a GitHub Workflow named `go.mod check` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) there is activity relating to a pull request. The workflow has one job. The 1st job is named `go.mod check` and its job id is `check`. The job `check` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Check go.mod files`. Here are some Github Actions that might be used in the workflow: 93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 version of actions/checkout and c4a742cab115ed795e34d4513e2cf7d472deb55f version of actions/setup-go. "}
{"id": "63c494be7843b61269a0325c", "level": "level3", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        language: [typescript]\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: ${{ matrix.language }}\n\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"main\" ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'javascript', 'typescript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 02:25 am, only on thursday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named `Perform CodeQL Analysis`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of github/codeql-action/init, v2 version of github/codeql-action/autobuild and v2 version of github/codeql-action/analyze. Here are some variables that might be used in the workflow: matrix.language. "}
{"id": "63c494228052faa2781a95a5", "level": "level3", "llm_response": "```yaml\nname: snyk-pr\n\non:\n  pull_request:\n    branches:\n      - master\n\njobs:\n  whitesource:\n    id: whitesource\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v3\n      - name: checkout action\n        uses: actions/checkout@v3\n      - name: PR\n        uses: ./whitesource-actions/snyk-pr\n        with:\n          pull_request_head_ref: ${{ github.event.pull_request.head.ref }}\n          whitesource_action_token: ${{ secrets.WHITESOURCE_ACTION_TOKEN }}\n          jira_token_public_repo: ${{ secrets.JIRA_TOKEN_PUBLIC_REPO }}\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          pull_request_title: ${{ github.event.pull_request.title }}\n```", "answer": "```yaml name: snyk-pr\non:\n  pull_request:\n    branches:\n      - master\njobs:\n  whitesource:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa' }}\n    steps:\n    - name: checkout\n      uses: actions/checkout@v3\n      with:\n        ref: ${{ github.event.pull_request.head.ref }}\n        fetch-depth: 0\n\n    - name: checkout action\n      uses: actions/checkout@v3\n      with:\n        repository: snowflakedb/whitesource-actions\n        token: ${{ secrets.WHITESOURCE_ACTION_TOKEN }}\n        path: whitesource-actions\n\n    - name: PR\n      uses: ./whitesource-actions/snyk-pr\n      env:\n        PR_TITLE: ${{ github.event.pull_request.title }}\n      with:\n        jira_token: ${{ secrets.JIRA_TOKEN_PUBLIC_REPO }}\n        gh_token: ${{ secrets.GITHUB_TOKEN }}\n        amend: false # true if you want the commit to be amended with the JIRA number\n```", "prompt": "Generate a GitHub Workflow named `snyk-pr` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `whitesource`. The job `whitesource` has 3 steps. The 1st step is named `checkout`. The 2nd step is named `checkout action`. The 3rd step is named `PR`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/checkout and ./whitesource-actions/snyk-pr. Here are some variables that might be used in the workflow: github.event.pull_request.head.ref, secrets.WHITESOURCE_ACTION_TOKEN, secrets.JIRA_TOKEN_PUBLIC_REPO, secrets.GITHUB_TOKEN and github.event.pull_request.title. "}
{"id": "63c493c37843b612699fd587", "level": "level3", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Draft Release\n        uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    # branches to consider in the event; optional, defaults to all\n    branches:\n      - main\n  # pull_request event is required only for autolabeler\n  pull_request:\n    # Only following types are handled by the action, but one can default to all as well\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Draft Release\n        uses: release-drafter/release-drafter@v5\n        with:\n          tag_name: vNext\n          release_name: vNext\n          draft: true\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is TSQL. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created, a previously closed pull request is reopened or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `update_release_draft`. The job `update_release_draft` has one step. The 1st step is named `Draft Release`. Here are some Github Actions that might be used in the workflow: v5 version of release-drafter/release-drafter. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c495238052faa2781afbf5", "level": "level3", "llm_response": "```yaml\nname: Greetings\n\non:\n  pull_request:\n  issues:\n\njobs:\n  greeting:\n    runs-on: macOS-latest\n    steps:\n      - name: Greet\n        uses: actions/first-interaction@v1\n        with:\n          issue-comment: |\n            Welcome to our repository! We appreciate your contribution.\n          pull-request-comment: |\n            Welcome to our repository! We appreciate your contribution.\n          owner: ${{ github.repository_owner }}\n          repo: ${{ github.repository }}\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Greetings\n\non: [pull_request, issues]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/first-interaction@v1\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        issue-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to fix your issue ASAP. Make sure that you have read about issue format in the docs'\n        pr-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to review your PR ASAP. Make sure that you have read about requirements to pull requests in the docs'\n```", "prompt": "Generate a GitHub Workflow named `Greetings` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) activity related to an issue occurs. The workflow has one job. The job id of the 1st job is `greeting`. The job `greeting` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v1 version of actions/first-interaction. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c496956fc19abdf9c9ce1c", "level": "level3", "llm_response": "```yaml\nname: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  Check licenses:\n    id: test\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set Node.js 16.x\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Install licensed\n        run: npm install licensed\n\n      - name: Run license check\n        run: licensed check\n```", "answer": "```yaml name: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    name: Check licenses\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set Node.js 16.x\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16.x\n          cache: npm\n      - run: npm ci\n      - name: Install licensed\n        run: |\n          cd $RUNNER_TEMP\n          curl -Lfs -o licensed.tar.gz https://github.com/github/licensed/releases/download/3.4.4/licensed-3.4.4-linux-x64.tar.gz\n          sudo tar -xzf licensed.tar.gz\n          sudo mv licensed /usr/local/bin/licensed\n      - run: licensed status\n```", "prompt": "Generate a GitHub Workflow named `Licensed` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Check licenses` and its job id is `test`. The job `test` has 5 steps. The 1st step is named ``. The 2nd step is named `Set Node.js 16.x`. The 3rd step is named ``. The 4th step is named `Install licensed`. The 5th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/setup-node. "}
{"id": "63c494937843b61269a02136", "level": "level3", "llm_response": "```yaml\nname: e2e melange bootstrap + build\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Fetch dependencies\n      uses: actions/checkout@v2541b1294d2704b0964813337f33b291d3f8596b\n\n    - name: Mark workspace as a safe repository\n      run: echo \"::add-path::$GITHUB_WORKSPACE\"\n\n    - name: Build bootstrap melange tool (stage1)\n      run: make bootstrap-melange-stage1\n\n    - name: Generate a package signing keypair\n      run: make generate-signing-keypair\n\n    - name: Prepare build workspace for stage2\n      run: make prepare-stage2-workspace\n\n    - name: Build stage2 melange package with bootstrap melange\n      run: make build-stage2-melange\n\n    - name: Install stage2 melange package\n      run: make install-stage2-melange\n\n    - name: Move stage2 artifacts to stage2 directory\n      run: make move-stage2-artifacts\n\n    - name: Verify operation of stage2 melange\n      run: make verify-stage2-melange\n\n    - name: Prepare build workspace for stage3\n      run: make prepare-stage3-workspace\n\n    - name: Build stage3 melange package with stage2 melange\n      run: make build-stage3-melange\n\n    - name: Install stage3 melange package\n      run: make install-stage3-melange\n\n    - name: Move stage3 artifacts to stage3 directory\n      run: make move-stage3-artifacts\n\n    - name: Ensure melange package is reproducible\n      run: make ensure-reproducible\n\n    - name: Verify operation of stage3 melange\n      run: make verify-stage3-melange\n```", "answer": "```yaml name: e2e melange bootstrap + build\n\non:\n  push:\n  pull_request:\n\njobs:\n  build:\n    name: bootstrap package\n    runs-on: ubuntu-latest\n    container:\n      image: alpine:latest\n      options: |\n        --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n\n    steps:\n    - name: Fetch dependencies\n      run: |\n        cat >/etc/apk/repositories <<_EOF_\n        https://dl-cdn.alpinelinux.org/alpine/edge/main\n        https://dl-cdn.alpinelinux.org/alpine/edge/community\n        https://dl-cdn.alpinelinux.org/alpine/edge/testing\n        _EOF_\n\n        apk upgrade -Ua\n        apk add go cosign build-base git bubblewrap\n    - uses: actions/checkout@2541b1294d2704b0964813337f33b291d3f8596b\n    - name: Mark workspace as a safe repository\n      run: git config --global --add safe.directory ${GITHUB_WORKSPACE}\n    - name: Build bootstrap melange tool (stage1)\n      run: make melange\n    - name: Generate a package signing keypair\n      run: |\n        ./melange keygen\n        mv melange.rsa.pub /etc/apk/keys\n    - name: Prepare build workspace for stage2\n      run: |\n        git clone . workspace-stage2/x86_64\n    - name: Build stage2 melange package with bootstrap melange\n      run: ./melange build --pipeline-dir=pipelines/ --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage2/\n    - name: Install stage2 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage2 artifacts to stage2 directory\n      run: |\n        mv packages stage2\n    - name: Verify operation of stage2 melange\n      run: melange version\n    - name: Prepare build workspace for stage3\n      run: |\n        git clone . workspace-stage3/x86_64\n    - name: Build stage3 melange package with stage2 melange\n      run: melange build --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage3/\n    - name: Install stage3 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage3 artifacts to stage3 directory\n      run: |\n        mv packages stage3\n    - name: Ensure melange package is reproducible\n      run: |\n        sha256sum stage2/x86_64/*.apk | sed -e 's:stage2/:stage3/:g' | sha256sum -c\n    - name: Verify operation of stage3 melange\n      run: melange version\n```", "prompt": "Generate a GitHub Workflow named `e2e melange bootstrap + build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `bootstrap package` and its job id is `build`. The job `build` has 16 steps. The 1st step is named `Fetch dependencies`. The 2nd step is named ``. The 3rd step is named `Mark workspace as a safe repository`. The 4th step is named `Build bootstrap melange tool (stage1)`. The 5th step is named `Generate a package signing keypair`. The 6th step is named `Prepare build workspace for stage2`. The 7th step is named `Build stage2 melange package with bootstrap melange`. The 8th step is named `Install stage2 melange package`. The 9th step is named `Move stage2 artifacts to stage2 directory`. The 10th step is named `Verify operation of stage2 melange`. The 11th step is named `Prepare build workspace for stage3`. The 12th step is named `Build stage3 melange package with stage2 melange`. The 13th step is named `Install stage3 melange package`. The 14th step is named `Move stage3 artifacts to stage3 directory`. The 15th step is named `Ensure melange package is reproducible`. The 16th step is named `Verify operation of stage3 melange`. Here are some Github Actions that might be used in the workflow: 2541b1294d2704b0964813337f33b291d3f8596b version of actions/checkout. Here are some variables that might be used in the workflow: GITHUB_WORKSPACE. "}
{"id": "63c495e58052faa2781b4f4c", "level": "level3", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 */6 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Mark stale issues and pull requests\n        uses: actions/stale@v6\n        with:\n          days-before-issue-stale: 30\n          days-before-pull-request-stale: 30\n          stale-issue-label: 'stale'\n          stale-pull-request-label: 'stale'\n          exempt-issue-labels: 'important,urgent'\n          exempt-pull-request-labels: 'important,urgent'\n          stale-issue-message: 'This issue has been inactive for a while. If it is still relevant, please comment below. Otherwise, it will be closed.'\n          stale-pull-request-message: 'This pull request has been inactive for a while. If it is still relevant, please comment below. Otherwise, it will be closed.'\n          remove-stale-label-on-reopen: true\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '0 */6 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v6\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        days-before-pr-stale: 14\n        days-before-pr-close: 14\n        stale-pr-label: 'inactive'\n        close-pr-label: 'auto-close'\n        exempt-pr-labels: 'keep-open'\n        stale-pr-message: >\n          This pull request has been inactive for 14 days. \n          If you are finished with your changes, don't forget to sign off. See the [contributor guide](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-write-pull-request-automation?branch=main) for instructions. \n          If this PR is inactive for 14 more days, it will be closed automatically. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n        close-pr-message: >\n          This pull request has been inactive for 28 days. At this time, we are closing the PR.  \n          If you decide to continue working on your change, you can reopen the PR and continue working. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n          \n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: every 6 hours. The workflow has one job. The job id of the 1st job is `stale`. The job `stale` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v6 version of actions/stale. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4951f7843b61269a0593c", "level": "level3", "llm_response": "```yaml\nname: docker-push\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build-and-push:\n    id: build-and-push\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.1.0\n\n      - name: Docker meta\n        id: meta\n        uses: docker/metadata-action@v4.1.0\n        with:\n          images: my-docker-image\n\n      - name: Setup QEMU\n        uses: docker/setup-qemu-action@v2.1.0\n\n      - name: Setup Buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2.1.0\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2.1.0\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v3.2.0\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n```", "answer": "```yaml name: docker-push\non:\n  push:\n    tags:\n      - \"v*\"\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n\n      - name: docker meta\n        id: meta\n        uses: docker/metadata-action@v4.1.0\n        with:\n          images: fsouza/fake-gcs-server\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n\n      - name: setup qemu\n        uses: docker/setup-qemu-action@v2.1.0\n\n      - name: setup buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2.1.0\n\n      - name: login to docker hub\n        uses: docker/login-action@v2.1.0\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: build and push\n        uses: docker/build-push-action@v3.2.0\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          platforms: linux/amd64,linux/arm64\n```", "prompt": "Generate a GitHub Workflow named `docker-push` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The job id of the 1st job is `build-and-push`. The job `build-and-push` has 6 steps. The 1st step is named ``. The 2nd step is named `docker meta` and its id is `meta`. The 3rd step is named `setup qemu`. The 4th step is named `setup buildx` and its id is `buildx`. The 5th step is named `login to docker hub`. The 6th step is named `build and push`. Here are some Github Actions that might be used in the workflow: v3.1.0 version of actions/checkout, v4.1.0 version of docker/metadata-action, v2.1.0 version of docker/setup-qemu-action, v2.1.0 version of docker/setup-buildx-action, v2.1.0 version of docker/login-action and v3.2.0 version of docker/build-push-action. Here are some variables that might be used in the workflow: secrets.DOCKER_USERNAME, secrets.DOCKER_PASSWORD, steps.meta.outputs.tags and steps.meta.outputs.labels. "}
{"id": "63c495407843b61269a06679", "level": "level3", "llm_response": "```yaml\nname: Tests\n\non:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Install Linux packages for Qt 5 support\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y libqt5gui5\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies and local packages\n      run: |\n        pip install -r requirements.txt\n        pip install .\n\n    - name: Create clean test directory\n      run: mkdir -p tests\n\n    - name: Test Traits package\n      run: pytest tests\n```", "answer": "```yaml name: Tests\n\non:\n- pull_request\n- workflow_dispatch\n\njobs:\n  tests:\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10', '3.11-dev']\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install Linux packages for Qt 5 support\n      run: |\n        sudo apt-get update\n        sudo apt-get install qt5-default\n        sudo apt-get install libxkbcommon-x11-0\n        sudo apt-get install libxcb-icccm4\n        sudo apt-get install libxcb-image0\n        sudo apt-get install libxcb-keysyms1\n        sudo apt-get install libxcb-randr0\n        sudo apt-get install libxcb-render-util0\n        sudo apt-get install libxcb-xinerama0\n      if: matrix.os == 'ubuntu-latest'\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies and local packages\n      run: |\n        python -m pip install .[test]\n    - name: Create clean test directory\n      run: |\n        mkdir testdir\n    - name: Test Traits package\n      uses: GabrielBB/xvfb-action@v1\n      with:\n        working-directory: testdir\n        run: python -m unittest discover -v traits\n```", "prompt": "Generate a GitHub Workflow named `Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `tests`. The job `tests` has 6 steps. The 1st step is named ``. The 2nd step is named `Install Linux packages for Qt 5 support`. The 3rd step is named `Set up Python ${{ matrix.python-version }}`. The 4th step is named `Install dependencies and local packages`. The 5th step is named `Create clean test directory`. The 6th step is named `Test Traits package`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v4 version of actions/setup-python and v1 version of GabrielBB/xvfb-action. Here are some variables that might be used in the workflow: matrix.python-version. "}
{"id": "63c495448052faa2781b0abc", "level": "level3", "llm_response": "```yaml\nname: Node Blog CI\n\non:\n  push:\n    branches:\n      - '*'\n      !-release\n  pull_request:\n    branches:\n      - '*'\n      !-release\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14, 16, 18]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@master\n\n    - name: Launch MongoDB\n      uses: wbari/start-mongoDB@master\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@master\n      with:\n        node-version: ${{ matrix.node-version }}\n\n    - name: yarn install, build, and test\n      run: |\n        yarn install\n        yarn build\n        yarn test\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@master\n      with:\n        token: ${{ secrets.CODECOV_TOKEN }}\n```", "answer": "```yaml name: Node Blog CI\n\non:\n  push:\n    branches-ignore:\n    - release\n  pull_request:\n    branches-ignore:\n    - release\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16.x]\n    steps:\n    - uses: actions/checkout@master\n    - name: Launch MongoDB\n      uses: wbari/start-mongoDB@master\n      with:\n        mongoDBVersion: 5\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@master\n      with:\n        node-version: ${{ matrix.node-version }}\n    - name: yarn install, build, and test\n      run: |\n        yarn install\n        yarn run build\n        yarn run test:cov\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@master\n      with:\n        token: ${{secrets.CODECOV_TOKEN}}\n      env:\n        CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node Blog CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event unless the push event is to: a branch named release. 2) The workflow would run whenever there is a pull_request event unless the pull request is targeting: a branch named release. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 5 steps. The 1st step is named ``. The 2nd step is named `Launch MongoDB`. The 3rd step is named `Use Node.js ${{ matrix.node-version }}`. The 4th step is named `yarn install, build, and test`. The 5th step is named `Upload coverage to Codecov`. Here are some Github Actions that might be used in the workflow: master version of actions/checkout, master version of wbari/start-mongoDB, master version of actions/setup-node and master version of codecov/codecov-action. Here are some variables that might be used in the workflow: matrix.node-version and secrets.CODECOV_TOKEN. "}
{"id": "63c496561899db58864d23cc", "level": "level3", "llm_response": "```yaml\nname: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  mysql:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule\n\n      - name: Run Molecule\n        run: |\n          molecule test --all\n        env:\n          MOLECULE_DEBUG: ${{ inputs.debug }}\n```", "answer": "```yaml name: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      # Plugins\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  mysql:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: mysql\n      versions: '[5.6, 5.7, \"8.0\", \"galera.3.mysql_wsrep.5.6\", \"galera.4.10.mysql_wsrep.8.0.26\", \"mariadb.10.3\", \"mariadb.10.4\", \"mariadb.10.5\", \"mariadb.10.6\"]'\n```", "prompt": "Generate a GitHub Workflow named `Molecule - MySQL` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.mysql.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/mysql.*/**, roles/mysql/**, plugins/filter/mysql_config.py, plugins/filter/staten.py or plugins/lookup/templates_exclusive.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `mysql`. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/molecule.yaml'}. Here are some variables that might be used in the workflow: inputs.debug == true and inputs.debug. "}
{"id": "63c495a88052faa2781b34fc", "level": "level3", "llm_response": "```yaml\nname: Build iso from elemental-iso-build as external user\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Install Docker\n      uses: docker-practice/actions-setup-docker@v1\n\n    - name: Install deps\n      run: |\n        go mod download\n\n    - name: Build iso from script\n      run: |\n        ./build-iso.sh\n\n    - name: Check config was inserted\n      run: |\n        grep -q \"config inserted\" build.log\n\n    - name: Basic sanity checks for ISO\n      run: |\n        ./check-iso.sh\n```", "answer": "```yaml name: Build iso from elemental-iso-build as external user\n# Test building the iso from an external point of view\n# This tests doesn't clone the repo, just interacts with the script as an external user would do\n# Gets the script only and runs it to see if the building is done properly\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Install Docker\n        uses: docker-practice/actions-setup-docker@v1\n      - name: Install deps\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y mkisofs\n      - name: Build iso from script\n        run: |\n          # Just a simple run to test the build script, no need to upload the generated iso!\n          echo \"TEST\" > config.yaml\n          curl -fsSL https://raw.githubusercontent.com/rancher/elemental/main/.github/elemental-iso-build -o elemental-iso-build\n          chmod +x ./elemental-iso-build\n          ./elemental-iso-build config.yaml\n      - name: Check config was inserted\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Extract config and check against our config\n          isoinfo -x /livecd-cloud-config.yaml -R -i $ISO > livecd-cloud-config.yaml\n          # This checks that the files are the same content\n          cmp config.yaml livecd-cloud-config.yaml\n      - name: Basic sanity checks for ISO\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Check it has eltorito\n          isoinfo -d -i $ISO|grep -q Eltorito\n          # check bootable flag\n          isoinfo -d -i $ISO|grep -q bootable        \n```", "prompt": "Generate a GitHub Workflow named `Build iso from elemental-iso-build as external user` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `deploy`. The job `deploy` has 5 steps. The 1st step is named `Install Docker`. The 2nd step is named `Install deps`. The 3rd step is named `Build iso from script`. The 4th step is named `Check config was inserted`. The 5th step is named `Basic sanity checks for ISO`. Here are some Github Actions that might be used in the workflow: v1 version of docker-practice/actions-setup-docker. "}
{"id": "63c495878052faa2781b26e9", "level": "level3", "llm_response": "```yaml\nname: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Autoclose issues\n        uses: arkon/issue-closer-action@v3.4\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoclose issues\n        uses: arkon/issue-closer-action@v3.4\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          ignoreLabel: do-not-autoclose\n          rules: |\n            [\n              {\n                \"type\": \"title\",\n                \"regex\": \".*<(Source Name|short description)>*\",\n                \"message\": \"You did not fill out the description in the title\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*DELETE THIS SECTION IF YOU HAVE READ AND ACKNOWLEDGED IT.*\",\n                \"message\": \"The acknowledgment section was not removed\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*\\\\* (Aniyomi version|Android version|Device|Name|Link|Extension version): \\\\?.*\",\n                \"message\": \"The requested information was not filled out\"\n              }\n            ]\n```", "prompt": "Generate a GitHub Workflow named `Issue closer` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: an issue is opened, the title or body on an issue is edited or a closed issue is reopened. The workflow has one job. The job id of the 1st job is `autoclose`. The job `autoclose` has one step. The 1st step is named `Autoclose issues`. Here are some Github Actions that might be used in the workflow: v3.4 version of arkon/issue-closer-action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c495257843b61269a05b78", "level": "level3", "llm_response": "```yaml\nname: Flatpak dependency updates\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3.1.0\n\n      - name: Run Flatpak dependency checker\n        uses: docker://ghcr.io/flathub/flatpak-external-data-checker:latest\n        env:\n          EASYEFFECTS_BOT: ${{ secrets.EASYEFFECTS_BOT }}\n```", "answer": "```yaml name: Flatpak dependency updates\non:\n  schedule: # for scheduling to work this file must be in the default branch\n  - cron: \"0 0 * * *\" # run every day\n  workflow_dispatch: # can be manually dispatched under GitHub's \"Actions\" tab \n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-20.04\n\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          # we can't push changes to a fork via a shallow update, we need to clone the full repo\n          fetch-depth: 0\n          # by default when persisting credentials the local git config will use the workflow provided GITHUB_TOKEN, not our own GITHUB_TOKEN env var for the container\n          # we must not use the provided GITHUB_TOKEN, as it will fail to push to the fork since the provided GITHUB_TOKEN is only for the repository where the workflow is running \n          persist-credentials: false\n\n      - uses: docker://ghcr.io/flathub/flatpak-external-data-checker:latest\n        env:\n          GIT_AUTHOR_NAME: EasyEffects Bot\n          GIT_COMMITTER_NAME: EasyEffects Bot\n          # email sets \"EasyEffects Bot\" user as commit author\n          GIT_AUTHOR_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GIT_COMMITTER_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GITHUB_TOKEN: ${{ secrets.EASYEFFECTS_BOT }}\n        with:\n          args: --update --always-fork util/flatpak/com.github.wwmm.easyeffects.Devel.json\n```", "prompt": "Generate a GitHub Workflow named `Flatpak dependency updates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `flatpak-external-data-checker`. The job `flatpak-external-data-checker` has 2 steps. The 1st step is named ``. The 2nd step is named ``. Here are some Github Actions that might be used in the workflow: v3.1.0 version of actions/checkout and docker://ghcr.io/flathub/flatpak-external-data-checker:latest. Here are some variables that might be used in the workflow: secrets.EASYEFFECTS_BOT. "}
{"id": "63c494a27843b61269a02770", "level": "level3", "llm_response": "```yaml\nname: Doc Site\n\non:\n  push:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  build-and-deploy-site:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n\n      - name: Install and Build \ud83d\udd27\n        run: |\n          npm install\n          npm run build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4.2.5\n        with:\n          branch: gh-pages\n          folder: dist\n```", "answer": "```yaml # This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Doc Site\n\non:\n  push:\n    branches: [master]\n  workflow_dispatch:\n\njobs:\n  build-and-deploy-site:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n\n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install --legacy-peer-deps\n          npm run docs:build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4.2.5\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist/site # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Doc Site` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build-and-deploy-site`. The job `build-and-deploy-site` has 3 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install and Build \ud83d\udd27`. The 3rd step is named `Deploy \ud83d\ude80`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v4.2.5 version of JamesIves/github-pages-deploy-action. "}
{"id": "63c495bf8052faa2781b3ef6", "level": "level3", "llm_response": "```yaml\nname: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - master\n    paths:\n      - .github/workflows/mol_tree2_lib.yml\n      - tree2/**\n  pull_request:\n  schedule:\n    - cron: '0 7 * * *'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Build and publish\n        uses: hyoo-ru/mam_build@master2\n        with:\n          NPM_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}\n```", "answer": "```yaml name: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches: \n      - master\n    paths:\n      - '.github/workflows/mol_tree2_lib.yml'\n      - 'tree2/**'\n  pull_request:\n  schedule:\n    - cron: \"0 7 * * *\"\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    \n    steps:\n    \n    - uses: hyoo-ru/mam_build@master2\n      with:\n        package: mol\n        modules: tree2/lib\n    \n    - uses: JS-DevTools/npm-publish@v1\n      if: ${{ github.ref == 'refs/heads/master' }}\n      with:\n        token: ${{ secrets.NPM_AUTH_TOKEN }}\n        package: ./mol/tree2/lib/-/package.json\n```", "prompt": "Generate a GitHub Workflow named `mol_tree2_lib` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/mol_tree2_lib.yml or tree2/**), the workflow runs. 3) there is activity relating to a pull request. 4) the scheduled time has come: at 07:00 am. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 2 steps. The 1st step is named ``. The 2nd step is named ``. Here are some Github Actions that might be used in the workflow: master2 version of hyoo-ru/mam_build and v1 version of JS-DevTools/npm-publish. Here are some variables that might be used in the workflow: secrets.NPM_AUTH_TOKEN. "}
{"id": "63c496361e33648075779191", "level": "level3", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. The job `update_release_draft` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v5 version of release-drafter/release-drafter. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c496561899db58864d23d2", "level": "level3", "llm_response": "```yaml\nname: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n\ninputs:\n  debug:\n    description: 'Run with tmate debugging'\n    required: false\n    default: false\n    type: boolean\n\njobs:\n  ntp:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule docker\n\n      - name: Run Molecule\n        run: |\n          molecule test --all\n        env:\n          MOLECULE_DEBUG: ${{ inputs.debug }}\n```", "answer": "```yaml name: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  ntp:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: ntp\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Ntp` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.ntp.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/ntp/** or roles/ntp/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `ntp`. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/molecule.yaml'}. Here are some variables that might be used in the workflow: inputs.debug == true and inputs.debug. "}
{"id": "63c494847843b61269a01ad6", "level": "level3", "llm_response": "```yaml\nname: Release v1 NPM Package\n\non:\n  workflow_dispatch:\n    inputs:\n      tag-this:\n        description: 'Enter the version for the release tag (must be larger than last tag)'\n        required: true\n        type: string\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  merge-to-v1-branch:\n    id: merge-to-v1-branch\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set git name, mail and origin\n        run: |\n          git config --global user.name \"GitHub Actions\"\n          git config --global user.email \"actions@github.com\"\n          git remote set-url origin https://$secrets.BOT_PIPELINE_TOKEN@github.com/${{ github.repository }}.git\n\n      - name: Checkout v1 branch and merge\n        run: |\n          git checkout v1\n          git pull origin v1\n          git checkout master\n          git merge v1\n\n      - name: Generate new tag, push tag and branch\n        run: |\n          npm version ${{ github.event.inputs.tag }} --no-git-tag-version\n          git add package.json package-lock.json\n          git commit -m \"chore: bump version to ${{ github.event.inputs.tag }}\"\n          git tag ${{ github.event.inputs.tag }}\n          git push origin v1\n          git push origin ${{ github.event.inputs.tag }}\n\n      - name: Publish to npm\n        run: npm publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "answer": "```yaml name: \"Release v1 NPM Package\"\non:\n  workflow_dispatch:\n    inputs:\n      tag:\n        description: |\n          Enter the version for the release tag.\n          Must be larger than last tag.\n          Use patch (0.0.x) for bug fixes.\n          Use minor (0.x.0) for new actions.\n        type: string\n        required: true\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false\njobs:\n  merge-to-v1-branch:\n    name: Create release by rebasing master to v1 and create a new tag\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n          registry-url: 'https://registry.npmjs.org'\n      - run: yarn install\n      - name: Set git name, mail and origin\n        run: |\n          git config --global user.name \"Josef Fr\u00f6hle\"\n          git config --global user.email \"github@josef-froehle.de\"\n          git remote set-url origin https://${{ secrets.BOT_PIPELINE_TOKEN }}@github.com/${{ github.repository }}\n      - name: Checkout v1 branch and merge\n        run: |\n          git checkout v1\n          git merge --ff-only master\n      - name: Generate new tag, push tag and branch\n        run: |\n          yarn run build\n          yarn version --non-interactive --no-git-tag-version --new-version ${{ github.event.inputs.tag }}\n          yarn run changelog\n          yarn run documentation\n          git add -A\n          yarn version --non-interactive --no-git-tag-version --new-version 0.0.0\n          yarn version --non-interactive --new-version ${{ github.event.inputs.tag }}\n          git push\n          git push --tags\n          git checkout master\n          git merge --ff-only v1\n          git push\n          git subtree split --prefix docs -b gh-pages\n          git push -f origin gh-pages:gh-pages\n      - run: yarn publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release v1 NPM Package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: tag-this input represents enter the version for the release tag.\nmust be larger than last tag.\nuse patch (0.0.x) for bug fixes.\nuse minor (0.x.0) for new actions.\n, the data type is string and it must be supplied. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Create release by rebasing master to v1 and create a new tag` and its job id is `merge-to-v1-branch`. The job `merge-to-v1-branch` has 7 steps. The 1st step is named `Checkout`. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Set git name, mail and origin`. The 5th step is named `Checkout v1 branch and merge`. The 6th step is named `Generate new tag, push tag and branch`. The 7th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/setup-node. Here are some variables that might be used in the workflow: secrets.BOT_PIPELINE_TOKEN, github.repository, github.event.inputs.tag and secrets.NPM_TOKEN. "}
{"id": "63c4963f1e3364807577960f", "level": "level3", "llm_response": "```yaml\nname: Validate Gradle Wrapper\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  validation:\n    id: validation\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Validate Gradle Wrapper\n        uses: gradle/wrapper-validation-action@v1\n```", "answer": "```yaml name: \"Validate Gradle Wrapper\"\n\non: [ pull_request ]\n\njobs:\n  validation:\n    name: \"Validation\"\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gradle/wrapper-validation-action@v1\n```", "prompt": "Generate a GitHub Workflow named `Validate Gradle Wrapper` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Validation` and its job id is `validation`. The job `validation` has 2 steps. The 1st step is named ``. The 2nd step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v1 version of gradle/wrapper-validation-action. "}
{"id": "63c4969cb008460c1df157a0", "level": "level3", "llm_response": "```yaml\nname: Post-release\n\non:\n  release:\n    types: [published, prereleased, edited]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Add release comment\n        uses: apexskier/github-release-commenter@v1\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          release_id: ${{ github.event.release.id }}\n          comment: \"This is a post-release comment.\"\n```", "answer": "```yaml name: Post-release\non:\n  release:\n    types:\n      - published\n      - edited\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: apexskier/github-release-commenter@v1\n        with:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          comment-template: This is addressed by {release_link}.\n          label-template: released\n```", "prompt": "Generate a GitHub Workflow named `Post-release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published or the details of a release, pre-release, or draft release are edited. The workflow has one job. The job id of the 1st job is `release`. The job `release` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v1 version of apexskier/github-release-commenter. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4946e8052faa2781ab27f", "level": "level3", "llm_response": "```yaml\nname: test\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Setup Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '1.17'\n\n      - name: Test\n        run: go test ./...\n\n  testacc:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Setup Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '1.17'\n\n      - name: Docker build\n        run: docker build -t myimage .\n\n      - name: Terraform version\n        run: terraform --version\n\n      - name: Test acceptance\n        run: go test -tags acceptance ./...\n```", "answer": "```yaml name: test\npermissions:\n  contents: read\n\non:\n  push:\n    branches:\n    - master\n  pull_request:\n    branches:\n    - master\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        os:\n        - ubuntu-latest\n        - macOS-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-go@v3\n      with:\n        go-version-file: '.go-version'\n        cache: true\n    - name: test\n      run: make test\n  testacc:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        terraform:\n        - 1.0.0\n        - 0.15.5\n        - 0.14.11\n        - 0.13.7\n        - 0.12.31\n    env:\n      TERRAFORM_VERSION: ${{ matrix.terraform }}\n    steps:\n    - uses: actions/checkout@v3\n    - name: docker build\n      run: docker-compose build\n    - name: terraform --version\n      run: docker-compose run --rm tfschema terraform --version\n    - name: testacc\n      run: docker-compose run --rm tfschema make testacc\n```", "prompt": "Generate a GitHub Workflow named `test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `test`. The job `test` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `test`. The job id of the 2nd job is `testacc`. The job `testacc` has 4 steps. The 1st step is named ``. The 2nd step is named `docker build`. The 3rd step is named `terraform --version`. The 4th step is named `testacc`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-go and v3 version of actions/checkout. Here are some variables that might be used in the workflow: matrix.terraform. "}
{"id": "63c495297843b61269a05d16", "level": "level3", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  golangci:\n    id: golangci\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '1.17'\n\n      - name: Get diff\n        uses: technote-space/get-diff-action@v6.1.0\n        id: get-diff\n\n      - name: Run golangci-lint\n        uses: golangci/golangci-lint-action@v3.2.0\n        with:\n          github_token: ${{ secrets.github_token }}\n          args: run --timeout 5m\n```", "answer": "```yaml name: Lint\n# Lint runs golangci-lint over the entire cosmos-sdk repository\n# This workflow is run on every pull request and push to main\n# The `golangci` will pass without running if no *.{go, mod, sum} files have been changed.\non:\n  pull_request:\n  push:\n    branches:\n      - main\njobs:\n  golangci:\n    name: golangci-lint\n    runs-on: ubuntu-latest\n    timeout-minutes: 8\n    steps:\n      - uses: actions/setup-go@v3\n        with:\n          go-version: 1.18\n      - uses: actions/checkout@v3\n      - uses: technote-space/get-diff-action@v6.1.0\n        with:\n          PATTERNS: |\n            **/**.go\n            go.mod\n            go.sum\n      - uses: golangci/golangci-lint-action@v3.2.0\n        with:\n          version: v1.47.2\n          args: --timeout 10m\n          github-token: ${{ secrets.github_token }}\n        if: env.GIT_DIFF\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The 1st job is named `golangci-lint` and its job id is `golangci`. The job `golangci` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/setup-go, v3 version of actions/checkout, v6.1.0 version of technote-space/get-diff-action and v3.2.0 version of golangci/golangci-lint-action. Here are some variables that might be used in the workflow: secrets.github_token. "}
{"id": "63c4951f7843b61269a0593e", "level": "level3", "llm_response": "```yaml\nname: goreleaser\n\non:\n  push:\n    tags:\n      - '*'\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    id: release\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.1.0\n\n      - name: Fetch tags\n        run: git fetch --tags\n\n      - name: Set up Go\n        uses: actions/setup-go@v3.3.0\n        with:\n          go-version: 'latest'\n\n      - name: Run Goreleaser\n        uses: goreleaser/goreleaser-action@v3.1.0\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: goreleaser\non:\n  push:\n    tags:\n      - \"*\"\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          fetch-depth: 0\n\n      - name: fetch tags\n        run: git fetch --tags --force\n\n      - uses: actions/setup-go@v3.3.0\n        with:\n          go-version: 1.19\n\n      - uses: goreleaser/goreleaser-action@v3.1.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          distribution: goreleaser\n          version: latest\n          args: release -f ci/.goreleaser.yml\n```", "prompt": "Generate a GitHub Workflow named `goreleaser` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches *. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `release`. The job `release` has 4 steps. The 1st step is named ``. The 2nd step is named `fetch tags`. The 3rd step is named ``. The 4th step is named ``. Here are some Github Actions that might be used in the workflow: v3.1.0 version of actions/checkout, v3.3.0 version of actions/setup-go and v3.1.0 version of goreleaser/goreleaser-action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4967e33b087f6bde2c5c1", "level": "level3", "llm_response": "```yaml\nname: Dependabot auto-merge\n\non:\n  pull_request:\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    id: dependabot\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        uses: dependabot/fetch-metadata@v1.3.4\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Enable auto-merge for Dependabot PRs\n        run: |\n          echo \"auto-merge enabled for PR: ${{ github.event.pull_request.html_url }}\"\n```", "answer": "```yaml ---\nname: Dependabot auto-merge\n\"on\": pull_request\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n    if: ${{ github.actor == 'dependabot[bot]' }}\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        uses: dependabot/fetch-metadata@v1.3.4\n        with:\n          github-token: \"${{ secrets.GITHUB_TOKEN }}\"\n      - name: Enable auto-merge for Dependabot PRs\n        if: >-\n          ${{\n          steps.metadata.outputs.update-type == 'version-update:semver-patch' ||\n          steps.metadata.outputs.update-type == 'version-update:semver-minor'\n          }}\n        run: gh pr merge --auto --merge \"$PR_URL\"\n        env:\n          PR_URL: ${{github.event.pull_request.html_url}}\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n```", "prompt": "Generate a GitHub Workflow named `Dependabot auto-merge` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope and write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `dependabot`. The job `dependabot` has 2 steps. The 1st step is named `Dependabot metadata` and its id is `metadata`. The 2nd step is named `Enable auto-merge for Dependabot PRs`. Here are some Github Actions that might be used in the workflow: v1.3.4 version of dependabot/fetch-metadata. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and github.event.pull_request.html_url. "}
{"id": "63c496326fc19abdf9c9a7c5", "level": "level3", "llm_response": "```yaml\nname: Test CI\n\non:\n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Install requirements\n      run: |\n        # Add commands to install requirements here\n\n    - name: Install Tangerine\n      run: |\n        # Add commands to install Tangerine here\n\n    - name: Build Runner\n      run: |\n        # Add commands to build the runner here\n\n    - name: Run Tests\n      run: |\n        # Add commands to run tests here\n```", "answer": "```yaml name: Test CI\n\non: \n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on:   ubuntu-latest\n    container: alpine\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Install requirements\n      run: |\n        apk update && apk upgrade \n        apk add make bash coreutils neovim lua5.4\n        # links lua5.4 -> lua\n        ln -sv /usr/bin/lua5.4           /usr/bin/lua\n        ln -sv /usr/lib/lua5.4/liblua.so /usr/lib/liblua5.4.so\n\n    - name: Install Tangerine\n      run:  make install\n\n    - name: Build Runner\n      run:  make runner\n\n    - name: Run Tests\n      run:  yes | make test\n```", "prompt": "Generate a GitHub Workflow named `Test CI` for a GitHub repository whose primary programming language is Fennel. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) Only if at least one path of push event matches a pattern in the paths filter(lua/**, test/** or .github/**), the workflow runs. The workflow has one job. The job id of the 1st job is `test`. The job `test` has 5 steps. The 1st step is named ``. The 2nd step is named `Install requirements`. The 3rd step is named `Install Tangerine`. The 4th step is named `Build Runner`. The 5th step is named `Run Tests`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout. "}
{"id": "63c495207843b61269a059a2", "level": "level3", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Apply labels to pull requests\n        uses: actions/labeler@v4\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler/blob/master/README.md\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/labeler@v4\n      with:\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. The job `label` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v4 version of actions/labeler. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c494378052faa2781a9e70", "level": "level3", "llm_response": "```yaml\nname: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches:\n      - main\n    types:\n      - opened\n      - synchronize\n      - reopened\n      - ready_for_review\n\njobs:\n  lint:\n    id: lint\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v3\n\n      - name: Protobuf format\n        uses: jidicula/clang-format-action@v4.9.0\n        with:\n          format: true\n          check: true\n          extensions: .proto\n\n      - name: Lint shell, Docker and protobuf\n        uses: github/super-linter/slim@v4\n        with:\n          LINTER_FILE_EXTENSIONS: sh,dockerfile,proto\n          VALIDATE_ALL_CODEBASE: true\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches: [ main ]\n    types: [opened, synchronize, reopened, ready_for_review]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v3\n        with:\n          # Full git history isn't needed to get a proper list of changed files within `super-linter`\n          fetch-depth: 0\n\n      - name: Protobuf format\n        uses: jidicula/clang-format-action@v4.9.0\n        with:\n          clang-format-version: '14'\n  \n      - name: Lint shell, Docker and protobuf\n        uses: github/super-linter/slim@v4\n        env:\n          VALIDATE_ALL_CODEBASE: false\n          DEFAULT_BRANCH: main\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # Select file types to lint. Python and Rust linters are configured separately.\n          VALIDATE_SHELL_SHFMT: true\n          #\n          # disable hadolint \n          # https://github.com/hadolint/hadolint/issues/821\n          # VALIDATE_DOCKERFILE_HADOLINT: true\n          # DOCKERFILE_HADOLINT_FILE_NAME: .github/config/.hadolint.yaml\n          #\n          # Enable after fixing proto lint issues.\n          # VALIDATE_PROTOBUF: true\n```", "prompt": "Generate a GitHub Workflow named `Miscellaneous Lint` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named devnet. 2) a pull request is created, a pull request's head branch is updated, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `lint`. The job `lint` has 3 steps. The 1st step is named `Checkout Code`. The 2nd step is named `Protobuf format`. The 3rd step is named `Lint shell, Docker and protobuf`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v4.9.0 version of jidicula/clang-format-action and v4 version of github/super-linter/slim. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c496561899db58864d23b6", "level": "level3", "llm_response": "```yaml\nname: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install molecule docker\n\n      - name: Run Molecule tests\n        run: |\n          molecule test --all\n        env:\n          MOLECULE_DEBUG: ${{ inputs.debug }}\n```", "answer": "```yaml name: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      # Plugins\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  docker:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: docker\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Docker` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.docker.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/docker/**, roles/docker/**, plugins/filter/json.py, plugins/filter/staten.py or plugins/lookup/docker_applications.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `docker`. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/molecule.yaml'}. Here are some variables that might be used in the workflow: inputs.debug == true and inputs.debug. "}
{"id": "63c496851899db58864d36f3", "level": "level3", "llm_response": "```yaml\nname: Test with Pre-commit\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n\n    - name: Lint with pre-commit\n      run: |\n        pip install pre-commit\n        pre-commit run --all-files\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Test with Pre-commit\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.10\"]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pre-commit\n          pre-commit install-hooks\n      - name: Lint with pre-commit\n        run: pre-commit run --all-files\n```", "prompt": "Generate a GitHub Workflow named `Test with Pre-commit` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python ${{ matrix.python-version }}`. The 3rd step is named `Install dependencies`. The 4th step is named `Lint with pre-commit`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v4 version of actions/setup-python. Here are some variables that might be used in the workflow: matrix.python-version. "}
{"id": "63c495e58052faa2781b4fae", "level": "level3", "llm_response": "```yaml\nname: Self-assign\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  one:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Self-assign issue\n        run: |\n          gh issue edit ${{ github.event.issue.number }} --assignee ${{ github.event.comment.user.login }}\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml # Allow users to automatically tag themselves to issues\n\nname: Self-assign\non:\n  issue_comment:\n    types: created\njobs:\n  one:\n    runs-on: ubuntu-latest\n    if: >-\n      (github.event.comment.body == '#take' ||\n       github.event.comment.body == '#self-assign') &&\n       (!github.event.issue.pull_request)\n    steps:\n      - run: |\n          echo \"Assigning issue ${{ github.event.issue.number }} to ${{ github.event.comment.user.login }}\"\n          curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -d '{\"assignees\": [\"${{ github.event.comment.user.login }}\"]}' https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/assignees\n```", "prompt": "Generate a GitHub Workflow named `Self-assign` for a GitHub repository whose primary programming language is Jupyter Notebook. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `one`. The job `one` has one step. The 1st step is named ``. Here are some variables that might be used in the workflow: github.event.issue.number, github.event.comment.user.login, secrets.GITHUB_TOKEN and github.repository. "}
{"id": "63c496561899db58864d23c2", "level": "level3", "llm_response": "```yaml\nname: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  java:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Run Molecule\n        run: |\n          if [ \"${{ inputs.debug }}\" = true ]; then\n            molecule --debug test\n          else\n            molecule test\n          fi\n        env:\n          MOLECULE_DEBUG: ${{ inputs.debug }}\n```", "answer": "```yaml name: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  java:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: java\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Java` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.java.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/java/** or roles/java/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `java`. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/molecule.yaml'}. Here are some variables that might be used in the workflow: inputs.debug == true and inputs.debug. "}
{"id": "63c4957c8052faa2781b2239", "level": "level3", "llm_response": "```yaml\nname: Add Issues/PRs to TF Provider DevEx team board\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    id: add-content-to-project\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set Issue to 'Priority = Triage Next'\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        with:\n          github_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          project_id: ${{ github.event.issue.node_id }}\n          column_name: 'Priority = Triage Next'\n\n      - name: Set Pull Request to 'Priority = Triage Next'\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        with:\n          github_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          project_id: ${{ github.event.pull_request.node_id }}\n          column_name: 'Priority = Triage Next'\n```", "answer": "```yaml # Based on https://github.com/leonsteinhaeuser/project-beta-automations\n\nname: \"Add Issues/PRs to TF Provider DevEx team board\"\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request_target:\n    # NOTE: The way content is added to project board is equivalent to an \"upsert\".\n    # Calling it multiple times will be idempotent.\n    #\n    # See https://securitylab.github.com/research/github-actions-preventing-pwn-requests/\n    #\u00a0to see the reasoning behind using `pull_request_target` instead of `pull_request`\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    name: \"Add Content to project\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Set Issue to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'issues'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.issue.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n      - name: \"Set Pull Request to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'pull_request_target'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.pull_request.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n```", "prompt": "Generate a GitHub Workflow named `Add Issues/PRs to TF Provider DevEx team board` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) an issue is opened or a closed issue is reopened. 2) a pull request is created, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow has one job. The 1st job is named `Add Content to project` and its job id is `add-content-to-project`. The job `add-content-to-project` has 2 steps. The 1st step is named `Set Issue to 'Priority = Triage Next'`. The 2nd step is named `Set Pull Request to 'Priority = Triage Next'`. Here are some Github Actions that might be used in the workflow: v2.0.1 version of leonsteinhaeuser/project-beta-automations and v2.0.1 version of leonsteinhaeuser/project-beta-automations. Here are some variables that might be used in the workflow: secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN, github.event.issue.node_id and github.event.pull_request.node_id. "}
{"id": "63c49697b008460c1df15590", "level": "level3", "llm_response": "```yaml\nname: Release\n\non:\n  release:\n    types: [published, prereleased, draft]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v1\n\n    - name: Build the file\n      run: npm run build\n\n    - name: Upload zip to release\n      uses: svenstaro/upload-release-action@v1-release\n      with:\n        repo_token: ${{ secrets.GITHUB_TOKEN }}\n        tag: ${{ github.ref }}\n        file: dist.zip\n        name: Release build\n        body: Release build\n\n    - name: HACS Action\n      uses: hacs/action@main\n      with:\n        token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Release\n\non:\n  release:\n    types: [published]\n\njobs:\n  release:\n    name: Prepare release\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n\n      # Build\n      - name: Build the file\n        run: |\n          cd /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card\n          npm install\n          npm run build\n\n      # Upload build file to the releas as an asset.\n      - name: Upload zip to release\n        uses: svenstaro/upload-release-action@v1-release\n\n        with:\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          file: /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card/dist/thermostat-dark-card.js\n          asset_name: thermostat-dark-card.js\n          tag: ${{ github.ref }}\n          overwrite: true\n      - name: HACS Action\n        uses: \"hacs/action@main\"\n        with:\n          category: \"plugin\"\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow has one job. The 1st job is named `Prepare release` and its job id is `release`. The job `release` has 4 steps. The 1st step is named ``. The 2nd step is named `Build the file`. The 3rd step is named `Upload zip to release`. The 4th step is named `HACS Action`. Here are some Github Actions that might be used in the workflow: v1 version of actions/checkout, v1-release version of svenstaro/upload-release-action and main version of hacs/action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and github.ref. "}
{"id": "63c4955b8052faa2781b1498", "level": "level3", "llm_response": "```yaml\nname: CI v2\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        go: [1.16, 1.17, 1.18]\n\n    steps:\n      - name: Setup\n        uses: actions/setup-go@v3\n        with:\n          go-version: ${{ matrix.go }}\n\n      - name: Prerequisites\n        run: |\n          go env -w GOPROXY=https://proxy.golang.org,direct\n          go env -w GO11MODULE=on\n\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Dependencies\n        run: go mod download\n\n      - name: Lint\n        run: go vet ./...\n\n      - name: Vet\n        run: go vet ./...\n\n      - name: Test\n        run: go test -v ./...\n\n      - name: Coverage\n        uses: codecov/codecov-action@v2\n        with:\n          file: ./coverage.out\n```", "answer": "```yaml name: CI v2\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go: ['1.16']\n    steps:\n    - name: Setup\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Prerequisites\n      run: |\n        sudo apt-get update\n        sudo apt-get -y install libvlc-dev vlc-plugin-base vlc-plugin-video-output vlc-plugin-access-extra\n\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Dependencies\n      working-directory: ./v2\n      run: |\n        go version\n        go get -v -t -d ./...\n        go install golang.org/x/lint/golint@latest\n\n    - name: Lint\n      working-directory: ./v2\n      run: golint -set_exit_status=1 ./...\n\n    - name: Vet\n      working-directory: ./v2\n      run: go vet -unsafeptr=false ./...\n\n    - name: Test\n      working-directory: ./v2\n      run: go test -v -coverprofile=coverage.txt -covermode=atomic ./...\n\n    - name: Coverage\n      uses: codecov/codecov-action@v3\n```", "prompt": "Generate a GitHub Workflow named `CI v2` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 8 steps. The 1st step is named `Setup`. The 2nd step is named `Prerequisites`. The 3rd step is named `Checkout`. The 4th step is named `Dependencies`. The 5th step is named `Lint`. The 6th step is named `Vet`. The 7th step is named `Test`. The 8th step is named `Coverage`. Here are some Github Actions that might be used in the workflow: v3 version of actions/setup-go, v3 version of actions/checkout and v3 version of codecov/codecov-action. Here are some variables that might be used in the workflow: matrix.go. "}
{"id": "63c494b87843b61269a03054", "level": "level3", "llm_response": "```yaml\nname: autoupdate\n\non:\n  push:\n    branches-ignore:\n      - version-bump/**\n      - dependabot/**\n      - bot/**\n      - all-contributors/**\n\njobs:\n  autoupdate-for-bot:\n    id: autoupdate-for-bot\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Autoupdating\n        uses: docker://chinthakagodawita/autoupdate-action:v1\n        env:\n          GH_TOKEN_BOT_EVE: ${{ secrets.GH_TOKEN_BOT_EVE }}\n```", "answer": "```yaml # This action is centrally managed in https://github.com/asyncapi/.github/\r\n# Don't make changes to this file in this repo as they will be overwritten with changes made to the same file in above mentioned repo\r\n\r\n# This workflow is designed to work with:\r\n# - autoapprove and automerge workflows for dependabot and asyncapibot.\r\n# - special release branches that we from time to time create in upstream repos. If we open up PRs for them from the very beginning of the release, the release branch will constantly update with new things from the destination branch they are opened against\r\n\r\n# It uses GitHub Action that auto-updates pull requests branches, whenever changes are pushed to their destination branch.\r\n# Autoupdating to latest destination branch works only in the context of upstream repo and not forks\r\n\r\nname: autoupdate\r\n\r\non:\r\n  push:\r\n    branches-ignore:  \r\n      - 'version-bump/**'\r\n      - 'dependabot/**'\r\n      - 'bot/**'\r\n      - 'all-contributors/**'\r\n\r\njobs:\r\n  autoupdate-for-bot:\r\n    if: startsWith(github.repository, 'asyncapi/')\r\n    name: Autoupdate autoapproved PR created in the upstream\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - name: Autoupdating\r\n        uses: docker://chinthakagodawita/autoupdate-action:v1\r\n        env:\r\n          GITHUB_TOKEN: '${{ secrets.GH_TOKEN_BOT_EVE }}'\r\n          PR_FILTER: \"labelled\"\r\n          PR_LABELS: \"autoupdate\"\r\n          PR_READY_STATE: \"ready_for_review\"\r\n          MERGE_CONFLICT_ACTION: \"ignore\"\r\n```", "prompt": "Generate a GitHub Workflow named `autoupdate` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: The workflow would run whenever there is a push event unless the push event is to: a branch whose name matches version-bump/**, a branch whose name matches dependabot/**, a branch whose name matches bot/** or a branch whose name matches all-contributors/**. The workflow has one job. The 1st job is named `Autoupdate autoapproved PR created in the upstream` and its job id is `autoupdate-for-bot`. The job `autoupdate-for-bot` has one step. The 1st step is named `Autoupdating`. Here are some Github Actions that might be used in the workflow: docker://chinthakagodawita/autoupdate-action:v1. Here are some variables that might be used in the workflow: secrets.GH_TOKEN_BOT_EVE. "}
{"id": "63c494877843b61269a01c1e", "level": "level3", "llm_response": "```yaml\nname: Prepare Release\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version number'\n        required: true\n        type: string\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Push Tag\n        run: git tag v$github.event.inputs.version && git push origin v$github.event.inputs.version\n```", "answer": "```yaml \nname: Prepare Release\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version Number'\n        required: true\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Push Tag\n      run: | \n            echo \"version is ${{ github.event.inputs.version }}\"\n            git config user.name \"GitHub Actions Bot\"\n            git config user.email \"<>\"\n            sed -i \"/is_master/d\" fxmanifest.lua\n            sed -i \"/^version/c\\version '${{ github.event.inputs.version }}'\" fxmanifest.lua\n            git add .\n            git commit -m \"${{ github.event.inputs.version }}\"\n            git tag -a ${{ github.event.inputs.version }} -m \"Version ${{ github.event.inputs.version }}\"\n            sed -i \"/^version/ais_master 'yes'\" fxmanifest.lua\n            git add .\n            git commit -m \"Update Version\"\n            git push --follow-tags\n```", "prompt": "Generate a GitHub Workflow named `Prepare Release` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: version-this input represents version number and it must be supplied. The workflow has one job. The job id of the 1st job is `create`. The job `create` has 2 steps. The 1st step is named ``. The 2nd step is named `Push Tag`. Here are some Github Actions that might be used in the workflow: master version of actions/checkout. Here are some variables that might be used in the workflow: github.event.inputs.version. "}
{"id": "63c4966d33b087f6bde2bebf", "level": "level3", "llm_response": "```yaml\nname: CodeQL\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    id: analyse\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '1.17'\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml name: \"CodeQL\"\n\non:\n  workflow_dispatch:\n  push:\n    branches: [main]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [main]\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    name: Analyse\n    runs-on: ubuntu-20.04\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n      with:\n        # We must fetch at least the immediate parents so that if this is\n        # a pull request then we can checkout the head.\n        fetch-depth: 2\n\n    # If this run was triggered by a pull request event, then checkout\n    # the head of the pull request instead of the merge commit.\n    - run: git checkout HEAD^2\n      if: ${{ github.event_name == 'pull_request' }}\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      # Override language selection by uncommenting this and choosing your languages\n      with:\n        languages: go\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) The workflow would run whenever there is a pull_request event targeting: a branch named main. 4) the scheduled time has come: at 05:00 am, only on sunday. The workflow has one job. The 1st job is named `Analyse` and its job id is `analyse`. The job `analyse` has 5 steps. The 1st step is named `Checkout repository`. The 2nd step is named ``. The 3rd step is named `Initialize CodeQL`. The 4th step is named `Autobuild`. The 5th step is named `Perform CodeQL Analysis`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of github/codeql-action/init, v2 version of github/codeql-action/autobuild and v2 version of github/codeql-action/analyze. "}
{"id": "63c496581e3364807577a144", "level": "level3", "llm_response": "```yaml\nname: Remove ALL artifacts\n\non:\n  workflow_dispatch:\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Remove ALL artifacts\n        uses: c-hive/gha-remove-artifacts@v1\n```", "answer": "```yaml name: Remove ALL artifacts\n\non:\n  workflow_dispatch: # only manually\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - name: Remove ALL artifacts\n        uses: c-hive/gha-remove-artifacts@v1\n        with:\n          age: '0 days'\n          skip-tags: true\n          skip-recent: 0\n```", "prompt": "Generate a GitHub Workflow named `Remove ALL artifacts` for a GitHub repository whose primary programming language is C. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `remove-all-artifacts`. The job `remove-all-artifacts` has one step. The 1st step is named `Remove ALL artifacts`. Here are some Github Actions that might be used in the workflow: v1 version of c-hive/gha-remove-artifacts. "}
{"id": "63c494e18052faa2781adf45", "level": "level3", "llm_response": "```yaml\nname: Deploy to GH Pages\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - docs/**\n      - !.github/workflows/deploy-storybook.yml\n      - .storybook/**\n      - .wordpress-org/**\n      - __mocks__/**\n      - __static__/**\n      - bin/**\n      - tests/**\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    id: build-storybook\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Setup Node\n        uses: actions/setup-node@8c91899e586c5b171469028077307d293428b516\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build storybook\n        run: npm run build-storybook\n\n      - name: Upload storybook\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: storybook\n          path: storybook-static\n\n  deploy-gh-pages:\n    id: deploy-gh-pages\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Harden Runner\n        uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Download storybook files\n        uses: actions/download-artifact@fb598a63ae348fa914e94cd0ff38f362e927b741\n        with:\n          name: storybook\n\n      - name: Move storybook assets\n        run: |\n          mv storybook-static/. ./\n\n      - name: Commit updates\n        run: |\n          git config --global user.name 'github-actions[bot]'\n          git config --global user.email 'github-actions[bot]@users.noreply.github.com'\n          git add -A\n          git commit -m \"Deploy storybook to gh-pages\"\n          git push origin gh-pages --force\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Deploy to GH Pages\n\non:\n  push:\n    # Don't run for irrelevant changes.\n    paths-ignore:\n      - 'docs/**'\n      - '!.github/workflows/deploy-storybook.yml'\n      - '.storybook/**'\n      - '.wordpress-org/**'\n      - '__mocks__/**'\n      - '__static__/**'\n      - 'bin/**'\n      - 'tests/**'\n    branches:\n      - main\n\npermissions:\n  contents: read\n\n# Cancels all previous workflow runs for pull requests that have not completed.\nconcurrency:\n  # The concurrency group contains the workflow name and the (target) branch name.\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    name: Build storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Setup Node\n        uses: actions/setup-node@8c91899e586c5b171469028077307d293428b516\n        with:\n          node-version-file: '.nvmrc'\n          cache: npm\n\n      - name: Install dependencies\n        run: npm ci\n        env:\n          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true\n\n      - name: Build storyook\n        run: npm run storybook:build\n\n      - name: Upload storybook\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: storybook-files\n          path: build/storybook\n\n  deploy-gh-pages:\n    name: Deploy storybook\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write # for Git to git push\n    timeout-minutes: 10\n    needs: [build-storybook]\n    steps:\n      - name: Harden Runner\n        uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n        with:\n          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs\n\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n        with:\n          ref: gh-pages\n          token: ${{ secrets.GOOGLEFORCREATORS_BOT_TOKEN }}\n\n      - name: Download storybook files\n        uses: actions/download-artifact@fb598a63ae348fa914e94cd0ff38f362e927b741\n        with:\n          name: storybook-files\n          path: storybook-files\n\n      - name: Move storybook assets\n        run: |\n          mkdir -p storybook\n          rm -rf storybook/*\n          mv storybook-files/* storybook/\n\n      - name: Commit updates\n        run: |\n          git add .\n          git status\n          git diff --staged --quiet && echo 'No changes to commit; exiting!' && exit 0\n          git commit -m \"Deploy storybook for ${{ github.sha }}\"\n          git pull --rebase --no-edit --quiet\n          git push origin gh-pages\n        env:\n          GIT_AUTHOR_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_AUTHOR_NAME: googleforcreators-bot\n          GIT_COMMITTER_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_COMMITTER_NAME: googleforcreators-bot\n```", "prompt": "Generate a GitHub Workflow named `Deploy to GH Pages` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**, !.github/workflows/deploy-storybook.yml, .storybook/**, .wordpress-org/**, __mocks__/**, __static__/**, bin/** or tests/**), the workflow will not run. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.head_ref || github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `Build storybook` and its job id is `build-storybook`. The job `build-storybook` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Setup Node`. The 3rd step is named `Install dependencies`. The 4th step is named `Build storyook`. The 5th step is named `Upload storybook`. The 2nd job is named `Deploy storybook` and its job id is `deploy-gh-pages`. The job `deploy-gh-pages` has 5 steps. The 1st step is named `Harden Runner`. The 2nd step is named `Checkout`. The 3rd step is named `Download storybook files`. The 4th step is named `Move storybook assets`. The 5th step is named `Commit updates`. Here are some Github Actions that might be used in the workflow: 93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 version of actions/checkout, 8c91899e586c5b171469028077307d293428b516 version of actions/setup-node, 3cea5372237819ed00197afe530f5a7ea3e805c8 version of actions/upload-artifact, 2e205a28d0e1da00c5f53b161f4067b052c61f34 version of step-security/harden-runner, 93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 version of actions/checkout and fb598a63ae348fa914e94cd0ff38f362e927b741 version of actions/download-artifact. Here are some variables that might be used in the workflow: secrets.GOOGLEFORCREATORS_BOT_TOKEN and github.sha. "}
{"id": "63c496571899db58864d2453", "level": "level3", "llm_response": "```yaml\nname: Lint Checks\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  contents: read\n\njobs:\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.x'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install flake8\n      - name: Run lint checks\n        run: flake8 .\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Rust\n        uses: actions/setup-rust@v2\n        with:\n          rust-version: '1.56'\n      - name: Rustfmt check\n        run: rustfmt --check src/**/*.rs\n      - name: Cargo update check\n        run: cargo update --aggressive\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Cargo lock check\n        run: cargo check --locked\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Cargo doc check\n        run: cargo doc --no-deps\n```", "answer": "```yaml # Syntax reference:\n# https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions\n\nname: Lint Checks\npermissions: read-all\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    types: [opened, synchronize]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          persist-credentials: false\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n      - run: pip install flake8\n      - run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude src/external\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Rustfmt check\n        run: (cd src && cargo fmt -- --check)\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Cargo update check\n        run: |\n          # This will return an error if any versions of local crates in the Cargo.lock\n          # are out of date compared to the crate versions in Cargo.toml. This can fail\n          # if the Shadow version is bumped without using Cargo to update the lock file.\n          (cd src && cargo update --locked --workspace)\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Cargo doc check\n        run: |\n          cmake -S . -B build\n          (cd src && RUSTDOCFLAGS='-D warnings' cargo doc)\n```", "prompt": "Generate a GitHub Workflow named `Lint Checks` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has 4 jobs. The job id of the 1st job is `lint-python`. The job `lint-python` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The job id of the 2nd job is `lint-rust`. The job `lint-rust` has 2 steps. The 1st step is named ``. The 2nd step is named `Rustfmt check`. The job id of the 3rd job is `lint-cargo-lock`. The job `lint-cargo-lock` has 2 steps. The 1st step is named ``. The 2nd step is named `Cargo update check`. The job id of the 4th job is `lint-cargo-doc`. The job `lint-cargo-doc` has 2 steps. The 1st step is named ``. The 2nd step is named `Cargo doc check`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v4 version of actions/setup-python, v3 version of actions/checkout, v3 version of actions/checkout and v3 version of actions/checkout. Here are some variables that might be used in the workflow: github.event.pull_request.head.sha. "}
{"id": "63c4956e7843b61269a0794c", "level": "level3", "llm_response": "```yaml\nname: Code Format Check\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n\njobs:\n  black:\n    id: black\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.8'\n      - name: Black\n        run: black .\n\n  flake8:\n    id: flake8\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install flake8\n      - name: Lint examples\n        run: flake8 examples\n      - name: Lint scripts\n        run: flake8 scripts\n      - name: Lint tests\n        run: flake8 tests\n      - name: Lint moviepy\n        run: flake8 moviepy\n\n  isort:\n    id: isort\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Check imports\n        run: isort --check .\n```", "answer": "```yaml name: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\n\njobs:\n  black:\n    runs-on: ubuntu-latest\n    name: Black\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n      - name: Black\n        uses: psf/black@22.3.0  # already includes args \"--check --diff\"\n  flake8:\n    runs-on: ubuntu-latest\n    name: Flake8\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade wheel pip\n          pip install .[lint]\n      - name: Lint examples\n        run: flake8 examples --show-source\n      - name: Lint scripts\n        run: flake8 setup.py docs/conf.py scripts --show-source\n      - name: Lint tests\n        run: flake8 tests --show-source\n      - name: Lint moviepy\n        run: flake8 moviepy --show-source\n  isort:\n    runs-on: ubuntu-latest\n    name: isort\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Check imports\n        run: isort --check-only moviepy tests examples docs/conf.py scripts\n```", "prompt": "Generate a GitHub Workflow named `Code Format Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. The workflow has 3 jobs. The 1st job is named `Black` and its job id is `black`. The job `black` has 3 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Black`. The 2nd job is named `Flake8` and its job id is `flake8`. The job `flake8` has 7 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Install dependencies`. The 4th step is named `Lint examples`. The 5th step is named `Lint scripts`. The 6th step is named `Lint tests`. The 7th step is named `Lint moviepy`. The 3rd job is named `isort` and its job id is `isort`. The job `isort` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Install dependencies`. The 4th step is named `Check imports`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-python, 22.3.0 version of psf/black, v3 version of actions/checkout, v3 version of actions/setup-python, v3 version of actions/checkout and v3 version of actions/setup-python. "}
{"id": "63c493ea8052faa2781a7e17", "level": "level3", "llm_response": "```yaml\nname: master\n\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  test:\n    id: test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust: [1.56, 1.57, 1.58]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Rust toolchain\n        uses: dtolnay/rust-toolchain@master\n        with:\n          toolchain: ${{ matrix.rust }}\n      - name: Run tests\n        run: cargo test\n      - name: Build project\n        run: cargo build --release\n```", "answer": "```yaml name: master\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0' # 00:00 Sunday\n\njobs:\n\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust: [1.31.0, stable]\n    steps:\n      - uses: actions/checkout@v3\n      - uses: dtolnay/rust-toolchain@master\n        with:\n          toolchain: ${{ matrix.rust }}\n      - run: cargo build\n      - run: ./ci/test_full.sh\n```", "prompt": "Generate a GitHub Workflow named `master` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The 1st job is named `Test` and its job id is `test`. The job `test` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and master version of dtolnay/rust-toolchain. Here are some variables that might be used in the workflow: matrix.rust. "}
{"id": "63c495668052faa2781b18dd", "level": "level3", "llm_response": "```yaml\nname: release management\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update draft release\n        uses: toolmantim/release-drafter@v5\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: release management\non:\n  push:\n    branches: [master]\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: toolmantim/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `release management` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `update-draft-release`. The job `update-draft-release` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v5 version of toolmantim/release-drafter. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c494608052faa2781aac1c", "level": "level3", "llm_response": "```yaml\nname: ASF-ci\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  main:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        configuration: [Debug, Release]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v3.0.2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --version\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build --configuration ${{ matrix.configuration }}\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test --configuration ${{ matrix.configuration }}\n\n    - name: Upload latest strings for translation on Crowdin\n      uses: crowdin/github-action@1.4.16\n      with:\n        project_id: ${{ secrets.ASF_CROWDIN_PROJECT_ID }}\n        api_token: ${{ secrets.ASF_CROWDIN_API_TOKEN }}\n```", "answer": "```yaml name: ASF-ci\n\non: [push, pull_request]\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: true\n  DOTNET_NOLOGO: true\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    strategy:\n      fail-fast: false\n      matrix:\n        configuration: [Debug, Release]\n        os: [macos-latest, ubuntu-latest, windows-latest]\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n      with:\n        submodules: recursive\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v3.0.2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --info\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test ArchiSteamFarm.Tests -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Upload latest strings for translation on Crowdin\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && matrix.configuration == 'Release' && startsWith(matrix.os, 'ubuntu-') }}\n      uses: crowdin/github-action@1.4.16\n      with:\n        crowdin_branch_name: main\n        config: '.github/crowdin.yml'\n        project_id: ${{ secrets.ASF_CROWDIN_PROJECT_ID }}\n        token: ${{ secrets.ASF_CROWDIN_API_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `ASF-ci` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `main`. The job `main` has 6 steps. The 1st step is named `Checkout code`. The 2nd step is named `Setup .NET Core`. The 3rd step is named `Verify .NET Core`. The 4th step is named `Build ${{ matrix.configuration }} ArchiSteamFarm and other projects`. The 5th step is named `Run ${{ matrix.configuration }} ArchiSteamFarm.Tests`. The 6th step is named `Upload latest strings for translation on Crowdin`. Here are some Github Actions that might be used in the workflow: v3.1.0 version of actions/checkout, v3.0.2 version of actions/setup-dotnet and 1.4.16 version of crowdin/github-action. Here are some variables that might be used in the workflow: env.DOTNET_SDK_VERSION, matrix.configuration, secrets.ASF_CROWDIN_PROJECT_ID and secrets.ASF_CROWDIN_API_TOKEN. "}
{"id": "63c495da7843b61269a0a66e", "level": "level3", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        go: [1.16, 1.17, 1.18]\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    strategy:\n      matrix:\n        go:\n          - 1.19\n        os:\n          - ubuntu-20.04\n          - ubuntu-22.04\n          - macos-11\n          - macos-12\n          - windows-2019\n          - windows-2022\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: ${{ matrix.go }}\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `main`. The job `main` has 4 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Go`. The 3rd step is named `Build`. The 4th step is named `Test`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/setup-go. Here are some variables that might be used in the workflow: matrix.go. "}
{"id": "63c494247843b612699ff48a", "level": "level3", "llm_response": "```yaml\nname: Rust\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@master\n\n    - name: Set up Rust\n      uses: hecrj/setup-rust-action@master\n\n    - name: Check Cargo availability\n      run: cargo --version\n\n    - name: Check Rustup default toolchain\n      run: rustup default\n\n    - name: Build without default features\n      run: cargo build --no-default-features\n\n    - name: Build with default features\n      run: cargo build\n```", "answer": "```yaml name: Rust\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@master\n      - uses: hecrj/setup-rust-action@master\n        with:\n          rust-version: stable\n      - name: Check Cargo availability\n        run: cargo --version\n      - name: Check Rustup default toolchain\n        run: rustup default | grep stable\n      - name: Build without default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check --no-default-features\n      - name: Build with default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check\n```", "prompt": "Generate a GitHub Workflow named `Rust` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Check Cargo availability`. The 4th step is named `Check Rustup default toolchain`. The 5th step is named `Build without default features`. The 6th step is named `Build with default features`. Here are some Github Actions that might be used in the workflow: master version of actions/checkout and master version of hecrj/setup-rust-action. "}
{"id": "63c494fd7843b61269a04a9b", "level": "level3", "llm_response": "```yaml\nname: Automatic Releases\n\non:\n  milestone:\n    closed:\n      types: [closed]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Use PHP\n        uses: shivammathur/setup-php@v2\n        with:\n          php-version: '7.4'\n\n      - name: Run Doctrine Release Workflow\n        uses: doctrine/.github/.github/workflows/release-on-milestone-closed.yml@v1.5.0\n```", "answer": "```yaml name: \"Automatic Releases\"\n\non:\n  milestone:\n    types:\n      - \"closed\"\n\njobs:\n  release:\n    name: \"Git tag, release & create merge-up PR\"\n    uses: \"doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0\"\n    secrets:\n      GIT_AUTHOR_EMAIL: ${{ secrets.GIT_AUTHOR_EMAIL }}\n      GIT_AUTHOR_NAME: ${{ secrets.GIT_AUTHOR_NAME }}\n      ORGANIZATION_ADMIN_TOKEN: ${{ secrets.ORGANIZATION_ADMIN_TOKEN }}\n      SIGNING_SECRET_KEY: ${{ secrets.SIGNING_SECRET_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Automatic Releases` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: a milestone is closed. The workflow has one job. The 1st job is named `Git tag, release & create merge-up PR` and its job id is `release`. Here are some reusable workflows that might be used in the workflow: {'version': '1.5.0', 'name': 'doctrine/.github/.github/workflows/release-on-milestone-closed.yml'}. "}
{"id": "63c4957d8052faa2781b22ad", "level": "level3", "llm_response": "```yaml\nname: nix-build\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main, 'release-v**' ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Install Nix\n      uses: cachix/install-nix-action@v17\n      with:\n        nix_path: nixpkgs=github:NixOS/nixpkgs/nixos-unstable\n\n    - name: Setup Cachix\n      uses: cachix/cachix-action@v10\n      with:\n        name: your-cache-name\n        authToken: ${{ secrets.CACHIX_AUTH_TOKEN }}\n\n    - name: Build centrifuge-chain\n      run: nix build .#centrifuge-chain\n```", "answer": "```yaml name: nix-build\non:\n  pull_request:\n  push:\n    branches: [main, 'release-v**']\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Nix Flakes doesn't work on shallow clones\n          fetch-depth: 0\n      - uses: cachix/install-nix-action@v17\n        with:\n          install_url: https://releases.nixos.org/nix/nix-2.10.3/install\n      - uses: cachix/cachix-action@v10\n        with:\n          name: centrifuge-chain\n          authToken: \"${{ secrets.CACHIX_AUTH_TOKEN }}\"\n      - name: Build centrifuge-chain\n        run: nix build --no-allow-dirty -L```", "prompt": "Generate a GitHub Workflow named `nix-build` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches release-v**. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Build centrifuge-chain`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v17 version of cachix/install-nix-action and v10 version of cachix/cachix-action. Here are some variables that might be used in the workflow: secrets.CACHIX_AUTH_TOKEN. "}
{"id": "63c4968a6fc19abdf9c9ca16", "level": "level3", "llm_response": "```yaml\nname: conda builds\n\non:\n  pull_request:\n    paths:\n      - conda-environment.yml\n      - .github/workflows/test_conda-build.yml\n  schedule:\n    - cron: '17 22 * * 6'\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    id: test_conda_install\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: checkout cylc-flow\n        uses: actions/checkout@v3\n\n      - name: build conda env\n        run: |\n          # Add your build conda env commands here\n\n      - name: check for activate scripts\n        run: |\n          # Add your check for activate scripts commands here\n```", "answer": "```yaml name: conda builds\n\non:\n  pull_request:\n    paths:\n      - 'conda-environment.yml'\n      - '.github/workflows/test_conda-build.yml'\n  schedule:\n    - cron: '17 22 * * 6'  # Every Saturday at 22:17\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: checkout cylc-flow\n        uses: actions/checkout@v3\n\n      - name: build conda env\n        run: |\n          # write environment file\n          env_file='conda-environment.yml'\n          echo \"  - pip\"  >> \"$env_file\"  # list pip as a dependency\n          echo \"  - pip:\" >> \"$env_file\"  # add a pip section\n          echo \"    - .\"  >> \"$env_file\"  # install cylc-flow (pip install .)\n          cat \"$env_file\"\n          # install environment\n          conda env create \\\n            -f \"$env_file\" \\\n            --prefix cylc-dev\n          . /usr/share/miniconda/etc/profile.d/conda.sh\n          # check cylc-flow was installed correctly\n          conda run --prefix cylc-dev cylc version --long\n\n      - name: check for activate scripts\n        run: |\n          # https://github.com/cylc/cylc-flow/issues/3704#issuecomment-897442365\n          # locate all activate scripts\n          find ./cylc-dev/ -name \"activate.d\" | tee > activates.txt\n          # ignore the conda activate script itself\n          sed -i '/cylc-dev\\/etc\\/conda\\/activate.d/d' activates.txt\n          # check to make sure no packages have contributed new activate scripts\n          # (we rely on having a conda activate-less environment)\n          if [[ $(cat activates.txt | wc -l) -ne 0 ]]; then\n              echo '::error::Found activate scripts in installation.'\n              cat activates.txt >&2\n              exit 1\n          fi\n```", "prompt": "Generate a GitHub Workflow named `conda builds` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(conda-environment.yml or .github/workflows/test_conda-build.yml), the workflow runs. 2) the scheduled time has come: at 10:17 pm, only on saturday. 3) someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `test_conda_install`. The job `test_conda_install` has 3 steps. The 1st step is named `checkout cylc-flow`. The 2nd step is named `build conda env`. The 3rd step is named `check for activate scripts`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout. "}
{"id": "63c496411e3364807577968e", "level": "level3", "llm_response": "```yaml\nname: Add to project\n\non:\n  issues:\n    types: [opened, transferred]\n\njobs:\n  add-to-project:\n    id: add-to-project\n    runs-on: ubuntu-latest\n    steps:\n    - name: Add issue to project\n      id: add_project\n      uses: actions/add-to-project@v1\n      with:\n        project_id: ${{ secrets.PROJECT_PLANNING_ID }}\n        token: ${{ secrets.BOT_TOKEN_PROJECT }}\n        issue_id: ${{ github.event.issue.number }}\n        planning_field_id: ${{ secrets.PLANNING_TEAM_FIELD_ID }}\n    - name: Set Team\n      run: |\n        echo \"::set-output name=team::${{ steps.add_project.outputs.itemId }}\"\n      id: set_team\n```", "answer": "```yaml name: Add to project\n\non:\n  issues:\n    types: [opened,transferred]\n\njobs:\n  add-to-project:\n    name: Add issue to project\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/add-to-project@main\n        id: add_project\n        with:\n          project-url: ${{ secrets.PROJECT_PLANNING }}\n          github-token: ${{ secrets.BOT_TOKEN_PROJECT }}\n      - name: Set Team\n        env:\n          GITHUB_TOKEN: ${{ secrets.BOT_TOKEN_PROJECT }}\n        run: |\n          gh api graphql -f query='\n          mutation(\n              $project: ID!\n              $item: ID!\n              $status_field: ID!\n              $status_value: String!\n            )  {\n            updateProjectV2ItemFieldValue(\n              input: {\n               projectId: $project\n                itemId: $item\n                fieldId: $status_field\n                value: { \n                  singleSelectOptionId: $status_value\n                  }\n              }\n            ) {\n              projectV2Item {\n                id\n              }\n            }\n          }' -f project=${{ secrets.PROJECT_PLANNING_ID }} -f item=${{ steps.add_project.outputs.itemId }} -f status_field=${{ secrets.PLANNING_TEAM_FIELD_ID }} -f status_value=ed46988b --silent```", "prompt": "Generate a GitHub Workflow named `Add to project` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: an issue is opened or an issue is transferred to another repository. The workflow has one job. The 1st job is named `Add issue to project` and its job id is `add-to-project`. The job `add-to-project` has 2 steps. The 1st step is named `` and its id is `add_project`. The 2nd step is named `Set Team`. Here are some Github Actions that might be used in the workflow: main version of actions/add-to-project. Here are some variables that might be used in the workflow: secrets.PROJECT_PLANNING, secrets.BOT_TOKEN_PROJECT, secrets.PROJECT_PLANNING_ID, steps.add_project.outputs.itemId and secrets.PLANNING_TEAM_FIELD_ID. "}
{"id": "63c494c17843b61269a0331c", "level": "level3", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    branches: [ dev ]\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        language: [ 'javascript' ]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: ${{ matrix.language }}\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"dev\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"dev\" ]\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n    - run: ./mvnw -q -Dmaven.test.skip=true -Dscala.version=2.12.8 -Dscala.binary.version=2.12 clean install || ./mvnw -q -Dmaven.test.skip=true clean install\n  \n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Vue. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 04:20 pm, only on friday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 5 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named ``. The 5th step is named `Perform CodeQL Analysis`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of github/codeql-action/init, v2 version of github/codeql-action/autobuild and v2 version of github/codeql-action/analyze. Here are some variables that might be used in the workflow: matrix.language. "}
{"id": "63c496861e3364807577b319", "level": "level3", "llm_response": "```yaml\nname: documentation\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  skip_duplicate_jobs:\n    id: skip_duplicate_jobs\n    runs-on: ubuntu-latest\n    steps:\n      - id: skip_check\n        uses: fkirc/skip-duplicate-actions@master\n\n  deploy:\n    id: deploy\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2.3.1\n      - name: Create output directories\n        run: mkdir -p docs\n      - name: Copy index.html\n        run: cp index.html docs/\n      - name: Generate reference\n        id: adocbuild\n        uses: tonynv/asciidoctor-action@master\n        with:\n          source_dir: docs\n          output_dir: docs\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.1.7\n        with:\n          publish_dir: ./docs\n```", "answer": "```yaml # adapted from:\n#\n# * base code: https://peterevans.dev/posts/github-actions-how-to-automate-code-formatting-in-pull-requests/\n# * fix push auth: https://github.com/ad-m/github-push-action\n# * checkout PR head commit https://github.com/actions/checkout#checkout-pull-request-head-commit-instead-of-merge-commit\nname: documentation\non:\n  push:\n    branches:\n      - master\njobs:\n  skip_duplicate_jobs:\n    runs-on: ubuntu-latest\n    outputs:\n      should_skip: ${{ steps.skip_check.outputs.should_skip }}\n    steps:\n      - id: skip_check\n        uses: fkirc/skip-duplicate-actions@master\n        with:\n          concurrent_skipping: 'same_content'\n          skip_after_successful_duplicate: 'true'\n          paths: '[\"doc/**\"]'\n  deploy:\n    needs: skip_duplicate_jobs\n    if: ${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2.3.1\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Create output directories\n        run: mkdir -p output/reference\n\n      - name: Copy index.html\n        run: cp website/index.html output/index.html\n\n      - name: Generate reference\n        id: adocbuild\n        uses: tonynv/asciidoctor-action@master\n        with:\n            program: asciidoctor doc/index.adoc -o output/reference/index.html\n\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.1.7\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: output # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `documentation` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has 2 jobs. The job id of the 1st job is `skip_duplicate_jobs`. The job `skip_duplicate_jobs` has one step. The 1st step is named `` and its id is `skip_check`. The job id of the 2nd job is `deploy`. The job `deploy` has 5 steps. The 1st step is named ``. The 2nd step is named `Create output directories`. The 3rd step is named `Copy index.html`. The 4th step is named `Generate reference` and its id is `adocbuild`. The 5th step is named `Deploy \ud83d\ude80`. Here are some Github Actions that might be used in the workflow: master version of fkirc/skip-duplicate-actions, v2.3.1 version of actions/checkout, master version of tonynv/asciidoctor-action and 4.1.7 version of JamesIves/github-pages-deploy-action. Here are some variables that might be used in the workflow: github.event.pull_request.head.sha. "}
{"id": "63c496496fc19abdf9c9b198", "level": "level3", "llm_response": "```yaml\nname: Run checks\n\non:\n  pull_request:\n\njobs:\n  go-checks:\n    id: go-checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n      - name: Test Go Modules Vendor\n        run: ./test_go_modules_vendor.sh\n      - name: Test Go Modules\n        run: ./test_go_modules.sh\n      - name: Test Go Standard\n        run: ./test_go_standard.sh\n\n  action-checks:\n    id: action-checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n      - name: Install dockerfile_lint\n        run: ./install_dockerfile_lint.sh\n      - name: Lint\n        run: ./lint.sh\n      - name: Test\n        run: ./test.sh\n      - name: Docker Build\n        run: ./docker_build.sh\n      - name: Check all versions\n        run: ./check_all_versions.sh\n```", "answer": "```yaml on: pull_request\nname: Run checks\njobs:\n  go-checks:\n    name: Run go checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Test Go Modules Vendor\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules_vendored\n    - name: Test Go Modules\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules\n    - name: Test Go Standard\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_standard\n  action-checks:\n    permissions:\n      contents: read\n    name: Run action checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Install dockerfile_lint\n      run: sudo npm i -g dockerfile_lint\n    - name: Lint\n      run: make lint\n    - name: Test\n      run: make test\n    - name: Docker Build\n      run: make build\n    - name: Check all versions\n      run: make docker-check\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Run go checks` and its job id is `go-checks`. The job `go-checks` has 4 steps. The 1st step is named ``. The 2nd step is named `Test Go Modules Vendor`. The 3rd step is named `Test Go Modules`. The 4th step is named `Test Go Standard`. The 2nd job is named `Run action checks` and its job id is `action-checks`. The job `action-checks` has 6 steps. The 1st step is named ``. The 2nd step is named `Install dockerfile_lint`. The 3rd step is named `Lint`. The 4th step is named `Test`. The 5th step is named `Docker Build`. The 6th step is named `Check all versions`. Here are some Github Actions that might be used in the workflow: master version of actions/checkout, ./, ./, ./ and master version of actions/checkout. "}
{"id": "63c4964f6fc19abdf9c9b3d1", "level": "level3", "llm_response": "```yaml\nname: Package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [clone]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Setup Python Environment\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.8'\n      - name: Build LabelImg\n        run: |\n          # Add build commands here\n      - name: Package LabelImg\n        run: |\n          # Add package commands here\n      - name: Archive macOS app\n        uses: actions/upload-artifact@v3\n        with:\n          name: labelimg-macos\n          path: labelimg.app\n      - name: \n\n  package-windows:\n    runs-on: windows-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Setup Python Environment\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.8'\n      - name: Build LabelImg\n        run: |\n          # Add build commands here\n      - name: Package LabelImg\n        run: |\n          # Add package commands here\n      - name: \n\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Setup Python Environment\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.8'\n      - name: Build LabelImg\n        run: |\n          # Add build commands here\n      - name: Package LabelImg\n        run: |\n          # Add package commands here\n      - name: \n```", "answer": "```yaml name: Package\non: [push, pull_request]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    env:\n      PIPENV_VENV_IN_PROJECT: 1\n      PIPENV_IGNORE_VIRTUALENVS: 1\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pipenv\n          pipenv install pyqt5 lxml\n          pipenv run pip install pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pipenv run make qt5py3\n          rm -rf build dist\n      - name: Package LabelImg\n        run: |\n          pipenv run python setup.py py2app\n          open dist/labelImg.app\n      - name: Archive macOS app\n        run: |\n          cd dist/\n          tar czf labelImg.tgz labelImg.app\n      - uses: actions/upload-artifact@v3\n        with:\n          name: macOS artifact\n          path: dist/labelImg.tgz\n  package-windows:\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Windows artifact\n          path: dist/labelImg.exe\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Linux artifact\n          path: dist/labelImg\n```", "prompt": "Generate a GitHub Workflow named `Package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has 3 jobs. The job id of the 1st job is `package-macos`. The job `package-macos` has 6 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named `Archive macOS app`. The 6th step is named ``. The job id of the 2nd job is `package-windows`. The job `package-windows` has 5 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named ``. The job id of the 3rd job is `package-linux`. The job `package-linux` has 5 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/upload-artifact, v3 version of actions/checkout, v3 version of actions/upload-artifact, v3 version of actions/checkout and v3 version of actions/upload-artifact. "}
{"id": "63c495c68052faa2781b4230", "level": "level3", "llm_response": "```yaml\nname: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n  label:\n\njobs:\n  issueHandler:\n    id: issueHandler\n    runs-on: windows-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Issue Handler\n      uses: Ash258/Scoop-GithubActions@stable-win\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n\njobs:\n  issueHandler:\n    runs-on: windows-latest\n    name: Issue Handler\n    steps:\n      - uses: actions/checkout@v3\n      - name: Issue Handler\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: github.event.action == 'opened' || (github.event.action == 'labeled' && contains(github.event.issue.labels.*.name, 'verify'))\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Issues` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: an issue is opened or a label is added to an issue. The workflow has one job. The 1st job is named `Issue Handler` and its job id is `issueHandler`. The job `issueHandler` has 2 steps. The 1st step is named ``. The 2nd step is named `Issue Handler`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and stable-win version of Ash258/Scoop-GithubActions. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c494c78052faa2781ad471", "level": "level3", "llm_response": "```yaml\nname: cla\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [opened, closed, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Get Team Members\n        id: team\n        uses: actions/github-script@7a5c598405937d486b0331594b5da2b14db670da\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            const teamMembers = await github.teams.listMembersInOrg({\n              org: context.repo.owner,\n              team_slug: 'your-team-slug'\n            });\n            return teamMembers.data.map(member => member.login);\n\n      - name: CLA Assistant\n        uses: cla-assistant/github-action@ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba\n        with:\n          personal-access-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n          team-members: ${{ steps.team.outputs.result }}\n```", "answer": "```yaml name: \"cla\"\non:\n  issue_comment:\n    types: [created]\n  pull_request_target:\n    types: [opened, closed, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Get Team Members\"\n        id: team\n        # github-script, v6.1.0\n        uses: actions/github-script@7a5c598405937d486b0331594b5da2b14db670da\n        with:\n          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n          result-encoding: string\n          script: |\n            const members = await github.paginate(\n              github.rest.orgs.listMembers,\n              { org: \"skalenetwork\" },\n            );\n            return members.map(m => m.login).join(\",\");\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        # Beta Release, v2.1.3-beta\n        uses: cla-assistant/github-action@ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          PERSONAL_ACCESS_TOKEN : ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: 'signatures/version1/cla.json'\n          path-to-document: 'https://skale.network/cla.txt'\n          remote-organization-name: 'skalenetwork'\n          remote-repository-name: cla-sigs\n          allowlist: '${{ steps.team.outputs.result }},*[bot]'\n```", "prompt": "Generate a GitHub Workflow named `cla` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `cla`. The job `cla` has 2 steps. The 1st step is named `Get Team Members` and its id is `team`. The 2nd step is named `CLA Assistant`. Here are some Github Actions that might be used in the workflow: 7a5c598405937d486b0331594b5da2b14db670da version of actions/github-script and ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba version of cla-assistant/github-action. Here are some variables that might be used in the workflow: secrets.PERSONAL_ACCESS_TOKEN, steps.team.outputs.result and secrets.GITHUB_TOKEN. "}
{"id": "63c495f07843b61269a0af74", "level": "level3", "llm_response": "```yaml\nname: Acquire activation file\n\non:\n  workflow_dispatch:\n\njobs:\n  activation:\n    id: activation\n    runs-on: ubuntu-latest\n    steps:\n      - name: Request manual activation file\n        id: getManualLicenseFile\n        uses: game-ci/unity-request-activation-file@v2\n      - name: Expose as artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: license-file\n          path: ${{ steps.getManualLicenseFile.outputs.filePath }}\n```", "answer": "```yaml \ufeffname: Acquire activation file\non:\n  workflow_dispatch: {}\njobs:\n  activation:\n    name: Request manual activation file\n    runs-on: ubuntu-latest\n    steps:\n      - name: Request manual activation file\n        id: getManualLicenseFile\n        uses: game-ci/unity-request-activation-file@v2\n      - name: Expose as artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: ${{ steps.getManualLicenseFile.outputs.filePath }}\n          path: ${{ steps.getManualLicenseFile.outputs.filePath }}\n```", "prompt": "Generate a GitHub Workflow named `Acquire activation file` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Request manual activation file` and its job id is `activation`. The job `activation` has 2 steps. The 1st step is named `Request manual activation file` and its id is `getManualLicenseFile`. The 2nd step is named `Expose as artifact`. Here are some Github Actions that might be used in the workflow: v2 version of game-ci/unity-request-activation-file and v3 version of actions/upload-artifact. Here are some variables that might be used in the workflow: steps.getManualLicenseFile.outputs.filePath. "}
{"id": "63c4967d33b087f6bde2c593", "level": "level3", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n    paths-ignore:\n      - assets/**\n      - .vscode/**\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Check\n        run: npm run check\n\n      - name: Lint\n        run: npm run lint\n\n      - name: Test\n        run: npm run test\n\n  deploy-site:\n    id: deploy-site\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Build Site\n        run: npm run build\n\n      - name: Deploy Website\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./dist\n```", "answer": "```yaml name: Release\n\non:\n  push:\n    paths-ignore:\n      - 'assets/**'\n      - '.vscode/**'\n    branches:\n      - master\n\njobs:\n  check:\n    name: Run checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Check\n        run: yarn check\n\n      - name: Lint\n        run: yarn lint\n\n      - name: Test\n        run: yarn test\n\n  deploy-site:\n    name: Deploy site\n    runs-on: ubuntu-latest\n    environment: github-pages\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Build Site\n        shell: bash\n        run: |\n          yarn --cwd apps/site ci:build\n\n      - name: Deploy Website\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./apps/site/out\n          cname: tamagui.dev\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. When all the path names of push event match patterns in the paths-ignore filter(assets/** or .vscode/**), the workflow will not run. The workflow has 2 jobs. The 1st job is named `Run checks` and its job id is `check`. The job `check` has 5 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install`. The 3rd step is named `Check`. The 4th step is named `Lint`. The 5th step is named `Test`. The 2nd job is named `Deploy site` and its job id is `deploy-site`. The job `deploy-site` has 4 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install`. The 3rd step is named `Build Site`. The 4th step is named `Deploy Website`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, ./.github/actions/install, v3 version of actions/checkout, ./.github/actions/install and v3 version of peaceiris/actions-gh-pages. Here are some variables that might be used in the workflow: secrets.ACTIONS_DEPLOY_KEY. "}
{"id": "63c495418052faa2781b099b", "level": "level3", "llm_response": "```yaml\nname: 60 Days Stale Check\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/stale@v3.0.14\n        with:\n          days-before-issue: 60\n          days-before-pull-request: 60\n          stale-issue-label: 'stale'\n          stale-pull-request-label: 'stale'\n          exempt-issue-labels: ' pinned'\n          exempt-pull-request-labels: ' pinned'\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: 60 Days Stale Check\non:\n  schedule:\n    - cron: '00 00 * * *' # Run each day at 00:00 UTC\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/stale@v3.0.14\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          stale-issue-message: 'This issue is stale because it has been open 60 days with no activity.'\n          stale-pr-message: 'This PR is stale because it has been open 60 days with no activity.'\n          days-before-stale: -1 # 60 days before marking anything stale - Turned off\n          days-before-close: -1 # Do not close anything automatically\n          stale-issue-label: 'stale'\n          stale-pr-label: 'stale'\n          exempt-pr-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n          exempt-issue-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n```", "prompt": "Generate a GitHub Workflow named `60 Days Stale Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `stale`. The job `stale` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v3.0.14 version of actions/stale. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c496731e3364807577abab", "level": "level3", "llm_response": "```yaml\nname: Automatically crawl CVEs\n\non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n  schedule:\n    - cron: '15 * * * *'\n\njobs:\n  build-and-deploy:\n    runs-on: ${{ runner.os }}\n\n    steps:\n    - name: Check out repo\n      uses: actions/checkout@v2\n\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n\n    - name: Configure pip caching\n      uses: actions/cache@v2\n      with:\n        path: ~/.cache/pip\n        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n        restore-keys: |\n          ${{ runner.os }}-pip-\n\n    - name: Install Python dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n\n    - name: Crawl CVEs\n      run: |\n        python crawl_cves.py --password ${{ secrets.CRAWL_PWD }} --token ${{ secrets.GRAPAQL_TOKEN }}\n\n    - name: Commit and push Github page (if changed)\n      run: |\n        git config --global user.name 'github-actions'\n        git config --global user.email 'github-actions@github.com'\n        git add .\n        git commit -m \"Update CVE data\"\n        git push origin master\n```", "answer": "```yaml name: Automatically crawl CVEs \non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n    branches:\n      - master\n  schedule:\n    - cron: '15 * * * *'\n\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Check out repo\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.8\n      - uses: actions/cache@v2\n        name: Configure pip caching\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install Python dependencies\n        run: |\n          python -m pip install -r requirements.txt\n\n      - name: Crawl CVEs\n        run: |-\n          python main.py -g \"${{ secrets.CRAWL_PWD }}\" --gtk ${{ secrets.GRAPAQL_TOKEN }}\n\n      # \u82e5\u8be5\u65f6\u95f4\u6bb5\u6ca1\u6709 CVE\uff0c \u5219 file://cache/mail.dat \u6587\u4ef6\u4e0d\u4f1a\u751f\u6210\uff0c\u6b64\u65f6\u4e0d\u4f1a\u53d1\u9001\u90ae\u4ef6\n      # - name: Send mail\n      #   if: ${{ secrets.CRAWL_PWD != '' && github.event_name != 'pull_request' }}\n      #   uses: lyy289065406/action-send-mail@master\n      #   with:\n      #     server_address: ${{ secrets.MAIL_SMTP }}\n      #     server_port: 465\n      #     username: ${{ secrets.MAIL_USER }}\n      #     password: ${{ secrets.MAIL_PASS }}\n      #     from: ${{ secrets.MAIL_USER }}\n      #     to: file://cache/mail_recvs.dat\n      #     body: file://cache/mail_content.dat\n      #     content_type: text/html\n      #     subject: \u5a01\u80c1\u60c5\u62a5\u64ad\u62a5\n\n      # \u5982\u679c\u4e0d\u5e0c\u671b\u6c61\u67d3 commit \u8bb0\u5f55\uff0cuser.email \u548c user.name \u968f\u4fbf\u586b\u5373\u53ef\n      # Github Runner \u662f\u6709\u6743\u9650\u63d0\u4ea4\u5230\u4ed3\u5e93\u7684\uff0c\u53ea\u8981 user \u4e0d\u662f owner \uff0c\u5f53\u6b21 commit \u4e0d\u4f1a\u88ab\u8bb0\u5f55\n      - name: Commit and push Github page (if changed)\n        if: ${{ github.event_name != 'pull_request' }}\n        run: |-\n          git diff\n          git config --global user.email \"github-bot@example.com\"\n          git config --global user.name \"Github-Bot\"\n          git add -A\n          git commit -m \"Updated by Github Bot\" || exit 0\n          git push origin master\n\n```", "prompt": "Generate a GitHub Workflow named `Automatically crawl CVEs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch named master. 2) someone manually triggers the workflow. 3) the scheduled time has come: at 15 minutes past the hour. The workflow has one job. The job id of the 1st job is `build-and-deploy`. The job `build-and-deploy` has 6 steps. The 1st step is named `Check out repo`. The 2nd step is named `Set up Python`. The 3rd step is named `Configure pip caching`. The 4th step is named `Install Python dependencies`. The 5th step is named `Crawl CVEs`. The 6th step is named `Commit and push Github page (if changed)`. Here are some Github Actions that might be used in the workflow: v2 version of actions/checkout, v2 version of actions/setup-python and v2 version of actions/cache. Here are some variables that might be used in the workflow: runner.os, secrets.CRAWL_PWD and secrets.GRAPAQL_TOKEN. "}
{"id": "63c496891e3364807577b43b", "level": "level3", "llm_response": "```yaml\nname: Build Docker\n\non:\n  push:\n    branches:\n      - trunk\n    paths:\n      - tools/docker/Dockerfile\n      - tools/docker/bin/run.sh\n      - tools/docker/config/**\n      - .github/versions.sh\n      - .github/workflows/build-docker.yml\n  pull_request:\n    branches:\n      - trunk\n    paths:\n      - tools/docker/Dockerfile\n      - tools/docker/bin/run.sh\n      - tools/docker/config/**\n      - .github/versions.sh\n      - .github/workflows/build-docker.yml\n\nconcurrency:\n  group: 'build-docker-${{ github.event_name }}-${{ github.ref }}'\n  cancel-in-progress: true\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up qemu\n        uses: docker/setup-qemu-action@v2\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: matticbot\n          password: ${{ secrets.DOCKER_HUB_MATTICBOT_TOKEN }}\n\n      - name: Log in to GitHub Packages\n        uses: docker/login-action@v2\n        with:\n          registry: docker.pkg.github.com\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Fetch build args\n        id: buildargs\n        run: |\n          # Fetch build arguments here\n          echo \"::set-output name=tags::latest\"\n          echo \"::set-output name=images::mattic/jetpack-dev-env:latest\"\n          echo \"::set-output name=php-version::8.1\"\n          echo \"::set-output name=composer-version::2.4\"\n          echo \"::set-output name=node-version::16\"\n          echo \"::set-output name=pnpm-version::6.14\"\n\n      - name: Extract Docker metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          images: ${{ steps.buildargs.outputs.images }}\n          tags: ${{ steps.buildargs.outputs.tags }}\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          build-args: |\n            PHP_VERSION=${{ steps.buildargs.outputs.php-version }}\n            COMPOSER_VERSION=${{ steps.buildargs.outputs.composer-version }}\n            NODE_VERSION=${{ steps.buildargs.outputs.node-version }}\n            PNPM_VERSION=${{ steps.buildargs.outputs.pnpm-version }}\n```", "answer": "```yaml name: Build Docker\non:\n  push:\n    branches: [ 'trunk' ]\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n  pull_request:\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\nconcurrency:\n  group: build-docker-${{ github.event_name }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    name: Build and publish Jetpack Dev Environment\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    timeout-minutes: 60  # 2021-10-26: Build for arm64 is S-L-O-W. Sigh.\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up qemu\n        uses: docker/setup-qemu-action@v2\n        with:\n          platforms: arm64\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: matticbot\n          password: ${{ secrets.DOCKER_HUB_MATTICBOT_TOKEN }}\n\n      - name: Log in to GitHub Packages\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Fetch build args\n        id: buildargs\n        run: |\n          source .github/versions.sh\n          source .github/files/gh-funcs.sh\n\n          gh_set_output php-version \"$PHP_VERSION\"\n          gh_set_output composer-version \"$COMPOSER_VERSION\"\n          gh_set_output node-version \"$NODE_VERSION\"\n          gh_set_output pnpm-version \"$PNPM_VERSION\"\n\n          # We're not git-tagging for the env. Just tag all trunk builds as latest.\n          if [[ \"$GITHUB_EVENT_NAME\" == \"push\" ]]; then\n            gh_set_output tags \"type=raw,latest\"\n            gh_set_output images $'automattic/jetpack-wordpress-dev\\nghcr.io/automattic/jetpack-wordpress-dev'\n          elif [[ \"$GITHUB_EVENT_NAME\" == \"pull_request\" ]]; then\n            gh_set_output tags \"type=ref,event=pr\"\n            gh_set_output images \"ghcr.io/automattic/jetpack-wordpress-dev\"\n          else\n            echo \"Unknown GITHUB_EVENT_NAME $GITHUB_EVENT_NAME\"\n            exit 1\n          fi\n\n      - name: Extract Docker metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          flavor: latest=false\n          tags: ${{ steps.buildargs.outputs.tags }}\n          images: ${{ steps.buildargs.outputs.images }}\n          labels: |\n            org.opencontainers.image.title=Jetpack Development Environment\n            org.opencontainers.image.description=Unified environment for developing in the Jetpack Monorepo using Docker containers.\n            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/trunk/tools/docker/README.md\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v3\n        with:\n          context: tools/docker\n          platforms: linux/amd64,linux/arm64\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          build-args: |\n            PHP_VERSION=${{ steps.buildargs.outputs.php-version }}\n            COMPOSER_VERSION=${{ steps.buildargs.outputs.composer-version }}\n            NODE_VERSION=${{ steps.buildargs.outputs.node-version }}\n            PNPM_VERSION=${{ steps.buildargs.outputs.pnpm-version }}\n```", "prompt": "Generate a GitHub Workflow named `Build Docker` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named trunk. Only if at least one path of push event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. 2) Only if at least one path of pull_request event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. Only a single workflow using the build-docker-${{ github.event_name }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Build and publish Jetpack Dev Environment` and its job id is `build`. The job `build` has 8 steps. The 1st step is named ``. The 2nd step is named `Set up qemu`. The 3rd step is named `Set up Docker Buildx`. The 4th step is named `Log in to Docker Hub`. The 5th step is named `Log in to GitHub Packages`. The 6th step is named `Fetch build args` and its id is `buildargs`. The 7th step is named `Extract Docker metadata` and its id is `meta`. The 8th step is named `Build and push Docker image`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of docker/setup-qemu-action, v2 version of docker/setup-buildx-action, v2 version of docker/login-action, v2 version of docker/login-action, v4 version of docker/metadata-action and v3 version of docker/build-push-action. Here are some variables that might be used in the workflow: secrets.DOCKER_HUB_MATTICBOT_TOKEN, github.actor, secrets.GITHUB_TOKEN, steps.buildargs.outputs.tags, steps.buildargs.outputs.images, github.server_url, github.repository, steps.meta.outputs.tags, steps.meta.outputs.labels, steps.buildargs.outputs.php-version, steps.buildargs.outputs.composer-version, steps.buildargs.outputs.node-version and steps.buildargs.outputs.pnpm-version. "}
{"id": "63c494318052faa2781a9bf5", "level": "level3", "llm_response": "```yaml\nname: Test a branch on canary\n\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n\npermissions:\n  contents: read\n\ndefaults:\n  run:\n    shell: pwsh\n\njobs:\n  update_tag:\n    id: update_tag\n    steps:\n      - name: Harden runner\n        uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n      - name: Checkout code\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n        with:\n          ref: ${{ github.event.inputs.COMMIT_SHA }}\n      - name: Update the rc tag\n        run: |\n          # Add your update tag command here\n          echo \"Updating tag with commit SHA: ${{ github.event.inputs.COMMIT_SHA }}\"\n      - name: Canary test\n        run: |\n          # Add your canary test command here\n          echo \"Running canary test for commit SHA: ${{ github.event.inputs.COMMIT_SHA }}\"\n```", "answer": "```yaml name: Test a branch on canary\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\ndefaults:\n  run:\n    shell: pwsh\n\npermissions:  # added using https://github.com/step-security/secure-workflows\n  contents: read\n\njobs:\n  update_tag:\n    name: Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n    - uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34 # v1\n      with:\n        allowed-endpoints: \n          api.github.com:443\n          github.com:443\n\n    - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 # v2\n    - name: Update the rc tag\n      uses: step-security/publish-action@b438f840875fdcb7d1de4fc3d1d30e86cf6acb5d\n      with:\n        rc-sha: ${{ env.COMMIT_SHA }}\n        rc: true\n\n    - name: Canary test\n      uses: docker://ghcr.io/step-security/integration-test/int:latest\n      env:\n        PAT: ${{ secrets.PAT }}\n        canary: true\n```", "prompt": "Generate a GitHub Workflow named `Test a branch on canary` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: COMMIT_SHA-this input represents commit sha to be tested and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. For all run steps in the workflow, default shell is set to pwsh. The workflow has one job. The 1st job is named `Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit` and its job id is `update_tag`. The job `update_tag` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Update the rc tag`. The 4th step is named `Canary test`. Here are some Github Actions that might be used in the workflow: 2e205a28d0e1da00c5f53b161f4067b052c61f34 version of step-security/harden-runner, 93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 version of actions/checkout, b438f840875fdcb7d1de4fc3d1d30e86cf6acb5d version of step-security/publish-action and docker://ghcr.io/step-security/integration-test/int:latest. Here are some variables that might be used in the workflow: github.event.inputs.COMMIT_SHA, env.COMMIT_SHA and secrets.PAT. "}
{"id": "63c4964733b087f6bde2ad41", "level": "level3", "llm_response": "```yaml\nname: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - 'py-*'\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [windows-latest, macos-latest]\n\n    defaults:\n      run:\n        shell: bash\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n\n      - name: Fix README symlink\n        run: |\n          if [ -L README ]; then\n            rm README\n            ln -s README.md README\n          fi\n\n      - name: Publish wheel\n        run: |\n          maturin publish --release --token ${{ secrets.PYPI_PASS }}\n        env:\n          CARGO_TARGET_X86_64_UNKNOWN_WINDOWS_MSVC_LINKER: x86_64-w64-mingw32-gcc\n```", "answer": "```yaml name: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - py-*\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, windows-latest]\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.7'\n\n      - name: Fix README symlink\n        run: |\n          rm py-polars/README.md\n          cp README.md py-polars/README.md\n\n      - name: Publish wheel\n        uses: messense/maturin-action@v1\n        env:\n          MATURIN_PASSWORD: ${{ secrets.PYPI_PASS }}\n          RUSTFLAGS: -C target-feature=+fxsr,+sse,+sse2,+sse3,+sse4.1,+sse4.2\n        with:\n          rust-toolchain: nightly-2022-10-06\n          maturin-version: '0.13.5'\n          command: publish\n          args: -m py-polars/Cargo.toml --no-sdist --skip-existing -o wheels -i python -u ritchie46\n```", "prompt": "Generate a GitHub Workflow named `Create Python release windows macos` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches py-*. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The job id of the 1st job is `win-macos`. The job `win-macos` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Fix README symlink`. The 4th step is named `Publish wheel`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v4 version of actions/setup-python and v1 version of messense/maturin-action. Here are some variables that might be used in the workflow: secrets.PYPI_PASS. "}
{"id": "63c496566fc19abdf9c9b6ef", "level": "level3", "llm_response": "```yaml\nname: automerge\n\non:\n  pull_request:\n    types: [labeled]\n\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: enable automerge\n        uses: peter-evans/enable-pull-request-automerge@v2\n        with:\n          github-token: ${{ secrets.PAT }}\n          pull-number: ${{ github.event.pull_request.number }}\n          merge-method: merge\n```", "answer": "```yaml name: automerge\non:\n  pull_request_target:\n    types:\n      - labeled\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: enable automerge\n        if: contains( github.event.pull_request.labels.*.name, 'automerge')\n        uses: peter-evans/enable-pull-request-automerge@v2\n        with:\n          token: ${{ secrets.PAT }}\n          pull-request-number: ${{ github.event.pull_request.number }}\n          merge-method: rebase\n```", "prompt": "Generate a GitHub Workflow named `automerge` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: a label is added to a pull request. The workflow has one job. The job id of the 1st job is `automerge`. The job `automerge` has one step. The 1st step is named `enable automerge`. Here are some Github Actions that might be used in the workflow: v2 version of peter-evans/enable-pull-request-automerge. Here are some variables that might be used in the workflow: secrets.PAT and github.event.pull_request.number. "}
{"id": "63c4941d8052faa2781a937b", "level": "level3", "llm_response": "```yaml\nname: update-flake-lock\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Install Nix\n      uses: cachix/install-nix-action@v18\n      with:\n        nix_version: '2.13.1'\n        channels: 'nixos-unstable'\n\n    - name: Update flake.lock\n      uses: DeterminateSystems/update-flake-lock@v14\n      with:\n        token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: update-flake-lock\non:\n  workflow_dispatch: # allows manual triggering\n  schedule:\n    - cron: '0 0 * * 0' # runs weekly on Sunday at 00:00\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Install Nix\n        uses: cachix/install-nix-action@v18\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n      - name: Update flake.lock\n        uses: DeterminateSystems/update-flake-lock@v14\n        with:\n          # we update nixos-common-styles manual\n          # and the rest of the inputs are content inputs\n          inputs: nixpkgs\n```", "prompt": "Generate a GitHub Workflow named `update-flake-lock` for a GitHub repository whose primary programming language is Less. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The job id of the 1st job is `lockfile`. The job `lockfile` has 3 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Install Nix`. The 3rd step is named `Update flake.lock`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v18 version of cachix/install-nix-action and v14 version of DeterminateSystems/update-flake-lock. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4965533b087f6bde2b378", "level": "level3", "llm_response": "```yaml\nname: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    id: packagist\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update Packagist\n        run: |\n          composer config --global http-basic.packagist.org ${{ secrets.PACKAGIST_API_KEY }} ''\n          composer config --global allow-plugins true\n          composer config --global prefer-dist true\n          composer config --global repo.packagist composer https://packagist.org\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow-plugins true\n          composer config --global repo.packagist.org.prefer-dist true\n          composer config --global repo.packagist.org.type vcs\n          composer config --global repo.packagist.org.url https://github.com/your-repo/your-package\n          composer config --global repo.packagist.org.username ${{ secrets.PACKAGIST_API_KEY }}\n          composer config --global repo.packagist.org.password ''\n          composer config --global repo.packagist.org.allow", "answer": "```yaml name: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    name: Update Packagist\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update Packagist\n        run: |\n          curl -X POST \"https://packagist.org/api/update-package?username=svix&apiToken=$PACKAGIST_API_KEY\" \\\n            -H 'content-type: application/json' \\\n            -d '{\"repository\":{\"url\":\"https://packagist.org/packages/svix/svix\"}}'\n        env:\n          PACKAGIST_API_KEY: ${{ secrets.PACKAGIST_API_KEY }}```", "prompt": "Generate a GitHub Workflow named `PHP Release` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Update Packagist` and its job id is `packagist`. The job `packagist` has one step. The 1st step is named `Update Packagist`. Here are some variables that might be used in the workflow: secrets.PACKAGIST_API_KEY. "}
{"id": "63c4959c7843b61269a08c30", "level": "level3", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  workflow_dispatch:\n\npermissions:\n  contents: read\n  pull-requests: read\n  issues: read\n  security-events: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n\n      - name: Run analysis\n        uses: ossf/scorecard-action@c8416b0b2bf627c349ca92fc8e3de51a64b005cf\n        with:\n          token: ${{ secrets.SCORECARD_READ_TOKEN }}\n\n      - name: Upload artifact\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2\n        with:\n          name: scorecard-report\n          path: scorecard-report.json\n\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5\n        with:\n          sarif_file: scorecard-report.sarif\n```", "answer": "```yaml name: Scorecards supply-chain security\n# Run only manually, because the answers don't change often and the results have \n# many unhelpful positives.\n  \non:\n  workflow_dispatch: \n  # Only the default branch is supported.\n  # branch_protection_rule:\n  # schedule:\n  #   - cron: '38 17 * * 6'\n  # push:\n  #  branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c8416b0b2bf627c349ca92fc8e3de51a64b005cf # v1.0.2\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. Here are some Github Actions that might be used in the workflow: ec3a7ce113134d7a93b817d10a8272cb61118579 version of actions/checkout, c8416b0b2bf627c349ca92fc8e3de51a64b005cf version of ossf/scorecard-action, 82c141cc518b40d92cc801eee768e7aafc9c2fa2 version of actions/upload-artifact and 5f532563584d71fdef14ee64d17bafb34f751ce5 version of github/codeql-action/upload-sarif. Here are some variables that might be used in the workflow: secrets.SCORECARD_READ_TOKEN. "}
{"id": "63c495547843b61269a06e6c", "level": "level3", "llm_response": "```yaml\nname: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 1 * * *'\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\njobs:\n  recreate:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Set up Cloud SDK\n      uses: google-github-actions/setup-gcloud@v0.2.1\n      with:\n        project_id: ${{ secrets.GCP_PROJECT_ID }}\n        service_account_key: ${{ secrets.GCP_SA_KEY }}\n        export_default_credentials: true\n\n    - name: Wait for idle runner\n      id: killable\n      uses: Homebrew/actions/wait-for-idle-runner@master\n      with:\n        runner_name: ${{ matrix.runner_name }}\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        public_repo_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n    - name: Kill runner and create a new one\n      uses: Homebrew/actions/create-gcloud-instance@master\n      with:\n        project_id: ${{ secrets.GCP_PROJECT_ID }}\n        service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n        runner_name: ${{ matrix.runner_name }}\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        public_repo_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "answer": "```yaml name: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    # Once each 24 hours, at 1 during the night\n    - cron: \"0 1 * * *\"\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  recreate:\n    if: github.repository == 'Homebrew/homebrew-core'\n    runs-on: ubuntu-22.04\n    env:\n      # TODO agree on one label for all runners\n      RUNNER_LABEL: TODO\n    strategy:\n      matrix:\n        runner_name:\n          - linux-self-hosted-1\n    steps:\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.2.1\n        with:\n          project_id: ${{ secrets.GCP_PROJECT_ID }}\n          service_account_key: ${{ secrets.GCP_SA_KEY }}\n          export_default_credentials: true\n\n      - name: Wait for idle runner\n        id: killable\n        uses: Homebrew/actions/wait-for-idle-runner@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n      - name: Kill runner and create a new one\n        if: ${{ steps.killable.outputs.runner-found == 'true' && steps.killable.outputs.runner-idle == 'true' }}\n        uses: Homebrew/actions/create-gcloud-instance@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          gcp_project_id: ${{ secrets.GCP_PROJECT_ID }}\n          gcp_service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n          gcp_sa_key: ${{ secrets.GCP_SA_KEY }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Recreate Linux self-hosted runners on schedule` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 01:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the recreate-linux-runners concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `recreate`. The job `recreate` has 3 steps. The 1st step is named `Set up Cloud SDK`. The 2nd step is named `Wait for idle runner` and its id is `killable`. The 3rd step is named `Kill runner and create a new one`. Here are some Github Actions that might be used in the workflow: v0.2.1 version of google-github-actions/setup-gcloud, master version of Homebrew/actions/wait-for-idle-runner and master version of Homebrew/actions/create-gcloud-instance. Here are some variables that might be used in the workflow: secrets.GCP_PROJECT_ID, secrets.GCP_SA_KEY, matrix.runner_name, secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN and secrets.GCP_SERVICE_ACCOUNT. "}
{"id": "63c4942a8052faa2781a9911", "level": "level3", "llm_response": "```yaml\nname: Integration tests\n\non:\n  push:\n    branches:\n      - main\n      - dev\n  workflow_dispatch:\n\njobs:\n  integration_tests:\n    id: integration_tests\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n\n      - name: Set up Go\n        uses: actions/setup-go@37335c7bb261b353407cff977110895fa0b4f7d8\n        with:\n          go-version: '1.17'\n\n      - name: Run tests\n        run: go test -v ./...\n\n      - name: Upload test results\n        uses: actions/upload-artifact@v2\n        with:\n          name: test-results\n          path: ./test-results.xml\n```", "answer": "```yaml name: Integration tests\non:\n  workflow_dispatch: null\n  push:\n    branches:\n      - main\n      - dev\njobs:\n  integration_tests:\n    name: Run integration tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f # pin@v2\n      - uses: actions/setup-go@37335c7bb261b353407cff977110895fa0b4f7d8 # pin@v2\n        with:\n          go-version: '1.18'\n      - run: go version\n      - run: make testacc\n        env:\n          LINODE_TOKEN: ${{ secrets.DX_LINODE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Integration tests` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main or a branch named dev. The workflow has one job. The 1st job is named `Run integration tests` and its job id is `integration_tests`. The job `integration_tests` has 4 steps. The 1st step is named `Clone Repository`. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. Here are some Github Actions that might be used in the workflow: 5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f version of actions/checkout and 37335c7bb261b353407cff977110895fa0b4f7d8 version of actions/setup-go. Here are some variables that might be used in the workflow: secrets.DX_LINODE_TOKEN. "}
{"id": "63c4942a8052faa2781a9910", "level": "level3", "llm_response": "```yaml\nname: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n  pull_request_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Generate App Installation Token\n      id: generate_token\n      uses: tibdex/github-app-token@v1\n      with:\n        app_id: ${{ secrets.DX_ACCTEST_APP_ID }}\n        private_key: ${{ secrets.DX_ACCTEST_PRIV_KEY }}\n\n    - name: Slash Command Dispatch\n      uses: peter-evans/slash-command-dispatch@v1\n      with:\n        token: ${{ steps.generate_token.outputs.token }}\n        command: '/acctest'\n        body: ${{ github.event.comment.body }}\n        owner: ${{ github.repository_owner }}\n        repo: ${{ github.repository }}\n        issue_number: ${{ github.event.issue.number }}\n```", "answer": "```yaml name: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.issue.pull_request }}\n    steps:\n      - name: Generate App Installation Token\n        id: generate_token\n        uses: tibdex/github-app-token@v1\n        with:\n          app_id: ${{ secrets.DX_ACCTEST_APP_ID }}\n          private_key: ${{ secrets.DX_ACCTEST_PRIV_KEY }}\n\n      - name: Slash Command Dispatch\n        uses: peter-evans/slash-command-dispatch@v1\n        env:\n          TOKEN: ${{ steps.generate_token.outputs.token }}\n        with:\n          token: ${{ env.TOKEN }}\n          reaction-token: ${{ secrets.GITHUB_TOKEN }}\n          issue-type: pull-request\n          commands: acctest\n          named-args: true\n          permission: write\n```", "prompt": "Generate a GitHub Workflow named `AccTest Command` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `acctest-command`. The job `acctest-command` has 2 steps. The 1st step is named `Generate App Installation Token` and its id is `generate_token`. The 2nd step is named `Slash Command Dispatch`. Here are some Github Actions that might be used in the workflow: v1 version of tibdex/github-app-token and v1 version of peter-evans/slash-command-dispatch. Here are some variables that might be used in the workflow: secrets.DX_ACCTEST_APP_ID, secrets.DX_ACCTEST_PRIV_KEY, env.TOKEN, secrets.GITHUB_TOKEN and steps.generate_token.outputs.token. "}
{"id": "63c4940f7843b612699feb8d", "level": "level3", "llm_response": "```yaml\nname: Go Coverage\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage:\n    id: coverage\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: 1.16\n\n      - name: Run tests and generate coverage report\n        run: |\n          go test -v -coverprofile=coverage.out ./...\n          go tool cover -func=coverage.out\n```", "answer": "```yaml # add public code coverage reports\non:\n  push:\n    branches:\n    - main\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - run: \"make test-cover\"\n    - uses: codecov/codecov-action@v2\n    with:\n      file: ./coverage.out\n      fail_ci_if_error: true\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `coverage`. The job `coverage` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. Here are some Github Actions that might be used in the workflow: master version of actions/checkout and v2 version of codecov/codecov-action. "}
{"id": "63c496a06fc19abdf9c9d2e3", "level": "level3", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '0 9 * * 4'\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: read\n  pull_requests: read\n  issues: read\n  repository_contents: read\n  security_events: read\n  statuses: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n\n      - name: Run analysis\n        uses: ossf/scorecard-action@c1aec4ac820532bab364f02a81873c555a0ba3a1\n        with:\n          token: ${{ secrets.SCORECARD_READ_TOKEN }}\n\n      - name: Upload artifact\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2\n        with:\n          name: scorecard-report\n          path: report.json\n\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5\n        with:\n          sarif_file: report.sarif\n```", "answer": "```yaml # This file is part of ICU4X. For terms of use, please see the file\n# called LICENSE at the top level of the ICU4X source tree\n# (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).\n\nname: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '18 9 * * 4'\n  push:\n    branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c1aec4ac820532bab364f02a81873c555a0ba3a1 # v1.0.4\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 09:18 am, only on thursday. 3) The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. Here are some Github Actions that might be used in the workflow: ec3a7ce113134d7a93b817d10a8272cb61118579 version of actions/checkout, c1aec4ac820532bab364f02a81873c555a0ba3a1 version of ossf/scorecard-action, 82c141cc518b40d92cc801eee768e7aafc9c2fa2 version of actions/upload-artifact and 5f532563584d71fdef14ee64d17bafb34f751ce5 version of github/codeql-action/upload-sarif. Here are some variables that might be used in the workflow: secrets.SCORECARD_READ_TOKEN. "}
{"id": "63c495257843b61269a05b79", "level": "level3", "llm_response": "```yaml\nname: Update translation templates\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-templates:\n    id: update-templates\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Install git\n        uses: actions/checkout@v3.1.0\n\n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n\n      - name: Install deps\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y meson\n\n      - name: Change git permissions\n        run: |\n          git config --global user.name \"EasyEffects Bot\"\n          git config --global user.email \"bot@easyeffects.io\"\n\n      - name: Run meson targets\n        run: meson compile -C builddir\n\n      - name: Check for non-timestamp diff\n        run: |\n          git diff --cached --name-only | grep -v 'po/.*/LINGUAS' | grep -v 'po/.*/.timestamp' | xargs git diff --cached --quiet && echo \"No non-timestamp diff found\" || echo \"Non-timestamp diff found\"\n\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4.1.3\n        with:\n          token: ${{ secrets.EASYEFFECTS_BOT }}\n          commit-message: \"Update translation templates\"\n          title: \"Update translation templates\"\n          body: \"Automated update of translation templates\"\n          branch: \"translation-update\"\n          delete-branch: true\n```", "answer": "```yaml on:\n  push:\n    branches: [ master ]\n\nname: Update translation templates\njobs:\n  update-templates:\n    name: Update translation templates\n    runs-on: ubuntu-20.04\n    container:\n      image: archlinux\n    steps:\n      # install git first otherwise checkout will not give us an actual git repo\n      - name: Install git\n        run: pacman -Syu --noconfirm git\n    \n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n\n      - name: Install deps\n        run: |\n          # install general build deps\n          pacman -Syu --noconfirm ninja gcc pkgconf python3 python-pip which\n          # install easyeffects deps\n          source ./PKGBUILD && pacman -Syu --noconfirm --needed --asdeps \"${makedepends[@]}\" \"${depends[@]}\"\n          \n      # workaround upstream permissions issue github.com/peter-evans/create-pull-request/issues/1170\n      - name: Change git permissions\n        run: git config --global --add safe.directory \"$GITHUB_WORKSPACE\"\n\n      - name: Run meson targets\n        run: |\n          meson build\n          cd build\n          ../util/update_translation_templates.sh\n          cd ..\n\n      - name: Check for non-timestamp diff\n        run: |\n          # see https://stackoverflow.com/a/26622262\n          DIFF_LINES=$(git diff --unified=0 | grep '^[+-]' | grep -Ev '^(--- a/|\\+\\+\\+ b/)')\n\n          if [[ $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\") != \"$DIFF_LINES\" ]]; then\n            echo \"The calculated diff includes modifications besides just timestamp changes (POT-Creation-Date).\"\n            echo \"Letting the PR continue as this is a valid reason to open a PR.\"\n          else\n            echo \"The calculated diff just has timestamp changes (POT-Creation-Date).\"\n            echo \"Restoring original files since this is not a valid reason to open a PR.\"\n            git restore .\n          fi\n\n          echo \"All diff lines count: $(echo \"$DIFF_LINES\" | wc -l)\"\n          echo \"Diff lines count where POT-Creation-Date was changed: $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\" | wc -l)\"\n\n      # TODO it would be ideal to refresh metainfo fully by copying release notes from the upcoming release in NEWS.yaml to metainfo, and then running the above update template script,\n      # however this is not possible without putting a dummy release in the metainfo with said upcoming release notes which would later have to be adjusted to the real release.\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4.1.3\n        with:\n          title: Update translation templates\n          body: Ensure to merge all other Pull Requests before merging this. Conflicts here will automatically be resolved in case of changes in master.\n          commit-message: Update translation templates\n          # email sets \"EasyEffects Bot\" user as commit author\n          committer: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          author: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          branch: automatically-update-translation-templates\n          # the easyeffects_bot secret/token is only valid for a fork\n          # note the machine user (easyeffects-bot) must have already forked the repository  where the action is running for this to work\n          push-to-fork: easyeffects-bot/easyeffects\n          token: ${{ secrets.EASYEFFECTS_BOT }}\n```", "prompt": "Generate a GitHub Workflow named `Update translation templates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The 1st job is named `Update translation templates` and its job id is `update-templates`. The job `update-templates` has 7 steps. The 1st step is named `Install git`. The 2nd step is named `Checkout`. The 3rd step is named `Install deps`. The 4th step is named `Change git permissions`. The 5th step is named `Run meson targets`. The 6th step is named `Check for non-timestamp diff`. The 7th step is named `Create Pull Request`. Here are some Github Actions that might be used in the workflow: v3.1.0 version of actions/checkout and v4.1.3 version of peter-evans/create-pull-request. Here are some variables that might be used in the workflow: secrets.EASYEFFECTS_BOT. "}
{"id": "63c4967d1899db58864d33af", "level": "level3", "llm_response": "```yaml\nname: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      name:\n        description: 'Package name'\n        required: true\n        default: 'generateblocks'\n\njobs:\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '14'\n\n    - name: NPM install\n      run: npm install\n\n    - name: NPM build\n      run: npm run build\n\n    - name: Grunt action-package\n      run: grunt action-package\n\n    - name: Build zip file\n      run: zip -r ${{ github.event.inputs.name }}.zip .\n      uses: actions/upload-artifact@v3.1.0\n      with:\n        name: ${{ github.event.inputs.name }}.zip\n        path: ${{ github.event.inputs.name }}.zip\n```", "answer": "```yaml name: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      name:\n        description: 'Package name'\n        default: 'generateblocks'\n        required: true\n\njobs:\n\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n          cache: 'npm'\n\n      - name: NPM install\n        run: npm install\n\n      - name: NPM build\n        run: npm run build\n\n      - name: Grunt action-package\n        run: npm run action-package\n\n      - name: Build zip file\n        uses: actions/upload-artifact@v3.1.0\n        with:\n          name: ${{ github.event.inputs.name }}\n          path: |\n            package/\n          retention-days: 1\n```", "prompt": "Generate a GitHub Workflow named `Build package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: name-this input represents package name, its default value is generateblocks and it must be supplied. The workflow has one job. The job id of the 1st job is `build-package`. The job `build-package` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `NPM install`. The 4th step is named `NPM build`. The 5th step is named `Grunt action-package`. The 6th step is named `Build zip file`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-node and v3.1.0 version of actions/upload-artifact. Here are some variables that might be used in the workflow: github.event.inputs.name. "}
{"id": "63c494637843b61269a00d3a", "level": "level3", "llm_response": "```yaml\nname: olm\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\n\njobs:\n  tests:\n    id: main\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Download binaries\n        run: echo \"Download binaries step\"\n\n      - name: Install dependencies\n        run: echo \"Install dependencies step\"\n\n      - name: Create and verify bundle\n        run: echo \"Create and verify bundle step\"\n\n      - name: Create and set up K8s KinD Cluster\n        run: echo \"Create and set up K8s KinD Cluster step\"\n\n      - name: Run the tests\n        run: echo \"Run the tests step\"\n```", "answer": "```yaml name: olm\non:\n  push:\n    branches:\n      - main\n  pull_request:\nenv:\n  GO_VERSION: '1.19'\n  KIND_IMG_TAG: v1.25.0\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\njobs:\n  main:\n    name: tests\n    runs-on: ubuntu-22.04\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Download binaries\n      run: |\n        mkdir -p ${GITHUB_WORKSPACE}/build\n        echo \"${GITHUB_WORKSPACE}/build\" >> ${GITHUB_PATH}\n        make operator-sdk\n        make opm\n\n    - uses: actions/setup-go@268d8c0ca0432bb2cf416faae41297df9d262d7f\n      with:\n        go-version: ${{ env.GO_VERSION }}\n    - name: Install dependencies\n      run: |\n        sudo apt update\n        sudo apt install -y libseccomp-dev libelf-dev libapparmor-dev\n        sudo hack/install-libbpf.sh\n\n    - name: Create and verify bundle\n      run: |\n        make verify-bundle\n\n    - name: Create and set up K8s KinD Cluster\n      run: |\n        ./hack/kind-with-registry.sh\n\n    - name: Run the tests\n      run: ./hack/ci/e2e-olm.sh\n```", "prompt": "Generate a GitHub Workflow named `olm` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: none access is granted to the GITHUB_TOKEN in the `actions` scope, none access is granted to the GITHUB_TOKEN in the `checks` scope, none access is granted to the GITHUB_TOKEN in the `contents` scope, none access is granted to the GITHUB_TOKEN in the `deployments` scope, none access is granted to the GITHUB_TOKEN in the `id-token` scope, none access is granted to the GITHUB_TOKEN in the `issues` scope, none access is granted to the GITHUB_TOKEN in the `discussions` scope, none access is granted to the GITHUB_TOKEN in the `packages` scope, none access is granted to the GITHUB_TOKEN in the `pull-requests` scope, none access is granted to the GITHUB_TOKEN in the `repository-projects` scope, none access is granted to the GITHUB_TOKEN in the `security-events` scope and none access is granted to the GITHUB_TOKEN in the `statuses` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `tests` and its job id is `main`. The job `main` has 7 steps. The 1st step is named ``. The 2nd step is named `Download binaries`. The 3rd step is named ``. The 4th step is named `Install dependencies`. The 5th step is named `Create and verify bundle`. The 6th step is named `Create and set up K8s KinD Cluster`. The 7th step is named `Run the tests`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and 268d8c0ca0432bb2cf416faae41297df9d262d7f version of actions/setup-go. Here are some variables that might be used in the workflow: GITHUB_WORKSPACE, GITHUB_PATH and env.GO_VERSION. "}
{"id": "63c494c78052faa2781ad49a", "level": "level3", "llm_response": "```yaml\nname: Pull Request Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Apply labels to pull requests\n      uses: actions/labeler@v4\n      with:\n        github-token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: \"Pull Request Labeler\"\non:\n  - pull_request_target\n\njobs:\n  triage:\n    permissions:\n      contents: read\n      pull-requests: write\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/labeler@v4\n        with:\n          repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Pull Request Labeler` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `triage`. The job `triage` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v4 version of actions/labeler. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c495928052faa2781b2bc0", "level": "level3", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Add labels to pull request\n        uses: rhysd/changelog-from-release-action@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n    - uses: rhysd/changelog-from-release/action@v2\n      with:\n        file: CHANGELOG.md\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. The job `label` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v2 version of rhysd/changelog-from-release/action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c494608052faa2781aabf2", "level": "level3", "llm_response": "```yaml\nname: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run Configlet\n        run: go run configlet.go\n```", "answer": "```yaml name: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    uses: exercism/github-actions/.github/workflows/configlet.yml@main\n```", "prompt": "Generate a GitHub Workflow named `Configlet` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. 3) someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `configlet`. Here are some reusable workflows that might be used in the workflow: {'version': 'main', 'name': 'exercism/github-actions/.github/workflows/configlet.yml'}. "}
{"id": "63c4949e7843b61269a025e6", "level": "level3", "llm_response": "```yaml\nname: TagBot\n\non:\n  issue_comment:\n    types: [created]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          documenter_key: ${{ secrets.DOCUMENTER_KEY }}\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. The job `TagBot` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v1 version of JuliaRegistries/TagBot. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN and secrets.DOCUMENTER_KEY. "}
{"id": "63c495d98052faa2781b4aa8", "level": "level3", "llm_response": "```yaml\nname: NMake\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    tags: [ 'v*' ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  nmake:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [windows-latest]\n        arch: [x64]\n        makefile: [Makefile]\n        additional-args: []\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Setup development environment\n      uses: ilammy/msvc-dev-cmd@v1.10.0\n      with:\n        arch: ${{ matrix.arch }}\n\n    - name: Compile source code\n      run: nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}\n\n    - name: Run test cases\n      run: nmake test\n```", "answer": "```yaml name: NMake\non: [push, pull_request]\njobs:\n  nmake:\n    name: ${{ matrix.name }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - name: Windows NMake x86\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86\n\n          - name: Windows NMake x64 compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes\n\n          - name: Windows NMake x64 Symbol Prefix\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64 Symbol Prefix Compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n\n          - name: Windows NMake ARM No Test\n            os: windows-2022\n            makefile: win32/Makefile.arm\n            arch: x86_arm\n\n          - name: Windows NMake ARM64 No Test\n            os: windows-2022\n            makefile: win32/Makefile.a64\n            arch: x86_arm64\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Setup development environment\n      uses: ilammy/msvc-dev-cmd@v1.10.0\n      with:\n        arch: ${{ matrix.arch }}\n\n    - name: Compile source code\n      shell: cmd\n      run: nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}\n\n    - name: Run test cases\n      shell: cmd\n      # Don't run tests on Windows ARM\n      if: contains(matrix.arch, 'arm') == false\n      run: |\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} test\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} testdll\n```", "prompt": "Generate a GitHub Workflow named `NMake` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `nmake`. The job `nmake` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Setup development environment`. The 3rd step is named `Compile source code`. The 4th step is named `Run test cases`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v1.10.0 version of ilammy/msvc-dev-cmd. Here are some variables that might be used in the workflow: matrix.arch, matrix.makefile and matrix.additional-args. "}
{"id": "63c493b77843b612699fd377", "level": "level3", "llm_response": "```yaml\nname: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - public/**\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install Nix\n        uses: cachix/install-nix-action@v15\n        with:\n          nix_path: nixpkgs#rust\n\n      - name: Build\n        run: cargo build --release\n\n      - name: Deploy \ud83d\ude80\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./target/release\n```", "answer": "```yaml name: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - \"public/**\"\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install Nix\n        uses: cachix/install-nix-action@v15\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build\n        run: nix build .#website\n\n      - name: Deploy \ud83d\ude80\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./result\n          cname: mdzk.app\n```", "prompt": "Generate a GitHub Workflow named `Publish website` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(public/**), the workflow runs. The workflow has one job. The job id of the 1st job is `deploy-website`. The job `deploy-website` has 4 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install Nix`. The 3rd step is named `Build`. The 4th step is named `Deploy \ud83d\ude80`. Here are some Github Actions that might be used in the workflow: v2.3.1 version of actions/checkout, v15 version of cachix/install-nix-action and v3 version of peaceiris/actions-gh-pages. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4946f7843b61269a011d1", "level": "level3", "llm_response": "```yaml\nname: I2::Dev::Nightly::Publish\n\non:\n  workflow_dispatch:\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n      - name: Build and push iroha2:dev-nightly image\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          push: true\n          tags: iroha2:dev-nightly\n          dockerfile: Dockerfile.dev\n          cache-from: type=local,src=/var/lib/docker/buildkit/cache\n          cache-to: type=local,dest=/var/lib/docker/buildkit/cache\n```", "answer": "```yaml name: I2::Dev::Nightly::Publish\n\non: workflow_dispatch\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n    container:\n      image: 7272721/i2-ci:nightly\n    steps:\n      - uses: actions/checkout@v3\n      - uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push iroha2:dev-nightly image\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          tags: hyperledger/iroha2:dev-nightly-${{ github.sha }}\n          labels: commit=${{ github.sha }}\n          build-args: TAG=dev\n```", "prompt": "Generate a GitHub Workflow named `I2::Dev::Nightly::Publish` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `dockerhub`. The job `dockerhub` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Build and push iroha2:dev-nightly image`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of docker/login-action and v3 version of docker/build-push-action. Here are some variables that might be used in the workflow: secrets.DOCKERHUB_USERNAME, secrets.DOCKERHUB_TOKEN and github.sha. "}
{"id": "63c4941b7843b612699ff0aa", "level": "level3", "llm_response": "```yaml\nname: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - zap/zap.gradle.kts\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Setup Java\n        uses: actions/setup-java@v3\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Build and Release\n        run: |\n          ./gradlew build\n          ./gradlew install\n```", "answer": "```yaml name: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - 'zap/zap.gradle.kts'\n\njobs:\n  release:\n    name: Build and Release\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n        persist-credentials: false\n    - name: Setup Java\n      uses: actions/setup-java@v3\n      with:\n        distribution: 'temurin'\n        java-version: 11\n    - name: Build and Release\n      env:\n        INSTALL4J_LICENSE: ${{ secrets.INSTALL4J_LICENSE }}\n        ZAPBOT_TOKEN: ${{ secrets.ZAPBOT_TOKEN }}\n        ZAP_RELEASE: 1\n        ZAP_JAVA_VERSION: 11\n      run: ./gradlew \"-Dorg.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m\" :zap:createMainRelease\n```", "prompt": "Generate a GitHub Workflow named `Release Main Version` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(zap/zap.gradle.kts), the workflow runs. The workflow has one job. The 1st job is named `Build and Release` and its job id is `release`. The job `release` has 3 steps. The 1st step is named ``. The 2nd step is named `Setup Java`. The 3rd step is named `Build and Release`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/setup-java. Here are some variables that might be used in the workflow: secrets.INSTALL4J_LICENSE and secrets.ZAPBOT_TOKEN. "}
{"id": "63c494a97843b61269a02a52", "level": "level3", "llm_response": "```yaml\nname: pytorch1_8_1-cuda11_1\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n```", "answer": "```yaml name: pytorch1_8_1-cuda11_1\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu111\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.8.1-cu111\n      develop_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_8_1-cuda11_1` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/resuable_gpu_build.yml'}. "}
{"id": "63c493ff8052faa2781a8681", "level": "level3", "llm_response": "```yaml\nname: Check License Lines\n\non:\n  push:\n    branches: [ '*' ]\n\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Check License Lines\n      uses: kt3k/license_checker@v1.0.6\n      with:\n        file: 'LICENSE'\n```", "answer": "```yaml name: Check License Lines\non:\n  push:\n    branches: '**'\n#  pull_request:\n#    branches:\n#      - main\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Check License Lines\n        uses: kt3k/license_checker@v1.0.6```", "prompt": "Generate a GitHub Workflow named `Check License Lines` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch whose name matches * or a branch whose name matches *. The workflow has one job. The job id of the 1st job is `check-license-lines`. The job `check-license-lines` has 2 steps. The 1st step is named ``. The 2nd step is named `Check License Lines`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v1.0.6 version of kt3k/license_checker. "}
{"id": "63c494888052faa2781abb68", "level": "level3", "llm_response": "```yaml\nname: MERGE_MASTER_TO_DEVELOP\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout develop\n      uses: actions/checkout@v3\n      with:\n        ref: develop\n\n    - name: Merge master to develop and push\n      run: |\n        git merge master\n        git push origin develop\n      env:\n        BPMN_IO_USERNAME: ${{ secrets.BPMN_IO_USERNAME }}\n        BPMN_IO_EMAIL: ${{ secrets.BPMN_IO_EMAIL }}\n\n    - name: Notify failure on Slack\n      uses: slackapi/slack-github-action@v1.15.0\n      if: failure()\n      with:\n        slack-token: ${{ secrets.SLACK_BOT_TOKEN }}\n        channel: ${{ secrets.SLACK_CHANNEL_ID }}\n        message: \"The merge from master to develop in ${{ github.repository }} failed.\"\n```", "answer": "```yaml name: MERGE_MASTER_TO_DEVELOP\non:\n  push:\n    branches:\n    - \"master\"\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n    - name: Checkout develop\n      uses: actions/checkout@v3\n      with:\n        ref: develop\n        fetch-depth: 0\n    - name: Merge master to develop and push\n      run: |\n        git config user.name '${{ secrets.BPMN_IO_USERNAME }}'\n        git config user.email '${{ secrets.BPMN_IO_EMAIL }}'\n        git merge -m 'Merge master to develop' --no-edit origin/master\n        git push\n\n    - name: Notify failure on Slack\n      if: failure()\n      uses: slackapi/slack-github-action@v1.15.0\n      with:\n        channel-id: ${{ secrets.SLACK_CHANNEL_ID }}\n        slack-message: \"Automatic merge of <https://github.com/${{ github.repository }}/tree/${{ github.ref }}|${{ github.ref }}> to <https://github.com/${{ github.repository }}/tree/develop|${{ github.repository }}#develop> failed.\"\n      env:\n        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `MERGE_MASTER_TO_DEVELOP` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `Merge_master_to_develop`. The job `Merge_master_to_develop` has 3 steps. The 1st step is named `Checkout develop`. The 2nd step is named `Merge master to develop and push`. The 3rd step is named `Notify failure on Slack`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v1.15.0 version of slackapi/slack-github-action. Here are some variables that might be used in the workflow: secrets.BPMN_IO_USERNAME, secrets.BPMN_IO_EMAIL, secrets.SLACK_CHANNEL_ID, github.repository, github.ref and secrets.SLACK_BOT_TOKEN. "}
{"id": "63c494298052faa2781a987a", "level": "level3", "llm_response": "```yaml\nname: Hypothesis Tests\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 6 * * *'\n\npermissions:\n  issues: write\n\njobs:\n  hypothesis:\n    runs-on: ${{ runner.os }}\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n\n    - name: Install Linux Dependencies\n      uses: ./.github/actions/linux_dependencies\n\n    - name: Set up Python\n      uses: actions/setup-python@v4.3.0\n      with:\n        python-version: ${{ env.python_version }}\n\n    - name: Use Python Dependency Cache\n      uses: actions/cache@v3.0.11\n      with:\n        path: ~/.cache/pip\n        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n        restore-keys: |\n          ${{ runner.os }}-pip-\n\n    - name: Use Hypothesis Cache\n      uses: pat-s/always-upload-cache@v3.0.1\n      with:\n        path: .hypothesis\n        key: ${{ runner.os }}-hypothesis-${{ github.sha }}\n\n    - name: Install Dependencies and Test\n      uses: ./.github/actions/setup_and_test\n\n    - name: Test with Hypothesis\n      run: |\n        python -m hypothesis --verbose\n\n    - name: Create Issue on Failure\n      if: failure()\n      uses: nashmaniac/create-issue-action@v1.1\n      with:\n        title: 'Test Failed'\n        body: 'The Hypothesis tests have failed.'\n        labels: 'bug'\n```", "answer": "```yaml name: Hypothesis Tests\non:\n  workflow_dispatch:\n  schedule:\n    # min hour dom month dow\n    - cron:  '0 6 * * *'\nenv:\n  python_version: '3.10'\n\npermissions:\n  issues: write\n\njobs:\n\n  hypothesis:\n    runs-on: ubuntu-22.04\n    timeout-minutes: 90\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Install Linux Dependencies\n        uses: ./.github/actions/linux_dependencies\n      - name: Set up Python\n        uses: actions/setup-python@v4.3.0\n        with:\n          python-version: ${{ env.python_version }}\n      - name: Use Python Dependency Cache\n        uses: actions/cache@v3.0.11\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}-20.04\n      - name: Use Hypothesis Cache\n        uses: pat-s/always-upload-cache@v3.0.1\n        with:\n          path: .hypothesis\n          key: ${{ runner.os }}-hypothesis\n      - name: Install Dependencies and Test\n        uses: ./.github/actions/setup_and_test\n      - name: Test with Hypothesis\n        run: xvfb-run poetry run pytest -m hypothesis --hypothesis-profile=ci\n        shell: bash\n      - uses: nashmaniac/create-issue-action@v1.1\n        if: failure()\n        name: Create Issue on Failure\n        with:\n          title: Hypothesis tests failed\n          token: ${{secrets.GITHUB_TOKEN}}\n          labels: bug,hypothesis\n          body: |\n            Test run failed for commit ${{github.sha}}.\n            See https://github.com/gaphor/gaphor/actions/workflows/hypothesis-test.yml.\n```", "prompt": "Generate a GitHub Workflow named `Hypothesis Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 06:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `hypothesis`. The job `hypothesis` has 8 steps. The 1st step is named ``. The 2nd step is named `Install Linux Dependencies`. The 3rd step is named `Set up Python`. The 4th step is named `Use Python Dependency Cache`. The 5th step is named `Use Hypothesis Cache`. The 6th step is named `Install Dependencies and Test`. The 7th step is named `Test with Hypothesis`. The 8th step is named `Create Issue on Failure`. Here are some Github Actions that might be used in the workflow: v3.1.0 version of actions/checkout, ./.github/actions/linux_dependencies, v4.3.0 version of actions/setup-python, v3.0.11 version of actions/cache, v3.0.1 version of pat-s/always-upload-cache, ./.github/actions/setup_and_test and v1.1 version of nashmaniac/create-issue-action. Here are some variables that might be used in the workflow: github.event.pull_request.head.sha, env.python_version, runner.os, secrets.GITHUB_TOKEN and github.sha. "}
{"id": "63c495038052faa2781aede8", "level": "level3", "llm_response": "```yaml\nname: Python package\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  windows:\n    id: windows\n    runs-on: windows-latest\n\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Miniconda\n        uses: conda-incubator/setup-miniconda@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Create Conda environment with the right deps\n        run: conda create -n testenv python=${{ matrix.python-version }} -y\n\n      - name: Install dependencies\n        run: conda activate testenv && pip install -r requirements.txt\n\n      - name: Run Tests\n        run: conda activate testenv && pytest\n\n      - name: Conda info\n        run: conda info\n\n      - name: Conda list\n        run: conda list\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Python package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  windows:\n    name: Windows Tests\n    runs-on: \"windows-latest\"\n    strategy:\n      fail-fast: True\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: conda-incubator/setup-miniconda@v2\n        with:\n          auto-update-conda: true\n          python-version: ${{ matrix.python-version }}\n          channels: conda-forge\n        env:\n          ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n      - name: Create Conda environment with the rights deps\n        shell: bash -l {0}\n        run: |\n          conda create -n zarr-env python==${{matrix.python-version}} numcodecs pip nodejs\n      - name: Install dependencies\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          python -m pip install --upgrade pip\n          python -m pip install -U pip setuptools wheel\n          python -m pip install -r requirements_dev_numpy.txt -r requirements_dev_minimal.txt -r requirements_dev_optional.txt\n          python -m pip install .\n          python -m pip freeze\n          npm install -g azurite\n      - name: Run Tests\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          mkdir ~/blob_emulator\n          azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n          pytest -sv --timeout=300\n        env:\n          ZARR_TEST_ABS: 1\n          ZARR_V3_EXPERIMENTAL_API: 1\n      - name: Conda info\n        shell: bash -l {0}\n        run: conda info\n      - name: Conda list\n        shell: pwsh\n        run: conda list\n```", "prompt": "Generate a GitHub Workflow named `Python package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Windows Tests` and its job id is `windows`. The job `windows` has 7 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Create Conda environment with the rights deps`. The 4th step is named `Install dependencies`. The 5th step is named `Run Tests`. The 6th step is named `Conda info`. The 7th step is named `Conda list`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v2 version of conda-incubator/setup-miniconda. Here are some variables that might be used in the workflow: matrix.python-version. "}
{"id": "63c494347843b612699ffaac", "level": "level3", "llm_response": "```yaml\nname: Monitor CI Scaler\n\non:\n  schedule:\n    - cron: '0 5 * * *'\n    - cron: '0 17 * * *'\n\njobs:\n  MonitorCI:\n    id: MonitorCI\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: checkout\n        uses: actions/checkout@v1\n\n      - name: setup environment\n        run: |\n          echo \"Setting up environment...\"\n          # Add any environment setup commands here\n\n      - name: check scaler\n        run: |\n          echo \"Checking scaler status...\"\n          # Add any scaler check commands here\n```", "answer": "```yaml name: Monitor CI Scaler\n\non:\n  # workflow_dispatch:\n  schedule:\n    - cron: '0 5,17 * * *'\n\njobs:\n  MonitorCI:\n    name: monitor ci scaler\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v1\n        with:\n          submodules: recursive\n      - name: setup environment\n        run: bash ./scripts/dev_setup.sh  -b -t -y\n      - name: check scaler\n        run: python3 ./scripts/monitor_autoscaler_recreate.py\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Monitor CI Scaler` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: the scheduled time has come: at 05:00 am and 05:00 pm. The workflow has one job. The 1st job is named `monitor ci scaler` and its job id is `MonitorCI`. The job `MonitorCI` has 3 steps. The 1st step is named `checkout`. The 2nd step is named `setup environment`. The 3rd step is named `check scaler`. Here are some Github Actions that might be used in the workflow: v1 version of actions/checkout. Here are some variables that might be used in the workflow: secrets.AWS_ACCESS_KEY_ID and secrets.AWS_SECRET_ACCESS_KEY. "}
{"id": "63c494cf8052faa2781ad80f", "level": "level3", "llm_response": "```yaml\nname: Release Documentation\n\non:\n  release:\n    types: [published, prereleased, drafted]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  java-build:\n    id: java-build\n    runs-on: ${{ runner.os }}\n    strategy:\n      matrix:\n        java: [11, 17]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Cache Gradle dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/caches\n          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-\n\n      - name: Cache Gradle wrappers\n        uses: actions/cache@v3\n        with:\n          path: .gradle/wrapper/dists\n          key: ${{ runner.os }}-gradle-wrapper-${{ hashFiles('gradle/wrapper/gradle-wrapper.properties') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-wrapper-\n\n      - name: Setup java\n        uses: actions/setup-java@v3\n        with:\n          java-version: ${{ matrix.java }}\n          distribution: 'adopt'\n\n      - name: Build with Gradle\n        run: ./gradlew build\n```", "answer": "```yaml name: Release Documentation\non:\n  release:\n    types: [published]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  GRADLE_OPTS: '-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail'\n\njobs:\n  java-build:\n    name: Publish Release Documentation\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        java: [ '8' ]\n        os: ['ubuntu-22.04' ]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Cache Gradle dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/caches\n          key: ${{ runner.os }}-gradle-caches-${{ hashFiles('**/*.gradle') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-caches-\n      - name: Cache Gradle wrappers\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-wrapper\n      - name: Setup java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: ${{ matrix.java }}\n      - name: Build with Gradle\n        run: ./gradlew tutorialPublish -Paeron.ci.apiKey=${{ secrets.WIKI_PAGE_TOKEN }} --stacktrace\n```", "prompt": "Generate a GitHub Workflow named `Release Documentation` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Publish Release Documentation` and its job id is `java-build`. The job `java-build` has 5 steps. The 1st step is named `Checkout code`. The 2nd step is named `Cache Gradle dependencies`. The 3rd step is named `Cache Gradle wrappers`. The 4th step is named `Setup java`. The 5th step is named `Build with Gradle`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/cache, v3 version of actions/cache and v3 version of actions/setup-java. Here are some variables that might be used in the workflow: runner.os, matrix.java and secrets.WIKI_PAGE_TOKEN. "}
{"id": "63c4967d6fc19abdf9c9c492", "level": "level3", "llm_response": "```yaml\nname: gradio-ui\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\nconcurrency:\n  group: 'deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}'\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    id: static-checks\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ui\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: pnpm install\n      - name: Formatting check\n        run: pnpm run format:check\n      - name: Typecheck\n        run: pnpm run typecheck\n      - name: Unit tests\n        run: pnpm run test:unit\n\n  functional-test:\n    id: functional-test\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ui\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: pnpm install\n      - name: Install Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n      - name: Run functional tests\n        run: pnpm run test:functional\n      - name: Upload failed tests screenshots\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: failed-tests-screenshots\n          path: screenshots\n```", "answer": "```yaml name: gradio-ui\n\non:\n  push:\n    branches:\n      - \"main\"\n  pull_request:\n\ndefaults:\n  run:\n    working-directory: ui\n\nenv:\n  CI: true\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: \"1\"\n  NODE_OPTIONS: \"--max-old-space-size=4096\"\n\nconcurrency:\n  group: deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    name: static checks\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: install dependencies\n        run: pnpm i --frozen-lockfile\n      - name: formatting check\n        run: pnpm format:check\n      - name: typecheck\n        run: pnpm ts:check\n      - name: unit tests\n        run: pnpm test:run\n  functional-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: Install Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.x'\n      - run: cd .. && bash scripts/install_gradio.sh\n      - run: pip install -r ../demo/outbreak_forecast/requirements.txt\n      - run: pnpm install --frozen-lockfile\n      - run: pnpm exec playwright install chromium\n      - run: pnpm test:browser:full\n      - name: Upload failed tests screenshots\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          retention-days: 3\n          name: test-failure-${{ github.run_id }}\n          path: ui/packages/app/test-results\n```", "prompt": "Generate a GitHub Workflow named `gradio-ui` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. For all run steps in the workflow, default working directory is set to ui. Only a single workflow using the deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `static checks` and its job id is `quick-checks`. The job `quick-checks` has 7 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `install dependencies`. The 5th step is named `formatting check`. The 6th step is named `typecheck`. The 7th step is named `unit tests`. The job id of the 2nd job is `functional-test`. The job `functional-test` has 10 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Install Python`. The 5th step is named ``. The 6th step is named ``. The 7th step is named ``. The 8th step is named ``. The 9th step is named ``. The 10th step is named `Upload failed tests screenshots`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2.2.1 version of pnpm/action-setup, v3 version of actions/setup-node, v3 version of actions/checkout, v2.2.1 version of pnpm/action-setup, v3 version of actions/setup-node, v3 version of actions/setup-python and v3 version of actions/upload-artifact. Here are some variables that might be used in the workflow: github.run_id. "}
{"id": "63c496851899db58864d368d", "level": "level3", "llm_response": "```yaml\nname: Bump repositories\n\non:\n  schedule:\n    - cron: '0 20 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Bump cos \ud83d\udd27\n        run: |\n          # Add your code to bump cos here\n          echo \"Bumping cos...\"\n\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4\n        with:\n          token: ${{ secrets.PAT_TOKEN }}\n          title: 'Bump cos'\n          commit-message: 'chore: bump cos'\n          body: 'Automated bump of cos'\n          branch: 'bump-cos'\n          delete-branch: true\n```", "answer": "```yaml name: Bump repositories\non: \n schedule:\n   - cron: 0 20 * * *\n workflow_dispatch:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Bump cos \ud83d\udd27\n      run: |\n           docker run --name=yq -v \"${PWD}\":/workdir mikefarah/yq\n           docker cp yq:/usr/bin/yq ./\n           export YQ=$PWD/yq\n           sudo -E bash ./.github/bump_repositories.sh\n           rm -rf yq\n    - name: Create Pull Request\n      uses: peter-evans/create-pull-request@v4\n      with:\n        token: ${{ secrets.PAT_TOKEN }}\n        push-to-fork: ci-robbot/c3os\n        commit-message: \":arrow_up: Update repositories\"\n        title: \"Repositories bump\"\n        body: \"Bump of luet repositories\"\n```", "prompt": "Generate a GitHub Workflow named `Bump repositories` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 08:00 pm. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 3 steps. The 1st step is named ``. The 2nd step is named `Bump cos \ud83d\udd27`. The 3rd step is named `Create Pull Request`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v4 version of peter-evans/create-pull-request. Here are some variables that might be used in the workflow: secrets.PAT_TOKEN. "}
{"id": "63c4945a7843b61269a00a52", "level": "level3", "llm_response": "```yaml\nname: ci\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Build and export to Docker\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          push: false\n          tags: my-dockerhub-username/my-repository:${{ github.sha }}\n\n      - name: Run\n        run: docker run --rm my-dockerhub-username/my-repository:${{ github.sha }} env.TEST_TAG\n```", "answer": "```yaml name: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      - name: Build and export to Docker\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          load: true\n          push: false\n          tags: ${{ env.TEST_TAG }}\n      - name: Run\n        run: |\n          docker run --rm ${{ env.TEST_TAG }} ci\n```", "prompt": "Generate a GitHub Workflow named `ci` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `docker`. The job `docker` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up QEMU`. The 3rd step is named `Set up Docker Buildx`. The 4th step is named `Build and export to Docker`. The 5th step is named `Run`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of docker/setup-qemu-action, v2 version of docker/setup-buildx-action and v3 version of docker/build-push-action. Here are some variables that might be used in the workflow: github.sha and env.TEST_TAG. "}
{"id": "63c49698b008460c1df15629", "level": "level3", "llm_response": "```yaml\nname: Auto Assign PR to Author\n\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    id: add-reviews\n    runs-on: ubuntu-latest\n    steps:\n      - uses: kentaro-m/auto-assign-action@v1.2.1\n```", "answer": "```yaml name: 'Auto Assign PR to Author'\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    permissions:\n      contents: read  # for kentaro-m/auto-assign-action to fetch config file\n      pull-requests: write  # for kentaro-m/auto-assign-action to assign PR reviewers\n    runs-on: ubuntu-latest\n    steps:\n      - uses: kentaro-m/auto-assign-action@v1.2.1\n```", "prompt": "Generate a GitHub Workflow named `Auto Assign PR to Author` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by an event: a pull request is created. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `add-reviews`. The job `add-reviews` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v1.2.1 version of kentaro-m/auto-assign-action. "}
{"id": "63c494a87843b61269a02a08", "level": "level3", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.8'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Build documentation\n        run: |\n          make html\n\n      - name: Upload documentation\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs/build/html\n```", "answer": "```yaml name: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-python@v4\n        with:\n          python-version: 3.x\n      - run: pip install -r requirements/build-docs.txt\n      - run: linkcheckMarkdown docs/ -v -r\n      - run: mkdocs build --verbose\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `docs`. The job `docs` has 5 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v4 version of actions/setup-python. "}
{"id": "63c4956d7843b61269a07890", "level": "level3", "llm_response": "```yaml\nname: Issue Comments for merge\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  check_comments_merge:\n    id: check_comments_merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        uses: xt0rted/slash-command-action@v1.1.0\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          command: /merge\n          issue_number: ${{ github.event.issue.number }}\n          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}\n          comment_id: ${{ github.event.client_payload.github.payload.comment.id }}\n\n  merge:\n    id: merge\n    needs: check_comments_merge\n    runs-on: ubuntu-latest\n    if: ${{ steps.check_comments_merge.outputs.command_found }}\n    steps:\n      - name: Merge Pull Request\n        uses: juliangruber/merge-pull-request-action@v1.1.0\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          issue_number: ${{ github.event.issue.number }}\n\n  commentFeedback:\n    id: commentFeedback\n    needs: merge\n    runs-on: ubuntu-latest\n    if: ${{ steps.merge.outcome == 'success' }}\n    steps:\n      - name: Add reaction on success\n        uses: peter-evans/create-or-update-comment@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          issue_number: ${{ github.event.issue.number }}\n          body: \"Pull request merged successfully!\"\n          reactions: \"+1\"\n```", "answer": "```yaml on: issue_comment\nname: Issue Comments for merge\njobs:\n  check_comments_merge:\n    name: Check comments for /merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        uses: xt0rted/slash-command-action@v1.1.0\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          command: merge\n          reaction: \"true\"\n          reaction-type: \"eyes\"\n          allow-edits: \"false\"\n          permission-level: admin\n  merge:\n    runs-on: ubuntu-latest\n    needs: [check_comments_merge]\n    steps:\n      - name: Merge Pull Request\n        uses: juliangruber/merge-pull-request-action@v1.1.0\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          number: ${{ github.event.issue.number }}\n          method: merge\n  commentFeedback:\n    runs-on: ubuntu-latest\n    needs: [merge]\n    steps:\n      - name: Add reaction on success\n        uses: peter-evans/create-or-update-comment@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}\n          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}\n          reaction-type: hooray\n```", "prompt": "Generate a GitHub Workflow named `Issue Comments for merge` for a GitHub repository whose primary programming language is HCL. This workflow will be triggered by an event: activity related to an issue or pull request comment occurs. The workflow has 3 jobs. The 1st job is named `Check comments for /merge` and its job id is `check_comments_merge`. The job `check_comments_merge` has one step. The 1st step is named `Check for Command`. The job id of the 2nd job is `merge`. The job `merge` has one step. The 1st step is named `Merge Pull Request`. The job id of the 3rd job is `commentFeedback`. The job `commentFeedback` has one step. The 1st step is named `Add reaction on success`. Here are some Github Actions that might be used in the workflow: v1.1.0 version of xt0rted/slash-command-action, v1.1.0 version of juliangruber/merge-pull-request-action and v2 version of peter-evans/create-or-update-comment. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN, github.event.issue.number, github.event.client_payload.github.payload.repository.full_name and github.event.client_payload.github.payload.comment.id. "}
{"id": "63c495888052faa2781b2739", "level": "level3", "llm_response": "```yaml\nname: \u2744\ufe0f Lint\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    id: misc\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v3.1.0\n      - name: spell check\n        run: echo \"Spell check step\"\n      - name: Merge conflict\n        run: echo \"Merge conflict step\"\n      - name: Plugin Code\n        run: echo \"Plugin Code step\"\n\n  ci-eclint:\n    id: ci-eclint\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v3.1.0\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v3.5.1\n        with:\n          node-version: '14'\n      - name: Install eclint\n        run: npm install -g eclint\n      - name: Run eclint\n        run: eclint check .\n```", "answer": "```yaml name: \u2744\ufe0f Lint\n\non: [push, pull_request]\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    name: misc checker\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v3.1.0\n      - name: spell check\n        run: |\n          pip install codespell==2.1.0\n          git grep --cached -l '' | xargs codespell --ignore-words=.ignore_words\n      - name: Merge conflict\n        run: |\n          bash ./utils/check-merge-conflict.sh\n      - name: Plugin Code\n        run: |\n          bash ./utils/check-plugins-code.sh\n\n  ci-eclint:\n    runs-on: ubuntu-latest\n    timeout-minutes: 5\n\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v3.1.0\n\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v3.5.1\n        with:\n          node-version: '12'\n\n      - name: Install eclint\n        run: |\n          sudo npm install -g eclint\n\n      - name: Run eclint\n        run: |\n          eclint check\n```", "prompt": "Generate a GitHub Workflow named `\u2744\ufe0f Lint` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `misc checker` and its job id is `misc`. The job `misc` has 4 steps. The 1st step is named `Check out code.`. The 2nd step is named `spell check`. The 3rd step is named `Merge conflict`. The 4th step is named `Plugin Code`. The job id of the 2nd job is `ci-eclint`. The job `ci-eclint` has 4 steps. The 1st step is named `Check out code`. The 2nd step is named `Setup Nodejs env`. The 3rd step is named `Install eclint`. The 4th step is named `Run eclint`. Here are some Github Actions that might be used in the workflow: v3.1.0 version of actions/checkout, v3.1.0 version of actions/checkout and v3.5.1 version of actions/setup-node. "}
{"id": "63c4951b8052faa2781af857", "level": "level3", "llm_response": "```yaml\nname: Docs Build\n\non:\n  push:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  docs-build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Install deps\n        run: npm install\n\n      - name: Build docs\n        run: npm run docs:build\n\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs\n```", "answer": "```yaml name: Docs Build\n\non:\n  # allows to manually run the job at any time\n  workflow_dispatch:\n  \n  # run on every push on the master branch\n  push:\n    branches:\n      - master\n\njobs:\n  docs-build:\n    timeout-minutes: 10\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Install deps\n        run: |\n          npm install vuepress -D\n          npm install macaca-ecosystem -D\n\n      - name: Build docs\n        run: npm run docs:build\n\n      - name: Deploy to GitHub Pages\n        if: success()\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs_dist\n```", "prompt": "Generate a GitHub Workflow named `Docs Build` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `docs-build`. The job `docs-build` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set node version to 16`. The 3rd step is named `Install deps`. The 4th step is named `Build docs`. The 5th step is named `Deploy to GitHub Pages`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-node and v3 version of peaceiris/actions-gh-pages. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c494027843b612699fe5e4", "level": "level3", "llm_response": "```yaml\nname: CLA\n\non:\n  pull_request:\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v1\n\n    - name: Check CLA\n      run: |\n        echo \"Checking CLA for user: ${{ github.event.pull_request.user.login }}\"\n        # Add your CLA checking logic here\n```", "answer": "```yaml name: CLA\non: [pull_request]\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v1\n    - run: ./ci/check-cla.sh \"${{ github.event.pull_request.user.login }}\"\n```", "prompt": "Generate a GitHub Workflow named `CLA` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check`. The job `check` has 2 steps. The 1st step is named ``. The 2nd step is named ``. Here are some Github Actions that might be used in the workflow: v1 version of actions/checkout. Here are some variables that might be used in the workflow: github.event.pull_request.user.login. "}
{"id": "63c496831e3364807577b1f9", "level": "level3", "llm_response": "```yaml\nname: Fastlane Metadata\n\non:\n  push:\n    branches:\n      - main\n      - '[0-9]+.[0-9]+.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n  pull_request:\n    branches:\n      - main\n      - '[0-9]+.[0-9]+.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n\njobs:\n  validate:\n    id: validate\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Validate Fastlane metadata\n        uses: ashutoshgngwr/validate-fastlane-supply-metadata@v2\n\n  play-store-upload:\n    id: play-store-upload\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '2.7'\n      - name: Install dependencies\n        run: bundle install\n      - name: Configure Google Play\n        run: echo \"$SECRETS_SERVICE_ACCOUNT_KEY\" | base64 --decode > service-account.json\n      - name: Upload to Play Store\n        run: fastlane supply --apk path/to/app.apk --track internal --json_key service-account.json\n      - name: Clean up\n        run: rm service-account.json\n```", "answer": "```yaml name: Fastlane Metadata\non:\n  push:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n  pull_request:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n\njobs:\n  validate:\n    name: Validate\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    steps:\n      - uses: actions/checkout@v3\n      - uses: ashutoshgngwr/validate-fastlane-supply-metadata@v2\n        with:\n          usePlayStoreLocales: true\n\n  play-store-upload:\n    name: Play Store Upload\n    needs: validate\n    if: github.event_name == 'push'\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    steps:\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n      - uses: actions/checkout@v3\n      - run: bundle install\n      - run: echo \"$SERVICE_ACCOUNT_KEY\" > service-account-key.json\n        env:\n          SERVICE_ACCOUNT_KEY: ${{ secrets.SERVICE_ACCOUNT_KEY }}\n      - run: bundle exec fastlane upload_metadata\n      - if: ${{ always() }}\n        run: rm -f service-account-key.json\n```", "prompt": "Generate a GitHub Workflow named `Fastlane Metadata` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of push event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of pull_request event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. The workflow has 2 jobs. The 1st job is named `Validate` and its job id is `validate`. The job `validate` has 2 steps. The 1st step is named ``. The 2nd step is named ``. The 2nd job is named `Play Store Upload` and its job id is `play-store-upload`. The job `play-store-upload` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of ashutoshgngwr/validate-fastlane-supply-metadata, v1 version of ruby/setup-ruby and v3 version of actions/checkout. Here are some variables that might be used in the workflow: secrets.SERVICE_ACCOUNT_KEY. "}
{"id": "63c496701e3364807577aa6c", "level": "level3", "llm_response": "```yaml\nname: dds-rtps\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  Linux:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: checkout OpenDDS\n      uses: actions/checkout@v3\n      with:\n        repository: omg-dds/OpenDDS\n        path: OpenDDS\n\n    - name: checkout dds-rtps\n      uses: actions/checkout@v3\n      with:\n        repository: omg-dds/dds-rtps\n        path: dds-rtps\n\n    - name: checkout ACE_TAO\n      uses: actions/checkout@v3\n      with:\n        repository: drepper/ace\n        path: ACE_TAO\n\n    - name: get ACE_TAO commit\n      run: echo \"ACE_TAO_COMMIT=$(git rev-parse HEAD)\" >> $GITHUB_ENV\n\n    - name: get compiler version\n      run: echo \"COMPILER_VERSION=$(gcc --version | head -n 1)\" >> $GITHUB_ENV\n      uses: ammaraskar/gcc-problem-matcher@v0.1\n\n    - name: checkout MPC\n      uses: actions/checkout@v3\n      with:\n        repository: gcc-mirror/mpc\n        path: MPC\n\n    - name: configure OpenDDS\n      run: cd OpenDDS && ./configure\n\n    - name: build OpenDDS\n      run: cd OpenDDS && make\n\n    - name: build shape_main\n      run: cd dds-rtps && make shape_main\n\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: shape_main\n        path: dds-rtps/shape_main\n```", "answer": "```yaml name: \"omg-dds/dds-rtps\"\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n\n  Linux:\n    runs-on: ubuntu-20.04\n    steps:\n    - name: checkout OpenDDS\n      uses: actions/checkout@v3\n      with:\n        path: OpenDDS\n        submodules: true\n    - name: checkout dds-rtps\n      uses: actions/checkout@v3\n      with:\n        repository: omg-dds/dds-rtps\n        path: dds-rtps\n    - name: checkout ACE_TAO\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/ACE_TAO\n        ref: Latest_Micro\n        path: OpenDDS/ACE_TAO\n    - name: get ACE_TAO commit\n      shell: bash\n      run: |\n        cd OpenDDS/ACE_TAO\n        export ACE_COMMIT=$(git rev-parse HEAD)\n        echo \"ACE_COMMIT=$ACE_COMMIT\" >> $GITHUB_ENV\n    - name: get compiler version\n      shell: bash\n      run: |\n        export COMPILER_VERSION=$(g++ --version 2>&1 | head -n 1)\n        echo \"COMPILER_VERSION=$COMPILER_VERSION\" >> $GITHUB_ENV\n    - name: checkout MPC\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/MPC\n        path: OpenDDS/ACE_TAO/ACE/MPC\n    - name: configure OpenDDS\n      run: |\n        cd OpenDDS\n        ./configure --optimize --no-debug --static --no-inline\n        tools/scripts/show_build_config.pl\n    - uses: ammaraskar/gcc-problem-matcher@0.1\n    - name: build OpenDDS\n      shell: bash\n      run: |\n        cd OpenDDS\n        make -j4 OpenDDS_Rtps_Udp\n    - name: build shape_main\n      shell: bash\n      run: |\n        cd dds-rtps/srcCxx\n        . ../../OpenDDS/setenv.sh\n        mwc.pl -type gnuace\n        make -sj4\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: ${{ github.job }}_artifact\n        path: dds-rtps/srcCxx/shape_main\n```", "prompt": "Generate a GitHub Workflow named `omg-dds/dds-rtps` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `Linux`. The job `Linux` has 11 steps. The 1st step is named `checkout OpenDDS`. The 2nd step is named `checkout dds-rtps`. The 3rd step is named `checkout ACE_TAO`. The 4th step is named `get ACE_TAO commit`. The 5th step is named `get compiler version`. The 6th step is named `checkout MPC`. The 7th step is named `configure OpenDDS`. The 8th step is named ``. The 9th step is named `build OpenDDS`. The 10th step is named `build shape_main`. The 11th step is named `upload shape_main artifact`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/checkout, v3 version of actions/checkout, v3 version of actions/checkout, 0.1 version of ammaraskar/gcc-problem-matcher and v3 version of actions/upload-artifact. Here are some variables that might be used in the workflow: github.job. "}
{"id": "63c495277843b61269a05c66", "level": "level3", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        channel: [stable]\n        dependencies: [none]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          channel: ${{ matrix.channel }}\n\n      - name: Removing example folder\n        run: rm -rf example\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Check format\n        run: flutter format --set-exit-if-changed .\n\n      - name: Generate\n        run: flutter pub run build_runner build\n\n      - name: Analyze\n        run: flutter analyze\n\n      - name: Run tests\n        run: flutter test\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    # runs the CI everyday at 10AM\n    - cron: \"0 10 * * *\"\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        package:\n          - packages/freezed\n          - packages/freezed_annotation\n        channel:\n          - master\n          - stable\n        dependencies:\n          - get\n          - downgrade\n        exclude:\n          - channel: master\n            dependencies: downgrade\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: subosito/flutter-action@v2\n        with:\n          channel: ${{ matrix.channel }}\n          cache: ${{ matrix.channel == 'stable' }}\n\n      # It is executed separately\n      - name: Removing example folder\n        run: rm -rf example\n        working-directory: ${{ matrix.package }}\n\n      - name: Install dependencies\n        run: |\n          flutter pub ${{ matrix.dependencies }}\n        working-directory: ${{ matrix.package }}\n\n      - name: Check format\n        # Check format only on master\n        if: matrix.channel == 'master'\n        run: flutter format --set-exit-if-changed .\n        working-directory: ${{ matrix.package }}\n\n      - name: Generate\n        run: |\n          if grep -q build_runner \"pubspec.yaml\"; then\n            flutter pub run build_runner build --delete-conflicting-outputs\n          fi\n        working-directory: ${{ matrix.package }}\n\n      - name: Analyze\n        run: flutter analyze\n        working-directory: ${{ matrix.package }}\n\n      - name: Run tests\n        run: |\n          if grep -q \"name: example\" \"pubspec.yaml\"; then\n            flutter test\n          else\n            dart test\n          fi\n        working-directory: ${{ matrix.package }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `freezed`. The job `freezed` has 8 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Removing example folder`. The 4th step is named `Install dependencies`. The 5th step is named `Check format`. The 6th step is named `Generate`. The 7th step is named `Analyze`. The 8th step is named `Run tests`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v2 version of subosito/flutter-action. Here are some variables that might be used in the workflow: matrix.channel, matrix.channel == 'stable' and matrix.dependencies. "}
{"id": "63c4968933b087f6bde2ca37", "level": "level3", "llm_response": "```yaml\nname: e2e-kind-upgrades\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: ~/.cache/bazel\n          key: ${{ runner.os }}-bazel-${{ hashFiles('**/WORKSPACE', '**/BUILD') }}\n          restore-keys: |\n            ${{ runner.os }}-bazel-\n\n      - name: End-to-end (k3d)\n        run: |\n          # Add your end-to-end test commands here\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: e2e-kind-upgrades\n\non:\n  # Triggers the workflow on push or pull request events but only for the master branch\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: End-to-end (k3d)\n        run: make test/e2e/k3d-upgrades\n```", "prompt": "Generate a GitHub Workflow named `e2e-kind-upgrades` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. 3) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `e2e-kind-upgrades`. The job `e2e-kind-upgrades` has 3 steps. The 1st step is named ``. The 2nd step is named `Mount bazel cache`. The 3rd step is named `End-to-end (k3d)`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/cache. "}
{"id": "63c494147843b612699fedb4", "level": "level3", "llm_response": "```yaml\nname: test-chart-testing-action\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Install chart-testing\n        run: |\n          # Install chart-testing here\n      - name: Check install!\n        run: |\n          # Check if chart-testing is installed here\n      - name: Check root directory\n        run: |\n          # Check root directory here\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Install chart-testing\n        run: |\n          # Install custom chart-testing here\n      - name: Check install!\n        run: |\n          # Check if custom chart-testing is installed here\n      - name: Check root directory\n        run: |\n          # Check root directory here\n```", "answer": "```yaml name: test-chart-testing-action\n\non: [pull_request]\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n\n    name: Install chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.7.1' ]]; then\n          echo 'should be v3.7.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n\n    name: Install Custom chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n      with:\n        version: 'v3.5.1'\n        yamllint_version: '1.27.1'\n        yamale_version: '3.0.4'\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.5.1' ]]; then\n          echo 'should be v3.5.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n```", "prompt": "Generate a GitHub Workflow named `test-chart-testing-action` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Install chart-testing and test presence in path` and its job id is `test_ct_action`. The job `test_ct_action` has 4 steps. The 1st step is named ``. The 2nd step is named `Install chart-testing`. The 3rd step is named `Check install!`. The 4th step is named `Check root directory`. The 2nd job is named `Install Custom chart-testing and test presence in path` and its job id is `test_ct_action_custom`. The job `test_ct_action_custom` has 4 steps. The 1st step is named ``. The 2nd step is named `Install chart-testing`. The 3rd step is named `Check install!`. The 4th step is named `Check root directory`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, ./, v3 version of actions/checkout and ./. "}
{"id": "63c494fc8052faa2781aead3", "level": "level3", "llm_response": "```yaml\nname: Update Release List\n\non:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [completed]\n    branches: [master]\n\npermissions:\n  contents: write\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n\n    - name: Update Release List\n      run: |\n        # Add your release list update script here\n        echo \"Updating release list for repository: ${{ github.repository }}\"\n```", "answer": "```yaml name: Update Release List\n\non:\n  #release:\n  #  types: [published]\n  workflow_run:\n    workflows: [\"Build\"]\n    branches: [master]\n    types: [completed]\n\npermissions:\n  contents: write # to update wiki\n\nenv:\n  # Account for committing\n  USER_NAME: \"ctags-win32 CI\"\n  USER_EMAIL: \"ctags-win32-ci@users.noreply.github.com\"\n\n  # Escape sequences\n  COL_RED: \"\\x1b[31m\"\n  COL_GREEN: \"\\x1b[32m\"\n  COL_YELLOW: \"\\x1b[33m\"\n  COL_RESET: \"\\x1b[m\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        path: main\n\n    - uses: actions/checkout@v3\n      with:\n        repository: \"${{ github.repository }}.wiki\"\n        path: wiki\n\n    - name: Update Release List\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      run: |\n        cd main\n        latest=$(cat ctagsver.txt)\n        cd ../wiki\n        ../main/scripts/update-release-list.py\n        git add Releases-in-*.md\n        if git diff HEAD --quiet; then\n          echo ${COL_YELLOW}No updates.${COL_RESET}\n        else\n          git config --local user.name ${USER_NAME}\n          git config --local user.email ${USER_EMAIL}\n          git commit -a -m \"Update Release List to ${latest}\"\n          git push origin HEAD\n        fi\n```", "prompt": "Generate a GitHub Workflow named `Update Release List` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the workflow named Build is completed on a branch whose name matches master. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `update`. The job `update` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Update Release List`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/checkout. Here are some variables that might be used in the workflow: github.repository and secrets.GITHUB_TOKEN. "}
{"id": "63c4969c1899db58864d4153", "level": "level3", "llm_response": "```yaml\nname: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: 'nightly-${{ github.ref }}'\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    id: backend-tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run backend tests\n        run: |\n          # Add your backend tests commands here\n\n  frontend-tests:\n    id: frontend-tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run frontend and end-to-end tests\n        run: |\n          # Add your frontend and end-to-end tests commands here\n\n  build-release:\n    id: build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Build tagged release\n        run: |\n          # Add your build tagged release commands here\n\n  notify-discord:\n    id: notify-discord\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        uses: Ilshidur/action-discord@0.3.2\n        with:\n          webhook: ${{ secrets.DISCORD_NIGHTLY_WEBHOOK }}\n          content: \"Deployment completed successfully!\"\n\n  deploy-demo:\n    id: deploy-demo\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clean and Deploy Demo\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.DEMO_SERVER_IP }}\n          username: ${{ secrets.DEMO_SERVER_USER }}\n          key: ${{ secrets.DEMO_SERVER_SSH_KEY }}\n          port: ${{ secrets.DEMO_SERVER_PORT }}\n          script: |\n            # Add your deploy demo commands here\n```", "answer": "```yaml name: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    name: \"Backend Server Tests\"\n    uses: ./.github/workflows/partial-backend.yml\n\n  frontend-tests:\n    name: \"Frontend and End-to-End Tests\"\n    uses: ./.github/workflows/partial-frontend.yml\n\n  build-release:\n    name: Build Tagged Release\n    uses: ./.github/workflows/partial-builder.yml\n    needs:\n      - frontend-tests\n      - backend-tests\n    with:\n      tag: nightly\n    secrets:\n      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}\n      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}\n\n  notify-discord:\n    name: Notify Discord\n    needs:\n      - build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        env:\n          DISCORD_WEBHOOK: ${{ secrets.DISCORD_NIGHTLY_WEBHOOK }}\n        uses: Ilshidur/action-discord@0.3.2\n        with:\n          args: \"\ud83d\ude80  A New build of mealie:api-nightly and mealie:frontend-nightly is available\"\n\n  deploy-demo:\n    runs-on: ubuntu-latest\n    name: Deploy Demo\n    needs:\n      - build-release\n    steps:\n      - name: Clean and Deploy Demo\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.DEMO_SERVER_IP }}\n          username: ${{ secrets.DEMO_SERVER_USER }}\n          key: ${{ secrets.DEMO_SERVER_SSH_KEY }}\n          port: ${{ secrets.DEMO_SERVER_PORT }}\n          script_stop: true\n          script: |\n            cd ~/docker/mealie-next\n            docker-compose pull\n            docker-compose down -v\n            docker-compose up -d\n```", "prompt": "Generate a GitHub Workflow named `Docker Nightly Production` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named mealie-next. Only a single workflow using the nightly-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 5 jobs. The 1st job is named `Backend Server Tests` and its job id is `backend-tests`. The 2nd job is named `Frontend and End-to-End Tests` and its job id is `frontend-tests`. The 3rd job is named `Build Tagged Release` and its job id is `build-release`. The 4th job is named `Notify Discord` and its job id is `notify-discord`. The job `notify-discord` has one step. The 1st step is named `Discord notification`. The 5th job is named `Deploy Demo` and its job id is `deploy-demo`. The job `deploy-demo` has one step. The 1st step is named `Clean and Deploy Demo`. Here are some Github Actions that might be used in the workflow: 0.3.2 version of Ilshidur/action-discord and master version of appleboy/ssh-action. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/partial-backend.yml'}, {'version': None, 'name': './.github/workflows/partial-frontend.yml'} and {'version': None, 'name': './.github/workflows/partial-builder.yml'}. Here are some variables that might be used in the workflow: secrets.DISCORD_NIGHTLY_WEBHOOK, secrets.DEMO_SERVER_IP, secrets.DEMO_SERVER_USER, secrets.DEMO_SERVER_SSH_KEY and secrets.DEMO_SERVER_PORT. "}
{"id": "63c494037843b612699fe649", "level": "level3", "llm_response": "```yaml\nname: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version'\n        required: true\n      tag:\n        description: 'Tag'\n        required: true\n        default: 'latest'\n\npermissions:\n  contents: write\n  packages: write\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Setup Node\n      uses: actions/setup-node@v3\n      with:\n        node-version: '14'\n\n    - name: Update tag\n      run: |\n        echo \"##[set-output name=tag;value=${{ github.event.inputs.tag }}]\"\n        echo \"##[set-output name=version;value=${{ github.event.inputs.version }}]\"\n        git tag ${{ github.event.inputs.tag }}\n        git push origin ${{ github.event.inputs.tag }}\n```", "answer": "```yaml name: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: Version\n        required: true\n      tag:\n        description: Tag\n        default: latest\n        required: true\n\npermissions: {}\njobs:\n  build:\n    name: Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}\n    environment: release\n    runs-on: ubuntu-latest\n    steps:\n    - name: Setup Node\n      uses: actions/setup-node@v3\n    - name: Update tag\n      env:\n        \"npm_config_//registry.npmjs.org/:_authToken\": ${{ secrets.NPM_TOKEN }}\n      run: |\n        npm dist-tag add pnpm@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n        npm dist-tag add @pnpm/exe@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n```", "prompt": "Generate a GitHub Workflow named `Tag` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives 2 inputs: version-this input represents version and it must be supplied; tag-this input represents tag, its default value is latest and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: the workflow disables permissions for the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}` and its job id is `build`. The job `build` has 2 steps. The 1st step is named `Setup Node`. The 2nd step is named `Update tag`. Here are some Github Actions that might be used in the workflow: v3 version of actions/setup-node. Here are some variables that might be used in the workflow: secrets.NPM_TOKEN, github.event.inputs.version and github.event.inputs.tag. "}
{"id": "63c4949a8052faa2781ac0b0", "level": "level3", "llm_response": "```yaml\nname: Node.js CI\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ${{ matrix.os }}\n\n    strategy:\n      matrix:\n        node-version: [14, 16, 18]\n        os: [ubuntu-latest, windows-latest, macos-latest]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n          cache: pnpm\n\n      - name: Cache pnpm modules\n        uses: actions/cache@v3\n        with:\n          path: ~/.pnpm-store\n          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/package-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-pnpm-\n\n      - name: Install dependencies\n        run: pnpm install\n\n      - name: Run tests\n        run: pnpm test\n\n      - name: Build project\n        run: pnpm build\n```", "answer": "```yaml # This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Node.js CI\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: Cache pnpm modules\n        uses: actions/cache@v3\n        env:\n          cache-name: cache-pnpm-modules\n        with:\n          path: ~/.pnpm-store\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n      - uses: actions/cache@v3\n        with:\n          path: |\n            ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}\n          restore-keys: |\n            ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-\n      - uses: pnpm/action-setup@v2.2.4\n        with:\n          version: 7.x.x\n          run_install: true\n      - name: Build project\n        run: |\n          yarn build\n          yarn lint\n        env:\n          CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node.js CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named `Use Node.js ${{ matrix.node-version }}`. The 3rd step is named `Cache pnpm modules`. The 4th step is named ``. The 5th step is named ``. The 6th step is named `Build project`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-node, v3 version of actions/cache, v3 version of actions/cache and v2.2.4 version of pnpm/action-setup. Here are some variables that might be used in the workflow: matrix.node-version, runner.os, env.cache-name and github.workspace. "}
{"id": "63c4967e1899db58864d33dd", "level": "level3", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    id: lint-commit-message\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Commit Message\n        run: echo \"Commit message step\"\n      - name: File names\n        run: echo \"File names step\"\n      - name: Functions\n        run: echo \"Functions step\"\n      - name: Logging messages should not have trailing newlines\n        run: echo \"Logging messages step\"\n\n  lint-go:\n    id: lint-go\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: golangci-lint\n        uses: golangci/golangci-lint-action@v3\n```", "answer": "```yaml #\n# DO NOT EDIT THIS FILE\n#\n# It is automatically copied from https://github.com/pion/.goassets repository.\n# If this repository should have package specific CI config,\n# remove the repository name from .goassets/.github/workflows/assets-sync.yml.\n#\n# If you want to update the shared CI config, send a PR to\n# https://github.com/pion/.goassets instead of this repository.\n#\n\nname: Lint\non:\n  pull_request:\n    types:\n      - opened\n      - edited\n      - synchronize\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    name: Metadata\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n        - uses: actions/checkout@v3\n          with:\n            fetch-depth: 0\n\n        - name: Commit Message\n          run: .github/lint-commit-message.sh\n\n        - name: File names\n          run: .github/lint-filename.sh\n\n        - name: Functions\n          run: .github/lint-disallowed-functions-in-library.sh\n\n        - name: Logging messages should not have trailing newlines\n          run: .github/lint-no-trailing-newline-in-log-messages.sh\n\n  lint-go:\n    name: Go\n    permissions:\n      contents: read\n      pull-requests: read\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: golangci-lint\n        uses: golangci/golangci-lint-action@v3\n        with:\n          version: v1.45.2\n          args: $GOLANGCI_LINT_EXRA_ARGS\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created, the title or body of a pull request is edited or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `Metadata` and its job id is `lint-commit-message`. The job `lint-commit-message` has 5 steps. The 1st step is named ``. The 2nd step is named `Commit Message`. The 3rd step is named `File names`. The 4th step is named `Functions`. The 5th step is named `Logging messages should not have trailing newlines`. The 2nd job is named `Go` and its job id is `lint-go`. The job `lint-go` has 2 steps. The 1st step is named ``. The 2nd step is named `golangci-lint`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/checkout and v3 version of golangci/golangci-lint-action. "}
{"id": "63c4947b8052faa2781ab631", "level": "level3", "llm_response": "```yaml\nname: Publish Test Results\n\non:\n  workflow_run:\n    workflows: [CI]\n    types: [completed]\n\njobs:\n  test-results:\n    id: test-results\n    runs-on: ubuntu-latest\n    steps:\n      - name: Download and Extract Artifacts\n        id: download-artifacts\n        run: |\n          wget -O artifacts.zip ${{ github.event.workflow_run.artifacts_url }}\n          unzip artifacts.zip\n      - name: Publish Test Results\n        uses: EnricoMi/publish-unit-test-result-action@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          report_paths: 'target/surefire-reports/*.xml'\n          commit_sha: ${{ github.event.workflow_run.head_sha }}\n          workflow_run_id: ${{ github.event.workflow_run.id }}\n          workflow_name: ${{ github.event.workflow_run.event }}\n```", "answer": "```yaml # Publishing of unit test results has to be a separate workflow in order to support forked PRs\n# See https://github.com/EnricoMi/publish-unit-test-result-action#support-fork-repositories-and-dependabot-branches\nname: Publish Test Results\non:\n  workflow_run:\n    workflows: [CI]\n    types:\n      - completed\njobs:\n  test-results:\n    name: Test Results\n    runs-on: ubuntu-latest\n    if: github.event.workflow_run.conclusion != 'skipped'\n\n    steps:\n      - name: Download and Extract Artifacts\n        env:\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n        run: |\n          mkdir -p artifacts && cd artifacts\n\n          artifacts_url=${{ github.event.workflow_run.artifacts_url }}\n\n          gh api \"$artifacts_url\" -q '.artifacts[] | [.name, .archive_download_url] | @tsv' | while read artifact\n          do\n            IFS=$'\\t' read name url <<< \"$artifact\"\n            gh api $url > \"$name.zip\"\n            unzip -d \"$name\" \"$name.zip\"\n          done\n\n      - name: Publish Test Results\n        uses: EnricoMi/publish-unit-test-result-action@v2\n        with:\n          commit: ${{ github.event.workflow_run.head_sha }}\n          event_file: artifacts/Event File/event.json\n          event_name: ${{ github.event.workflow_run.event }}\n          junit_files: |\n            artifacts/**/surefire-reports/*.xml\n            artifacts/**/failsafe-reports/TEST-*.xml\n```", "prompt": "Generate a GitHub Workflow named `Publish Test Results` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: the workflow named CI is completed. The workflow has one job. The 1st job is named `Test Results` and its job id is `test-results`. The job `test-results` has 2 steps. The 1st step is named `Download and Extract Artifacts`. The 2nd step is named `Publish Test Results`. Here are some Github Actions that might be used in the workflow: v2 version of EnricoMi/publish-unit-test-result-action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN, github.event.workflow_run.artifacts_url, github.event.workflow_run.head_sha and github.event.workflow_run.event. "}
{"id": "63c4964a1e33648075779a84", "level": "level3", "llm_response": "```yaml\nname: Publish Terminal.Gui\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  publish:\n    id: publish\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Install and calculate the new version with GitVersion\n        uses: gittools/actions/gitversion/setup@v0.9.13\n\n      - name: Determine Version\n        id: gitversion\n        uses: gittools/actions/gitversion/execute@v0.9.13\n\n      - name: Display GitVersion outputs\n        run: echo \"Version: ${{ steps.gitversion.outputs.SemVer }}\"\n\n      - name: Setup dotnet\n        uses: actions/setup-dotnet@v3.0.1\n        with:\n          dotnet-version: '6.0'\n\n      - name: Install dependencies\n        run: dotnet restore\n\n      - name: Build Release\n        run: dotnet build --configuration Release\n\n      - name: Pack\n        run: dotnet pack --configuration Release --no-build\n\n      - name: Test to generate Code Coverage Report\n        run: dotnet test --configuration Release --collect \"XPlat Code Coverage\" --logger \"console;includeTestAdapterResults=true\"\n\n      - name: Create Test Coverage Badge\n        id: create_coverage_badge\n        uses: simon-k/dotnet-code-coverage-badge@v1.0.0\n        with:\n          coverage: ${{ steps.create_coverage_badge.outputs.percentage }}\n          output: ${{ steps.create_coverage_badge.outputs.badge }}\n\n      - name: Print Code Coverage\n        run: echo \"Code Coverage: ${{ steps.create_coverage_badge.outputs.percentage }}%\"\n\n      - name: Publish to NuGet.org\n        run: dotnet nuget push **/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json\n```", "answer": "```yaml name: Publish Terminal.Gui\non:\n  push:\n    tags:\n      - v*\n\njobs:\n\n  publish:\n    name: Build and Publish to Nuget.org\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0 #fetch-depth is needed for GitVersion\n\n    - name: Install and calculate the new version with GitVersion \n      uses: gittools/actions/gitversion/setup@v0.9.13\n      with:\n        versionSpec: 5.x\n\n    - name: Determine Version\n      uses: gittools/actions/gitversion/execute@v0.9.13\n      id: gitversion # step id used as reference for output values\n\n    - name: Display GitVersion outputs\n      run: |\n        echo \"Version: ${{ steps.gitversion.outputs.SemVer }}\"\n        echo \"CommitsSinceVersionSource: ${{ steps.gitversion.outputs.CommitsSinceVersionSource }}\"\n\n    - name: Setup dotnet\n      uses: actions/setup-dotnet@v3.0.1\n      with:\n        dotnet-version: 6.0.100\n\n    - name: Install dependencies\n      run: dotnet restore\n\n    - name: Build Release\n      run: |\n        dotnet-gitversion /updateprojectfiles\n        dotnet build --no-restore -c Release\n\n    - name: Pack\n      run: dotnet pack -c Release --include-symbols -p:Version='${{ steps.gitversion.outputs.SemVer }}' \n\n    - name: Test to generate Code Coverage Report\n      run: |\n        dotnet test --verbosity normal --collect:\"XPlat Code Coverage\" --settings UnitTests/coverlet.runsettings\n        mv -v UnitTests/TestResults/*/*.* UnitTests/TestResults/\n\n    - name: Create Test Coverage Badge\n      uses: simon-k/dotnet-code-coverage-badge@v1.0.0\n      id: create_coverage_badge\n      with:\n        label: Unit Test Coverage\n        color: brightgreen\n        path: UnitTests/TestResults/coverage.opencover.xml\n        gist-filename: code-coverage.json\n        # https://gist.github.com/migueldeicaza/90ef67a684cb71db1817921a970f8d27\n        gist-id: 90ef67a684cb71db1817921a970f8d27\n        gist-auth-token: ${{ secrets.GIST_AUTH_TOKEN }}   \n\n    - name: Print Code Coverage\n      run: |\n        echo \"Code coverage percentage: ${{steps.create_coverage_badge.outputs.percentage}}%\"\n        echo \"Badge data: ${{steps.create_coverage_badge.outputs.badge}}\"\n        \n    #- name: Prep GitHub Packages\n    #  run: dotnet nuget add source --username tig --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/tig/index.json\"\n\n    #- name: Publish to GitHub packages \n    #  run: dotnet nuget push NStack/bin/Release/*.nupkg --api-key ${{ secrets.GITHUB_TOKEN }}  --source \"github\"\n\n    - name: Publish to NuGet.org\n      run: dotnet nuget push Terminal.Gui/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json\n```", "prompt": "Generate a GitHub Workflow named `Publish Terminal.Gui` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Build and Publish to Nuget.org` and its job id is `publish`. The job `publish` has 12 steps. The 1st step is named ``. The 2nd step is named `Install and calculate the new version with GitVersion`. The 3rd step is named `Determine Version` and its id is `gitversion`. The 4th step is named `Display GitVersion outputs`. The 5th step is named `Setup dotnet`. The 6th step is named `Install dependencies`. The 7th step is named `Build Release`. The 8th step is named `Pack`. The 9th step is named `Test to generate Code Coverage Report`. The 10th step is named `Create Test Coverage Badge` and its id is `create_coverage_badge`. The 11th step is named `Print Code Coverage`. The 12th step is named `Publish to NuGet.org`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v0.9.13 version of gittools/actions/gitversion/setup, v0.9.13 version of gittools/actions/gitversion/execute, v3.0.1 version of actions/setup-dotnet and v1.0.0 version of simon-k/dotnet-code-coverage-badge. Here are some variables that might be used in the workflow: steps.gitversion.outputs.SemVer, steps.gitversion.outputs.CommitsSinceVersionSource, secrets.GIST_AUTH_TOKEN, steps.create_coverage_badge.outputs.percentage, steps.create_coverage_badge.outputs.badge and secrets.NUGET_API_KEY. "}
{"id": "63c4950a7843b61269a0501c", "level": "level3", "llm_response": "```yaml\nname: Integration test on schedule (minimal)\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false\n\njobs:\n  start-integration-test-minimal:\n    id: start-integration-test-minimal\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run integration test\n        run: |\n          # Add your integration test commands here\n          echo \"Running integration test...\"\n```", "answer": "```yaml name: Integration test on schedule (minimal)\nconcurrency: ${{ github.workflow }}-${{ github.ref }}\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  start-integration-test-minimal:\n    name: Start integration test (minimal)\n    uses: ./.github/workflows/integration.yml\n    secrets: inherit\n    with:\n      install_profile: minimal\n      cluster_region: ams3\n      kubernetes_versions: \"['1.22', '1.23']\"\n```", "prompt": "Generate a GitHub Workflow named `Integration test on schedule (minimal)` for a GitHub repository whose primary programming language is Mustache. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Start integration test (minimal)` and its job id is `start-integration-test-minimal`. Here are some reusable workflows that might be used in the workflow: {'version': None, 'name': './.github/workflows/integration.yml'}. "}
{"id": "63c494b08052faa2781aca76", "level": "level3", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@cc7986c02bac29104a72998e67239bb5ee2ee110\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@cc7986c02bac29104a72998e67239bb5ee2ee110\n```", "answer": "```yaml name: 'CodeQL'\n\non:\n  push:\n    branches: [master]\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: macos-11\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: ['cpp']\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n        with:\n          languages: ${{ matrix.language }}\n\n      - run: >-\n          env NSUnbufferedIO=YES\n          xcodebuild\n          -workspace Sentry.xcworkspace\n          -scheme Sentry\n          -configuration Release\n          -destination platform=\"iOS Simulator,OS=latest,name=iPhone 11 Pro\"\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 04:40 am, only on saturday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named ``. The 4th step is named `Perform CodeQL Analysis`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, cc7986c02bac29104a72998e67239bb5ee2ee110 version of github/codeql-action/init and cc7986c02bac29104a72998e67239bb5ee2ee110 version of github/codeql-action/analyze. Here are some variables that might be used in the workflow: matrix.language. "}
{"id": "63c496891e3364807577b43d", "level": "level3", "llm_response": "```yaml\nname: Check Actions rate limit\n\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check rate limit\n        run: |\n          curl -s -H \"Authorization: token ${{ github.token }}\" https://api.github.com/rate_limit\n```", "answer": "```yaml name: Check Actions rate limit\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    name: Check Actions rate limit\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check rate limit\n        env:\n          TOKEN: ${{ github.token }}\n        run: |\n          curl -v --no-progress-meter --header \"Authorization: Bearer $TOKEN\" https://api.github.com/rate_limit\n```", "prompt": "Generate a GitHub Workflow named `Check Actions rate limit` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Check Actions rate limit` and its job id is `check`. The job `check` has one step. The 1st step is named `Check rate limit`. Here are some variables that might be used in the workflow: github.token. "}
{"id": "63c4969e1899db58864d41ee", "level": "level3", "llm_response": "```yaml\nname: Auto message on Creating Issue\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Create comment for issue\n        uses: peter-evans/create-or-update-comment@v1\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          comment: \"Hello @${{ github.actor }}! Thank you for opening this issue.\"\n```", "answer": "```yaml name: Auto message on Creating Issue.\n\non:\n\n  issues:\n\n    types: [opened]\n\njobs:\n\n  greeting:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - name: Create comment for issue\n\n      if: github.event_name =='issues' \n\n      uses: peter-evans/create-or-update-comment@v1\n\n      with:\n\n        issue-number: ${{tojson(github.event.issue.number)}}\n\n        body: |\n\n            Hi \ud83d\ude04, @${{ github.actor }} Thanks for creating an issue at FunwithPhysics. We request you to follow the contributing guidelines. \n```", "prompt": "Generate a GitHub Workflow named `Auto message on Creating Issue.` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `greeting`. The job `greeting` has one step. The 1st step is named `Create comment for issue`. Here are some Github Actions that might be used in the workflow: v1 version of peter-evans/create-or-update-comment. Here are some variables that might be used in the workflow: github.event.issue.number and github.actor. "}
{"id": "63c496941899db58864d3d85", "level": "level3", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Release Please\n        uses: GoogleCloudPlatform/release-please-action@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: release-please\non:\n   push:\n      branches:\n         - master\njobs:\n   release-please:\n      runs-on: ubuntu-latest\n      steps:\n         - uses: GoogleCloudPlatform/release-please-action@v2\n           with:\n            token: ${{ secrets.GITHUB_TOKEN }}\n            release-type: simple\n            version-file: \"./version.txt\"\n            package-name: release-please-action\n            default-branch: master\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is Swift. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. The job `release-please` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v2 version of GoogleCloudPlatform/release-please-action. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c496486fc19abdf9c9b0d5", "level": "level3", "llm_response": "```yaml\nname: Dependencies\n\non:\n  schedule:\n    - cron: '0 12 * * 1'\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    id: upgrade\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Set up pnpm\n        uses: pnpm/action-setup@v2\n        with:\n          version: 6\n\n      - name: Install dependencies\n        run: pnpm install\n\n      - name: Upgrade dependencies\n        run: pnpm update\n\n      - name: Commit and push changes\n        uses: EndBug/add-and-commit@v9\n        with:\n          message: 'chore: upgrade dependencies'\n          files: 'package.json package-lock.json'\n          github_token: ${{ secrets.NPM_GITHUB_TOKEN }}\n```", "answer": "```yaml name: Dependencies\n\non:\n  schedule:\n    - cron: \"0 12 * * 1\"\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    name: Upgrade dependencies\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2\n        with:\n          version: latest\n      - uses: actions/setup-node@v3\n        with:\n          cache: \"pnpm\"\n          node-version-file: \".nvmrc\"\n          registry-url: \"https://npm.pkg.github.com\"\n      - run: rm -rf pnpm-lock.yaml **/node_modules/\n      - run: pnpm install\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_GITHUB_TOKEN }}\n      - uses: EndBug/add-and-commit@v9\n        with:\n          message: \"chore(deps): upgrade versions\"\n```", "prompt": "Generate a GitHub Workflow named `Dependencies` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 pm, only on monday. 2) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Upgrade dependencies` and its job id is `upgrade`. The job `upgrade` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of pnpm/action-setup, v3 version of actions/setup-node and v9 version of EndBug/add-and-commit. Here are some variables that might be used in the workflow: secrets.NPM_GITHUB_TOKEN. "}
{"id": "63c4954d8052faa2781b0e83", "level": "level3", "llm_response": "```yaml\nname: xgo\n\non:\n  push:\n    branches:\n      - master\n    tags:\n      - v*\n    paths-ignore:\n      - '**.md'\n  pull_request:\n    branches:\n      - master\n    paths-ignore:\n      - '**.md'\n\nconcurrency:\n  group: 'xgo-${{ github.ref }}'\n  cancel-in-progress: true\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Build artifacts\n        uses: docker/bake-action@v2\n        with:\n          file: ./docker-compose.yml\n\n      - name: Move artifacts\n        run: |\n          mkdir -p ./artifacts\n          mv *.tar.gz ./artifacts/\n\n      - name: Upload artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: build-artifacts\n          path: ./artifacts/\n\n      - name: GitHub Release\n        uses: softprops/action-gh-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          files: ./artifacts/*.tar.gz\n```", "answer": "```yaml name: xgo\n\nconcurrency:\n  group: xgo-${{ github.ref }}\n  cancel-in-progress: true\n\non:\n  push:\n    branches:\n      - 'master'\n    tags:\n      - 'v*'\n    paths-ignore:\n      - '**.md'\n  pull_request:\n    branches:\n      - 'master'\n    paths-ignore:\n      - '**.md'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n      -\n        name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      -\n        name: Build artifacts\n        uses: docker/bake-action@v2\n        with:\n          targets: artifact-all\n      -\n        name: Move artifacts\n        run: |\n          mv ./dist/**/* ./dist/\n      -\n        name: Upload artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: xgo\n          path: ./dist/*\n          if-no-files-found: error\n      -\n        name: GitHub Release\n        uses: softprops/action-gh-release@v1\n        if: startsWith(github.ref, 'refs/tags/v')\n        with:\n          draft: true\n          files: |\n            dist/*.tar.gz\n            dist/*.zip\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `xgo` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a tag whose name matches v*. When all the path names of push event match patterns in the paths-ignore filter(**.md), the workflow will not run. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. When all the path names of pull_request event match patterns in the paths-ignore filter(**.md), the workflow will not run. Only a single workflow using the xgo-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Docker Buildx`. The 3rd step is named `Build artifacts`. The 4th step is named `Move artifacts`. The 5th step is named `Upload artifacts`. The 6th step is named `GitHub Release`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v2 version of docker/setup-buildx-action, v2 version of docker/bake-action, v3 version of actions/upload-artifact and v1 version of softprops/action-gh-release. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c494a48052faa2781ac54e", "level": "level3", "llm_response": "```yaml\nname: lint\n\non:\n  pull_request:\n    branches:\n      - main\n    paths-ignore:\n      - 'docs/**'\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - 'docs/**'\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Run cspell\n        run: cspell \"**\"\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Install dependencies\n        run: npm install\n      - name: Run lint\n        run: npm run lint\n```", "answer": "```yaml name: lint\non: # rebuild any PRs and main branch changes\n  pull_request:\n    paths-ignore:\n      - \"docs/**\"\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - \"docs/**\"\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx cspell \"**\" --dot --no-progress\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: yarn\n      - run: yarn lint\n```", "prompt": "Generate a GitHub Workflow named `lint` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) When all the path names of pull_request event match patterns in the paths-ignore filter(docs/**), the workflow will not run. 2) The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**), the workflow will not run. The workflow has 2 jobs. The job id of the 1st job is `cspell`. The job `cspell` has 2 steps. The 1st step is named ``. The 2nd step is named ``. The job id of the 2nd job is `lint`. The job `lint` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/checkout. "}
{"id": "63c4957d8052faa2781b229c", "level": "level3", "llm_response": "```yaml\nname: Build site nightly\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  dot-release:\n    id: dot-release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: curl\n        uses: wei/curl@v1\n        with:\n          url: ${{ secrets.NETLIFY_BUILD_HOOK }}\n```", "answer": "```yaml # Copyright 2022 The Knative Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nname: Build site nightly\n\non:\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  dot-release:\n    name: dot-release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: curl\n        env:\n          NETLIFY_BUILD_HOOK: ${{ secrets.NETLIFY_BUILD_HOOK }}\n        uses: wei/curl@v1\n        with:\n          args: -X POST -d '{}' \"$NETLIFY_BUILD_HOOK\"\n```", "prompt": "Generate a GitHub Workflow named `Build site nightly` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `dot-release` and its job id is `dot-release`. The job `dot-release` has one step. The 1st step is named `curl`. Here are some Github Actions that might be used in the workflow: v1 version of wei/curl. Here are some variables that might be used in the workflow: secrets.NETLIFY_BUILD_HOOK. "}
{"id": "63c496891e3364807577b43a", "level": "level3", "llm_response": "```yaml\nname: Jetpack block performance\n\non:\n  schedule:\n    - cron: '0 */12 * * *'\n\njobs:\n  block-performance:\n    runs-on: ${{ runner.os }}\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n      - name: Cache dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n      - name: Build Gutenberg\n        run: npm run build:gutenberg\n      - name: Setup tools for Jetpack\n        run: ./.github/actions/tool-setup\n      - name: Build Production Jetpack\n        run: npm run build:production\n      - name: Environment set-up\n        run: ./.github/actions/setup-env\n      - name: Run performance tests\n        run: npm run test:performance\n      - name: Environment tear-down\n        run: ./.github/actions/teardown-env\n      - name: Upload test artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-results\n          path: test-results\n\n  test-reports:\n    runs-on: ${{ runner.os }}\n    steps:\n      - name: Repository Dispatch\n        uses: peter-evans/repository-dispatch@v2\n        with:\n          token: ${{ secrets.E2E_TEST_REPORTS_TOKEN }}\n          repository: ${{ github.repository }}\n          event-type: performance-tests\n\n  slack-notification:\n    runs-on: ${{ runner.os }}\n    steps:\n      - name: Set up tools\n        run: ./.github/actions/setup-tools\n      - name: Build action\n        run: ./.github/actions/build-action\n      - name: Send notification\n        run: ./projects/github-actions/test-results-to-slack\n        env:\n          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}\n          SLACK_CHANNEL: ${{ secrets.SLACK_E2E_CHANNEL }}\n          RUN_ID: ${{ github.run_id }}\n          REPOSITORY: ${{ github.repository }}\n```", "answer": "```yaml name: Jetpack block performance\n\non:\n  schedule:\n    - cron:  '0 */12 * * *'\n\njobs:\n  block-performance:\n    name: \"Performance tests\"\n    runs-on: ubuntu-latest\n    timeout-minutes: 50  # 2021-12-13: Successful runs seem to take 40 minutes\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n\n      - uses: actions/checkout@v3\n        with:\n          repository: 'WordPress/gutenberg'\n          path: 'gutenberg'\n\n      - name: Build Gutenberg\n        working-directory: gutenberg\n        run: |\n          npm ci\n          npm run build\n\n      - uses: actions/cache@v3\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('gutenberg/**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - name: Setup tools for J\n        uses: ./.github/actions/tool-setup\n\n      - name: Build Production Jetpack\n        run: |\n          pnpm install\n          pnpm jetpack build plugins/jetpack -v --production\n\n      - name: Environment set-up\n        working-directory: tools/e2e-commons\n        env:\n          CONFIG_KEY: ${{ secrets.E2E_CONFIG_KEY }}\n        run: |\n          # Gutenberg Performance tests require disable-animations.php test plugin to be available on a site. Below we inject the mapping for that plugin into a Docker config file\n\n          echo \"e2e:\" >> ../docker/jetpack-docker-config.yml\n          echo \"  volumeMappings:\" >> ../docker/jetpack-docker-config.yml\n          echo \"    gutenberg/packages/e2e-tests/plugins/disable-animations.php: /var/www/html/wp-content/plugins/disable-animations.php\" >> ../docker/jetpack-docker-config.yml\n\n          mkdir results\n          pnpm config:decrypt\n          pnpm env:start\n\n      - name: Run performance tests\n        working-directory: tools/e2e-commons\n        run: |\n          node ./bin/performance.js\n\n      - name: Environment tear-down\n        if: ${{ always() }}\n        working-directory: tools/e2e-commons\n        continue-on-error: true\n        run: |\n          pnpm run tunnel:off\n          # Update permissions to workaround https://github.com/actions/cache/issues/753\n          sudo chown -R runner:docker \"$GITHUB_WORKSPACE/tools/docker\"\n\n      - name: Upload test artifacts\n        if: ${{ always() }}\n        continue-on-error: true\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-output-block-perf\n          path: tools/e2e-commons/results\n\n  test-reports:\n    name: \"Trigger test report workflow\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: block-performance\n\n    steps:\n      - name: Repository Dispatch\n        uses: peter-evans/repository-dispatch@v2\n        with:\n          token: ${{ secrets.E2E_TEST_REPORTS_TOKEN }}\n          repository: automattic/jetpack-e2e-reports\n          event-type: block-perf\n          client-payload: '{\"run_id\": \"${{github.run_id}}\", \"repository\": \"${{github.repository}}\"}'\n\n  slack-notification:\n    name: \"Slack notification\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: [block-performance]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up tools\n        uses: ./.github/actions/tool-setup\n\n      - name: Build action\n        env:\n          COMPOSER_ROOT_VERSION: dev-trunk\n        run: |\n          pnpm install\n          composer install\n          composer build-development\n        working-directory: ./projects/github-actions/test-results-to-slack\n\n      - name: \"Send notification\"\n        uses: ./projects/github-actions/test-results-to-slack\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          slack_token: ${{ secrets.SLACK_TOKEN }}\n          slack_channel: ${{ secrets.SLACK_E2E_CHANNEL }}\n          slack_icon_emoji: \":jetpack:\"\n          suite_name: \"blocks performance\"\n```", "prompt": "Generate a GitHub Workflow named `Jetpack block performance` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: the scheduled time has come: every 12 hours. The workflow has 3 jobs. The 1st job is named `Performance tests` and its job id is `block-performance`. The job `block-performance` has 11 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Build Gutenberg`. The 5th step is named ``. The 6th step is named `Setup tools for J`. The 7th step is named `Build Production Jetpack`. The 8th step is named `Environment set-up`. The 9th step is named `Run performance tests`. The 10th step is named `Environment tear-down`. The 11th step is named `Upload test artifacts`. The 2nd job is named `Trigger test report workflow` and its job id is `test-reports`. The job `test-reports` has one step. The 1st step is named `Repository Dispatch`. The 3rd job is named `Slack notification` and its job id is `slack-notification`. The job `slack-notification` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up tools`. The 3rd step is named `Build action`. The 4th step is named `Send notification`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/setup-node, v3 version of actions/checkout, v3 version of actions/cache, ./.github/actions/tool-setup, v3 version of actions/upload-artifact, v2 version of peter-evans/repository-dispatch, v3 version of actions/checkout, ./.github/actions/tool-setup and ./projects/github-actions/test-results-to-slack. Here are some variables that might be used in the workflow: runner.os, secrets.E2E_CONFIG_KEY, secrets.E2E_TEST_REPORTS_TOKEN, github.run_id, github.repository, secrets.GITHUB_TOKEN, secrets.SLACK_TOKEN and secrets.SLACK_E2E_CHANNEL. "}
{"id": "63c4968633b087f6bde2c8ea", "level": "level3", "llm_response": "```yaml\nname: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - '[0-9]+.[0-9]+.[0-9]+'\n      - '[0-9]+.[0-9]+.[0-9]+rc[0-9]+'\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment: [py36, py37, py38, py39]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install tox\n        run: pip install tox\n      - name: Run tox\n        run: tox -e ${{ matrix.environment }}\n```", "answer": "```yaml name: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - \"[0-9]+.[0-9]+.[0-9]+\"\n      - \"[0-9]+.[0-9]+.[0-9]+rc[0-9]+\"\n\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment:\n          - \"py36\"\n          - \"py37\"\n          - \"flake8\"\n\n        include:\n          - environment: \"py36\"\n            python: \"3.6\"\n          - environment: \"py37\"\n            python: \"3.7\"\n          - environment: \"flake8\"\n            python: \"3.7\"\n\n    container:\n      image: python:${{ matrix.python }}\n\n    steps:\n      - uses: actions/checkout@master\n      - name: Install tox\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install tox\n      - name: Run tox\n        run: |\n          tox -e ${{ matrix.environment }}\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a tag whose name matches [0-9]+.[0-9]+.[0-9]+ or a tag whose name matches [0-9]+.[0-9]+.[0-9]+rc[0-9]+. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `tox`. The job `tox` has 3 steps. The 1st step is named ``. The 2nd step is named `Install tox`. The 3rd step is named `Run tox`. Here are some Github Actions that might be used in the workflow: master version of actions/checkout. Here are some variables that might be used in the workflow: matrix.environment. "}
{"id": "63c494187843b612699fef56", "level": "level3", "llm_response": "```yaml\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Enable debug mode'\n        required: false\n        default: 'false'\n        type: boolean\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: true\n\njobs:\n  fork_update_pr:\n    id: fork_update_pr\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Run debug mode\n        if: ${{ github.event.inputs.debug == 'true' }}\n        run: echo \"Debug mode is enabled\"\n\n      - name: Update fork PR\n        run: |\n          # Add your fork PR update logic here\n          echo \"Updating fork PR...\"\n```", "answer": "```yaml #\n#  Author: Hari Sekhon\n#  Date: Tue Feb 4 09:53:28 2020 +0000\n#\n#  vim:ts=2:sts=2:sw=2:et\n#\n#  https://github.com/HariSekhon/Kubernetes-configs\n#\n#  If you're using my code you're welcome to connect with me on LinkedIn and optionally send me feedback\n#\n#  https://www.linkedin.com/in/HariSekhon\n#\n\n---\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        required: false\n        default: false\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: false\n\njobs:\n  fork_update_pr:\n    # github.event.repository context not available in scheduled workflows\n    #if: github.event.repository.fork == true\n    if: github.repository_owner != 'HariSekhon'\n    name: Fork Update PR\n    uses: HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master\n    with:\n      debug: ${{ github.event.inputs.debug }}\n```", "prompt": "Generate a GitHub Workflow named `Fork Update PR` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, it is optional and its default value is False. 2) the scheduled time has come: at 10:00 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.ref }}-${{ github.workflow }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Fork Update PR` and its job id is `fork_update_pr`. Here are some reusable workflows that might be used in the workflow: {'version': 'master', 'name': 'HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml'}. Here are some variables that might be used in the workflow: github.event.inputs.debug. "}
{"id": "63c494e67843b61269a04123", "level": "level3", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n    branches:\n      - '**'\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        channel: 'stable'\n        flutter-version: '3.0.0'\n\n    - name: Checkout OneSignal-Flutter-SDK\n      uses: actions/checkout@v3\n\n    - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n      run: flutter pub get\n\n    - name: Static Analysis\n      run: flutter analyze\n\n    - name: Ensure the Dart code is formatted correctly\n      run: flutter format --set-exit-if-changed .\n\n    - name: Run Flutter unit tests\n      run: flutter test\n```", "answer": "```yaml name: CI\non:\n  pull_request:\n    branches:\n      - '**'\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '2.10.4'\n          channel: 'stable'\n\n      - name: Checkout OneSignal-Flutter-SDK\n        uses: actions/checkout@v3\n\n      - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n        run: flutter pub get\n\n      - name: Static Analysis\n        run: flutter analyze\n\n      - name: Ensure the Dart code is formatted correctly\n        run: flutter format --set-exit-if-changed --dry-run .\n\n      - name: Run Flutter unit tests\n        run: flutter test\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch whose name matches **. When all the path names of pull_request event match patterns in the paths-ignore filter(.github/**, .vscode/** or README.md), the workflow will not run. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 6 steps. The 1st step is named `Setup Flutter`. The 2nd step is named `Checkout OneSignal-Flutter-SDK`. The 3rd step is named `Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6`. The 4th step is named `Static Analysis`. The 5th step is named `Ensure the Dart code is formatted correctly`. The 6th step is named `Run Flutter unit tests`. Here are some Github Actions that might be used in the workflow: v2 version of subosito/flutter-action and v3 version of actions/checkout. "}
{"id": "63c4957b8052faa2781b219f", "level": "level3", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - '**.go'\n  pull_request:\n    branches:\n      - main\n    paths:\n      - '**.go'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '1.17'\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - '**.go'\n  pull_request:\n    branches: [ main ]\n    paths:\n      - '**.go'\n\njobs:\n\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: 1.18\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -cover -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(**.go), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. Only if at least one path of pull_request event matches a pattern in the paths filter(**.go), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Go`. The 3rd step is named `Build`. The 4th step is named `Test`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout and v3 version of actions/setup-go. "}
{"id": "63c495928052faa2781b2bc1", "level": "level3", "llm_response": "```yaml\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@master\n\n    - name: Create Release\n      id: create_release\n      uses: actions/create-release@latest\n      env:\n        GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}\n      with:\n        tag_name: ${{ github.ref }}\n        release_name: Release ${{ github.ref }}\n        draft: false\n        prerelease: false\n```", "answer": "```yaml \n# https://github.com/actions/create-release\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    name: Create Release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Create Release\n        id: create_release\n        uses: actions/create-release@latest\n        env:\n          GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: ${{ github.ref }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Create Release` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Create Release` and its job id is `build`. The job `build` has 2 steps. The 1st step is named `Checkout code`. The 2nd step is named `Create Release` and its id is `create_release`. Here are some Github Actions that might be used in the workflow: master version of actions/checkout and latest version of actions/create-release. Here are some variables that might be used in the workflow: github.ref and secrets.GIT_TOKEN. "}
{"id": "63c496686fc19abdf9c9bea4", "level": "level3", "llm_response": "```yaml\nname: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.ADMIN_GITHUB_TOKEN }}\n```", "answer": "```yaml name: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.ADMIN_GITHUB_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Drafts/updates the next repository release` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. The job `update_release_draft` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v5 version of release-drafter/release-drafter. Here are some variables that might be used in the workflow: secrets.ADMIN_GITHUB_TOKEN. "}
{"id": "63c494768052faa2781ab616", "level": "level3", "llm_response": "```yaml\nname: Static analysis\n\non:\n  pull_request:\n\njobs:\n  static-psalm-analysis:\n    id: static-psalm-analysis\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ocp-version: [7.4, 8.0, 8.1]\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@master\n\n      - name: Set up PHP\n        uses: shivammathur/setup-php@master\n        with:\n          php-version: ${{ matrix.ocp-version }}\n\n      - name: Install dependencies\n        run: composer install --no-dev --optimize-autoloader\n\n      - name: Install dependencies\n        run: composer install --no-dev --optimize-autoloader\n\n      - name: Run coding standards check\n        run: vendor/bin/phpcs --standard=PSR2 src/\n```", "answer": "```yaml name: Static analysis\n\non: [pull_request]\n\njobs:\n  static-psalm-analysis:\n      runs-on: ubuntu-latest\n      strategy:\n          matrix:\n              ocp-version: [ 'v20.0.7', 'v21.0.0', 'dev-stable22', 'dev-stable23', 'dev-master' ]\n      name: Nextcloud ${{ matrix.ocp-version }}\n      steps:\n          - name: Checkout\n            uses: actions/checkout@master\n          - name: Set up php\n            uses: shivammathur/setup-php@master\n            with:\n                php-version: 7.4\n                tools: composer:v1\n                coverage: none\n          - name: Install dependencies\n            run: composer i\n          - name: Install dependencies\n            run: composer require --dev christophwurst/nextcloud:${{ matrix.ocp-version }}\n          - name: Run coding standards check\n            run: composer run psalm\n```", "prompt": "Generate a GitHub Workflow named `Static analysis` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Nextcloud ${{ matrix.ocp-version }}` and its job id is `static-psalm-analysis`. The job `static-psalm-analysis` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up php`. The 3rd step is named `Install dependencies`. The 4th step is named `Install dependencies`. The 5th step is named `Run coding standards check`. Here are some Github Actions that might be used in the workflow: master version of actions/checkout and master version of shivammathur/setup-php. Here are some variables that might be used in the workflow: matrix.ocp-version. "}
{"id": "63c4951f8052faa2781af9e5", "level": "level3", "llm_response": "```yaml\nname: IRC Notification\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: irc push\n      uses: vmiklos/notify-irc@bfd6f632b683859f6cd074e2ee9db68bef204f7d\n      with:\n        irc_server: ${{ github.event.repository.irc_server }}\n        irc_channel: ${{ github.event.repository.irc_channel }}\n        irc_nick: ${{ github.event.repository.irc_nick }}\n        message: ${{ github.event.repository.message }}\n```", "answer": "```yaml name: \"IRC Notification\"\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: irc push\n        uses: vmiklos/notify-irc@bfd6f632b683859f6cd074e2ee9db68bef204f7d\n        if: github.event_name == 'push' && github.event.ref == 'refs/heads/master' && github.repository == 'CollaboraOnline/online'\n        with:\n          channel: \"#cool-dev\"\n          nickname: github-online\n          message: |\n            ${{ toJson(github.event) }}\n```", "prompt": "Generate a GitHub Workflow named `IRC Notification` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `test`. The job `test` has one step. The 1st step is named `irc push`. Here are some Github Actions that might be used in the workflow: bfd6f632b683859f6cd074e2ee9db68bef204f7d version of vmiklos/notify-irc. Here are some variables that might be used in the workflow: github.event. "}
{"id": "63c493ee7843b612699fde0c", "level": "level3", "llm_response": "```yaml\nname: nf-core AWS test\n\non:\n  workflow_dispatch:\n\njobs:\n  run-tower:\n    id: run-tower\n    runs-on: ubuntu-latest\n    steps:\n      - name: Launch workflow via tower\n        uses: nf-core/tower-action@v3\n        with:\n          workspace_id: ${{ secrets.TOWER_WORKSPACE_ID }}\n          access_token: ${{ secrets.TOWER_ACCESS_TOKEN }}\n          compute_env: ${{ secrets.TOWER_COMPUTE_ENV }}\n          s3_bucket: ${{ secrets.AWS_S3_BUCKET }}\n          commit_sha: ${{ github.sha }}\n```", "answer": "```yaml name: nf-core AWS test\n# This workflow can be triggered manually with the GitHub actions workflow dispatch button.\n# It runs the -profile 'test' on AWS batch\n\non:\n  workflow_dispatch:\njobs:\n  run-tower:\n    name: Run AWS tests\n    if: github.repository == 'nf-core/mag'\n    runs-on: ubuntu-latest\n    steps:\n      # Launch workflow using Tower CLI tool action\n      - name: Launch workflow via tower\n        uses: nf-core/tower-action@v3\n        with:\n          workspace_id: ${{ secrets.TOWER_WORKSPACE_ID }}\n          access_token: ${{ secrets.TOWER_ACCESS_TOKEN }}\n          compute_env: ${{ secrets.TOWER_COMPUTE_ENV }}\n          workdir: s3://${{ secrets.AWS_S3_BUCKET }}/work/mag/work-${{ github.sha }}\n          parameters: |\n            {\n              \"outdir\": \"s3://${{ secrets.AWS_S3_BUCKET }}/mag/results-test-${{ github.sha }}\"\n            }\n          profiles: test,aws_tower\n```", "prompt": "Generate a GitHub Workflow named `nf-core AWS test` for a GitHub repository whose primary programming language is Nextflow. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Run AWS tests` and its job id is `run-tower`. The job `run-tower` has one step. The 1st step is named `Launch workflow via tower`. Here are some Github Actions that might be used in the workflow: v3 version of nf-core/tower-action. Here are some variables that might be used in the workflow: secrets.TOWER_WORKSPACE_ID, secrets.TOWER_ACCESS_TOKEN, secrets.TOWER_COMPUTE_ENV, secrets.AWS_S3_BUCKET and github.sha. "}
{"id": "63c496981899db58864d3f73", "level": "level3", "llm_response": "```yaml\nname: Triage tasks\n\non:\n  pull_request:\n    types: [opened, synchronize]\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: triage-${{ github.event.number }}\n  cancel-in-progress: true\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check commit format\n        uses: Homebrew/actions/check-commit-format@master\n        with:\n          github-token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n      - name: Label pull request\n        uses: Homebrew/actions/label-pull-requests@master\n        with:\n          github-token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "answer": "```yaml name: Triage tasks\n\non: pull_request_target\n\nconcurrency:\n  group: \"triage-${{ github.event.number }}\"\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check commit format\n        uses: Homebrew/actions/check-commit-format@master\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n      - name: Label pull request\n        uses: Homebrew/actions/label-pull-requests@master\n        if: always()\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n          def: |\n            - label: new cask\n              status: added\n              path: Casks/.+\n\n            - label: marked for removal/rejection\n              status: removed\n              path: Casks/.+\n\n            - label: documentation\n              path: (.*\\.md|\\.github/ISSUE_TEMPLATE/.*\\.yml)\n\n            - label: bump-cask-pr\n              pr_body_content: Created with `brew bump-cask-pr`\n\n            - label: missing description\n              path: Casks/.+\n              missing_content: \\n  desc .+\\n\n\n            - label: appcast migration needed\n              path: Casks/.+\n              content: \\n  appcast .+\\n\n```", "prompt": "Generate a GitHub Workflow named `Triage tasks` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the triage-${{ github.event.number }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `triage`. The job `triage` has 2 steps. The 1st step is named `Check commit format`. The 2nd step is named `Label pull request`. Here are some Github Actions that might be used in the workflow: master version of Homebrew/actions/check-commit-format and master version of Homebrew/actions/label-pull-requests. Here are some variables that might be used in the workflow: secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN. "}
{"id": "63c494a27843b61269a02781", "level": "level3", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 8 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Mark stale issues and pull requests\n        uses: actions/stale@v5\n        with:\n          days-before-stale: 90\n          days-before-close: 7\n          stale-label: 'stale'\n          exempt-issue-labels: 'important, security'\n          exempt-pr-labels: 'important, security'\n          stale-issue-message: 'This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thanks for your understanding!'\n          stale-pr-message: 'This pull request has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thanks for your understanding!'\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml # This workflow warns and then closes issues and PRs that have had no activity for a specified amount of time.\n#\n# You can adjust the behavior by modifying this file.\n# For more information, see:\n# https://github.com/actions/stale\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '16 8 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v5\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        ascending: true\n        stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-pr-message: 'This PR has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-issue-label: 'no-issue-activity'\n        stale-pr-label: 'no-pr-activity'\n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by an event: the scheduled time has come: at 08:16 am. The workflow has one job. The job id of the 1st job is `stale`. The job `stale` has one step. The 1st step is named ``. Here are some Github Actions that might be used in the workflow: v5 version of actions/stale. Here are some variables that might be used in the workflow: secrets.GITHUB_TOKEN. "}
{"id": "63c4963d6fc19abdf9c9abf2", "level": "level3", "llm_response": "```yaml\nname: Submit to Web Store\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ${{ runner.os }}\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Cache pnpm modules\n        uses: actions/cache@v3\n        with:\n          path: ~/.pnpm-store\n          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/package-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-pnpm-\n\n      - name: Set up pnpm\n        uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n\n      - name: Build and zip extension artifact\n        run: |\n          pnpm install\n          pnpm run build\n          zip -r extension.zip dist\n\n      - name: Browser Platform Publish\n        uses: PlasmoHQ/bpp@v2\n        with:\n          submit_keys: ${{ secrets.SUBMIT_KEYS }}\n          platform: webstore\n          artifact_path: extension.zip\n```", "answer": "```yaml name: \"Submit to Web Store\"\r\non:\r\n  workflow_dispatch:\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Cache pnpm modules\r\n        uses: actions/cache@v3\r\n        with:\r\n          path: ~/.pnpm-store\r\n          key: ${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}\r\n          restore-keys: |\r\n            ${{ runner.os }}-\r\n      - uses: pnpm/action-setup@v2.2.1\r\n        with:\r\n          version: 7.1.0\r\n          run_install: true\r\n      - name: Build and zip extension artifact\r\n        run: pnpm build -- --zip\r\n      - name: Browser Platform Publish\r\n        uses: PlasmoHQ/bpp@v2\r\n        with:\r\n          keys: ${{ secrets.SUBMIT_KEYS }}\r\n          artifact: build/chrome-mv3-prod.zip\r\n```", "prompt": "Generate a GitHub Workflow named `Submit to Web Store` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. The job `build` has 5 steps. The 1st step is named ``. The 2nd step is named `Cache pnpm modules`. The 3rd step is named ``. The 4th step is named `Build and zip extension artifact`. The 5th step is named `Browser Platform Publish`. Here are some Github Actions that might be used in the workflow: v3 version of actions/checkout, v3 version of actions/cache, v2.2.1 version of pnpm/action-setup and v2 version of PlasmoHQ/bpp. Here are some variables that might be used in the workflow: runner.os and secrets.SUBMIT_KEYS. "}
{"id": "63c494a97843b61269a02a50", "level": "level4", "llm_response": "```yaml\nname: pytorch1_7_1-cuda11_0\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    id: build\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: 'cu110'\n      remote_runtime_docker: 'bladedisc:latest-runtime-torch1.7.1-cu110'\n      develop_base_image: 'nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04'\n      runtime_base_image: 'nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04'\n      extra_envs: '-e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110'\n      exec_command: 'bash ./scripts/ci/test_pytorch_blade.sh'\n      deploy_command: 'TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh'\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "answer": "```yaml name: pytorch1_7_1-cuda11_0\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu110\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.7.1-cu110\n      develop_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_7_1-cuda11_0` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will call a reusable workflow located at `./.github/workflows/resuable_gpu_build.yml`. The job will pass 7 inputs to the called workflow: the input `cuda_version` is `cu110`, the input `remote_runtime_docker` is `bladedisc:latest-runtime-torch1.7.1-cu110`, the input `develop_base_image` is `nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04`, the input `runtime_base_image` is `nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04`, the input `extra_envs` is `-e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110`, the input `exec_command` is `bash ./scripts/ci/test_pytorch_blade.sh` and the input `deploy_command` is `TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh`. The job will pass 4 secrets to the called workflow: the secret `ALIYUN_DOCKER_USERNAME` is `${{ secrets.ALIYUN_DOCKER_USERNAME }}`, the secret `ALIYUN_DOCKER_PASSWORD` is `${{ secrets.ALIYUN_DOCKER_PASSWORD }}`, the secret `DOCKER_USERNAME` is `${{ secrets.DOCKER_USERNAME }}` and the secret `DOCKER_PASSWORD` is `${{ secrets.DOCKER_PASSWORD }}`. "}
{"id": "63c496986fc19abdf9c9cf90", "level": "level4", "llm_response": "```yaml\nname: Issue Check\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Close Issue\n      run: |\n        gh issue close ${{ github.event.issue.number }}\n\n    - name: Create comment\n      run: |\n        gh issue comment ${{ github.event.issue.number }} --body \"This issue will be automatically closed.\"\n```", "answer": "```yaml name: 'Issue Check'\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n    steps:\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == false\n        name: Close Issue\n        uses: peter-evans/close-issue@v1\n        with:\n          comment: |\n            Hello, Please use the Github template to report an issue. If this is a feature request, please take a look at the readme. <br/> Thanks, <br/> Ombi Bot\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == true\n        name: Create comment\n        uses: peter-evans/create-or-update-comment@v1\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            Hi!\n            <br/>Thanks for the issue report. Before a real human comes by, please make sure you used our bug report format.\n            <br/>Have you looked at the wiki yet? https://docs.ombi.app/\n            <br/>Before posting make sure you also read our [FAQ](https://docs.ombi.app/info/faq/).\n            <br/> Make the title describe your issue. Having 'not working' or 'I get this bug' for 100 issues, isn't really helpful.\n            <br/> If we need more information or there is some progress we tag the issue or update the tag and keep you updated.\n            <br/> Thanks!\n            <br/> Ombi Bot.\n```", "prompt": "Generate a GitHub Workflow named `Issue Check` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `issueCheck`. This job will run on ubuntu-latest runner. The job `issueCheck` has 2 steps. The 1st step is named `Close Issue`. The 2nd step is named `Create comment`. "}
{"id": "63c494da7843b61269a03d4f", "level": "level4", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2\n\n      - name: Install \ud83c\udf31\n        run: |\n          # Install dependencies here\n          echo \"Installing dependencies...\"\n\n      - name: Build \ud83d\udd27\n        run: |\n          # Build the project here\n          echo \"Building the project...\"\n\n      - name: Deploy \ud83d\ude80\n        run: |\n          # Deploy the project here\n          echo \"Deploying the project...\"\n```", "answer": "```yaml name: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\njobs:\n  build-and-deploy:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n      - name: Install \ud83c\udf31\n        run: |\n          sudo apt-get install -y pandoc\n      - name: Build \ud83d\udd27\n        run: |\n          ./run build itch\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4\n        with:\n          folder: build\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is GDScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets 3 environment variables to use: `BUTLER_API_KEY` is set to `${{ secrets.BUTLER_API_KEY }}`, `ITCHIO_USERNAME` is set to `${{ secrets.ITCHIO_USERNAME }}` and `ITCHIO_GAME` is set to `${{ secrets.ITCHIO_GAME }}`. The workflow has one job. The job id of the 1st job is `build-and-deploy`. This job will run on ubuntu-latest runner. Only a single job using the ci-${{ github.ref }} concurrency group will run at a time. The job `build-and-deploy` has 4 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install \ud83c\udf31`. The 3rd step is named `Build \ud83d\udd27`. The 4th step is named `Deploy \ud83d\ude80`. "}
{"id": "63c4968933b087f6bde2ca3a", "level": "level4", "llm_response": "```yaml\nname: Nightly Smoketest\n\non:\n  schedule:\n    - cron: '0 3 * * 1-5'\n  workflow_dispatch:\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        NODE_VERSION: [1.19.16, 1.20.15, 1.21.9, 1.22.6, 1.23.3]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Mount bazel cache\n        run: echo \"Mounting bazel cache\"\n      - name: Bank Workload\n        run: echo \"Running bank workload\"\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# This workflow tests that we can stand up a CRDB cluster with the operator and execute SQL in the cluster. It uses the\n# steps that are outlined in our public docs to ensure that the flow we're recommending always works.\nname: Nightly Smoketest\n\non:\n  schedule:\n    # runs at 3am UTC Mon-Fri\n    # ref: <min> <hr> <month-day> <month> <weekday>\n    - cron: '0 3 * * 1-5'\n\n  # allows running from the actions tab in GitHub\n  workflow_dispatch: ~\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        # supported Kubenetes versions\n        NODE_VERSION: [1.19.16, 1.20.15, 1.21.9, 1.22.6, 1.23.3]\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: Bank Workload\n        env:\n          NODE_VERSION: ${{ matrix.NODE_VERSION }}\n        run: make test/smoketest\n```", "prompt": "Generate a GitHub Workflow named `Nightly Smoketest` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am, monday through friday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `smoketest`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `NODE_VERSION` has 5 values: 1.19.16, 1.20.15, 1.21.9, 1.22.6 and 1.23.3. The job `smoketest` has 3 steps. The 1st step is named ``. The 2nd step is named `Mount bazel cache`. The 3rd step is named `Bank Workload`. "}
{"id": "63c496686fc19abdf9c9be9c", "level": "level4", "llm_response": "```yaml\nname: Unit testing (Ubuntu)\n\non:\n  push:\n    branches:\n      - main\n      - ver_*\n      - dev\n    paths:\n      - '**.py'\n  pull_request:\n    branches:\n      - main\n      - ver_*\n      - dev\n    paths:\n      - '**.py'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.6, 3.7, 3.8, 3.9, 3.10]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Test with pytest\n        run: |\n          pytest\n```", "answer": "```yaml name: Unit testing (Ubuntu)\non:\n  push:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n  pull_request:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n\njobs:\n  build:\n    strategy:\n      matrix:\n        # os: [macos-latest, windows-latest, ubuntu-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10']  # , '3.11-dev'\n    # runs-on: ${{ matrix.os }}\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        python -m pip install pytest coverage\n        pip install -r requirements.txt\n    - name: Test with pytest\n      env:\n        DEBUG_API_ID: ${{ secrets.DEBUG_API_ID }}\n        DEBUG_API_SECRET: ${{ secrets.DEBUG_API_SECRET }}\n        CROSS_DEBUG_KEY: ${{ secrets.CROSS_DEBUG_KEY }}\n        CROSS_DEBUG_SECRET: ${{ secrets.CROSS_DEBUG_SECRET }}\n      run: |\n        coverage run --source=src --omit=src/falconpy/debug.py -m pytest -s --ignore-glob=**/manual/*\n        coverage report\n```", "prompt": "Generate a GitHub Workflow named `Unit testing (Ubuntu)` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of push event matches a pattern in the paths filter(**.py), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of pull_request event matches a pattern in the paths filter(**.py), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `python-version` has 5 values: 3.6, 3.7, 3.8, 3.9 and 3.10. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python ${{ matrix.python-version }}`. The 3rd step is named `Install dependencies`. The 4th step is named `Test with pytest`. "}
{"id": "63c49698b008460c1df15628", "level": "level4", "llm_response": "```yaml\nname: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\npermissions:\n  contents: read\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\njobs:\n  add_to_gh_projects:\n    id: add_to_gh_projects\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Add labeled issues to GH projects\n      run: echo \"Adding labeled issues to GH projects\"\n```", "answer": "```yaml name: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\npermissions:\n  contents: read\n\njobs:\n  add_to_gh_projects:\n    name: Adds issues to GH projects\n    runs-on: ubuntu-latest\n    steps:\n      - name: Add labeled issues to GH projects\n        uses: gradle/build-tool-issue-automation-actions/add-labeled-issues@v1\n```", "prompt": "Generate a GitHub Workflow named `add-to-gh-projects` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by multiple events: 1) an issue is opened or a label is added to an issue. 2) a pull request is created or a label is added to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}`. The workflow has one job. The 1st job is named `Adds issues to GH projects` and its job id is `add_to_gh_projects`. This job will run on ubuntu-latest runner. The job `add_to_gh_projects` has one step. The 1st step is named `Add labeled issues to GH projects`. "}
{"id": "63c494f67843b61269a0479e", "level": "level4", "llm_response": "```yaml\nname: Sync-To-Gitlab\n\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request:\n    branches:\n      - master\n      - master-template\n    types: [closed]\n  workflow_dispatch:\n\njobs:\n  sync:\n    id: sync\n    runs-on: ubuntu-latest\n    concurrency: ${{ github.workflow }}-${{ github.ref_name }}\n    if: github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch'\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n      - name: Mirror\n        run: echo \"Mirroring to Gitlab\"\n```", "answer": "```yaml name: Sync-To-Gitlab\nrun-name: Sync-To-Gitlab ${{ github.sha }}\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request_target:\n    types:\n      - closed\n    branches:\n      - master\n      - master-template\n  workflow_dispatch:\n\n\njobs:\n  sync:\n    concurrency:\n      group: ${{ github.workflow }}-${{ github.ref_name }}\n      cancel-in-progress: true\n    name: \"Sync To Gitlab\"\n    if: github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Mirror\n        env:\n          input_git_config_user_name: ${{ secrets.GITLAB_USERNAME }}\n          input_git_config_user_email: ${{ secrets.GITLAB_EMAIL }}\n          input_git_remote_url: ${{ secrets.GITLAB_URL }}\n          input_git_push_options: --force\n        run: |\n          git config --global user.name \"${{ env.input_git_config_user_name }}\"\n          git config --global user.email \"${{ env.input_git_config_user_email }}\"\n          git clone \"https://github.com/${{ github.repository }}.git\" \"git\"\n          cd git\n          git remote set-url origin \"${{ env.input_git_remote_url }}\"\n          git push ${{ env.input_git_push_options }} origin ${{ github.ref_name }}:${{ github.ref_name }}\n#      - name: Mirror + trigger CI\n#        uses: SvanBoxel/gitlab-mirror-and-ci-action@master\n#        with:\n#          args: \"https://gitlab.com/Zerek-Cheng/Simple-Assets-Platform\"\n#        env:\n#          FORCE_PUSH: \"true\"\n#          GITLAB_HOSTNAME: \"gitlab.com\"\n#          GITLAB_USERNAME: \"Zerek-Cheng\"\n#          GITLAB_PASSWORD: ${{ secrets.GITLAB_PASSWORD }}\n#          GITLAB_PROJECT_ID: \"40146411\"\n#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Sync-To-Gitlab` for a GitHub repository whose primary programming language is Java. The name for workflow runs is set to `Sync-To-Gitlab ${{ github.sha }}`. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named master-template. 2) a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named master-template. 3) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Sync To Gitlab` and its job id is `sync`. This job will run only if the condition(github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch') is met. This job will run on ubuntu-latest runner. Only a single job using the ${{ github.workflow }}-${{ github.ref_name }} concurrency group will run at a time. When this job is queued, any currently running job in the same concurrency group will be canceled. The job `sync` has 2 steps. The 1st step is named `Checkout`. The 2nd step is named `Mirror`. "}
{"id": "63c496561899db58864d23de", "level": "level4", "llm_response": "```yaml\nname: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  sqlite:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: sqlite\n```", "answer": "```yaml name: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  sqlite:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: sqlite\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Sqlite` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.sqlite.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/sqlite/** or roles/sqlite/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `sqlite`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 2 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}` and the input `scenario` is `sqlite`. "}
{"id": "63c494078052faa2781a8a1f", "level": "level4", "llm_response": "```yaml\nname: CLA Assistant\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [opened, closed, synchronize]\n  comment:\n    types: [created]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: CLA Assistant\n      run: echo \"Running CLA Assistant...\"\n```", "answer": "```yaml name: \"CLA Assistant\"\non:\n  issue_comment:\n    types: [ created ]\n  pull_request_target:\n    types: [ opened,closed,synchronize ]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        uses: cla-assistant/github-action@v2.1.3-beta\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # the below token should have repo scope and must be manually added by you in the repository's secret\n          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: '.cla/v1/signatures.json'\n          path-to-document: 'https://github.com/christian-schlichtherle/truelicense/blob/develop/CLA.md'\n          branch: 'develop'\n          allowlist: bot*\n\n          #below are the optional inputs - If the optional inputs are not given, then default values will be taken\n          #remote-organization-name: enter the remote organization name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #remote-repository-name:  enter the  remote repository name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #create-file-commit-message: 'For example: Creating file for storing CLA Signatures'\n          #signed-commit-message: 'For example: $contributorName has signed the CLA in #$pullRequestNo'\n          #custom-notsigned-prcomment: 'pull request comment with Introductory message to ask new contributors to sign'\n          #custom-pr-sign-comment: 'The signature to be committed in order to sign the CLA'\n          #custom-allsigned-prcomment: 'pull request comment when all contributors has signed, defaults to **CLA Assistant Lite bot** All Contributors have signed the CLA.'\n          #lock-pullrequest-aftermerge: false - if you don't want this bot to automatically lock the pull request after merging (default - true)\n          #use-dco-flag: true - If you are using DCO instead of CLA\n```", "prompt": "Generate a GitHub Workflow named `CLA Assistant` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `CLAssistant`. This job will run on ubuntu-latest runner. The job `CLAssistant` has one step. The 1st step is named `CLA Assistant`. "}
{"id": "63c494298052faa2781a98f8", "level": "level4", "llm_response": "```yaml\nname: Linux build with address sanitizer enabled\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Compiler version\n      run: |\n        g++ --version\n\n    - name: Build\n      run: |\n        make -j4\n\n    - name: Run tests\n      run: |\n        make check\n\n    - name: Run examples\n      run: |\n        make examples\n```", "answer": "```yaml name: Linux build with address sanitizer enabled\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n    container: ghcr.io/lballabio/quantlib-devenv:rolling\n    steps:\n    - uses: actions/checkout@v3\n    - name: Compiler version\n      run: |\n        gcc --version\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"gcc\" CXX=\"g++\" CXXFLAGS=\"-O2 -g0 -fsanitize=address,undefined -fno-sanitize-recover=all -fno-omit-frame-pointer -Wall -Wno-unknown-pragmas -Werror\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --log_level=message\n    - name: Run examples\n      run: |\n        make check-examples\n```", "prompt": "Generate a GitHub Workflow named `Linux build with address sanitizer enabled` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `sanitize`. This job will run on ubuntu-latest runner. The job creates a Docker container that uses `ghcr.io/lballabio/quantlib-devenv:rolling` image. The job `sanitize` has 5 steps. The 1st step is named ``. The 2nd step is named `Compiler version`. The 3rd step is named `Build`. The 4th step is named `Run tests`. The 5th step is named `Run examples`. "}
{"id": "63c493cd7843b612699fd710", "level": "level4", "llm_response": "```yaml\nname: Clean\n\non:\n  push:\n    branches: [ main ]\n  release:\n    types: [ created ]\n  repository_dispatch:\n\njobs:\n  delete-artifacts:\n    id: delete-artifacts\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n    - name: Delete artifacts\n      run: |\n        # Add your commands to delete artifacts here\n```", "answer": "```yaml # This file was automatically generated by sbt-github-actions using the\n# githubWorkflowGenerate task. You should add and commit this file to\n# your git repository. It goes without saying that you shouldn't edit\n# this file by hand! Instead, if you wish to make changes, you should\n# change your sbt build configuration to revise the workflow description\n# to meet your needs, then regenerate this file.\n\nname: Clean\n\non: push\n\njobs:\n  delete-artifacts:\n    name: Delete Artifacts\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Delete artifacts\n        run: |\n          # Customize those three lines with your repository and credentials:\n          REPO=${GITHUB_API_URL}/repos/${{ github.repository }}\n\n          # A shortcut to call GitHub API.\n          ghapi() { curl --silent --location --user _:$GITHUB_TOKEN \"$@\"; }\n\n          # A temporary file which receives HTTP response headers.\n          TMPFILE=/tmp/tmp.$$\n\n          # An associative array, key: artifact name, value: number of artifacts of that name.\n          declare -A ARTCOUNT\n\n          # Process all artifacts on this repository, loop on returned \"pages\".\n          URL=$REPO/actions/artifacts\n          while [[ -n \"$URL\" ]]; do\n\n            # Get current page, get response headers in a temporary file.\n            JSON=$(ghapi --dump-header $TMPFILE \"$URL\")\n\n            # Get URL of next page. Will be empty if we are at the last page.\n            URL=$(grep '^Link:' \"$TMPFILE\" | tr ',' '\\n' | grep 'rel=\"next\"' | head -1 | sed -e 's/.*<//' -e 's/>.*//')\n            rm -f $TMPFILE\n\n            # Number of artifacts on this page:\n            COUNT=$(( $(jq <<<$JSON -r '.artifacts | length') ))\n\n            # Loop on all artifacts on this page.\n            for ((i=0; $i < $COUNT; i++)); do\n\n              # Get name of artifact and count instances of this name.\n              name=$(jq <<<$JSON -r \".artifacts[$i].name?\")\n              ARTCOUNT[$name]=$(( $(( ${ARTCOUNT[$name]} )) + 1))\n\n              id=$(jq <<<$JSON -r \".artifacts[$i].id?\")\n              size=$(( $(jq <<<$JSON -r \".artifacts[$i].size_in_bytes?\") ))\n              printf \"Deleting '%s' #%d, %'d bytes\\n\" $name ${ARTCOUNT[$name]} $size\n              ghapi -X DELETE $REPO/actions/artifacts/$id\n            done\n          done\n```", "prompt": "Generate a GitHub Workflow named `Clean` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The 1st job is named `Delete Artifacts` and its job id is `delete-artifacts`. This job will run on ubuntu-latest runner. The job sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. The job `delete-artifacts` has one step. The 1st step is named `Delete artifacts`. "}
{"id": "63c494167843b612699fee3f", "level": "level4", "llm_response": "```yaml\nname: Dead Link Check\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [clone]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n    if: github.repository == 'apache/incubator-linkis'\n    timeout-minutes: 30\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Run dead link check\n      run: |\n        # Add your dead link check command here\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\n\nname: Dead Link Check\n\non: [push, pull_request]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    if: (github.repository == 'apache/incubator-linkis')\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gaurav-nelson/github-action-markdown-link-check@v1\n        with:\n          use-quiet-mode: 'no'\n          use-verbose-mode: 'yes'\n          folder-path: '../'\n          config-file: '.github/workflows/dlc.json'\n```", "prompt": "Generate a GitHub Workflow named `Dead Link Check` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `dead-links-check`. This job will run only if the condition((github.repository == 'apache/incubator-linkis')) is met. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 30. The job `dead-links-check` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c4964b33b087f6bde2aead", "level": "level4", "llm_response": "```yaml\nname: Build release\n\non:\n  push:\n    tags:\n      - 'v**'\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: ''\n      - name: Set up JDK 11\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n      - name: Set up ruby env\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '2.7'\n      - name: Decode Service Account Key JSON File\n        id: service_account_json_file\n        run: echo ${{ secrets.SERVICE_ACCOUNT_KEY }} | base64 --decode > service-account.json\n      - name: Grant execute permission for gradlew\n        run: chmod +x gradlew\n      - name: Create local properties\n        run: echo \"serviceAccountKeyPath=service-account.json\" > local.properties\n      - name: Create maps api key\n        run: echo \"mapsApiKey=${{ secrets.MAPS_API_KEY }}\" >> local.properties\n      - name: Decode Keystore\n        run: echo ${{ secrets.KEYSTORE }} | base64 --decode > keystore.jks\n      - name: Decode Google Services json\n        run: echo ${{ secrets.GOOGLE_SERVICES_JSON }} | base64 --decode > google-services.json\n      - name: Build & deploy Android release\n        run: ./gradlew assembleRelease\n```", "answer": "```yaml name: Build release\n\non:\n  push:\n    tags:\n      - v**\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: set up JDK 11\n      uses: actions/setup-java@v3\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n        cache: gradle\n\n    - name: Set up ruby env\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: 2.7.2\n        bundler-cache: true\n\n    - name: Decode Service Account Key JSON File\n      uses: timheuer/base64-to-file@v1\n      id: service_account_json_file\n      with:\n        fileName: \"serviceAccount.json\"\n        encodedString: ${{ secrets.GOOGLE_JSON }}\n\n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n\n    - name: Create local properties\n      run: touch local.properties\n\n    - name: Create maps api key\n      run: echo \"MAPS_API_KEY=${{ secrets.MAPS_API_KEY }}\" > secrets.properties\n\n    - name: Decode Keystore\n      env:\n        ENCODED_STRING: ${{ secrets.KEYSTORE }}\n      run: |\n        mkdir app/keystore\n        echo $ENCODED_STRING | base64 -di > app/keystore/keystore.jks\n    - name: Decode Google Services json\n      env:\n        ENCODED_STRING: ${{ secrets.GOOGLE_SERVICES }}\n      run: |\n        echo $ENCODED_STRING | base64 -di > app/google-services.json\n        \n\n    - name: Build & deploy Android release\n      run: bundle exec fastlane android deploy\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n        ANDROID_JSON_KEY_FILE: ${{ steps.service_account_json_file.outputs.filePath }}\n\n#    - name: Build with Gradle\n#      run: ./gradlew app:bundleRelease\n#      env:\n#        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n#        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n#        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n#\n#    - name: Archive release bundle\n#      uses: actions/upload-artifact@v3\n#      with:\n#        name: bundle\n#        path: |\n#          app/build/outputs/bundle/release\n```", "prompt": "Generate a GitHub Workflow named `Build release` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v**. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 10 steps. The 1st step is named ``. The 2nd step is named `set up JDK 11`. The 3rd step is named `Set up ruby env`. The 4th step is named `Decode Service Account Key JSON File` and its id is `service_account_json_file`. The 5th step is named `Grant execute permission for gradlew`. The 6th step is named `Create local properties`. The 7th step is named `Create maps api key`. The 8th step is named `Decode Keystore`. The 9th step is named `Decode Google Services json`. The 10th step is named `Build & deploy Android release`. "}
{"id": "63c4956e8052faa2781b1ca5", "level": "level4", "llm_response": "```yaml\nname: Conventional PR\n\non:\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: semantic-pull-request\n        uses: \"greenkeeperio/semantic-pull-request-action@v2\"\n```", "answer": "```yaml name: Conventional PR\n\n# Controls when the action will run. \non:\n  pull_request:\n    branches:\n    - develop\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n      - name: semantic-pull-request\n        # Internal Unity mirror available at jesseo/action-semantic-pull-request, but actions from private repos aren't supported, so continue to use the public one below\n        uses: amannn/action-semantic-pull-request@b7a9a97cb10fa6e1ae02647e718798175f6b1f1d\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          # Provide custom types if you don't want the default ones from https://www.conventionalcommits.org\n          types: # optional\n          # Configure which scopes are allowed.\n          #scopes: # optional\n          # Configure that a scope must always be provided.\n          #requireScope: # optional\n          # Configure additional validation for the subject based on a regex. E.g. '^(?![A-Z]).+$' ensures the subject doesn't start with an uppercase character.\n          #subjectPattern: # optional\n          # If `subjectPattern` is configured, you can use this property to override the default error message that is shown when the pattern doesn't match. The variables `subject` and `title` can be used within the message.\n          #subjectPatternError: # optional\n          # For work-in-progress PRs you can typically use draft pull requests from Github. However, private repositories on the free plan don't have this option and therefore this action allows you to opt-in to using the special '[WIP]' prefix to indicate this state. This will avoid the validation of the PR title and the pull request checks remain pending. Note that a second check will be reported if this is enabled.\n          #wip: # optional\n          # When using \"Squash and merge\" on a PR with only one commit, GitHub will suggest using that commit message instead of the PR title for the merge commit, and it's easy to commit this by mistake. Enable this option to also validate the commit message for one commit PRs.\n          validateSingleCommit: true # optional\n```", "prompt": "Generate a GitHub Workflow named `Conventional PR` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has one step. The 1st step is named `semantic-pull-request`. "}
{"id": "63c4965b33b087f6bde2b689", "level": "level4", "llm_response": "```yaml\nname: fortran-format-check\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  fortran-format-check:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash -l {0}\n\n    steps:\n      - name: .\n        run: echo \"Starting the workflow\"\n\n      - name: Install Conda environment from environment.yml\n        run: |\n          conda env create -f environment.yml\n          conda activate myenv\n\n      - name: Install gfortran\n        run: sudo apt-get update && sudo apt-get install gfortran\n\n      - name: Print python package versions\n        run: pip list\n\n      - name: Set and print branch name\n        run: echo \"Branch name: ${{ github.ref_name }}\"\n\n      - name: Fortran source format check\n        run: fprettify --check --write --inplace *.f90\n```", "answer": "```yaml name: fortran-format-check\n\non:\n  push:\n    branches: [ master, develop ]\n  pull_request:\n    branches: [ develop ]\n\njobs:\n  fortan-format-check:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash -l {0}\n\n    steps:\n      - uses: actions/checkout@v2.3.4\n\n      - name: Install Conda environment from environment.yml\n        uses: mamba-org/provision-with-micromamba@main\n        with:\n            cache-downloads: true\n            cache-env: true\n\n      - name: Install gfortran\n        uses: modflowpy/install-gfortran-action@v1\n\n      - name: Print python package versions\n        run: |\n          pip list\n\n      - name: Set and print branch name\n        run: |\n          .github/common/git-branch-export.sh\n\n      - name: Fortran source format check\n        run: |\n          .github/common/fortran-format-check.sh\n```", "prompt": "Generate a GitHub Workflow named `fortran-format-check` for a GitHub repository whose primary programming language is Fortran. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `fortan-format-check`. This job will run on ubuntu-latest runner. For all run steps in the job, default shell is set to bash -l {0}. The job `fortan-format-check` has 6 steps. The 1st step is named ``. The 2nd step is named `Install Conda environment from environment.yml`. The 3rd step is named `Install gfortran`. The 4th step is named `Print python package versions`. The 5th step is named `Set and print branch name`. The 6th step is named `Fortran source format check`. "}
{"id": "63c494c88052faa2781ad4bd", "level": "level4", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    if: github.actor != 'RWT-bot'\n    strategy:\n      matrix:\n        ros_distro: [melodic, noetic]\n        node_version: [14]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: ${{ matrix.node_version }}\n\n    - name: Own /github/home\n      run: sudo chown -R $USER:$USER /github/home\n\n    - name: Install apt dependencies\n      run: sudo apt-get update && sudo apt-get install -y python3-pip\n\n    - name: Tests\n      run: npm test\n\n    - name: Cleanup\n      run: sudo rm -rf /github/home\n```", "answer": "```yaml name: CI\n\non: [push, pull_request]\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  ci:\n    name: ${{ matrix.ros_distro }}\n    if: ${{ github.actor != 'RWT-bot' }}\n    runs-on: ubuntu-latest\n    container: ros:${{ matrix.ros_distro }}-ros-core\n    strategy:\n      fail-fast: false\n      matrix:\n        ros_distro: [melodic, noetic]\n        node_version: [14]\n    env:\n      ROS_DISTRO: ${{ matrix.ros_distro }}\n    steps:\n      - uses: actions/checkout@v3\n        env:\n          TOKEN: \"${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' && secrets.RWT_BOT_PAT || github.token }}\"\n        with:\n          token: ${{ env.TOKEN }}\n      - uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node_version }}\n      - name: Own /github/home\n        run: |\n          chown -hR $(whoami):$(whoami) /github/home\n      - name: Install apt dependencies\n        run: |\n          apt-get update\n          apt-get install -y firefox ros-$ROS_DISTRO-rosbridge-server ros-$ROS_DISTRO-tf2-web-republisher ros-$ROS_DISTRO-common-tutorials ros-$ROS_DISTRO-rospy-tutorials ros-$ROS_DISTRO-actionlib-tutorials\n      - name: Tests\n        run: |\n          bash -c \"source /opt/ros/$ROS_DISTRO/setup.bash && bash test/build.bash\"\n      - uses: stefanzweifel/git-auto-commit-action@v4\n        if: ${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' }}\n        with:\n          commit_message: Update Build\n          file_pattern: 'build/*.js'\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The 1st job is named `${{ matrix.ros_distro }}` and its job id is `ci`. This job will run only if the condition(${{ github.actor != 'RWT-bot' }}) is met. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `ros_distro` has 2 values: melodic and noetic. The variable `node_version` has one value: 14. The job creates a Docker container that uses `ros:${{ matrix.ros_distro }}-ros-core` image. The job sets an environment variable to use: `ROS_DISTRO` is set to `${{ matrix.ros_distro }}`. The job `ci` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Own /github/home`. The 4th step is named `Install apt dependencies`. The 5th step is named `Tests`. The 6th step is named ``. "}
{"id": "63c494287843b612699ff643", "level": "level4", "llm_response": "```yaml\nname: README to PDF\n\non:\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Generate PDF\n      run: |\n        # Add your PDF generation commands here\n\n    - name: Add PDF to repository\n      run: |\n        git add README.pdf\n\n    - name: Commit files\n      run: |\n        git commit -m \"Add README.pdf\"\n\n    - name: Push changes\n      uses: ad-m/github-push-action@v0.6.0\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        branch: ${{ github.ref }}\n```", "answer": "```yaml name: README to PDF\n# This workflow is triggered on pushes to the repository.\non:\n#   push:\n#     branches:\n#       - main\n#     paths:\n#       - 'README.md'\n    \n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    name: Build PDF\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: baileyjm02/markdown-to-pdf@v1.1.0\n        with:\n          input_dir: .\n          output_dir: .\n          build_html: false\n          table_of_contents: false\n      - uses: actions/upload-artifact@v3\n        with:\n          name: python-engineer-roadmap\n          path: README.pdf\n      - name: Commit files\n        run: |\n          git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n          git config --local user.name \"github-actions[bot]\"\n          git add README.pdf\n          if ! git diff-index --quiet HEAD; then\n            git commit -m \"Generate PDF file\"\n          fi\n      - name: Push changes\n        uses: ad-m/github-push-action@master\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          branch: ${{ github.ref }}\n#       - name: Commit changes\n#         uses: EndBug/add-and-commit@v9\n#         with:\n#           default_author: github_actions\n#           add: 'README.pdf'\n#           new_branch: generate-pdf\n#           push: origin generate-pdf --set-upstream --force\n```", "prompt": "Generate a GitHub Workflow named `README to PDF` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Build PDF` and its job id is `converttopdf`. This job will run on ubuntu-latest runner. The job `converttopdf` has 5 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Commit files`. The 5th step is named `Push changes`. "}
{"id": "63c494578052faa2781aa8bb", "level": "level4", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\nenv:\n  CODECOV_TOKEN: 2fc0d617-8e9a-47d7-ab58-52fa92b23741\n  MAIN_GO_VER: 1.16\n  MAIN_HOST_OS: ubuntu-latest\n\njobs:\n  go_test_and_coverage:\n    runs-on: ${{ matrix.HOST_OS }}\n    strategy:\n      matrix:\n        GO_VER: [1.16]\n        HOST_OS: [ubuntu-latest]\n      max-parallel: 6\n\n    steps:\n    - name: Checkout Repository\n      uses: actions/checkout@v2\n\n    - name: Setup Go\n      id: go\n      uses: actions/setup-go@v2\n      with:\n        go-version: ${{ matrix.GO_VER }}\n\n    - name: Get Dependencies\n      run: go mod download\n\n    - name: Show Environments\n      run: echo \"Go Version: ${{ matrix.GO_VER }}, Host OS: ${{ matrix.HOST_OS }}\"\n\n    - name: Test and Generate Coverage Report\n      run: |\n        go test -v ./... -coverprofile=coverage.out\n        go tool cover -func=coverage.out\n\n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        token: ${{ env.CODECOV_TOKEN }}\n        file: coverage.out\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branchs:\n    - 'master'\n    - 'feature/**'\n    - 'dev/**'\n\nenv:\n  CODECOV_TOKEN: '2fc0d617-8e9a-47d7-ab58-52fa92b23741'\n  MAIN_GO_VER: '1.16'\n  MAIN_HOST_OS: 'ubuntu-latest'\n\njobs:\n  go_test_and_coverage:\n    strategy:\n      max-parallel: 6\n      matrix:\n        GO_VER: ['1.16']\n        HOST_OS: ['ubuntu-latest']\n\n    runs-on: ${{ matrix.HOST_OS }}\n\n    steps:\n\n    - name: Checkout Repositary\n      uses: actions/checkout@v3\n\n    - name: Setup Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.GO_VER }}\n      id: go\n\n    - name: Get Dependencies\n      run: |\n        echo GO_VER = ${{ matrix.GO_VER }}\n        go get golang.org/x/tools/cmd/cover\n        go install github.com/mattn/goveralls || go get github.com/mattn/goveralls\n        go get .\n\n    - name: Show Environments\n      run: |\n        echo repo status ======== && git status\n        echo GITHUB_REF = ${{ env.GITHUB_REF }}\n        echo GITHUB_REF_NAME = ${{ env.GITHUB_REF_NAME }}\n        echo GO_VER = ${{ matrix.GO_VER }}\n        echo HOST_OS = ${{ matrix.HOST_OS }}\n        which goveralls\n        echo envs ======== && printenv\n\n    - name: Test and Generate Coverage Report\n      run: |\n        go test -v -failfast -cover -covermode=atomic -coverprofile=coverage.out\n\n    # - name: Upload Coverage to Goveralls\n    #   run: |\n    #     goveralls -coverprofile=coverage.out -repotoken ${{ env.COVERALLS_TOKEN }}\n\n    # - name: Upload Coverage to Codecov\n    #   if: ${{ matrix.GO_VER }} == ${{ env.MAIN_GO_VER }}\n    #   run: |\n    #     bash <(curl -s https://codecov.io/bash) -t ${{ env.CODECOV_TOKEN }}\n\n    # - name: Convert Coverage file to lcov format\n    #   uses: jandelgado/gcov2lcov-action@v1.0.8\n    #   with:\n    #     infile: ./coverage.out\n    #     outfile: ./coverage.lcov\n\n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        files: ./coverage.out\n        fail_ci_if_error: true\n        flags: unittests\n        name: codecov-umbrella\n        path_to_write_report: ./coverage/codecov_report.txt\n        verbose: true\n\n    # - name: Coveralls GitHub Action\n    #   uses: coverallsapp/github-action@1.1.3\n    #   with:\n    #     path-to-lcov: ./coverage.lcov\n    #     github-token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow sets 3 environment variables to use: `CODECOV_TOKEN` is set to `2fc0d617-8e9a-47d7-ab58-52fa92b23741`, `MAIN_GO_VER` is set to `1.16` and `MAIN_HOST_OS` is set to `ubuntu-latest`. The workflow has one job. The job id of the 1st job is `go_test_and_coverage`. This job will run on ${{ matrix.HOST_OS }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `GO_VER` has one value: 1.16. The variable `HOST_OS` has one value: ubuntu-latest. The maximum number of job runs in parallel is set to 6. The job `go_test_and_coverage` has 6 steps. The 1st step is named `Checkout Repositary`. The 2nd step is named `Setup Go` and its id is `go`. The 3rd step is named `Get Dependencies`. The 4th step is named `Show Environments`. The 5th step is named `Test and Generate Coverage Report`. The 6th step is named `Upload Coverage to Codecov`. "}
{"id": "63c495297843b61269a05d37", "level": "level4", "llm_response": "```yaml\nname: pr\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  release:\n    id: release\n    uses: the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main\n    with:\n      npmTag: alpha\n      buildScript: build\n      nodeVersion: 18\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n      npmToken: ${{ secrets.NPM_TOKEN }}\n\n  algolia:\n    id: algolia\n    uses: the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main\n    with:\n      domain: https://www.the-guild.dev/graphql/shield/\n      source: Shield\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: pr\non:\n  pull_request:\n\njobs:\n  release:\n    uses: the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main\n    with:\n      npmTag: alpha\n      buildScript: build\n      nodeVersion: 18\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n      npmToken: ${{ secrets.NPM_TOKEN }}\n\n\n  algolia:\n    uses: the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main\n    with:\n      domain: https://www.the-guild.dev/graphql/shield/\n      source: 'Shield'\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `pr` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The job id of the 1st job is `release`. This job will call a reusable workflow located at `the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main`. The job will pass 4 inputs to the called workflow: the input `npmTag` is `alpha`, the input `buildScript` is `build`, the input `nodeVersion` is `18` and the input `packageManager` is `pnpm`. The job will pass 2 secrets to the called workflow: the secret `githubToken` is `${{ secrets.GITHUB_TOKEN }}` and the secret `npmToken` is `${{ secrets.NPM_TOKEN }}`. The job id of the 2nd job is `algolia`. This job will call a reusable workflow located at `the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main`. The job will pass 3 inputs to the called workflow: the input `domain` is `https://www.the-guild.dev/graphql/shield/`, the input `source` is `Shield` and the input `packageManager` is `pnpm`. The job will pass a secret to the called workflow: the secret `githubToken` is `${{ secrets.GITHUB_TOKEN }}`. "}
{"id": "63c4959c7843b61269a08c2d", "level": "level4", "llm_response": "```yaml\nname: Rust Workflow\n\non:\n  push:\n    paths:\n      - .github/workflows/install.yml\n  schedule:\n    - cron: '17 0 * * 1'\n\npermissions:\n  contents: read\n\njobs:\n  cargo-install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: cargo install\n```", "answer": "```yaml permissions:\n  contents: read\n\non:\n  push:\n    paths:\n      - \".github/workflows/install.yml\"\n  schedule:\n    - cron: \"17 0 * * 1\"\n\njobs:\n  cargo-install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: |\n          cargo install cargo-mutants\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/install.yml), the workflow runs. 2) the scheduled time has come: at 12:17 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `cargo-install`. This job will run on ubuntu-latest runner. The job `cargo-install` has one step. The 1st step is named `cargo-install`. "}
{"id": "63c4968e1899db58864d3b1c", "level": "level4", "llm_response": "```yaml\nname: HTML5 check\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\njobs:\n  HTML5-check:\n    uses: easystats/workflows/.github/workflows/html-5-check.yaml@main\n```", "answer": "```yaml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n\nname: HTML5 check\n\njobs:\n  HTML5-check:\n    uses: easystats/workflows/.github/workflows/html-5-check.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `HTML5 check` for a GitHub repository whose primary programming language is R. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch named master. The workflow has one job. The job id of the 1st job is `HTML5-check`. This job will call a reusable workflow located at `easystats/workflows/.github/workflows/html-5-check.yaml@main`. "}
{"id": "63c496861e3364807577b31b", "level": "level4", "llm_response": "```yaml\nname: license-check\n\non:\n  pull_request:\n\njobs:\n  license:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Check License Header\n      run: cargo license --check\n```", "answer": "```yaml name: license-check\non: pull_request\njobs:\n  license:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Check License Header\n      uses: apache/skywalking-eyes/header@501a28d2fb4a9b962661987e50cf0219631b32ff\n```", "prompt": "Generate a GitHub Workflow named `license-check` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `license`. This job will run on ubuntu-latest runner. The job `license` has 2 steps. The 1st step is named ``. The 2nd step is named `Check License Header`. "}
{"id": "63c4962c6fc19abdf9c9a4e3", "level": "level4", "llm_response": "```yaml\nname: Continuous integration\n\non:\n  push:\n    branches: [ develop, master ]\n  pull_request:\n    branches: [ develop, master ]\n  repository_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:14-alpine\n        env:\n          POSTGRES_PASSWORD: postgres\n        ports:\n          - 5432:5432\n      redis:\n        image: redis:alpine\n        ports:\n          - 6379:6379\n      opensearch:\n        image: opensearchproject/opensearch:latest\n        env:\n          discovery.type: single-node\n          plugins.security.disabled: True\n        ports:\n          - 9200:9200\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n      - name: Lint with RuboCop\n        run: bundle exec rubocop\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install Node modules\n        run: npm install\n      - name: Run ESLint\n        run: npm run lint\n      - name: Run Tests\n        run: bundle exec rspec\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: test\n    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v1\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      - name: Build, push and deploy the LATEST image\n        run: |\n          docker build -t ghcr.io/${{ github.repository }}/latest:latest .\n          docker push ghcr.io/${{ github.repository }}/latest:latest\n      - name: Build and push the STABLE image\n        run: |\n          docker build -t ghcr.io/${{ github.repository }}/stable:$(git rev-parse --short HEAD) .\n          docker push ghcr.io/${{ github.repository }}/stable:$(git rev-parse --short HEAD)\n```", "answer": "```yaml name: Continuous integration\non: push\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:14-alpine\n        ports: [\"5432:5432\"]\n        env:\n          POSTGRES_PASSWORD: postgres\n\n      redis:\n        image: redis:alpine\n        ports: [\"6379:6379\"]\n\n      opensearch:\n        image: opensearchproject/opensearch:latest\n        ports: [\"9200:9200\"]\n        env:\n          discovery.type: single-node\n          plugins.security.disabled: true\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          bundler-cache: true\n\n      - name: Lint with RuboCop\n        run: bundle exec rubocop --parallel\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3.5.1\n        with:\n          cache: yarn\n\n      - name: Install Node modules\n        run: bin/yarn install --frozen-lockfile\n\n      - name: Run ESLint\n        run: bin/yarn lint\n\n      - name: Run Tests\n        env:\n          DB_HOST: localhost\n          DB_USER: postgres\n          DB_PASSWORD: postgres\n          RAILS_ENV: test\n          SECRET_KEY_BASE: we-dont-need-a-secret-here\n          APP_ADMIN_EMAIL: admin@example.org\n          APP_ADMIN_PASSWORD: secret\n          APP_EMAIL: reply@example.org\n          APP_HOST: example.org\n          AWS_ACCESS_KEY_ID: my-access-key\n          AWS_SECRET_ACCESS_KEY: my-secret\n          AWS_BUCKET: my-bucket\n          AWS_REGION: eu-central-1\n          CI: true\n        run: |\n          bundle exec rake assets:precompile\n          bundle exec rake db:create db:schema:load\n          bundle exec rake spec\n\n  deploy:\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'\n    needs: test\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build, push and deploy the LATEST image\n        if: github.ref == 'refs/heads/develop'\n        run: |\n          export COMMIT_TIME=$(git show -s --format=%cD ${GITHUB_SHA})\n          export COMMIT_SHA=${GITHUB_SHA}\n          docker buildx build --build-arg COMMIT_TIME --build-arg COMMIT_SHA -t ghcr.io/ledermann/docker-rails/docker-rails:latest .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:latest\n          curl -X POST ${{ secrets.DEPLOY_HOOK_APP }}\n          curl -X POST ${{ secrets.DEPLOY_HOOK_WORKER }}\n\n      - name: Build and push the STABLE image\n        if: github.ref == 'refs/heads/master'\n        run: |\n          docker buildx build -t ghcr.io/ledermann/docker-rails/docker-rails:stable .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:stable\n```", "prompt": "Generate a GitHub Workflow named `Continuous integration` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The job id of the 1st job is `test`. This job will run on ubuntu-latest runner. The job defines a service called postgres which will be created using the Docker image `postgres:14-alpine`. The service container sets an environment variable to use: `POSTGRES_PASSWORD` is set to `postgres`. For communication, the port 5432 on the Docker host is mapped to port 5432 on the service container. The job defines a service called redis which will be created using the Docker image `redis:alpine`. For communication, the port 6379 on the Docker host is mapped to port 6379 on the service container. The job defines a service called opensearch which will be created using the Docker image `opensearchproject/opensearch:latest`. The service container sets 2 environment variables to use: `discovery.type` is set to `single-node` and `plugins.security.disabled` is set to `True`. For communication, the port 9200 on the Docker host is mapped to port 9200 on the service container. The job `test` has 7 steps. The 1st step is named ``. The 2nd step is named `Set up Ruby`. The 3rd step is named `Lint with RuboCop`. The 4th step is named `Setup Node.js`. The 5th step is named `Install Node modules`. The 6th step is named `Run ESLint`. The 7th step is named `Run Tests`. The job id of the 2nd job is `deploy`. Before this job runs, `test` must complete successfully. This job will run only if the condition(github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master') is met. This job will run on ubuntu-latest runner. The job `deploy` has 4 steps. The 1st step is named ``. The 2nd step is named `Login to GitHub Container Registry`. The 3rd step is named `Build, push and deploy the LATEST image`. The 4th step is named `Build and push the STABLE image`. "}
{"id": "63c495707843b61269a07a00", "level": "level4", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '23 20 * * 1'\n  push:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n    permissions:\n      security-events: write\n      id-token: write\n      actions: read\n      contents: read\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run analysis\n        run: |\n          # Add your analysis command here\n      - name: Upload artifact\n        uses: actions/upload-artifact@v2\n        with:\n          name: analysis-results\n          path: results\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@v1\n        with:\n          sarif_file: results.sarif\n```", "answer": "```yaml name: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '43 20 * * 1'\n  push:\n    branches: [ master ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      # Used to receive a badge. (Upcoming feature)\n      id-token: write\n      actions: read\n      contents: read\n    \n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@a12a3943b4bdde767164f792f33f40b04645d846 # v3.0.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@3e15ea8318eee9b333819ec77a36aca8d39df13e # v1.1.1\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # (Optional) Read-only PAT token. Uncomment the `repo_token` line below if:\n          # - you want to enable the Branch-Protection check on a *public* repository, or\n          # - you are installing Scorecards on a *private* repository\n          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action#authentication-with-pat.\n          # repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n\n          # Publish the results for public repositories to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results. \n          # For private repositories, `publish_results` will automatically be set to `false`, regardless \n          # of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF\n      # format to the repository Actions tab.\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8 # v3.1.0\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n      \n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 08:43 pm, only on monday. 3) The workflow would run whenever there is a push event to: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. This job will run on ubuntu-latest runner. The job `analysis` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `security-events` scope, write access is granted to the GITHUB_TOKEN in the `id-token` scope, read access is granted to the GITHUB_TOKEN in the `actions` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. "}
{"id": "63c495c68052faa2781b4231", "level": "level4", "llm_response": "```yaml\nname: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n    repositories:\n      - your-repository-name\n\njobs:\n  pullRequestHandler:\n    id: pullRequestHandler\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Pull Request Validation\n        run: |\n          # Add your PowerShell validation script here\n```", "answer": "```yaml name: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pullRequestHandler:\n    name: Pull Request Validator\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Pull Request Validation\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: startsWith(github.event.comment.body, '/verify')\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          SKIP_UPDATED: '1'\n```", "prompt": "Generate a GitHub Workflow named `Commented Pull Request` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The 1st job is named `Pull Request Validator` and its job id is `pullRequestHandler`. This job will run on windows-latest runner. The job `pullRequestHandler` has 2 steps. The 1st step is named ``. The 2nd step is named `Pull Request Validation`. "}
{"id": "63c4969e1899db58864d41ef", "level": "level4", "llm_response": "```yaml\nname: Auto message on pr merge\n\non:\n  pull_request:\n    types: [closed]\n\njobs:\n  auto-response:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Auto response on PR merge\n      run: echo \"PR has been merged. Thank you for your contribution!\"\n```", "answer": "```yaml name: Auto message on pr merge\n\non:\n\n  pull_request_target:\n\n    types: [closed]\n\njobs:\n\n  auto-response:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - uses: derekprior/add-autoresponse@master\n\n      env:\n\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      with:\n\n        respondableId: ${{ github.event.pull_request.node_id }}\n\n        response: \"Thank you @${{ github.event.pull_request.user.login }} for taking out your valuable time in order to contribute to our project. Looking forward for more such amazing contributions :).\"\n\n        author: ${{ github.event.pull_request.user.login }}\n\n        exemptedAuthors: \"Amit366\"\n```", "prompt": "Generate a GitHub Workflow named `Auto message on pr merge` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a pull request is closed. The workflow has one job. The job id of the 1st job is `auto-response`. This job will run on ubuntu-latest runner. The job `auto-response` has one step. The 1st step is named ``. "}
{"id": "63c4966b33b087f6bde2bde4", "level": "level4", "llm_response": "```yaml\nname: tests\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    runs-on: ${{ matrix.os }}\n\n    strategy:\n      matrix:\n        name: [3.11-dev, Linux, Windows, Mac, 3.9, PyPy]\n        python: [3.11-dev, 3.10, 3.10, 3.10, 3.9, pypy-3.9]\n        os: [ubuntu-latest, ubuntu-latest, windows-latest, macos-latest, ubuntu-latest, ubuntu-latest]\n        tox: [py311, py310, py310, py310, py39, pypy39]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python ${{ matrix.python }}\n        uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python }}\n\n      - name: Install system dependencies\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y build-essential libssl-dev zlib1g-dev libncurses5-dev libncursesw5-dev libreadline-dev libsqlite3-dev libgdbm-dev libdb5.3-dev libbz2-dev libexpat1-dev liblzma-dev tk-dev libffi-dev\n\n      - name: Update pip\n        run: python -m pip install --upgrade pip\n\n      - name: Install dependencies\n        run: pip install tox\n\n      - name: Run tests\n        run: tox -e ${{ matrix.tox }}\n```", "answer": "```yaml name: tests\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    name: ${{ matrix.name }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - {name: '3.11-dev', python: '3.11-dev', os: ubuntu-latest, tox: py311}\n          - {name: Linux, python: '3.10', os: ubuntu-latest, tox: py310}\n          - {name: Windows, python: '3.10', os: windows-latest, tox: py310}\n          - {name: Mac, python: '3.10', os: macos-latest, tox: py310}\n          - {name: '3.9', python: '3.9', os: ubuntu-latest, tox: py39}\n          - {name: 'PyPy', python: 'pypy-3.9', os: ubuntu-latest, tox: pypy39}\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python }}\n      - name: install system dependencies\n        run: sudo apt-get install libxml2-dev libxslt1-dev --yes\n        if: ${{ matrix.python == '3.11-dev' }}\n      - name: update pip\n        run: |\n          pip install -U wheel\n          pip install -U setuptools\n          python -m pip install -U pip\n      - run: pip install tox\n      - run: tox -e ${{ matrix.tox }}\n```", "prompt": "Generate a GitHub Workflow named `tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named develop. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `tests`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. For each object in the [{'name': '3.11-dev', 'python': '3.11-dev', 'os': 'ubuntu-latest', 'tox': 'py311'}, {'name': 'Linux', 'python': '3.10', 'os': 'ubuntu-latest', 'tox': 'py310'}, {'name': 'Windows', 'python': '3.10', 'os': 'windows-latest', 'tox': 'py310'}, {'name': 'Mac', 'python': '3.10', 'os': 'macos-latest', 'tox': 'py310'}, {'name': '3.9', 'python': '3.9', 'os': 'ubuntu-latest', 'tox': 'py39'}, {'name': 'PyPy', 'python': 'pypy-3.9', 'os': 'ubuntu-latest', 'tox': 'pypy39'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `tests` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `install system dependencies`. The 4th step is named `update pip`. The 5th step is named ``. The 6th step is named ``. "}
{"id": "63c495c88052faa2781b42d4", "level": "level4", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        language: [java]\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: ${{ matrix.language }}\n      - name: CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        queries: security-and-quality,security-extended\n\n    # Autobuild failed (OOM)\n    # Hence, supply memory args for gradle build\n    - run: |\n        JAVA_OPTS=\"-Xmx1000M\" ./gradlew --no-scan compileJava\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. When all the path names of pull_request event match patterns in the paths-ignore filter(**/*.json, **/*.md, **/*.properties or **/*.txt), the workflow will not run. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has one value: java. The job `analyze` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `actions` scope, read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `security-events` scope. This permission setting only applies to the job `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named ``. The 4th step is named `Perform CodeQL Analysis`. "}
{"id": "63c495e48052faa2781b4f0b", "level": "level4", "llm_response": "```yaml\nname: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n\ninputs:\n  from-this:\n    description: 'Generate from this release/commit'\n    required: false\n    default: ''\n  to-this:\n    description: 'Generate until this release/commit'\n    required: false\n    default: 'HEAD'\n\njobs:\n  generate-changelog:\n    if: github.repository_owner == 'Mudlet'\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v2\n\n    - name: Install Lua 5.1.5\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y lua5.1\n\n    - name: Install Luarocks\n      run: |\n        wget https://luarocks.org/releases/luarocks-3.8.0.tar.gz\n        tar -xzf luarocks-3.8.0.tar.gz\n        cd luarocks-3.8.0\n        ./configure --prefix=/usr/local\n        make build\n        sudo make install\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install lua-cjson\n        luarocks install luasocket\n\n    - name: Calculate from and to releases\n      run: |\n        echo \"from=${{ github.event.inputs.from-this }}\" >> $GITHUB_ENV\n        echo \"to=${{ github.event.inputs.to-this }}\" >> $GITHUB_ENV\n\n    - name: Generate changelog\n      run: |\n        lua generate_changelog.lua ${{ env.from }} ${{ env.to }}\n\n    - name: Upload changelog as html\n      uses: actions/upload-artifact@v2\n      with:\n        name: changelog.html\n        path: changelog.html\n```", "answer": "```yaml name: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n    inputs:\n      from:\n        description: 'Generate from this release/commit (defaults to the latest release)'\n        required: false\n        # default is calculated dynamically\n      to:\n        description: 'Generate until this release/commit (defaults to latest development)'\n        required: false\n        default: 'HEAD'\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n    if: ${{ github.repository_owner == 'Mudlet' }}\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Install Lua 5.1.5\n      uses: leafo/gh-actions-lua@v9\n      with:\n        luaVersion: \"5.1.5\"\n\n    - name: Install Luarocks\n      uses: leafo/gh-actions-luarocks@v4\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install argparse\n        luarocks install lunajson\n\n    - name: Calculate from and to releases\n      run: |\n        if [[ -z \"${{ github.event.inputs.from }}\" ]] ; then\n            FROM_RELEASE=$(git tag --sort=committerdate | tail -1)\n        else\n            FROM_RELEASE=${{ github.event.inputs.from }}\n        fi\n\n        if [[ -z \"${{ github.event.inputs.to }}\" ]] ; then\n            TO_RELEASE=\"HEAD\"\n        else\n            TO_RELEASE=${{ github.event.inputs.to }}\n        fi\n\n        echo \"Generating a changelog from $FROM_RELEASE until $TO_RELEASE\"\n\n        echo \"FROM_RELEASE=$FROM_RELEASE\" >> $GITHUB_ENV\n        echo \"TO_RELEASE=$TO_RELEASE\" >> $GITHUB_ENV\n\n    - name: Generate changelog\n      run: |\n        changelog=$(lua CI/generate-changelog.lua -m release --start-commit $FROM_RELEASE --end-commit $TO_RELEASE)\n        echo \"$changelog\" >> changelog.html\n\n        echo \"[INFO] Changelog generated (from $FROM_RELEASE to $TO_RELEASE). If it's too big, Github won't show it, so it's available as an artifact as well at: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts\"\n        echo \"[INFO] Changelog is:\"\n        echo $changelog\n\n    - name: Upload changelog as html\n      uses: actions/upload-artifact@v3\n      with:\n        name: changelog.html\n        path: changelog.html\n```", "prompt": "Generate a GitHub Workflow named `Generate a changelog` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am. 2) someone manually triggers the workflow. This workflow receives 2 inputs: from-this input represents generate from this release/commit (defaults to the latest release) and it is optional; to-this input represents generate until this release/commit (defaults to latest development), it is optional and its default value is HEAD. The workflow has one job. The job id of the 1st job is `generate-changelog`. This job will run only if the condition(${{ github.repository_owner == 'Mudlet' }}) is met. This job will run on ubuntu-latest runner. The job `generate-changelog` has 7 steps. The 1st step is named `Checkout Mudlet repository`. The 2nd step is named `Install Lua 5.1.5`. The 3rd step is named `Install Luarocks`. The 4th step is named `Install Lua dependencies`. The 5th step is named `Calculate from and to releases`. The 6th step is named `Generate changelog`. The 7th step is named `Upload changelog as html`. "}
{"id": "63c494347843b612699ffa9f", "level": "level4", "llm_response": "```yaml\nname: Release Charts\n\non:\n  push:\n    tags:\n      - 'chart-v*'\n\njobs:\n  build:\n    runs-on: ubuntu-20.04\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n      - name: Set up Helm\n        uses: helm/helm-github-action@v0.12.0\n      - name: Check chart version\n        run: helm version\n      - name: Packaging the chart\n        run: helm package .\n      - name: Upload package to GitHub releases\n        uses: softprops/action-gh-release@v1\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          files: '*.tgz'\n\n  publish:\n    runs-on: ubuntu-20.04\n    needs: build\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n      - name: Set up Helm\n        uses: helm/helm-github-action@v0.12.0\n      - name: Update charts index\n        run: helm repo index charts\n      - name: Check diffs\n        run: git diff --cached charts\n      - name: Commit changes\n        run: git commit -m \"Update charts index\" charts\n      - name: Push to gh-pages\n        run: git push origin gh-pages\n```", "answer": "```yaml name: Release Charts\n\non:\n  push:\n    tags:\n      - 'chart-v*'\n\njobs:\n  build:\n    runs-on: ubuntu-20.04\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - name: Check chart version\n        run: |\n          tag_version=${GITHUB_REF##*/chart-v}\n          chart_version=$(cat charts/moco/Chart.yaml | grep 'version:' | sed 's/version:\\s//')\n          if [ \"$tag_version\" != \"$chart_version\" ]; then\n            echo \"Different versions: tag \\\"$tag_version\\\", chart \\\"$chart_version\\\"\"\n            exit 1\n          fi\n      - name: Packaging the chart\n        run: helm package ./charts/moco/\n\n      - uses: actions/upload-artifact@v3\n        with:\n          name: helm-charts\n          path: ./moco-*.tgz\n          retention-days: 1\n\n  publish:\n    name: Publish charts on GitHub Pages\n    runs-on: ubuntu-20.04\n    needs: build\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: gh-pages\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - uses: actions/download-artifact@v3\n        with:\n          name: helm-charts\n\n      - name: Update charts index\n        run: helm repo index --url https://cybozu-go.github.io/moco/ --merge index.yaml .\n\n      - run: git add .\n\n      - name: Check diffs\n        run: |\n          diffs=$(git status -s)\n          if [ \"$diffs\" = \"\" ]; then\n            echo \"NO_DIFF=1\" >> $GITHUB_ENV\n          else\n            printf \"%s\\n\" \"$diffs\"\n          fi\n      - name: Commit changes\n        if: env.NO_DIFF != '1'\n        run: |\n          git config --global user.name 'Cybozu Neco'\n          git config --global user.email 'cybozu-neco@users.noreply.github.com'\n          git commit -m 'update'\n      - name: Push to gh-pages\n        if: env.NO_DIFF != '1'\n        run: git push origin gh-pages\n```", "prompt": "Generate a GitHub Workflow named `Release Charts` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches chart-v*. The workflow has 2 jobs. The job id of the 1st job is `build`. This job will run on ubuntu-20.04 runner. The job `build` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Helm`. The 3rd step is named `Check chart version`. The 4th step is named `Packaging the chart`. The 5th step is named ``. The 2nd job is named `Publish charts on GitHub Pages` and its job id is `publish`. Before this job runs, `build` must complete successfully. This job will run on ubuntu-20.04 runner. The job `publish` has 8 steps. The 1st step is named ``. The 2nd step is named `Set up Helm`. The 3rd step is named ``. The 4th step is named `Update charts index`. The 5th step is named ``. The 6th step is named `Check diffs`. The 7th step is named `Commit changes`. The 8th step is named `Push to gh-pages`. "}
{"id": "63c495ca8052faa2781b43be", "level": "level4", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      \n      - name: Bump version and push tag\n        id: tagging\n        uses: conda-incubator/action-semantic-version@v2\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n      \n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v1\n      \n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n      \n      - name: Login to DockerHub\n        uses: docker/login-action@v1\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_PASSWORD }}\n      \n      - name: Login to Quay.io\n        uses: quay-io/quay-action@v1\n        with:\n          username: ${{ secrets.QUAY_USERNAME }}\n          password: ${{ secrets.QUAY_PASSWORD }}\n      \n      - name: Build and push\n        id: docker_build\n        run: |\n          docker build -t your-docker-image-name .\n          docker push your-docker-image-name\n      \n      - name: Build Changelog\n        id: build_changelog\n        run: |\n          echo \"Generating changelog...\"\n      \n      - name: Create Github Release\n        run: |\n          echo \"Creating release...\"\n```", "answer": "```yaml name: Release\non:\n  push:\n    branches:\n      - master\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: '0'\n      - name: Bump version and push tag\n        id: tagging\n        uses: anothrNick/github-tag-action@1.52.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          INITIAL_VERSION: 1.0.0\n          DEFAULT_BUMP: none\n      -\n        name: \"Set up QEMU\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-qemu-action@v2\n      -\n        name: \"Set up Docker Buildx\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-buildx-action@v2\n      -\n        name: \"Login to DockerHub\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      -\n        name: \"Login to Quay.io\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          registry: quay.io\n          username: ${{ secrets.QUAY_BOT_USERNAME }}\n          password: ${{ secrets.QUAY_BOT_PASSWORD }}\n      -\n        name: \"Build and push\"\n        if: steps.tagging.outputs.part\n        id: docker_build\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          platforms: linux/amd64,linux/arm64,linux/arm/v7,linux/ppc64le,linux/s390x\n          tags: |\n            docker.io/kiwigrid/k8s-sidecar:latest\n            docker.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n            quay.io/kiwigrid/k8s-sidecar:latest\n            quay.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n      - name: \"Build Changelog\"\n        if: steps.tagging.outputs.part\n        id: build_changelog\n        uses: mikepenz/release-changelog-builder-action@v3\n        with:\n          configuration: \".github/workflows/release-notes-config.json\"\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      - name: \"Create Github Release\"\n        if: steps.tagging.outputs.part\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token\n        with:\n          tag_name: ${{ steps.tagging.outputs.tag }}\n          release_name: v${{ steps.tagging.outputs.tag }}\n          body: ${{ steps.build_changelog.outputs.changelog }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 9 steps. The 1st step is named ``. The 2nd step is named `Bump version and push tag` and its id is `tagging`. The 3rd step is named `Set up QEMU`. The 4th step is named `Set up Docker Buildx`. The 5th step is named `Login to DockerHub`. The 6th step is named `Login to Quay.io`. The 7th step is named `Build and push` and its id is `docker_build`. The 8th step is named `Build Changelog` and its id is `build_changelog`. The 9th step is named `Create Github Release`. "}
{"id": "63c494007843b612699fe516", "level": "level4", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches: [ main ]\n    tags: [ '*' ]\n  repository_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-20.04\n    strategy:\n      matrix:\n        py: [3.7]\n        pylint: ['==2.9.6']\n        go: [1.18, 1.19]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Install pylint\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y python3-pip\n        pip3 install ${{ matrix.pylint }}\n\n    - name: pylint\n      run: pylint .\n\n    - name: Run tests\n      run: go test -v ./...\n\n    - name: Build for darwin\n      run: GOOS=darwin GOARCH=amd64 go build -o myapp\n\n    - name: Run integration tests\n      run: go test -v ./integration\n\n  bazel:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Go\n      id: setup_go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.19'\n\n    - name: Show bazel variables\n      run: echo $BAZEL_VERSION\n\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v2\n      with:\n        path: ${{ steps.setup_go.outputs.bazel_cache_dir }}\n        key: ${{ runner.os }}-bazel-${{ hashFiles('**/WORKSPACE') }}\n        restore-keys: |\n          ${{ runner.os }}-bazel-\n\n    - name: Cache bazel external repositories\n      uses: actions/cache@v2\n      with:\n        path: ${{ steps.setup_go.outputs.bazel_cache_dir }}\n        key: ${{ runner.os }}-bazel-${{ hashFiles('**/WORKSPACE') }}\n        restore-keys: |\n          ${{ runner.os }}-bazel-\n\n    - name: Test\n      run: bazel test //...\n\n    - name: Show build timing summary\n      run: bazel info build --color=no\n```", "answer": "```yaml name:\n  Test\n\non:\n  push\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-20.04\n    strategy:\n      matrix:\n        py: [\"3.7\"]\n        pylint: [\"==2.9.6\"]\n        go: [ \"1.18\", \"1.19\" ]\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.py }}\n    - name: Install pylint\n      run: pip install --user pylint${{ matrix.pylint }}\n    - name: pylint\n      run: |\n        pylint adapters/python/martian_shell.py\n        pylint adapters/python/martian.py\n        pylint test/martian_test.py\n    - uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n    - uses: actions/setup-node@v3\n      with:\n        node-version: \"lts/*\"\n        cache: \"npm\"\n        cache-dependency-path: |\n          web/martian/yarn.lock\n          tools/syntax/vscode/yarn.lock\n    - name: make all\n      run: make all tarball\n    - name: darwin build\n      run: GOOS=darwin go build ./cmd/...\n    - name: Integration tests\n      run: make longtests\n\n  bazel:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: \"3.x\"\n    - uses: actions/setup-go@v3\n      id: setup_go\n      with:\n        go-version: \">=1.19\"\n    - name: Show bazel variables\n      run: |\n        bazel info\n        echo \"bazel_repository_cache=$(bazel info repository_cache)\" >> $GITHUB_ENV\n        echo \"bazel_output_base=$(bazel info output_base)\" >> $GITHUB_ENV\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_output_base }}/external\n        key: bazel-build-cache-${{steps.setup_go.outputs.go-version}}-${{hashFiles('deps.bzl', 'WORKSPACE')}}\n        restore-keys: |\n          bazel-build-cache-${{steps.setup_go.outputs.go-version}}\n          bazel-build-cache-\n    - name: Cache bazel external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_repository_cache }}\n        key: bazel-repo-cache-${{hashFiles('deps.bzl', 'WORKSPACE', 'web/martian/yarn.lock')}}\n        restore-keys: |\n          bazel-repo-cache-\n    - name: test\n      run: |\n        bazel test --nobuild_tests_only \\\n                   --verbose_failures \\\n                   --discard_analysis_cache \\\n                   --notrack_incremental_state \\\n                   --nokeep_state_after_build \\\n                   //...\n    - name: Show build timing summary\n      run: bazel analyze-profile ${{ env.bazel_output_base }}/command.profile.gz\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `make`. This job will run on ubuntu-20.04 runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `py` has one value: 3.7. The variable `pylint` has one value: ==2.9.6. The variable `go` has 2 values: 1.18 and 1.19. The job `make` has 9 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Install pylint`. The 4th step is named `pylint`. The 5th step is named ``. The 6th step is named ``. The 7th step is named `make all`. The 8th step is named `darwin build`. The 9th step is named `Integration tests`. The job id of the 2nd job is `bazel`. This job will run on ubuntu-latest runner. The job `bazel` has 8 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `` and its id is `setup_go`. The 4th step is named `Show bazel variables`. The 5th step is named `Cache bazel build of external repositories`. The 6th step is named `Cache bazel external repositories`. The 7th step is named `test`. The 8th step is named `Show build timing summary`. "}
{"id": "63c494257843b612699ff4b7", "level": "level4", "llm_response": "```yaml\nname: functional-identity\n\non:\n  pull_request:\n    paths:\n      - identity/**\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-identity:\n    id: functional-identity\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    strategy:\n      matrix:\n        name: [master]\n        openstack_version: [master]\n        ubuntu_version: [20.04]\n        include:\n          - name: yoga\n            openstack_version: stable/yoga\n          - name: xena\n            openstack_version: stable/xena\n          - name: wallaby\n            openstack_version: stable/wallaby\n          - name: victoria\n            openstack_version: stable/victoria\n          - name: ussuri\n            openstack_version: stable/ussuri\n            ubuntu_version: 18.04\n          - name: train\n            openstack_version: stable/train\n            ubuntu_version: 18.04\n\n    steps:\n      - name: Checkout Gophercloud\n        run: git clone https://github.com/gophercloud/gophercloud.git\n\n      - name: Deploy devstack\n        run: echo \"Deploying devstack\"\n\n      - name: Checkout go\n        run: git clone https://github.com/golang/go.git\n\n      - name: Run Gophercloud acceptance tests\n        run: echo \"Running Gophercloud acceptance tests\"\n\n      - name: Generate logs on failure\n        if: failure()\n        run: echo \"Generating logs on failure\"\n\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v2\n        with:\n          name: logs\n          path: logs\n```", "answer": "```yaml name: functional-identity\non:\n  pull_request:\n    paths:\n      - '**identity**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-identity:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: \"^.*identity.*$\"\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-identity-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-identity` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**identity**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests` and its job id is `functional-identity`. This job will run on ubuntu-${{ matrix.ubuntu_version }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `name` has one value: master. The variable `openstack_version` has one value: master. The variable `ubuntu_version` has one value: 20.04. For each object in the [{'name': 'yoga', 'openstack_version': 'stable/yoga', 'ubuntu_version': '20.04'}, {'name': 'xena', 'openstack_version': 'stable/xena', 'ubuntu_version': '20.04'}, {'name': 'wallaby', 'openstack_version': 'stable/wallaby', 'ubuntu_version': '20.04'}, {'name': 'victoria', 'openstack_version': 'stable/victoria', 'ubuntu_version': '20.04'}, {'name': 'ussuri', 'openstack_version': 'stable/ussuri', 'ubuntu_version': '18.04'}, {'name': 'train', 'openstack_version': 'stable/train', 'ubuntu_version': '18.04'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `functional-identity` has 6 steps. The 1st step is named `Checkout Gophercloud`. The 2nd step is named `Deploy devstack`. The 3rd step is named `Checkout go`. The 4th step is named `Run Gophercloud acceptance tests`. The 5th step is named `Generate logs on failure`. The 6th step is named `Upload logs artifacts on failure`. "}
{"id": "63c495038052faa2781aede6", "level": "level4", "llm_response": "```yaml\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n        numpy_version: [\">=1.22.0\", \"==1.20.*\"]\n      exclude:\n        - python-version: 3.10\n          numpy_version: \"==1.20.*\"\n\n    services:\n      redis:\n        image: redis\n        ports:\n          - 6379:6379\n        options: --health-cmd \"redis-cli ping\" --health-interval 10s --health-timeout 5s --health-retries 5\n      mongodb:\n        image: mongo:4.4.11\n        ports:\n          - 27017:27017\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Setup Miniconda\n        uses: conda-incubator/setup-miniconda@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Create Conda environment with the right deps\n        run: conda create -n testenv python=${{ matrix.python-version }} numpy=${{ matrix.numpy_version }} -y\n\n      - name: Install dependencies\n        run: conda activate testenv && pip install -r requirements.txt\n\n      - name: Tests\n        run: conda activate testenv && pytest\n\n      - name: Cleanup\n        run: conda deactivate\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n        numpy_version: ['>=1.22.0', '==1.20.*']\n        exclude:\n          - python-version: '3.10'\n            numpy_version: '==1.20.*'\n    services:\n      redis:\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n      mongodb:\n        image: mongo:4.4.11\n        ports:\n          - 27017:27017\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Setup Miniconda\n      uses: conda-incubator/setup-miniconda@master\n      with:\n          channels: conda-forge\n          python-version: ${{ matrix.python-version }}\n      env:\n        ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n    # Runs a set of commands using the runners shell\n    - name: Create Conda environment with the rights deps\n      shell: \"bash -l {0}\"\n      run: |\n        conda create -n zarr-env python==${{matrix.python-version}} bsddb3 numcodecs lmdb pip nodejs flake8 mypy\n        conda activate zarr-env\n        npm install -g azurite\n    - name: Install dependencies\n      shell: \"bash -l {0}\"\n      run: |\n        conda activate zarr-env\n        python -m pip install --upgrade pip\n        python -m pip install -U pip setuptools wheel codecov line_profiler\n        python -m pip install -rrequirements_dev_minimal.txt numpy${{matrix.numpy_version}} -rrequirements_dev_optional.txt pymongo redis\n        python -m pip install .\n        python -m pip freeze\n    - name: Tests\n      shell: \"bash -l {0}\"\n      env:\n        COVERAGE_FILE: .coverage.${{matrix.python-version}}.${{matrix.numpy_version}}\n        ZARR_TEST_ABS: 1\n        ZARR_TEST_MONGO: 1\n        ZARR_TEST_REDIS: 1\n        ZARR_V3_EXPERIMENTAL_API: 1\n      run: |\n        conda activate zarr-env\n        mkdir ~/blob_emulator\n        azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n        pytest --cov=zarr --cov-config=.coveragerc --doctest-plus --cov-report xml --cov=./ --timeout=300\n    - uses: codecov/codecov-action@v3\n      with:\n        #token: ${{ secrets.CODECOV_TOKEN }} # not required for public repos\n          #files: ./coverage1.xml,./coverage2.xml # optional\n          #flags: unittests # optional\n          #name: codecov-umbrella # optional\n          #fail_ci_if_error: true # optional (default = false)\n        verbose: true # optional (default = false)\n```", "prompt": "Generate a GitHub Workflow named `Linux Testing` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `python-version` has 3 values: 3.8, 3.9 and 3.10. The variable `numpy_version` has 2 values: >=1.22.0 and ==1.20.*. If combinations of variables partially match one of the objects [{'python-version': '3.10', 'numpy_version': '==1.20.*'}], combinations should be excluded from the matrix. The job defines a service called redis which will be created using the Docker image `redis`. For communication, the port 6379 on the Docker host is mapped to port 6379 on the service container. It configures additional Docker container resource options: --health-cmd \"redis-cli ping\" --health-interval 10s --health-timeout 5s --health-retries 5. The job defines a service called mongodb which will be created using the Docker image `mongo:4.4.11`. For communication, the port 27017 on the Docker host is mapped to port 27017 on the service container. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named `Setup Miniconda`. The 3rd step is named `Create Conda environment with the rights deps`. The 4th step is named `Install dependencies`. The 5th step is named `Tests`. The 6th step is named ``. "}
{"id": "63c4967e33b087f6bde2c5c4", "level": "level4", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2\n\n      - name: Install and Build \ud83d\udd27\n        run: |\n          npm install\n          npm run build\n\n      - name: Deploy \ud83d\ude80\n        run: |\n          echo \"Deploying to production...\"\n          # Add deployment commands here\n```", "answer": "```yaml name: Build and Deploy\non:\n  push:\n    branches:\n    - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n        \n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install\n          npm run build\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.0.0\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist #  The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build-and-deploy`. This job will run on ubuntu-latest runner. The job `build-and-deploy` has 3 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install and Build \ud83d\udd27`. The 3rd step is named `Deploy \ud83d\ude80`. "}
{"id": "63c496926fc19abdf9c9cd93", "level": "level4", "llm_response": "```yaml\nname: Contributor License Agreement (CLA)\n\non:\n  pull_request:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.issue.pull_request && !github.event.issue.pull_request.merged_at && contains(github.event.comment.body, 'signed') || github.event.pull_request && !github.event.pull_request.merged }}\n    steps:\n      - name: Check CLA\n        run: |\n          # Add your CLA check logic here\n          echo \"Checking CLA...\"\n```", "answer": "```yaml name: Contributor License Agreement (CLA)\n\non:\n  pull_request_target:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    if: |\n      (github.event.issue.pull_request \n        && !github.event.issue.pull_request.merged_at\n        && contains(github.event.comment.body, 'signed')\n      ) \n      || (github.event.pull_request && !github.event.pull_request.merged)\n    steps:\n      - uses: Shopify/shopify-cla-action@v1\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          cla-token: ${{ secrets.CLA_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Contributor License Agreement (CLA)` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) a pull request is created or a pull request's head branch is updated. 2) a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `cla`. This job will run only if the condition((github.event.issue.pull_request \n  && !github.event.issue.pull_request.merged_at\n  && contains(github.event.comment.body, 'signed')\n) \n|| (github.event.pull_request && !github.event.pull_request.merged)\n) is met. This job will run on ubuntu-latest runner. The job `cla` has one step. The 1st step is named ``. "}
{"id": "63c496836fc19abdf9c9c720", "level": "level4", "llm_response": "```yaml\nname: TagBot\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Tag and push\n        run: |\n          git tag v$(date +%Y%m%d)\n          git push origin v$(date +%Y%m%d)\n```", "answer": "```yaml name: TagBot\non:\n  schedule:\n    - cron: 0 0 * * *\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `TagBot`. This job will run on ubuntu-latest runner. The job `TagBot` has one step. The 1st step is named ``. "}
{"id": "63c496741e3364807577abc2", "level": "level4", "llm_response": "```yaml\nname: TagBot\n\non:\n  issue_comment:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    steps:\n      - name: TagBot Step\n        run: echo \"Running TagBot step\"\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. This job will run only if the condition(github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot') is met. This job will run on ubuntu-latest runner. The job `TagBot` has one step. The 1st step is named ``. "}
{"id": "63c495f37843b61269a0b108", "level": "level4", "llm_response": "```yaml\nname: PR Approval Bypass Notifier\n\non:\n  pull_request:\n    branches:\n      - main\n    types: [closed]\n\npermissions:\n  pull-requests: read\n\njobs:\n  approval:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Fail If No Approval\n      run: |\n        if [ \"$PR_APPROVED\" != \"true\" ]; then\n          echo \"PR was not approved. Bypass not allowed.\"\n          exit 1\n        fi\n\n    - name: Slack Notification\n      run: |\n        echo \"PR has been closed and approved. Bypass successful.\"\n        # Add Slack notification logic here\n```", "answer": "```yaml name: PR Approval Bypass Notifier\non:\n  pull_request:\n    types:\n      - closed\n    branches:\n      - main\npermissions:\n  pull-requests: read\njobs:\n  approval:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Fail If No Approval\n        if: ${{ github.event.pull_request.merged }}\n        env:\n          AUTH_HEADER: 'Authorization: token ${{ secrets.GITHUB_TOKEN }}'\n          JSON_HEADER: 'Content-Type: application/json'\n          REVIEWS_URL: 'https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews'\n        run: |\n          curl -sSL -H \"${JSON_HEADER}\" -H \"${AUTH_HEADER}\" \"${REVIEWS_URL}\" \\\n            | jq -e '. | map({user: .user.login, state: .state})\n                       | reduce .[] as $x ({}; .[$x.user] = $x.state)\n                       | to_entries | map(.value)\n                       | contains([\"APPROVED\"]) and (contains([\"CHANGES_REQUESTED\"]) | not)'\n      - name: Slack Notification\n        if: ${{ failure() }}\n        run: |\n          jq --null-input '{ text: \"Oh no! The following PR was merged without approval: w${{github.event.pull_request.html_url}}\" }' \\\n          | curl -sSL -X POST -H 'Content-Type: application/json' -d @- '${{ secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK }}'\n```", "prompt": "Generate a GitHub Workflow named `PR Approval Bypass Notifier` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `approval`. This job will run on ubuntu-latest runner. The job `approval` has 2 steps. The 1st step is named `Fail If No Approval`. The 2nd step is named `Slack Notification`. "}
{"id": "63c496561e3364807577a06a", "level": "level4", "llm_response": "```yaml\nname: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '30 17 * * *'\n\nenv:\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: Step 4\n        run: echo \"Step 4\"\n```", "answer": "```yaml name: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"30 17 * * *\"\n#  push:\n#    branches:\n#      - main\n\nenv:\n  # please change to your own config.\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    name: Gather RQ statistical data and write it to google sheet\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n      - run: yarn\n      - run: yarn rq\n```", "prompt": "Generate a GitHub Workflow named `Gather RQ statistical data and write it to google sheet` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 05:30 pm. The workflow sets 11 environment variables to use: `RQ_COOKIE` is set to `${{ secrets.RQ_COOKIE }}`, `RQ_CSRF_TOKEN` is set to `${{ secrets.RQ_CSRF_TOKEN }}`, `RQ_USERID` is set to `${{ secrets.RQ_USERID }}`, `GOOGLE_SHEET_ID` is set to `${{ secrets.GOOGLE_SHEET_ID }}`, `GOOGLE_API_CLIENT_EMAIL` is set to `${{ secrets.GOOGLE_API_CLIENT_EMAIL }}`, `GOOGLE_API_PRIVATE_KEY` is set to `${{ secrets.GOOGLE_API_PRIVATE_KEY }}`, `BARK_KEY` is set to `${{ secrets.BARK_KEY }}`, `GARMIN_USERNAME` is set to `${{ secrets.GARMIN_USERNAME }}`, `GARMIN_PASSWORD` is set to `${{ secrets.GARMIN_PASSWORD }}`, `GARMIN_GLOBAL_USERNAME` is set to `${{ secrets.GARMIN_GLOBAL_USERNAME }}` and `GARMIN_GLOBAL_PASSWORD` is set to `${{ secrets.GARMIN_GLOBAL_PASSWORD }}`. The workflow has one job. The 1st job is named `Gather RQ statistical data and write it to google sheet` and its job id is `build`. This job will run on ubuntu-latest runner. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c4957d8052faa2781b22a0", "level": "level4", "llm_response": "```yaml\nname: Close stale\n\non:\n  schedule:\n    - cron: '0 1 * * *'\n\njobs:\n  stale:\n    id: stale\n    uses: knative/actions/.github/workflows/stale.yaml@main\n```", "answer": "```yaml # Copyright 2020 The Knative Authors.\n# SPDX-License-Identifier: Apache-2.0\n\n# This file is automagically synced here from github.com/knative-sandbox/knobots\nname: 'Close stale'\n\non:\n  schedule:\n  - cron: '0 1 * * *'\n\njobs:\n\n  stale:\n    uses: knative/actions/.github/workflows/stale.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `Close stale` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 01:00 am. The workflow has one job. The job id of the 1st job is `stale`. This job will call a reusable workflow located at `knative/actions/.github/workflows/stale.yaml@main`. "}
{"id": "63c4959f7843b61269a08d83", "level": "level4", "llm_response": "```yaml\nname: CompatHelper\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: [1.2.0]\n        julia-arch: [x86]\n        os: [ubuntu-latest]\n\n    steps:\n    - name: Pkg.add(\"CompatHelper\")\n      run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n\n    - name: CompatHelper.main()\n      run: julia -e 'using CompatHelper; CompatHelper.main()'\n```", "answer": "```yaml name: CompatHelper\n\non:\n  schedule:\n    - cron: '00 00 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: [1.2.0]\n        julia-arch: [x86]\n        os: [ubuntu-latest]\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n      - name: CompatHelper.main()\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          COMPATHELPER_PRIV: ${{ secrets.TAGBOT }}\n        run: julia -e 'using CompatHelper; CompatHelper.main()'\n```", "prompt": "Generate a GitHub Workflow named `CompatHelper` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `CompatHelper`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `julia-version` has one value: 1.2.0. The variable `julia-arch` has one value: x86. The variable `os` has one value: ubuntu-latest. The job `CompatHelper` has 2 steps. The 1st step is named `Pkg.add(\"CompatHelper\")`. The 2nd step is named `CompatHelper.main()`. "}
{"id": "63c494358052faa2781a9de3", "level": "level4", "llm_response": "```yaml\nname: JumpServer repos generic handler\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  release:\n    types: [ published ]\n\njobs:\n  generic_handler:\n    id: generic_handler\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml on: [push, pull_request, release]\n\nname: JumpServer repos generic handler\n\njobs:\n  generic_handler:\n    name: Run generic handler\n    runs-on: ubuntu-latest\n    steps:\n      - uses: jumpserver/action-generic-handler@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.PRIVATE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `JumpServer repos generic handler` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. 3) release activity in the repository occurs. The workflow has one job. The 1st job is named `Run generic handler` and its job id is `generic_handler`. This job will run on ubuntu-latest runner. The job `generic_handler` has one step. The 1st step is named ``. "}
{"id": "63c494998052faa2781ac05b", "level": "level4", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    branches: [ dev ]\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n    strategy:\n      matrix:\n        language: [java, javascript]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ dev ]\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java', 'javascript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://git.io/codeql-language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      run: |\n        cd etc/build\n        npm install workbox-cli@6.3.0 --global\n        ant\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 01:06 pm. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has 2 values: java and javascript. The job `analyze` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `actions` scope, read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `security-events` scope. This permission setting only applies to the job `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named `Perform CodeQL Analysis`. "}
{"id": "63c494298052faa2781a98fa", "level": "level4", "llm_response": "```yaml\nname: Check test times\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Cache\n      uses: actions/cache@v2\n      with:\n        path: ~/.cache\n        key: ${{ runner.os }}-cpp-${{ hashFiles('**/CMakeLists.txt') }}\n        restore-keys: |\n          ${{ runner.os }}-cpp-\n\n    - name: Setup\n      uses: actions/setup-cpp@v2\n      with:\n        cpp-version: '10'\n        architecture: 'x64'\n\n    - name: Build\n      run: cmake --build .\n\n    - name: Run tests\n      run: ctest --output-on-failure\n\n    - name: Save test times\n      run: |\n        echo \"::set-output name=test_times::$(cat /tmp/test_times.txt)\"\n\n    - name: Check test times\n      run: |\n        test_times=$(cat /tmp/test_times.txt)\n        if [ \"$test_times\" -gt 10 ]; then\n          echo \"Test times are too high: $test_times\"\n          exit 1\n        else\n          echo \"Test times are acceptable: $test_times\"\n        fi\n```", "answer": "```yaml name: Check test times\non: [push, pull_request]\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Cache\n      uses: hendrikmuhs/ccache-action@v1.2\n      with:\n        key: linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-${{ hashFiles('**/*.hpp', '**/*.cpp') }}\n        restore-keys: |\n          linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-\n          linux-ci-build-times-${{ github.ref }}-\n          linux-ci-build-times-refs/heads/master-\n          linux-ci-build-times-\n    - name: Setup\n      run: |\n        sudo apt update\n        sudo apt install -y libboost-dev autoconf automake libtool ccache\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"ccache gcc\" CXX=\"ccache g++\" CXXFLAGS=\"-O2 -g0\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,faster.xml:HRF,message -- --faster\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,fast.xml:HRF,message -- --fast\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,all.xml:HRF,message\n    - name: Save test times\n      uses: actions/upload-artifact@v3\n      with:\n        name: test-reports\n        path: ./all.xml\n    - name: Check test times\n      run: |\n        python ./tools/check_test_times.py\n```", "prompt": "Generate a GitHub Workflow named `Check test times` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check-test-times`. This job will run on ubuntu-latest runner. The job `check-test-times` has 7 steps. The 1st step is named ``. The 2nd step is named `Cache`. The 3rd step is named `Setup`. The 4th step is named `Build`. The 5th step is named `Run tests`. The 6th step is named `Save test times`. The 7th step is named `Check test times`. "}
{"id": "63c496981899db58864d3f6f", "level": "level4", "llm_response": "```yaml\nname: Re-run Workflow\n\non:\n  workflow_run:\n    workflows: [CI]\n    types: [completed]\n  pull_request:\n    types: [closed, labeled, unlabeled]\n  schedule:\n    - cron: '30 */3 * * *'\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    runs-on: ubuntu-latest\n    if: startsWith(github.repository, 'Homebrew/') && (\n      github.event.label.name == 'ci-requeue' ||\n      github.event.label.name == 'ci-retry' ||\n      github.event.label.name == 'ci-skip-appcast' ||\n      github.event.label.name == 'ci-skip-install' ||\n      github.event.label.name == 'ci-syntax-only' ||\n      !github.event.label.name\n    )\n    steps:\n      - name: Re-run CI workflow\n        run: |\n          # Add your commands here to re-run the CI workflow\n```", "answer": "```yaml name: Re-run Workflow\n\non:\n  workflow_run:\n    workflows:\n      - CI\n    types:\n      - completed\n  pull_request_target:\n    types:\n      - closed\n      - labeled\n      - unlabeled\n  schedule:\n    - cron: '30 */3 * * *' # every 3 hours (30 minutes past the hour)\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    if: >\n      startsWith(github.repository, 'Homebrew/') &&\n      (\n        github.event.label.name == 'ci-requeue' ||\n        github.event.label.name == 'ci-retry' ||\n        github.event.label.name == 'ci-skip-appcast' ||\n        github.event.label.name == 'ci-skip-install' ||\n        github.event.label.name == 'ci-syntax-only' ||\n        !github.event.label.name\n      )\n    runs-on: ubuntu-latest\n    steps:\n      - name: Re-run CI workflow\n        uses: reitermarkus/rerun-workflow@c8d5bc3526acb50c12004f31c0dcb1598c87e32d\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n          once-label: ci-requeue\n          continuous-label: ci-retry\n          trigger-labels: ci-skip-appcast,ci-skip-install,ci-syntax-only\n          workflow: ci.yml\n```", "prompt": "Generate a GitHub Workflow named `Re-run Workflow` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) the workflow named CI is completed. 2) a pull request is closed, a label is added to a pull request or a label is removed from a pull request. 3) the scheduled time has come: at 30 minutes past the hour, every 3 hours. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `rerun-workflow`. This job will run only if the condition(startsWith(github.repository, 'Homebrew/') && (\n  github.event.label.name == 'ci-requeue' ||\n  github.event.label.name == 'ci-retry' ||\n  github.event.label.name == 'ci-skip-appcast' ||\n  github.event.label.name == 'ci-skip-install' ||\n  github.event.label.name == 'ci-syntax-only' ||\n  !github.event.label.name\n)\n) is met. This job will run on ubuntu-latest runner. The job `rerun-workflow` has one step. The 1st step is named `Re-run CI workflow`. "}
{"id": "63c493bc7843b612699fd432", "level": "level4", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n  push:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n    - name: Install dependencies\n      run: npm install\n    - name: Run linting\n      run: npx xo\n\n  Build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n    - name: Install dependencies\n      run: npm install\n    - name: Build project\n      run: npm run build\n```", "answer": "```yaml env: {}\n\n# FILE GENERATED WITH: npx ghat fregante/ghatemplates/node\n# SOURCE: https://github.com/fregante/ghatemplates\n# OPTIONS: {\"exclude\":[\"jobs.Test\"]}\n\nname: CI\non:\n  - pull_request\n  - push\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n      - name: install\n        run: npm ci || npm install\n      - name: XO\n        run: npx xo\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: install\n        run: npm ci || npm install\n      - name: build\n        run: npm run build\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) a commit or tag is pushed, or a repository is cloned. The workflow has 2 jobs. The job id of the 1st job is `Lint`. This job will run on ubuntu-latest runner. The job `Lint` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `install`. The 4th step is named `XO`. The job id of the 2nd job is `Build`. This job will run on ubuntu-latest runner. The job `Build` has 3 steps. The 1st step is named ``. The 2nd step is named `install`. The 3rd step is named `build`. "}
{"id": "63c493f47843b612699fe037", "level": "level4", "llm_response": "```yaml\nname: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        branch: [master, 1.24, 1.23, 1.22]\n        channel: [latest/edge, 1.24, 1.23, 1.22]\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Update image list\n        run: |\n          # Add your script to update the image list here\n          echo \"Updating image list for branch ${{ matrix.branch }} and channel ${{ matrix.channel }}\"\n\n      - name: Create pull request\n        run: |\n          # Add your script to create a pull request here\n          echo \"Creating pull request for branch ${{ matrix.branch }} and channel ${{ matrix.channel }}\"\n```", "answer": "```yaml name: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"0 10 * * *\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        include:\n          - { branch: master, channel: latest/edge }\n          - { branch: 1.24, channel: 1.24 }\n          - { branch: 1.23, channel: 1.23 }\n          - { branch: 1.22, channel: 1.22 }\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ matrix.branch }}\n      - name: Update image list\n        run: |\n          ./build-scripts/update-images.sh ${{ matrix.channel }} build-scripts/images.txt\n      - name: Create pull request\n        uses: peter-evans/create-pull-request@v4\n        with:\n          commit-message: update list of images used by ${{ matrix.channel }}\n          title: \"[${{ matrix.channel }}] Update MicroK8s images\"\n          body: update list of images used by ${{ matrix.channel }}\n          reviewers: neoaggelos,ktsakalozos\n          branch: auto-update-images/${{ matrix.branch }}\n          delete-branch: true\n          base: ${{ matrix.branch }}\n```", "prompt": "Generate a GitHub Workflow named `Update list of images` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `update`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. For each object in the [{'branch': 'master', 'channel': 'latest/edge'}, {'branch': 1.24, 'channel': 1.24}, {'branch': 1.23, 'channel': 1.23}, {'branch': 1.22, 'channel': 1.22}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `update` has 3 steps. The 1st step is named `Checkout`. The 2nd step is named `Update image list`. The 3rd step is named `Create pull request`. "}
{"id": "63c494368052faa2781a9e20", "level": "level4", "llm_response": "```yaml\nname: build\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - 'v*'\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  contents: write\n  id-token: write\n  packages: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Cache Go modules\n        uses: actions/cache@v2\n        with:\n          path: ~/.go/pkg/mod\n          key: ${{ runner.os }}-go-${{ hashFiles('**/go.mod') }}\n          restore-keys: |\n            ${{ runner.os }}-go-\n\n      - name: CI\n        run: go test -v ./...\n\n      - name: Run GoReleaser\n        uses: goreleaser/goreleaser-action@v2\n        with:\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: build\n\non:\n  push:\n    branches:\n      - 'main'\n    tags:\n      - 'v*'\n  pull_request:\n\npermissions:\n   contents: write\n   id-token: write\n   packages: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      -\n        name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: 1.17\n      -\n        name: Cache Go modules\n        uses: actions/cache@v3\n        with:\n          path: ~/go/pkg/mod\n          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}\n          restore-keys: |\n            ${{ runner.os }}-go-\n      -\n        name: CI\n        run: |\n          go mod tidy\n          go test -v ./...\n          go build -o tt .\n      - uses: sigstore/cosign-installer@v2.8.1\n      -\n        name: Run GoReleaser\n        uses: goreleaser/goreleaser-action@v3\n        if: success() && startsWith(github.ref, 'refs/tags/')\n        with:\n          distribution: goreleaser-pro\n          version: latest\n          args: release --rm-dist\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n          FURY_TOKEN: ${{ secrets.FURY_TOKEN }}\n          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}\n          TWITTER_CONSUMER_KEY: ${{ secrets.TWITTER_CONSUMER_KEY }}\n          TWITTER_CONSUMER_SECRET: ${{ secrets.TWITTER_CONSUMER_SECRET }}\n          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}\n          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}\n          COSIGN_PWD: ${{ secrets.COSIGN_PWD }}\n          AUR_KEY: ${{ secrets.AUR_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a tag whose name matches v*. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope, write access is granted to the GITHUB_TOKEN in the `id-token` scope and write access is granted to the GITHUB_TOKEN in the `packages` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 6 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Go`. The 3rd step is named `Cache Go modules`. The 4th step is named `CI`. The 5th step is named ``. The 6th step is named `Run GoReleaser`. "}
{"id": "63c493b77843b612699fd355", "level": "level4", "llm_response": "```yaml\nname: docs\n\non:\n  push:\n    branches:\n      - develop\n      - release\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n\nconcurrency:\n  group: docs\n  cancel-in-progress: true\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Track Docs Branch\n        run: echo \"Docs branch is ${{ github.ref }}\"\n\n      - name: Install Python dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Lint Docs\n        run: |\n          pip install flake8\n          flake8 docs\n\n      - name: Update pip\n        run: pip install --upgrade pip\n\n      - name: Set Git author\n        run: git config --global user.name \"GitHub Actions\" && git config --global user.email \"actions@github.com\"\n\n      - name: Install native dependencies\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y build-essential libssl-dev libffi-dev python3-dev\n\n      - name: Install wheel\n        run: pip install wheel\n\n      - name: Install Material for MkDocs Insiders\n        run: pip install mkdocs-material-insiders\n\n      - name: Install dependencies\n        run: pip install -r docs/requirements.txt\n\n      - name: Update from Remote\n        run: git pull origin ${{ github.ref }}\n\n      - name: Build docs (latest)\n        run: mkdocs build --config-file docs/mkdocs.yml\n\n      - name: Build docs (develop)\n        run: mkdocs build --config-file docs/mkdocs.yml --site-dir docs-site-develop\n\n      - name: Build docs\n        run: mkdocs build --config-file docs/mkdocs.yml --site-dir docs-site\n```", "answer": "```yaml name: docs\n\nconcurrency: docs\n\non:\n  push:\n    branches: [ develop, release ]\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Track Docs Branch\n      run: git branch docs -t origin/docs\n    - uses: actions/setup-python@v4\n      with:\n        python-version: 3.x\n    - uses: actions/cache@v3\n      with:\n        key: ${{ github.ref }}\n        path: .cache\n    - uses: pnpm/action-setup@v2.2.2\n      with:\n        version: 7\n    - name: Lint Docs\n      run: |\n        pnpm i\n        pnpm lint\n    - name: Update pip\n      run: python -m pip install -U pip setuptools\n    - name: Set Git author\n      run: |\n        git config user.name \"github-actions[bot]\"\n        git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n    - name: Install native dependencies\n      run: sudo apt-get install libcairo2-dev libfreetype6-dev libffi-dev libjpeg-dev libpng-dev libz-dev\n    - name: Install wheel\n      run: pip install wheel\n    - name: Install Material for MkDocs Insiders\n      run: pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git\n      if: ${{ github.repository_owner == 'mastercomfig' && github.event_name != 'pull_request' }}\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Install dependencies\n      run: pip install -r docs/requirements.txt\n    - name: Update from Remote\n      run: git fetch --tags -f\n    - name: Build docs (latest)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/release' }}\n      run: mike deploy --alias-type copy -b docs -up $(git describe --tags --abbrev=0) latest page\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs (develop)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/develop' }}\n      run: mike deploy --alias-type copy -b docs -p dev\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs\n      if: ${{ github.event_name == 'pull_request' }}\n      run: mike deploy --config-file mkdocs.base.yml -u $(git describe --tags) latest\n```", "prompt": "Generate a GitHub Workflow named `docs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named develop or a branch named release. Only if at least one path of push event matches a pattern in the paths filter(docs/**, mkdocs.yml or .github/workflows/docs.yml), the workflow runs. 2) there is activity relating to a pull request. Only a single workflow using the docs concurrency group will run at a time. The workflow has one job. The job id of the 1st job is `deploy`. This job will run on ubuntu-latest runner. The job `deploy` has 16 steps. The 1st step is named ``. The 2nd step is named `Track Docs Branch`. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named `Lint Docs`. The 7th step is named `Update pip`. The 8th step is named `Set Git author`. The 9th step is named `Install native dependencies`. The 10th step is named `Install wheel`. The 11th step is named `Install Material for MkDocs Insiders`. The 12th step is named `Install dependencies`. The 13th step is named `Update from Remote`. The 14th step is named `Build docs (latest)`. The 15th step is named `Build docs (develop)`. The 16th step is named `Build docs`. "}
{"id": "63c495a68052faa2781b342a", "level": "level4", "llm_response": "```yaml\nname: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches:\n      - master\n      - '1.x'\n      - release\n\njobs:\n  release:\n    if: github.repository == 'jdbc-observations/datasource-proxy'\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Maven Central Repository\n        run: |\n          echo \"repositoryId=mavenCentral\" >> ~/.m2/settings.xml\n          echo \"repositoryUrl=https://oss.sonatype.org/service/local/staging/deploy/maven2/\" >> ~/.m2/settings.xml\n          echo \"username=${{ secrets.MAVEN_CENTRAL_USERNAME }}\" >> ~/.m2/settings.xml\n          echo \"password=${{ secrets.MAVEN_CENTRAL_PASSWORD }}\" >> ~/.m2/settings.xml\n\n      - name: Publish package\n        run: mvn clean deploy -Prelease\n        env:\n          MAVEN_CENTRAL_USERNAME: ${{ secrets.MAVEN_CENTRAL_USERNAME }}\n          MAVEN_CENTRAL_PASSWORD: ${{ secrets.MAVEN_CENTRAL_PASSWORD }}\n```", "answer": "```yaml name: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches: [master, 1.x, release]\n\njobs:\n  release:\n    if: github.repository == 'jdbc-observations/datasource-proxy'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Maven Central Repository\n        uses: actions/setup-java@v3\n        with:\n          java-version: 8\n          distribution: temurin\n          server-id: ossrh\n          server-username: MAVEN_USERNAME\n          server-password: MAVEN_PASSWORD\n          gpg-private-key: ${{ secrets.MAVEN_GPG_PRIVATE_KEY }}\n          gpg-passphrase: MAVEN_GPG_PASSPHRASE\n      - name: Publish package\n        run: ./mvnw --batch-mode deploy -DskipTests=true -Pgithub-ossrh\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}\n          MAVEN_GPG_PASSPHRASE: ${{ secrets.MAVEN_GPG_PASSPHRASE }}\n\n```", "prompt": "Generate a GitHub Workflow named `Release to Maven Central (Deploy Snapshot or Stage Release)` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master, a branch named 1.x or a branch named release. The workflow has one job. The job id of the 1st job is `release`. This job will run only if the condition(github.repository == 'jdbc-observations/datasource-proxy') is met. This job will run on ubuntu-latest runner. The job `release` has 3 steps. The 1st step is named ``. The 2nd step is named `Set up Maven Central Repository`. The 3rd step is named `Publish package`. "}
{"id": "63c494257843b612699ff4be", "level": "level4", "llm_response": "```yaml\nname: functional-orchestration\n\non:\n  pull_request:\n    paths:\n      - 'orchestration/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-orchestration:\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    strategy:\n      matrix:\n        name: [master]\n        openstack_version: [master]\n        ubuntu_version: [20.04]\n        additional_vars: [\n          {name: 'yoga', openstack_version: 'stable/yoga', ubuntu_version: '20.04'},\n          {name: 'xena', openstack_version: 'stable/xena', ubuntu_version: '20.04'},\n          {name: 'wallaby', openstack_version: 'stable/wallaby', ubuntu_version: '20.04'},\n          {name: 'victoria', openstack_version: 'stable/victoria', ubuntu_version: '20.04'},\n          {name: 'ussuri', openstack_version: 'stable/ussuri', ubuntu_version: '18.04'},\n          {name: 'train', openstack_version: 'stable/train', ubuntu_version: '18.04'}\n        ]\n\n    steps:\n      - name: Checkout Gophercloud\n        run: git clone https://github.com/gophercloud/gophercloud.git\n\n      - name: Deploy devstack\n        run: echo \"Deploying devstack\"\n\n      - name: Checkout go\n        run: git clone https://github.com/golang/go.git\n\n      - name: Run Gophercloud acceptance tests\n        run: go test -v ./gophercloud\n\n      - name: Generate logs on failure\n        if: failure()\n        run: echo \"Generating logs\"\n\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v2\n        with:\n          name: logs\n          path: logs/\n```", "answer": "```yaml name: functional-orchestration\non:\n  pull_request:\n    paths:\n      - '**orchestration**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-orchestration:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n          conf_overrides: |\n            enable_plugin heat https://opendev.org/openstack/heat ${{ matrix.openstack_version }}\n          enabled_services: 'h-eng,h-api,h-api-cfn,h-api-cw'\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: ^.*orchestration.*$\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-orchestration-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-orchestration` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**orchestration**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests` and its job id is `functional-orchestration`. This job will run on ubuntu-${{ matrix.ubuntu_version }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `name` has one value: master. The variable `openstack_version` has one value: master. The variable `ubuntu_version` has one value: 20.04. For each object in the [{'name': 'yoga', 'openstack_version': 'stable/yoga', 'ubuntu_version': '20.04'}, {'name': 'xena', 'openstack_version': 'stable/xena', 'ubuntu_version': '20.04'}, {'name': 'wallaby', 'openstack_version': 'stable/wallaby', 'ubuntu_version': '20.04'}, {'name': 'victoria', 'openstack_version': 'stable/victoria', 'ubuntu_version': '20.04'}, {'name': 'ussuri', 'openstack_version': 'stable/ussuri', 'ubuntu_version': '18.04'}, {'name': 'train', 'openstack_version': 'stable/train', 'ubuntu_version': '18.04'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `functional-orchestration` has 6 steps. The 1st step is named `Checkout Gophercloud`. The 2nd step is named `Deploy devstack`. The 3rd step is named `Checkout go`. The 4th step is named `Run Gophercloud acceptance tests`. The 5th step is named `Generate logs on failure`. The 6th step is named `Upload logs artifacts on failure`. "}
{"id": "63c495167843b61269a0553c", "level": "level4", "llm_response": "```yaml\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Call reusable workflow\n        uses: actions/github-script@v4\n        with:\n          script: |\n            github.repos.createDispatchEvent({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              event_type: 'add-depr-ticket-to-depr-board',\n              client_payload: {\n                issue_number: context.payload.issue.number,\n                secrets: {\n                  GITHUB_APP_ID: process.env.GRAPHQL_AUTH_APP_ID,\n                  GITHUB_APP_PRIVATE_KEY: process.env.GRAPHQL_AUTH_APP_PEM,\n                  SLACK_BOT_TOKEN: process.env.SLACK_ISSUE_BOT_TOKEN\n                }\n              }\n            })\n```", "answer": "```yaml # Run the workflow that adds new tickets that are either:\n# - labelled \"DEPR\"\n# - title starts with \"[DEPR]\"\n# - body starts with \"Proposal Date\" (this is the first template field)\n# to the org-wide DEPR project board\n\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    uses: openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master\n    secrets:\n      GITHUB_APP_ID: ${{ secrets.GRAPHQL_AUTH_APP_ID }}\n      GITHUB_APP_PRIVATE_KEY: ${{ secrets.GRAPHQL_AUTH_APP_PEM }}\n      SLACK_BOT_TOKEN: ${{ secrets.SLACK_ISSUE_BOT_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Add newly created DEPR issues to the DEPR project board` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `routeissue`. This job will call a reusable workflow located at `openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master`. The job will pass 3 secrets to the called workflow: the secret `GITHUB_APP_ID` is `${{ secrets.GRAPHQL_AUTH_APP_ID }}`, the secret `GITHUB_APP_PRIVATE_KEY` is `${{ secrets.GRAPHQL_AUTH_APP_PEM }}` and the secret `SLACK_BOT_TOKEN` is `${{ secrets.SLACK_ISSUE_BOT_TOKEN }}`. "}
{"id": "63c495e88052faa2781b50cc", "level": "level4", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [commented]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    steps:\n      - name: Step 1\n        run: echo \"Hello, World!\"\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. This job will run only if the condition(github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot') is met. This job will run on ubuntu-latest runner. The job `TagBot` has one step. The 1st step is named ``. "}
{"id": "63c496876fc19abdf9c9c8bb", "level": "level4", "llm_response": "```yaml\nname: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: '*/30 * * * *'\n\njobs:\n  build-feeds:\n    id: build-feeds\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Repo\n      uses: actions/checkout@v2\n\n    - name: Install Dependencies\n      run: |\n        # Install dependencies specific to Solidity\n        npm install -g solc\n\n    - name: Checkout Data Source Repo\n      uses: actions/checkout@v2\n      with:\n        repository: 'username/data-source-repo'\n        ref: 'main'\n\n    - name: Process Data\n      run: |\n        # Process data using Solidity scripts\n        solc --bin --abi ./contracts/FeedContract.sol -o ./build\n\n    - name: Deploy to Firebase\n      run: |\n        # Deploy processed data to Firebase\n        firebase deploy --only database\n      env:\n        FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n```", "answer": "```yaml name: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: \"*/30 * * * *\"\n\njobs:\n  build-feeds:\n    name: Update latest feed data from source repo\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n      - name: Install Dependencies\n        run: yarn\n      - name: Checkout Data Source Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n        with:\n          repository: smartcontractkit/reference-data-directory\n          path: data-source\n          token: ${{ secrets.GH_API_KEY }}\n      # - name: Read Data Source\n      #   run: cat data-source/package.json\n      - name: Process Data\n        run: yarn process\n      - name: Deploy to Firebase\n        uses: w9jds/firebase-action@94389a881adad57284e35860f5d258ab262dcd91\n        with:\n\n          args: -c firebase-addresses.json deploy --only hosting\n        env:\n          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n          PROJECT_ID: cl-docs-addresses\n```", "prompt": "Generate a GitHub Workflow named `Build and Publish Feed Resources` for a GitHub repository whose primary programming language is Solidity. This workflow will be triggered by an event: the scheduled time has come: every 30 minutes. The workflow has one job. The 1st job is named `Update latest feed data from source repo` and its job id is `build-feeds`. This job will run on ubuntu-latest runner. The job `build-feeds` has 5 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install Dependencies`. The 3rd step is named `Checkout Data Source Repo`. The 4th step is named `Process Data`. The 5th step is named `Deploy to Firebase`. "}
{"id": "63c494298052faa2781a98f7", "level": "level4", "llm_response": "```yaml\nname: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  build: ${{ github.workspace }}/build\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: windows-2022\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n    - name: Setup\n      # Add your setup steps here\n      run: echo \"Setting up the environment...\"\n    - name: Configure CMake\n      # Add your CMake configuration steps here\n      run: echo \"Configuring CMake...\"\n    - name: Initialize MSVC Code Analysis\n      id: run-analysis\n      # Add your MSVC code analysis initialization steps here\n      run: echo \"Initializing MSVC Code Analysis...\"\n    - name: Upload SARIF to GitHub\n      # Add your SARIF upload steps here\n      run: echo \"Uploading SARIF to GitHub...\"\n    - name: Upload SARIF as an Artifact\n      # Add your SARIF artifact upload steps here\n      run: echo \"Uploading SARIF as an Artifact...\"\n```", "answer": "```yaml name: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  # Path to the CMake build directory.\n  build: '${{ github.workspace }}/build'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: windows-2022\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup\n        run: |\n          $Url = \"https://boostorg.jfrog.io/artifactory/main/release/1.75.0/binaries/boost_1_75_0-msvc-14.2-64.exe\"\n          (New-Object System.Net.WebClient).DownloadFile($Url, \"$env:TEMP\\boost.exe\")\n          Start-Process -Wait -FilePath \"$env:TEMP\\boost.exe\" \"/SILENT\",\"/SP-\",\"/SUPPRESSMSGBOXES\",\"/DIR=C:\\local\\boost-1.75.0\"\n\n      - name: Configure CMake\n        env:\n          BOOST_ROOT: C:\\local\\boost-1.75.0\n        run: cmake -B ${{ env.build }} -DQL_USE_STD_CLASSES=ON\n\n      - name: Initialize MSVC Code Analysis\n        uses: microsoft/msvc-code-analysis-action@v0.1.1\n        # Provide a unique ID to access the sarif output path\n        id: run-analysis\n        env:\n          CAExcludePath: C:\\local\\boost-1.75.0\n        with:\n          cmakeBuildDirectory: ${{ env.build }}\n          buildConfiguration: Release\n          ruleset: '${{ github.workspace }}/.msvc-analysis.ruleset'\n\n      - name: Upload SARIF to GitHub\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: ${{ steps.run-analysis.outputs.sarif }}\n\n      - name: Upload SARIF as an Artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: sarif-file\n          path: ${{ steps.run-analysis.outputs.sarif }}\n\n```", "prompt": "Generate a GitHub Workflow named `Microsoft C++ Code Analysis` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow sets an environment variable to use: `build` is set to `${{ github.workspace }}/build`. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on windows-2022 runner. The job `analyze` has 6 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Setup`. The 3rd step is named `Configure CMake`. The 4th step is named `Initialize MSVC Code Analysis` and its id is `run-analysis`. The 5th step is named `Upload SARIF to GitHub`. The 6th step is named `Upload SARIF as an Artifact`. "}
{"id": "63c494a48052faa2781ac54a", "level": "level4", "llm_response": "```yaml\nname: cspell-action\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run cspell\n        run: npx cspell \"**/*.{ts,tsx}\"\n```", "answer": "```yaml name: cspell-action\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: streetsidesoftware/cspell-action@v2\n```", "prompt": "Generate a GitHub Workflow named `cspell-action` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `cspell`. This job will run on ubuntu-latest runner. The job `cspell` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c495197843b61269a056bc", "level": "level4", "llm_response": "```yaml\nname: Code Scanning - Action\n\non:\n  pull_request:\n    branches:\n      - dev\n      - master\n\njobs:\n  CodeQL-Build:\n    runs-on: ubuntu-latest\n    permissions:\n      security-events: write\n      actions: read\n      contents: read\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml name: \"Code Scanning - Action\"\n\non:\n  pull_request:\n    branches: [dev, master]\n    types: [opened, synchronize]\n\njobs:\n  CodeQL-Build:\n    # CodeQL runs on ubuntu-latest, windows-latest, and macos-latest\n    runs-on: ubuntu-latest\n\n    permissions:\n      # required for all workflows\n      security-events: write\n\n      # only required for workflows in private repositories\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      # Initializes the CodeQL tools for scanning.\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n        # Override language selection by uncommenting this and choosing your languages\n        # with:\n        #   languages: go, javascript, csharp, python, cpp, java\n\n      # Autobuild attempts to build any compiled languages (C/C++, C#, or Java).\n      # If this step fails, then you should remove it and run the build manually (see below).\n      # - name: Autobuild\n      #   uses: github/codeql-action/autobuild@v2\n\n      # \u2139\ufe0f Command-line programs to run using the OS shell.\n      # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n      # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following\n      #    three lines and modify them (or add more) to build your code if your\n      #    project uses a compiled language\n\n      #- run: |\n      #     make bootstrap\n      #     make release\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `Code Scanning - Action` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created or a pull request's head branch is updated. The workflow would run whenever there is a pull_request event targeting: a branch named dev or a branch named master. The workflow has one job. The job id of the 1st job is `CodeQL-Build`. This job will run on ubuntu-latest runner. The job `CodeQL-Build` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `security-events` scope, read access is granted to the GITHUB_TOKEN in the `actions` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `CodeQL-Build`. The job `CodeQL-Build` has 3 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Perform CodeQL Analysis`. "}
{"id": "63c495547843b61269a06e8e", "level": "level4", "llm_response": "```yaml\nname: Build and Release [Manual]\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    if: github.actor == 'ayuhito'\n\n    steps:\n    - name: checkout\n      uses: actions/checkout@v2\n\n    - name: Enable PNPM\n      run: npm install -g pnpm\n\n    - name: Set node version to 16\n      uses: actions/setup-node@v2\n      with:\n        node-version: '16'\n\n    - name: Install\n      run: pnpm install\n\n    - name: Install\n      run: pnpm install\n\n    - name: Fetch API\n      run: echo \"Fetching API...\"\n\n    - name: Parse API\n      run: echo \"Parsing API...\"\n\n    - name: Build fonts\n      run: echo \"Building fonts...\"\n\n    - name: Generate fontlist\n      run: echo \"Generating fontlist...\"\n\n    - name: Generate Algolia index\n      run: echo \"Generating Algolia index...\"\n\n    - name: Lint files\n      run: echo \"Linting files...\"\n\n    - name: Format files\n      run: echo \"Formatting files...\"\n\n    - name: Stage, commit and push files\n      run: echo \"Staging, committing, and pushing files...\"\n\n    - name: Check font files\n      run: echo \"Checking font files...\"\n\n    - name: If error, commit again before publishing\n      run: echo \"If error, committing again before publishing...\"\n\n    - name: Configure CI Git\n      run: echo \"Configuring CI Git...\"\n\n    - name: Publish package\n      run: echo \"Publishing package...\"\n```", "answer": "```yaml name: Build and Release [Manual]\n\non: [workflow_dispatch]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    if: github.actor == 'ayuhito'\n\n    steps:\n      - name: checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: \"0\"\n\n      - name: Enable PNPM\n        uses: pnpm/action-setup@v2\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"16\"\n          cache: \"pnpm\"\n\n      - name: Install\n        run: pnpm install --frozen-lockfile\n\n      - name: Install\n        run: pnpm i\n\n      - name: Fetch API # Calls Google Font Metadata to fetch the latest data from Google's Developer API\n        run: pnpm --filter scripts exec gfm generate $GOOGLE_API_KEY\n        env:\n          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}\n\n      - name: Parse API # Process generated API data\n        run: pnpm --filter scripts exec gfm parse\n\n      - name: Build fonts # Build all updated Google Fonts in repository\n        run: pnpm run build:google\n\n      - name: Generate fontlist # Generate FONTLIST.json and FONTLIST.md\n        run: pnpm run util:fontlist\n\n      - name: Generate Algolia index # Generate Algolia search index for website\n        run: pnpm run util:algolia\n        env:\n          ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }}\n\n      - name: Lint files\n        run: pnpm run lint\n\n      - name: Format files\n        run: pnpm run format\n\n      - name: Stage, commit and push files\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): update packages [Manual]\"\n        continue-on-error: true\n\n      - name: Check font files # Detects if all binaries are downloaded successfully and in the right place\n        run: pnpm run util:run-check\n\n      - name: If error, commit again before publishing\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): resolve file check errors [Manual]\"\n        continue-on-error: true\n\n      - name: Configure CI Git\n        run: |\n          git config --global user.email \"83556432+fontsource-bot@users.noreply.github.com\"\n          git config --global user.name \"fontsource-bot\"\n\n      - name: Publish package # Call mass-publish\n        run: pnpm run deploy:ci\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build and Release [Manual]` for a GitHub repository whose primary programming language is CSS. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run only if the condition(github.actor == 'ayuhito') is met. This job will run on ubuntu-latest runner. The job `build` has 17 steps. The 1st step is named `checkout`. The 2nd step is named `Enable PNPM`. The 3rd step is named `Set node version to 16`. The 4th step is named `Install`. The 5th step is named `Install`. The 6th step is named `Fetch API`. The 7th step is named `Parse API`. The 8th step is named `Build fonts`. The 9th step is named `Generate fontlist`. The 10th step is named `Generate Algolia index`. The 11th step is named `Lint files`. The 12th step is named `Format files`. The 13th step is named `Stage, commit and push files`. The 14th step is named `Check font files`. The 15th step is named `If error, commit again before publishing`. The 16th step is named `Configure CI Git`. The 17th step is named `Publish package`. "}
{"id": "63c494ee8052faa2781ae44b", "level": "level4", "llm_response": "```yaml\nname: Add PR Deploy Badge\n\non:\n  deployment_status:\n    types: [created]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    if: github.event.deployment_status.state == 'success'\n    permissions:\n      pull-requests: write\n\n    steps:\n    - name: Kb Pull Request Deployment Badges\n      # Add your step commands here\n```", "answer": "```yaml name: Add PR Deploy Badge\n# https://docs.github.com/en/actions/reference/events-that-trigger-workflows\non: [deployment_status]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    permissions:\n      pull-requests: write\n    # only runs this job on successful deploy\n    if: github.event.deployment_status.state == 'success'\n    steps:\n    - name: Kb Pull Request Deployment Badges\n      uses: kibibit/kb-badger-action@v2\n      with:\n        github-token: ${{secrets.GITHUB_TOKEN}}\n        badge-left: demo\n        badge-right: application\n        badge-logo: heroku\n        badge-path: api\n        badge2-left: demo\n        badge2-right: api-docs\n        badge2-color: 85EA2D\n        badge2-logo: swagger\n        badge2-path: api/docs\n```", "prompt": "Generate a GitHub Workflow named `Add PR Deploy Badge` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a new deployment status is created. The workflow has one job. The job id of the 1st job is `badge`. This job will run only if the condition(github.event.deployment_status.state == 'success') is met. This job will run on ubuntu-latest runner. The job `badge` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `badge`. The job `badge` has one step. The 1st step is named `Kb Pull Request Deployment Badges`. "}
{"id": "63c4968b33b087f6bde2caaa", "level": "level4", "llm_response": "```yaml\nname: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\nenv:\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  publish:\n    runs-on: windows-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --version\n\n    - name: Restore packages in preparation for ASFEnhance publishing\n      run: dotnet restore\n\n    - name: Publish ASFEnhance on Windows\n      run: dotnet publish -c Release -o ./publish\n\n    - name: Upload ASFEnhance-zh-Hans\n      uses: actions/upload-artifact@v2\n      with:\n        name: ASFEnhance-zh-Hans\n        path: ./publish/zh-Hans\n\n    - name: Upload ASFEnhance-en-US\n      uses: actions/upload-artifact@v2\n      with:\n        name: ASFEnhance-en-US\n        path: ./publish/en-US\n```", "answer": "```yaml name: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n\nenv:\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  publish:\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.0.2\n        with:\n          submodules: recursive\n\n      - name: Setup .NET Core\n        uses: actions/setup-dotnet@v2.1.0\n        with:\n          dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n      - name: Verify .NET Core\n        run: dotnet --info\n\n      - name: Restore packages in preparation for ASFEnhance publishing\n        run: dotnet restore ASFEnhance -p:ContinuousIntegrationBuild=true --nologo\n\n      - name: Publish ASFEnhance on Windows\n        shell: pwsh\n        run: |\n          $script = \"./build.ps1\";\n          Set-Location ${{ github.workspace }};\n          powershell $script;\n\n      - name: Upload ASFEnhance-zh-Hans\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-zh-Hans\n          path: dist/ASFEnhance-zh-Hans.zip\n\n      - name: Upload ASFEnhance-en-US\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-en-US\n          path: dist/ASFEnhance-en-US.zip\n```", "prompt": "Generate a GitHub Workflow named `AutoBuild-Dev` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) a commit or tag is pushed, or a repository is cloned. The workflow sets an environment variable to use: `DOTNET_SDK_VERSION` is set to `6.0.x`. The workflow has one job. The job id of the 1st job is `publish`. This job will run on windows-latest runner. The job `publish` has 7 steps. The 1st step is named `Checkout code`. The 2nd step is named `Setup .NET Core`. The 3rd step is named `Verify .NET Core`. The 4th step is named `Restore packages in preparation for ASFEnhance publishing`. The 5th step is named `Publish ASFEnhance on Windows`. The 6th step is named `Upload ASFEnhance-zh-Hans`. The 7th step is named `Upload ASFEnhance-en-US`. "}
{"id": "63c494b78052faa2781acd9d", "level": "level4", "llm_response": "```yaml\nname: Merge me!\n\non:\n  workflow_run:\n    workflows: [Continuous Integration]\n    types: [completed]\n\njobs:\n  merge-me:\n    id: merge-me\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    timeout-minutes: 5\n    steps:\n      - name: Merge me!\n```", "answer": "```yaml name: Merge me!\n\non:\n  workflow_run:\n    types:\n      - completed\n    workflows:\n      - 'Continuous Integration'\n\njobs:\n  merge-me:\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    name: Merge me!\n    runs-on: ubuntu-latest\n    steps:\n      - name: Merge me!\n        uses: ridedott/merge-me-action@master\n        with:\n          GITHUB_TOKEN: ${{ secrets.DOTTBOTT_TOKEN }}\n    timeout-minutes: 5\n```", "prompt": "Generate a GitHub Workflow named `Merge me!` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: the workflow named Continuous Integration is completed. The workflow has one job. The 1st job is named `Merge me!` and its job id is `merge-me`. This job will run only if the condition(${{ github.event.workflow_run.conclusion == 'success' }}) is met. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 5. The job `merge-me` has one step. The 1st step is named `Merge me!`. "}
{"id": "63c494a37843b61269a027ed", "level": "level4", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  test:\n    runs-on: ${{ matrix.platform }}\n    strategy:\n      matrix:\n        go-version: [1.17.x]\n        platform: [ubuntu-latest, macos-latest, windows-latest]\n\n    steps:\n      - name: Install Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: ${{ matrix.go-version }}\n\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\n\nname: CI\n\njobs:\n  test:\n    ## We want to define a strategy for our job\n    strategy:\n      ## this will contain a matrix of all the combinations\n      ## we wish to test again:\n      matrix:\n        go-version: [1.17.x]\n        platform: [ubuntu-latest, macos-latest, windows-latest]\n\n    ## Defines the platform for each test run\n    runs-on: ${{ matrix.platform }}\n\n    ## the steps that will be run through for each version and platform\n    ## combination\n    steps:\n    ## sets up go based on the version\n    - name: Install Go\n      uses: actions/setup-go@v3.3.0\n      with:\n        go-version: ${{ matrix.go-version }}\n\n    ## checks out our code locally, so we can work with the files\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n\n    ## runs go test ./...\n    - name: Build\n      run: go build ./...\n\n    ## runs go test ./...\n    - name: Test\n      run: go test ./...\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `test`. This job will run on ${{ matrix.platform }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `go-version` has one value: 1.17.x. The variable `platform` has 3 values: ubuntu-latest, macos-latest and windows-latest. The job `test` has 4 steps. The 1st step is named `Install Go`. The 2nd step is named `Checkout code`. The 3rd step is named `Build`. The 4th step is named `Test`. "}
{"id": "63c493b87843b612699fd399", "level": "level4", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Release Please\n        uses: release-please/release-please-action@v3\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          release-type: node\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\nname: release-please\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: GoogleCloudPlatform/release-please-action@v2\n        with:\n          release-type: node\n          package-name: release-please-action\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. This job will run on ubuntu-latest runner. The job `release-please` has one step. The 1st step is named ``. "}
{"id": "63c4941e7843b612699ff1f7", "level": "level4", "llm_response": "```yaml\nname: Demo link\n\non:\n  pull_request:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    id: add_demo_link\n    runs-on: ubuntu-latest\n    permissions:\n      pull-requests: write\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Update PR description\n        run: echo \"Demo link: [insert link here]\" >> $GITHUB_EVENT_PATH\n```", "answer": "```yaml name: Demo link\n\non:\n  pull_request_target:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    name: Add demo link to PR description\n    runs-on: ubuntu-latest\n    env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    permissions:\n      pull-requests: write\n    steps:\n      - name: Update PR description\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const pullRequestId = context.payload.pull_request.number\n            const pullRequestBranch = context.payload.pull_request.head.ref\n\n            github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: pullRequestId,\n              body: `\ud83d\udc40 [Visit Preview](https://${pullRequestBranch}--welcome-ui.netlify.app)`\n            });\n```", "prompt": "Generate a GitHub Workflow named `Demo link` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a pull request is created. The workflow has one job. The 1st job is named `Add demo link to PR description` and its job id is `add_demo_link`. This job will run on ubuntu-latest runner. The job `add_demo_link` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `add_demo_link`. The job sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. The job `add_demo_link` has one step. The 1st step is named `Update PR description`. "}
{"id": "63c494608052faa2781aabf4", "level": "level4", "llm_response": "```yaml\nname: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Check go.mod files\n        run: go mod tidy\n```", "answer": "```yaml name: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    name: go.mod check\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - uses: actions/setup-go@c4a742cab115ed795e34d4513e2cf7d472deb55f\n        with:\n          go-version: 1.17\n\n      - name: Check go.mod files\n        shell: bash\n        run: |\n          cd gomod-sync\n          go run main.go check\n```", "prompt": "Generate a GitHub Workflow named `go.mod check` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) there is activity relating to a pull request. The workflow has one job. The 1st job is named `go.mod check` and its job id is `check`. This job will run on ubuntu-latest runner. The job `check` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Check go.mod files`. "}
{"id": "63c494be7843b61269a0325c", "level": "level4", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n    strategy:\n      matrix:\n        language: [javascript, typescript]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: ${{ matrix.language }}\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"main\" ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'javascript', 'typescript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 02:25 am, only on thursday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has 2 values: javascript and typescript. The job `analyze` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `actions` scope, read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `security-events` scope. This permission setting only applies to the job `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named `Perform CodeQL Analysis`. "}
{"id": "63c494228052faa2781a95a5", "level": "level4", "llm_response": "```yaml\nname: snyk-pr\n\non:\n  pull_request:\n    branches:\n      - master\n\njobs:\n  whitesource:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa' }}\n    steps:\n      - name: checkout\n        uses: actions/checkout@v2\n      - name: checkout action\n        run: echo \"Checkout action step\"\n      - name: PR\n        run: echo \"PR step\"\n```", "answer": "```yaml name: snyk-pr\non:\n  pull_request:\n    branches:\n      - master\njobs:\n  whitesource:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa' }}\n    steps:\n    - name: checkout\n      uses: actions/checkout@v3\n      with:\n        ref: ${{ github.event.pull_request.head.ref }}\n        fetch-depth: 0\n\n    - name: checkout action\n      uses: actions/checkout@v3\n      with:\n        repository: snowflakedb/whitesource-actions\n        token: ${{ secrets.WHITESOURCE_ACTION_TOKEN }}\n        path: whitesource-actions\n\n    - name: PR\n      uses: ./whitesource-actions/snyk-pr\n      env:\n        PR_TITLE: ${{ github.event.pull_request.title }}\n      with:\n        jira_token: ${{ secrets.JIRA_TOKEN_PUBLIC_REPO }}\n        gh_token: ${{ secrets.GITHUB_TOKEN }}\n        amend: false # true if you want the commit to be amended with the JIRA number\n```", "prompt": "Generate a GitHub Workflow named `snyk-pr` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `whitesource`. This job will run only if the condition(${{ github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa' }}) is met. This job will run on ubuntu-latest runner. The job `whitesource` has 3 steps. The 1st step is named `checkout`. The 2nd step is named `checkout action`. The 3rd step is named `PR`. "}
{"id": "63c493c37843b612699fd587", "level": "level4", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Draft Release\n        # Add the steps to draft a release here\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    # branches to consider in the event; optional, defaults to all\n    branches:\n      - main\n  # pull_request event is required only for autolabeler\n  pull_request:\n    # Only following types are handled by the action, but one can default to all as well\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Draft Release\n        uses: release-drafter/release-drafter@v5\n        with:\n          tag_name: vNext\n          release_name: vNext\n          draft: true\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is TSQL. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created, a previously closed pull request is reopened or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `update_release_draft`. This job will run on ubuntu-latest runner. The job `update_release_draft` has one step. The 1st step is named `Draft Release`. "}
{"id": "63c495238052faa2781afbf5", "level": "level4", "llm_response": "```yaml\nname: Greetings\n\non:\n  pull_request:\n  issues:\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: Greetings\n\non: [pull_request, issues]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/first-interaction@v1\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        issue-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to fix your issue ASAP. Make sure that you have read about issue format in the docs'\n        pr-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to review your PR ASAP. Make sure that you have read about requirements to pull requests in the docs'\n```", "prompt": "Generate a GitHub Workflow named `Greetings` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) activity related to an issue occurs. The workflow has one job. The job id of the 1st job is `greeting`. This job will run on ubuntu-latest runner. The job `greeting` has one step. The 1st step is named ``. "}
{"id": "63c496956fc19abdf9c9ce1c", "level": "level4", "llm_response": "```yaml\nname: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set Node.js 16.x\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Install licensed\n        run: npm install licensed\n      - name: Check licenses\n        run: licensed check\n```", "answer": "```yaml name: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    name: Check licenses\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set Node.js 16.x\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16.x\n          cache: npm\n      - run: npm ci\n      - name: Install licensed\n        run: |\n          cd $RUNNER_TEMP\n          curl -Lfs -o licensed.tar.gz https://github.com/github/licensed/releases/download/3.4.4/licensed-3.4.4-linux-x64.tar.gz\n          sudo tar -xzf licensed.tar.gz\n          sudo mv licensed /usr/local/bin/licensed\n      - run: licensed status\n```", "prompt": "Generate a GitHub Workflow named `Licensed` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Check licenses` and its job id is `test`. This job will run on ubuntu-latest runner. The job `test` has 5 steps. The 1st step is named ``. The 2nd step is named `Set Node.js 16.x`. The 3rd step is named ``. The 4th step is named `Install licensed`. The 5th step is named ``. "}
{"id": "63c494937843b61269a02136", "level": "level4", "llm_response": "```yaml\nname: 'e2e melange bootstrap + build'\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository:\n    types: [created]\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    container:\n      image: alpine:latest\n      options: --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n\n    steps:\n    - name: Fetch dependencies\n      run: |\n        # Add your dependencies fetching commands here\n        echo \"Fetching dependencies...\"\n\n    - name: Mark workspace as a safe repository\n      run: |\n        # Add your workspace marking commands here\n        echo \"Marking workspace as safe...\"\n\n    - name: Build bootstrap melange tool (stage1)\n      run: |\n        # Add your stage1 build commands here\n        echo \"Building stage1 melange tool...\"\n\n    - name: Generate a package signing keypair\n      run: |\n        # Add your keypair generation commands here\n        echo \"Generating package signing keypair...\"\n\n    - name: Prepare build workspace for stage2\n      run: |\n        # Add your stage2 workspace preparation commands here\n        echo \"Preparing build workspace for stage2...\"\n\n    - name: Build stage2 melange package with bootstrap melange\n      run: |\n        # Add your stage2 build commands here\n        echo \"Building stage2 melange package...\"\n\n    - name: Install stage2 melange package\n      run: |\n        # Add your stage2 installation commands here\n        echo \"Installing stage2 melange package...\"\n\n    - name: Move stage2 artifacts to stage2 directory\n      run: |\n        # Add your stage2 artifact moving commands here\n        echo \"Moving stage2 artifacts to stage2 directory...\"\n\n    - name: Verify operation of stage2 melange\n      run: |\n        # Add your stage2 verification commands here\n        echo \"Verifying operation of stage2 melange...\"\n\n    - name: Prepare build workspace for stage3\n      run: |\n        # Add your stage3 workspace preparation commands here\n        echo \"Preparing build workspace for stage3...\"\n\n    - name: Build stage3 melange package with stage2 melange\n      run: |\n        # Add your stage3 build commands here\n        echo \"Building stage3 melange package...\"\n\n    - name: Install stage3 melange package\n      run: |\n        # Add your stage3 installation commands here\n        echo \"Installing stage3 melange package...\"\n\n    - name: Move stage3 artifacts to stage3 directory\n      run: |\n        # Add your stage3 artifact moving commands here\n        echo \"Moving stage3 artifacts to stage3 directory...\"\n\n    - name: Ensure melange package is reproducible\n      run: |\n        # Add your reproducibility check commands here\n        echo \"Ensuring melange package is reproducible...\"\n\n    - name: Verify operation of stage3 melange\n      run: |\n        # Add your stage3 verification commands here\n        echo \"Verifying operation of stage3 melange...\"\n```", "answer": "```yaml name: e2e melange bootstrap + build\n\non:\n  push:\n  pull_request:\n\njobs:\n  build:\n    name: bootstrap package\n    runs-on: ubuntu-latest\n    container:\n      image: alpine:latest\n      options: |\n        --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n\n    steps:\n    - name: Fetch dependencies\n      run: |\n        cat >/etc/apk/repositories <<_EOF_\n        https://dl-cdn.alpinelinux.org/alpine/edge/main\n        https://dl-cdn.alpinelinux.org/alpine/edge/community\n        https://dl-cdn.alpinelinux.org/alpine/edge/testing\n        _EOF_\n\n        apk upgrade -Ua\n        apk add go cosign build-base git bubblewrap\n    - uses: actions/checkout@2541b1294d2704b0964813337f33b291d3f8596b\n    - name: Mark workspace as a safe repository\n      run: git config --global --add safe.directory ${GITHUB_WORKSPACE}\n    - name: Build bootstrap melange tool (stage1)\n      run: make melange\n    - name: Generate a package signing keypair\n      run: |\n        ./melange keygen\n        mv melange.rsa.pub /etc/apk/keys\n    - name: Prepare build workspace for stage2\n      run: |\n        git clone . workspace-stage2/x86_64\n    - name: Build stage2 melange package with bootstrap melange\n      run: ./melange build --pipeline-dir=pipelines/ --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage2/\n    - name: Install stage2 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage2 artifacts to stage2 directory\n      run: |\n        mv packages stage2\n    - name: Verify operation of stage2 melange\n      run: melange version\n    - name: Prepare build workspace for stage3\n      run: |\n        git clone . workspace-stage3/x86_64\n    - name: Build stage3 melange package with stage2 melange\n      run: melange build --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage3/\n    - name: Install stage3 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage3 artifacts to stage3 directory\n      run: |\n        mv packages stage3\n    - name: Ensure melange package is reproducible\n      run: |\n        sha256sum stage2/x86_64/*.apk | sed -e 's:stage2/:stage3/:g' | sha256sum -c\n    - name: Verify operation of stage3 melange\n      run: melange version\n```", "prompt": "Generate a GitHub Workflow named `e2e melange bootstrap + build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `bootstrap package` and its job id is `build`. This job will run on ubuntu-latest runner. The job creates a Docker container that uses `alpine:latest` image. It configures additional container resource options: --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n. The job `build` has 16 steps. The 1st step is named `Fetch dependencies`. The 2nd step is named ``. The 3rd step is named `Mark workspace as a safe repository`. The 4th step is named `Build bootstrap melange tool (stage1)`. The 5th step is named `Generate a package signing keypair`. The 6th step is named `Prepare build workspace for stage2`. The 7th step is named `Build stage2 melange package with bootstrap melange`. The 8th step is named `Install stage2 melange package`. The 9th step is named `Move stage2 artifacts to stage2 directory`. The 10th step is named `Verify operation of stage2 melange`. The 11th step is named `Prepare build workspace for stage3`. The 12th step is named `Build stage3 melange package with stage2 melange`. The 13th step is named `Install stage3 melange package`. The 14th step is named `Move stage3 artifacts to stage3 directory`. The 15th step is named `Ensure melange package is reproducible`. The 16th step is named `Verify operation of stage3 melange`. "}
{"id": "63c495e58052faa2781b4f4c", "level": "level4", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 */6 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n    steps:\n      - name: Mark stale issues and pull requests\n        run: |\n          gh issue list --state open --limit 100 | while read -r issue; do\n            echo \"Marking issue $issue as stale\"\n            gh issue edit $issue --add-labels stale\n          done\n          gh pr list --state open --limit 100 | while read -r pr; do\n            echo \"Marking pull request $pr as stale\"\n            gh pr edit $pr --add-labels stale\n          done\n```", "answer": "```yaml name: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '0 */6 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v6\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        days-before-pr-stale: 14\n        days-before-pr-close: 14\n        stale-pr-label: 'inactive'\n        close-pr-label: 'auto-close'\n        exempt-pr-labels: 'keep-open'\n        stale-pr-message: >\n          This pull request has been inactive for 14 days. \n          If you are finished with your changes, don't forget to sign off. See the [contributor guide](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-write-pull-request-automation?branch=main) for instructions. \n          If this PR is inactive for 14 more days, it will be closed automatically. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n        close-pr-message: >\n          This pull request has been inactive for 28 days. At this time, we are closing the PR.  \n          If you decide to continue working on your change, you can reopen the PR and continue working. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n          \n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: every 6 hours. The workflow has one job. The job id of the 1st job is `stale`. This job will run on ubuntu-latest runner. The job `stale` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `stale`. The job `stale` has one step. The 1st step is named ``. "}
{"id": "63c4951f7843b61269a0593c", "level": "level4", "llm_response": "```yaml\nname: docker-push\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build-and-push:\n    id: build-and-push\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Docker meta\n        id: meta\n        uses: docker/metadata-action@v3\n        with:\n          images: my-docker-image\n\n      - name: Setup qemu\n        uses: docker/setup-qemu-action@v2\n\n      - name: Setup buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Build and push\n        run: |\n          docker buildx build --platform linux/amd64,linux/arm64 -t ${{ steps.meta.outputs.tags }} -t ${{ steps.meta.outputs.digest }} --push .\n```", "answer": "```yaml name: docker-push\non:\n  push:\n    tags:\n      - \"v*\"\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n\n      - name: docker meta\n        id: meta\n        uses: docker/metadata-action@v4.1.0\n        with:\n          images: fsouza/fake-gcs-server\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n\n      - name: setup qemu\n        uses: docker/setup-qemu-action@v2.1.0\n\n      - name: setup buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2.1.0\n\n      - name: login to docker hub\n        uses: docker/login-action@v2.1.0\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: build and push\n        uses: docker/build-push-action@v3.2.0\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          platforms: linux/amd64,linux/arm64\n```", "prompt": "Generate a GitHub Workflow named `docker-push` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The job id of the 1st job is `build-and-push`. This job will run on ubuntu-latest runner. The job `build-and-push` has 6 steps. The 1st step is named ``. The 2nd step is named `docker meta` and its id is `meta`. The 3rd step is named `setup qemu`. The 4th step is named `setup buildx` and its id is `buildx`. The 5th step is named `login to docker hub`. The 6th step is named `build and push`. "}
{"id": "63c495407843b61269a06679", "level": "level4", "llm_response": "```yaml\nname: Tests\n\non:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  tests:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: [3.6, 3.7, 3.8, 3.9, 3.10, 3.11-dev]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Install Linux packages for Qt 5 support\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y qtbase5-dev\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v2\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies and local packages\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n        pip install -e .\n\n    - name: Create clean test directory\n      run: mkdir -p tests\n\n    - name: Test Traits package\n      run: pytest tests\n```", "answer": "```yaml name: Tests\n\non:\n- pull_request\n- workflow_dispatch\n\njobs:\n  tests:\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10', '3.11-dev']\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install Linux packages for Qt 5 support\n      run: |\n        sudo apt-get update\n        sudo apt-get install qt5-default\n        sudo apt-get install libxkbcommon-x11-0\n        sudo apt-get install libxcb-icccm4\n        sudo apt-get install libxcb-image0\n        sudo apt-get install libxcb-keysyms1\n        sudo apt-get install libxcb-randr0\n        sudo apt-get install libxcb-render-util0\n        sudo apt-get install libxcb-xinerama0\n      if: matrix.os == 'ubuntu-latest'\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies and local packages\n      run: |\n        python -m pip install .[test]\n    - name: Create clean test directory\n      run: |\n        mkdir testdir\n    - name: Test Traits package\n      uses: GabrielBB/xvfb-action@v1\n      with:\n        working-directory: testdir\n        run: python -m unittest discover -v traits\n```", "prompt": "Generate a GitHub Workflow named `Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `tests`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `os` has 3 values: ubuntu-latest, windows-latest and macos-latest. The variable `python-version` has 6 values: 3.6, 3.7, 3.8, 3.9, 3.10 and 3.11-dev. The job `tests` has 6 steps. The 1st step is named ``. The 2nd step is named `Install Linux packages for Qt 5 support`. The 3rd step is named `Set up Python ${{ matrix.python-version }}`. The 4th step is named `Install dependencies and local packages`. The 5th step is named `Create clean test directory`. The 6th step is named `Test Traits package`. "}
{"id": "63c495448052faa2781b0abc", "level": "level4", "llm_response": "```yaml\nname: Node Blog CI\n\non:\n  push:\n    branches:\n      - '!release'\n  pull_request:\n    branches:\n      - '!release'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Launch MongoDB\n      run: |\n        docker run -d --name mongo -p 27017:27017 mongo\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v2\n      with:\n        node-version: ${{ matrix.node-version }}\n\n    - name: yarn install, build, and test\n      run: |\n        yarn install\n        yarn build\n        yarn test\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v1\n```", "answer": "```yaml name: Node Blog CI\n\non:\n  push:\n    branches-ignore:\n    - release\n  pull_request:\n    branches-ignore:\n    - release\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16.x]\n    steps:\n    - uses: actions/checkout@master\n    - name: Launch MongoDB\n      uses: wbari/start-mongoDB@master\n      with:\n        mongoDBVersion: 5\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@master\n      with:\n        node-version: ${{ matrix.node-version }}\n    - name: yarn install, build, and test\n      run: |\n        yarn install\n        yarn run build\n        yarn run test:cov\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@master\n      with:\n        token: ${{secrets.CODECOV_TOKEN}}\n      env:\n        CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node Blog CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event unless the push event is to: a branch named release. 2) The workflow would run whenever there is a pull_request event unless the pull request is targeting: a branch named release. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `node-version` has one value: 16.x. The job `build` has 5 steps. The 1st step is named ``. The 2nd step is named `Launch MongoDB`. The 3rd step is named `Use Node.js ${{ matrix.node-version }}`. The 4th step is named `yarn install, build, and test`. The 5th step is named `Upload coverage to Codecov`. "}
{"id": "63c496561899db58864d23cc", "level": "level4", "llm_response": "```yaml\nname: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  mysql:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: mysql\n      versions: \"[5.6, 5.7, \\\"8.0\\\", \\\"galera.3.mysql_wsrep.5.6\\\", \\\"galera.4.10.mysql_wsrep.8.0.26\\\", \\\"mariadb.10.3\\\", \\\"mariadb.10.4\\\", \\\"mariadb.10.5\\\", \\\"mariadb.10.6\\\"]\"\n```", "answer": "```yaml name: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      # Plugins\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  mysql:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: mysql\n      versions: '[5.6, 5.7, \"8.0\", \"galera.3.mysql_wsrep.5.6\", \"galera.4.10.mysql_wsrep.8.0.26\", \"mariadb.10.3\", \"mariadb.10.4\", \"mariadb.10.5\", \"mariadb.10.6\"]'\n```", "prompt": "Generate a GitHub Workflow named `Molecule - MySQL` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.mysql.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/mysql.*/**, roles/mysql/**, plugins/filter/mysql_config.py, plugins/filter/staten.py or plugins/lookup/templates_exclusive.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `mysql`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 3 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}`, the input `scenario` is `mysql` and the input `versions` is `[5.6, 5.7, \"8.0\", \"galera.3.mysql_wsrep.5.6\", \"galera.4.10.mysql_wsrep.8.0.26\", \"mariadb.10.3\", \"mariadb.10.4\", \"mariadb.10.5\", \"mariadb.10.6\"]`. "}
{"id": "63c495a88052faa2781b34fc", "level": "level4", "llm_response": "```yaml\nname: Build iso from elemental-iso-build as external user\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Install Docker\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y docker.io\n      - name: Install deps\n        run: go mod download\n      - name: Build iso from script\n        run: ./build_iso.sh\n      - name: Check config was inserted\n        run: grep -q \"config inserted\" output.log\n      - name: Basic sanity checks for ISO\n        run: ./sanity_checks.sh\n```", "answer": "```yaml name: Build iso from elemental-iso-build as external user\n# Test building the iso from an external point of view\n# This tests doesn't clone the repo, just interacts with the script as an external user would do\n# Gets the script only and runs it to see if the building is done properly\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Install Docker\n        uses: docker-practice/actions-setup-docker@v1\n      - name: Install deps\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y mkisofs\n      - name: Build iso from script\n        run: |\n          # Just a simple run to test the build script, no need to upload the generated iso!\n          echo \"TEST\" > config.yaml\n          curl -fsSL https://raw.githubusercontent.com/rancher/elemental/main/.github/elemental-iso-build -o elemental-iso-build\n          chmod +x ./elemental-iso-build\n          ./elemental-iso-build config.yaml\n      - name: Check config was inserted\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Extract config and check against our config\n          isoinfo -x /livecd-cloud-config.yaml -R -i $ISO > livecd-cloud-config.yaml\n          # This checks that the files are the same content\n          cmp config.yaml livecd-cloud-config.yaml\n      - name: Basic sanity checks for ISO\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Check it has eltorito\n          isoinfo -d -i $ISO|grep -q Eltorito\n          # check bootable flag\n          isoinfo -d -i $ISO|grep -q bootable        \n```", "prompt": "Generate a GitHub Workflow named `Build iso from elemental-iso-build as external user` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `deploy`. This job will run on ubuntu-latest runner. The job `deploy` has 5 steps. The 1st step is named `Install Docker`. The 2nd step is named `Install deps`. The 3rd step is named `Build iso from script`. The 4th step is named `Check config was inserted`. The 5th step is named `Basic sanity checks for ISO`. "}
{"id": "63c495878052faa2781b26e9", "level": "level4", "llm_response": "```yaml\nname: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Autoclose issues\n      run: |\n        # Add your autoclose logic here\n        echo \"Autoclosing issues based on criteria\"\n```", "answer": "```yaml name: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoclose issues\n        uses: arkon/issue-closer-action@v3.4\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          ignoreLabel: do-not-autoclose\n          rules: |\n            [\n              {\n                \"type\": \"title\",\n                \"regex\": \".*<(Source Name|short description)>*\",\n                \"message\": \"You did not fill out the description in the title\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*DELETE THIS SECTION IF YOU HAVE READ AND ACKNOWLEDGED IT.*\",\n                \"message\": \"The acknowledgment section was not removed\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*\\\\* (Aniyomi version|Android version|Device|Name|Link|Extension version): \\\\?.*\",\n                \"message\": \"The requested information was not filled out\"\n              }\n            ]\n```", "prompt": "Generate a GitHub Workflow named `Issue closer` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: an issue is opened, the title or body on an issue is edited or a closed issue is reopened. The workflow has one job. The job id of the 1st job is `autoclose`. This job will run on ubuntu-latest runner. The job `autoclose` has one step. The 1st step is named `Autoclose issues`. "}
{"id": "63c495257843b61269a05b78", "level": "level4", "llm_response": "```yaml\nname: Flatpak dependency updates\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-20.04\n\n    steps:\n    - name: Step 1\n      run: echo \"Step 1 is running\"\n\n    - name: Step 2\n      run: echo \"Step 2 is running\"\n```", "answer": "```yaml name: Flatpak dependency updates\non:\n  schedule: # for scheduling to work this file must be in the default branch\n  - cron: \"0 0 * * *\" # run every day\n  workflow_dispatch: # can be manually dispatched under GitHub's \"Actions\" tab \n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-20.04\n\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          # we can't push changes to a fork via a shallow update, we need to clone the full repo\n          fetch-depth: 0\n          # by default when persisting credentials the local git config will use the workflow provided GITHUB_TOKEN, not our own GITHUB_TOKEN env var for the container\n          # we must not use the provided GITHUB_TOKEN, as it will fail to push to the fork since the provided GITHUB_TOKEN is only for the repository where the workflow is running \n          persist-credentials: false\n\n      - uses: docker://ghcr.io/flathub/flatpak-external-data-checker:latest\n        env:\n          GIT_AUTHOR_NAME: EasyEffects Bot\n          GIT_COMMITTER_NAME: EasyEffects Bot\n          # email sets \"EasyEffects Bot\" user as commit author\n          GIT_AUTHOR_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GIT_COMMITTER_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GITHUB_TOKEN: ${{ secrets.EASYEFFECTS_BOT }}\n        with:\n          args: --update --always-fork util/flatpak/com.github.wwmm.easyeffects.Devel.json\n```", "prompt": "Generate a GitHub Workflow named `Flatpak dependency updates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `flatpak-external-data-checker`. This job will run on ubuntu-20.04 runner. The job `flatpak-external-data-checker` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c494a27843b61269a02770", "level": "level4", "llm_response": "```yaml\nname: Doc Site\n\non:\n  push:\n    branches:\n      - master\n  workflow_dispatch:\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-and-deploy-site:\n    id: build-and-deploy-site\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2\n      \n      - name: Install and Build \ud83d\udd27\n        run: |\n          npm install\n          npm run build\n      \n      - name: Deploy \ud83d\ude80\n        run: |\n          npm run deploy\n```", "answer": "```yaml # This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Doc Site\n\non:\n  push:\n    branches: [master]\n  workflow_dispatch:\n\njobs:\n  build-and-deploy-site:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n\n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install --legacy-peer-deps\n          npm run docs:build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4.2.5\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist/site # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Doc Site` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build-and-deploy-site`. This job will run on ubuntu-latest runner. Only a single job using the ci-${{ github.ref }} concurrency group will run at a time. The job `build-and-deploy-site` has 3 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install and Build \ud83d\udd27`. The 3rd step is named `Deploy \ud83d\ude80`. "}
{"id": "63c495bf8052faa2781b3ef6", "level": "level4", "llm_response": "```yaml\nname: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - master\n    paths:\n      - .github/workflows/mol_tree2_lib.yml\n      - tree2/**\n  pull_request:\n  schedule:\n    - cron: '0 7 * * *'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n      - name: Step 2\n```", "answer": "```yaml name: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches: \n      - master\n    paths:\n      - '.github/workflows/mol_tree2_lib.yml'\n      - 'tree2/**'\n  pull_request:\n  schedule:\n    - cron: \"0 7 * * *\"\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    \n    steps:\n    \n    - uses: hyoo-ru/mam_build@master2\n      with:\n        package: mol\n        modules: tree2/lib\n    \n    - uses: JS-DevTools/npm-publish@v1\n      if: ${{ github.ref == 'refs/heads/master' }}\n      with:\n        token: ${{ secrets.NPM_AUTH_TOKEN }}\n        package: ./mol/tree2/lib/-/package.json\n```", "prompt": "Generate a GitHub Workflow named `mol_tree2_lib` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/mol_tree2_lib.yml or tree2/**), the workflow runs. 3) there is activity relating to a pull request. 4) the scheduled time has come: at 07:00 am. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c496361e33648075779191", "level": "level4", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. This job will run on ubuntu-latest runner. The job `update_release_draft` has one step. The 1st step is named ``. "}
{"id": "63c496561899db58864d23d2", "level": "level4", "llm_response": "```yaml\nname: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  ntp:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug-the == true }}\n      scenario: ntp\n```", "answer": "```yaml name: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  ntp:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: ntp\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Ntp` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.ntp.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/ntp/** or roles/ntp/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `ntp`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 2 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}` and the input `scenario` is `ntp`. "}
{"id": "63c494847843b61269a01ad6", "level": "level4", "llm_response": "```yaml\nname: Release v1 NPM Package\n\non:\n  workflow_dispatch:\n    inputs:\n      tag-this:\n        description: 'Enter the version for the release tag'\n        required: true\n        type: string\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  merge-to-v1-branch:\n    id: merge-to-v1-branch\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v2\n\n    - name: Checkout v1 branch and merge\n      run: |\n        git checkout v1\n        git merge master\n\n    - name: Generate new tag, push tag and branch\n      run: |\n        NEW_TAG=${{ github.event.inputs.tag-this }}\n        git tag $NEW_TAG\n        git push origin $NEW_TAG\n        git push origin v1\n```", "answer": "```yaml name: \"Release v1 NPM Package\"\non:\n  workflow_dispatch:\n    inputs:\n      tag:\n        description: |\n          Enter the version for the release tag.\n          Must be larger than last tag.\n          Use patch (0.0.x) for bug fixes.\n          Use minor (0.x.0) for new actions.\n        type: string\n        required: true\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false\njobs:\n  merge-to-v1-branch:\n    name: Create release by rebasing master to v1 and create a new tag\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n          registry-url: 'https://registry.npmjs.org'\n      - run: yarn install\n      - name: Set git name, mail and origin\n        run: |\n          git config --global user.name \"Josef Fr\u00f6hle\"\n          git config --global user.email \"github@josef-froehle.de\"\n          git remote set-url origin https://${{ secrets.BOT_PIPELINE_TOKEN }}@github.com/${{ github.repository }}\n      - name: Checkout v1 branch and merge\n        run: |\n          git checkout v1\n          git merge --ff-only master\n      - name: Generate new tag, push tag and branch\n        run: |\n          yarn run build\n          yarn version --non-interactive --no-git-tag-version --new-version ${{ github.event.inputs.tag }}\n          yarn run changelog\n          yarn run documentation\n          git add -A\n          yarn version --non-interactive --no-git-tag-version --new-version 0.0.0\n          yarn version --non-interactive --new-version ${{ github.event.inputs.tag }}\n          git push\n          git push --tags\n          git checkout master\n          git merge --ff-only v1\n          git push\n          git subtree split --prefix docs -b gh-pages\n          git push -f origin gh-pages:gh-pages\n      - run: yarn publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release v1 NPM Package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: tag-this input represents enter the version for the release tag.\nmust be larger than last tag.\nuse patch (0.0.x) for bug fixes.\nuse minor (0.x.0) for new actions.\n, the data type is string and it must be supplied. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Create release by rebasing master to v1 and create a new tag` and its job id is `merge-to-v1-branch`. This job will run on ubuntu-latest runner. The job `merge-to-v1-branch` has 7 steps. The 1st step is named `Checkout`. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Set git name, mail and origin`. The 5th step is named `Checkout v1 branch and merge`. The 6th step is named `Generate new tag, push tag and branch`. The 7th step is named ``. "}
{"id": "63c4963f1e3364807577960f", "level": "level4", "llm_response": "```yaml\nname: Validate Gradle Wrapper\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  validation:\n    id: validation\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Validate Gradle Wrapper\n      run: ./gradlew wrapper --gradle-version=7.0\n```", "answer": "```yaml name: \"Validate Gradle Wrapper\"\n\non: [ pull_request ]\n\njobs:\n  validation:\n    name: \"Validation\"\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gradle/wrapper-validation-action@v1\n```", "prompt": "Generate a GitHub Workflow named `Validate Gradle Wrapper` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Validation` and its job id is `validation`. This job will run on ubuntu-latest runner. The job `validation` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c4969cb008460c1df157a0", "level": "level4", "llm_response": "```yaml\nname: Post-release\n\non:\n  release:\n    types: [published, prereleased, edited]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: Post-release\non:\n  release:\n    types:\n      - published\n      - edited\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: apexskier/github-release-commenter@v1\n        with:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          comment-template: This is addressed by {release_link}.\n          label-template: released\n```", "prompt": "Generate a GitHub Workflow named `Post-release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published or the details of a release, pre-release, or draft release are edited. The workflow has one job. The job id of the 1st job is `release`. This job will run on ubuntu-latest runner. The job `release` has one step. The 1st step is named ``. "}
{"id": "63c4946e8052faa2781ab27f", "level": "level4", "llm_response": "```yaml\nname: test\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macOS-latest]\n    max-parallel: 2\n    timeout-minutes: 10\n    steps:\n      - name: Checkout code\n      - name: Set up Go\n      - name: Test\n\n  testacc:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        terraform: [1.0.0, 0.15.5, 0.14.11, 0.13.7, 0.12.31]\n    env:\n      TERRAFORM_VERSION: ${{ matrix.terraform }}\n    max-parallel: 2\n    timeout-minutes: 10\n    steps:\n      - name: Checkout code\n      - name: Docker build\n      - name: Terraform version\n      - name: Test acceptance\n```", "answer": "```yaml name: test\npermissions:\n  contents: read\n\non:\n  push:\n    branches:\n    - master\n  pull_request:\n    branches:\n    - master\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        os:\n        - ubuntu-latest\n        - macOS-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-go@v3\n      with:\n        go-version-file: '.go-version'\n        cache: true\n    - name: test\n      run: make test\n  testacc:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        terraform:\n        - 1.0.0\n        - 0.15.5\n        - 0.14.11\n        - 0.13.7\n        - 0.12.31\n    env:\n      TERRAFORM_VERSION: ${{ matrix.terraform }}\n    steps:\n    - uses: actions/checkout@v3\n    - name: docker build\n      run: docker-compose build\n    - name: terraform --version\n      run: docker-compose run --rm tfschema terraform --version\n    - name: testacc\n      run: docker-compose run --rm tfschema make testacc\n```", "prompt": "Generate a GitHub Workflow named `test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `test`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `os` has 2 values: ubuntu-latest and macOS-latest. The maximum number of minutes to run the job is 10. The job `test` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `test`. The job id of the 2nd job is `testacc`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `terraform` has 5 values: 1.0.0, 0.15.5, 0.14.11, 0.13.7 and 0.12.31. The job sets an environment variable to use: `TERRAFORM_VERSION` is set to `${{ matrix.terraform }}`. The maximum number of minutes to run the job is 10. The job `testacc` has 4 steps. The 1st step is named ``. The 2nd step is named `docker build`. The 3rd step is named `terraform --version`. The 4th step is named `testacc`. "}
{"id": "63c495297843b61269a05d16", "level": "level4", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  golangci:\n    id: golangci\n    runs-on: ubuntu-latest\n    timeout-minutes: 8\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n      - name: Run golangci-lint\n        run: go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.43.0\n        run: golangci-lint run\n```", "answer": "```yaml name: Lint\n# Lint runs golangci-lint over the entire cosmos-sdk repository\n# This workflow is run on every pull request and push to main\n# The `golangci` will pass without running if no *.{go, mod, sum} files have been changed.\non:\n  pull_request:\n  push:\n    branches:\n      - main\njobs:\n  golangci:\n    name: golangci-lint\n    runs-on: ubuntu-latest\n    timeout-minutes: 8\n    steps:\n      - uses: actions/setup-go@v3\n        with:\n          go-version: 1.18\n      - uses: actions/checkout@v3\n      - uses: technote-space/get-diff-action@v6.1.0\n        with:\n          PATTERNS: |\n            **/**.go\n            go.mod\n            go.sum\n      - uses: golangci/golangci-lint-action@v3.2.0\n        with:\n          version: v1.47.2\n          args: --timeout 10m\n          github-token: ${{ secrets.github_token }}\n        if: env.GIT_DIFF\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The 1st job is named `golangci-lint` and its job id is `golangci`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 8. The job `golangci` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c4951f7843b61269a0593e", "level": "level4", "llm_response": "```yaml\nname: goreleaser\n\non:\n  push:\n    tags:\n      - '*'\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Fetch tags\n        run: git fetch --tags\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Run Goreleaser\n        run: goreleaser release --snapshot --rm-dist\n```", "answer": "```yaml name: goreleaser\non:\n  push:\n    tags:\n      - \"*\"\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          fetch-depth: 0\n\n      - name: fetch tags\n        run: git fetch --tags --force\n\n      - uses: actions/setup-go@v3.3.0\n        with:\n          go-version: 1.19\n\n      - uses: goreleaser/goreleaser-action@v3.1.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          distribution: goreleaser\n          version: latest\n          args: release -f ci/.goreleaser.yml\n```", "prompt": "Generate a GitHub Workflow named `goreleaser` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches *. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `release`. This job will run on ubuntu-latest runner. The job `release` has 4 steps. The 1st step is named ``. The 2nd step is named `fetch tags`. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c4967e33b087f6bde2c5c1", "level": "level4", "llm_response": "```yaml\nname: Dependabot auto-merge\n\non:\n  pull_request:\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n    if: ${{ github.actor == 'dependabot[bot]' }}\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        run: echo \"This step retrieves metadata about the Dependabot PR\"\n\n      - name: Enable auto-merge for Dependabot PRs\n        run: echo \"This step enables auto-merge for Dependabot PRs\"\n```", "answer": "```yaml ---\nname: Dependabot auto-merge\n\"on\": pull_request\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n    if: ${{ github.actor == 'dependabot[bot]' }}\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        uses: dependabot/fetch-metadata@v1.3.4\n        with:\n          github-token: \"${{ secrets.GITHUB_TOKEN }}\"\n      - name: Enable auto-merge for Dependabot PRs\n        if: >-\n          ${{\n          steps.metadata.outputs.update-type == 'version-update:semver-patch' ||\n          steps.metadata.outputs.update-type == 'version-update:semver-minor'\n          }}\n        run: gh pr merge --auto --merge \"$PR_URL\"\n        env:\n          PR_URL: ${{github.event.pull_request.html_url}}\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n```", "prompt": "Generate a GitHub Workflow named `Dependabot auto-merge` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope and write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `dependabot`. This job will run only if the condition(${{ github.actor == 'dependabot[bot]' }}) is met. This job will run on ubuntu-latest runner. The job `dependabot` has 2 steps. The 1st step is named `Dependabot metadata` and its id is `metadata`. The 2nd step is named `Enable auto-merge for Dependabot PRs`. "}
{"id": "63c496326fc19abdf9c9a7c5", "level": "level4", "llm_response": "```yaml\nname: Test CI\n\non:\n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install requirements\n        run: |\n          # Add installation commands for requirements\n      - name: Install Tangerine\n        run: |\n          # Add installation commands for Tangerine\n      - name: Build Runner\n        run: |\n          # Add build commands for the runner\n      - name: Run Tests\n        run: |\n          # Add test commands\n```", "answer": "```yaml name: Test CI\n\non: \n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on:   ubuntu-latest\n    container: alpine\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Install requirements\n      run: |\n        apk update && apk upgrade \n        apk add make bash coreutils neovim lua5.4\n        # links lua5.4 -> lua\n        ln -sv /usr/bin/lua5.4           /usr/bin/lua\n        ln -sv /usr/lib/lua5.4/liblua.so /usr/lib/liblua5.4.so\n\n    - name: Install Tangerine\n      run:  make install\n\n    - name: Build Runner\n      run:  make runner\n\n    - name: Run Tests\n      run:  yes | make test\n```", "prompt": "Generate a GitHub Workflow named `Test CI` for a GitHub repository whose primary programming language is Fennel. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) Only if at least one path of push event matches a pattern in the paths filter(lua/**, test/** or .github/**), the workflow runs. The workflow has one job. The job id of the 1st job is `test`. This job will run on ubuntu-latest runner. The job creates a Docker container that uses `alpine` image. The job `test` has 5 steps. The 1st step is named ``. The 2nd step is named `Install requirements`. The 3rd step is named `Install Tangerine`. The 4th step is named `Build Runner`. The 5th step is named `Run Tests`. "}
{"id": "63c495207843b61269a059a2", "level": "level4", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Add label to pull request\n        run: |\n          gh pr edit ${{ github.event.pull_request.number }} --add-label \"Needs review\"\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler/blob/master/README.md\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/labeler@v4\n      with:\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. This job will run on ubuntu-latest runner. The job `label` has one step. The 1st step is named ``. "}
{"id": "63c494378052faa2781a9e70", "level": "level4", "llm_response": "```yaml\nname: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches:\n      - main\n    types: [opened, synchronize, reopened, ready_for_review]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v2\n\n      - name: Protobuf format\n        run: make format-protobuf\n\n      - name: Lint shell, Docker and protobuf\n        run: make lint-shell-docker-protobuf\n```", "answer": "```yaml name: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches: [ main ]\n    types: [opened, synchronize, reopened, ready_for_review]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v3\n        with:\n          # Full git history isn't needed to get a proper list of changed files within `super-linter`\n          fetch-depth: 0\n\n      - name: Protobuf format\n        uses: jidicula/clang-format-action@v4.9.0\n        with:\n          clang-format-version: '14'\n  \n      - name: Lint shell, Docker and protobuf\n        uses: github/super-linter/slim@v4\n        env:\n          VALIDATE_ALL_CODEBASE: false\n          DEFAULT_BRANCH: main\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # Select file types to lint. Python and Rust linters are configured separately.\n          VALIDATE_SHELL_SHFMT: true\n          #\n          # disable hadolint \n          # https://github.com/hadolint/hadolint/issues/821\n          # VALIDATE_DOCKERFILE_HADOLINT: true\n          # DOCKERFILE_HADOLINT_FILE_NAME: .github/config/.hadolint.yaml\n          #\n          # Enable after fixing proto lint issues.\n          # VALIDATE_PROTOBUF: true\n```", "prompt": "Generate a GitHub Workflow named `Miscellaneous Lint` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named devnet. 2) a pull request is created, a pull request's head branch is updated, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `lint`. This job will run on ubuntu-latest runner. The job `lint` has 3 steps. The 1st step is named `Checkout Code`. The 2nd step is named `Protobuf format`. The 3rd step is named `Lint shell, Docker and protobuf`. "}
{"id": "63c496561899db58864d23b6", "level": "level4", "llm_response": "```yaml\nname: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  docker:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: docker\n```", "answer": "```yaml name: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      # Plugins\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  docker:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: docker\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Docker` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.docker.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/docker/**, roles/docker/**, plugins/filter/json.py, plugins/filter/staten.py or plugins/lookup/docker_applications.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `docker`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 2 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}` and the input `scenario` is `docker`. "}
{"id": "63c496851899db58864d36f3", "level": "level4", "llm_response": "```yaml\nname: Test with Pre-commit\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [3.10]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Lint with pre-commit\n        run: |\n          pip install pre-commit\n          pre-commit run --all-files\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Test with Pre-commit\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.10\"]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pre-commit\n          pre-commit install-hooks\n      - name: Lint with pre-commit\n        run: pre-commit run --all-files\n```", "prompt": "Generate a GitHub Workflow named `Test with Pre-commit` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `python-version` has one value: 3.10. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python ${{ matrix.python-version }}`. The 3rd step is named `Install dependencies`. The 4th step is named `Lint with pre-commit`. "}
{"id": "63c495e58052faa2781b4fae", "level": "level4", "llm_response": "```yaml\nname: Self-assign\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  one:\n    runs-on: ubuntu-latest\n    if: |\n      (github.event.comment.body == '#take' ||\n      github.event.comment.body == '#self-assign') &&\n      (!github.event.issue.pull_request)\n    steps:\n      - name: ''\n```", "answer": "```yaml # Allow users to automatically tag themselves to issues\n\nname: Self-assign\non:\n  issue_comment:\n    types: created\njobs:\n  one:\n    runs-on: ubuntu-latest\n    if: >-\n      (github.event.comment.body == '#take' ||\n       github.event.comment.body == '#self-assign') &&\n       (!github.event.issue.pull_request)\n    steps:\n      - run: |\n          echo \"Assigning issue ${{ github.event.issue.number }} to ${{ github.event.comment.user.login }}\"\n          curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -d '{\"assignees\": [\"${{ github.event.comment.user.login }}\"]}' https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/assignees\n```", "prompt": "Generate a GitHub Workflow named `Self-assign` for a GitHub repository whose primary programming language is Jupyter Notebook. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `one`. This job will run only if the condition((github.event.comment.body == '#take' ||\n github.event.comment.body == '#self-assign') &&\n (!github.event.issue.pull_request)) is met. This job will run on ubuntu-latest runner. The job `one` has one step. The 1st step is named ``. "}
{"id": "63c496561899db58864d23c2", "level": "level4", "llm_response": "```yaml\nname: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  java:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: java\n```", "answer": "```yaml name: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  java:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: java\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Java` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.java.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/java/** or roles/java/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `java`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 2 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}` and the input `scenario` is `java`. "}
{"id": "63c4957c8052faa2781b2239", "level": "level4", "llm_response": "```yaml\nname: Add Issues/PRs to TF Provider DevEx team board\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    id: add-content-to-project\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Set Issue to 'Priority = Triage Next'\n        run: |\n          # Add your code here to set the issue priority to 'Triage Next'\n          echo \"Issue priority set to 'Triage Next'\"\n\n      - name: Set Pull Request to 'Priority = Triage Next'\n        run: |\n          # Add your code here to set the pull request priority to 'Triage Next'\n          echo \"Pull request priority set to 'Triage Next'\"\n```", "answer": "```yaml # Based on https://github.com/leonsteinhaeuser/project-beta-automations\n\nname: \"Add Issues/PRs to TF Provider DevEx team board\"\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request_target:\n    # NOTE: The way content is added to project board is equivalent to an \"upsert\".\n    # Calling it multiple times will be idempotent.\n    #\n    # See https://securitylab.github.com/research/github-actions-preventing-pwn-requests/\n    #\u00a0to see the reasoning behind using `pull_request_target` instead of `pull_request`\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    name: \"Add Content to project\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Set Issue to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'issues'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.issue.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n      - name: \"Set Pull Request to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'pull_request_target'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.pull_request.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n```", "prompt": "Generate a GitHub Workflow named `Add Issues/PRs to TF Provider DevEx team board` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) an issue is opened or a closed issue is reopened. 2) a pull request is created, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow has one job. The 1st job is named `Add Content to project` and its job id is `add-content-to-project`. This job will run on ubuntu-latest runner. The job `add-content-to-project` has 2 steps. The 1st step is named `Set Issue to 'Priority = Triage Next'`. The 2nd step is named `Set Pull Request to 'Priority = Triage Next'`. "}
{"id": "63c49697b008460c1df15590", "level": "level4", "llm_response": "```yaml\nname: Release\n\non:\n  release:\n    types: [published, prereleased, drafted]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Build the file\n      run: npm run build\n\n    - name: Upload zip to release\n      uses: actions/upload-release-asset@v1\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      with:\n        upload_url: ${{ github.event.release.upload_url }}\n        asset_path: dist.zip\n        asset_name: dist.zip\n        asset_content_type: application/zip\n\n    - name: HACS Action\n      run: |\n        # Add your HACS Action commands here\n        echo \"Running HACS Action...\"\n```", "answer": "```yaml name: Release\n\non:\n  release:\n    types: [published]\n\njobs:\n  release:\n    name: Prepare release\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n\n      # Build\n      - name: Build the file\n        run: |\n          cd /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card\n          npm install\n          npm run build\n\n      # Upload build file to the releas as an asset.\n      - name: Upload zip to release\n        uses: svenstaro/upload-release-action@v1-release\n\n        with:\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          file: /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card/dist/thermostat-dark-card.js\n          asset_name: thermostat-dark-card.js\n          tag: ${{ github.ref }}\n          overwrite: true\n      - name: HACS Action\n        uses: \"hacs/action@main\"\n        with:\n          category: \"plugin\"\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow has one job. The 1st job is named `Prepare release` and its job id is `release`. This job will run on ubuntu-latest runner. The job `release` has 4 steps. The 1st step is named ``. The 2nd step is named `Build the file`. The 3rd step is named `Upload zip to release`. The 4th step is named `HACS Action`. "}
{"id": "63c4955b8052faa2781b1498", "level": "level4", "llm_response": "```yaml\nname: CI v2\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go: [1.16]\n    steps:\n      - name: Setup\n        run: echo \"Setting up the environment\"\n      - name: Prerequisites\n        run: echo \"Installing prerequisites\"\n      - name: Checkout\n        uses: actions/checkout@v2\n      - name: Dependencies\n        run: go mod download\n      - name: Lint\n        run: go vet ./...\n      - name: Vet\n        run: go lint ./...\n      - name: Test\n        run: go test -v ./...\n      - name: Coverage\n        run: go test -coverprofile=coverage.out && go tool cover -func=coverage.out\n```", "answer": "```yaml name: CI v2\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go: ['1.16']\n    steps:\n    - name: Setup\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Prerequisites\n      run: |\n        sudo apt-get update\n        sudo apt-get -y install libvlc-dev vlc-plugin-base vlc-plugin-video-output vlc-plugin-access-extra\n\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Dependencies\n      working-directory: ./v2\n      run: |\n        go version\n        go get -v -t -d ./...\n        go install golang.org/x/lint/golint@latest\n\n    - name: Lint\n      working-directory: ./v2\n      run: golint -set_exit_status=1 ./...\n\n    - name: Vet\n      working-directory: ./v2\n      run: go vet -unsafeptr=false ./...\n\n    - name: Test\n      working-directory: ./v2\n      run: go test -v -coverprofile=coverage.txt -covermode=atomic ./...\n\n    - name: Coverage\n      uses: codecov/codecov-action@v3\n```", "prompt": "Generate a GitHub Workflow named `CI v2` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `go` has one value: 1.16. The job `build` has 8 steps. The 1st step is named `Setup`. The 2nd step is named `Prerequisites`. The 3rd step is named `Checkout`. The 4th step is named `Dependencies`. The 5th step is named `Lint`. The 6th step is named `Vet`. The 7th step is named `Test`. The 8th step is named `Coverage`. "}
{"id": "63c494b87843b61269a03054", "level": "level4", "llm_response": "```yaml\nname: autoupdate\n\non:\n  push:\n    branches-ignore:\n      - version-bump/**\n      - dependabot/**\n      - bot/**\n      - all-contributors/**\n\njobs:\n  autoupdate-for-bot:\n    if: startsWith(github.repository, 'asyncapi/')\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoupdating\n```", "answer": "```yaml # This action is centrally managed in https://github.com/asyncapi/.github/\r\n# Don't make changes to this file in this repo as they will be overwritten with changes made to the same file in above mentioned repo\r\n\r\n# This workflow is designed to work with:\r\n# - autoapprove and automerge workflows for dependabot and asyncapibot.\r\n# - special release branches that we from time to time create in upstream repos. If we open up PRs for them from the very beginning of the release, the release branch will constantly update with new things from the destination branch they are opened against\r\n\r\n# It uses GitHub Action that auto-updates pull requests branches, whenever changes are pushed to their destination branch.\r\n# Autoupdating to latest destination branch works only in the context of upstream repo and not forks\r\n\r\nname: autoupdate\r\n\r\non:\r\n  push:\r\n    branches-ignore:  \r\n      - 'version-bump/**'\r\n      - 'dependabot/**'\r\n      - 'bot/**'\r\n      - 'all-contributors/**'\r\n\r\njobs:\r\n  autoupdate-for-bot:\r\n    if: startsWith(github.repository, 'asyncapi/')\r\n    name: Autoupdate autoapproved PR created in the upstream\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - name: Autoupdating\r\n        uses: docker://chinthakagodawita/autoupdate-action:v1\r\n        env:\r\n          GITHUB_TOKEN: '${{ secrets.GH_TOKEN_BOT_EVE }}'\r\n          PR_FILTER: \"labelled\"\r\n          PR_LABELS: \"autoupdate\"\r\n          PR_READY_STATE: \"ready_for_review\"\r\n          MERGE_CONFLICT_ACTION: \"ignore\"\r\n```", "prompt": "Generate a GitHub Workflow named `autoupdate` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: The workflow would run whenever there is a push event unless the push event is to: a branch whose name matches version-bump/**, a branch whose name matches dependabot/**, a branch whose name matches bot/** or a branch whose name matches all-contributors/**. The workflow has one job. The 1st job is named `Autoupdate autoapproved PR created in the upstream` and its job id is `autoupdate-for-bot`. This job will run only if the condition(startsWith(github.repository, 'asyncapi/')) is met. This job will run on ubuntu-latest runner. The job `autoupdate-for-bot` has one step. The 1st step is named `Autoupdating`. "}
{"id": "63c494877843b61269a01c1e", "level": "level4", "llm_response": "```yaml\nname: Prepare Release\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version number'\n        required: true\n        type: string\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Push Tag\n      run: git tag ${{ github.event.inputs.version }} && git push origin ${{ github.event.inputs.version }}\n```", "answer": "```yaml \nname: Prepare Release\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version Number'\n        required: true\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Push Tag\n      run: | \n            echo \"version is ${{ github.event.inputs.version }}\"\n            git config user.name \"GitHub Actions Bot\"\n            git config user.email \"<>\"\n            sed -i \"/is_master/d\" fxmanifest.lua\n            sed -i \"/^version/c\\version '${{ github.event.inputs.version }}'\" fxmanifest.lua\n            git add .\n            git commit -m \"${{ github.event.inputs.version }}\"\n            git tag -a ${{ github.event.inputs.version }} -m \"Version ${{ github.event.inputs.version }}\"\n            sed -i \"/^version/ais_master 'yes'\" fxmanifest.lua\n            git add .\n            git commit -m \"Update Version\"\n            git push --follow-tags\n```", "prompt": "Generate a GitHub Workflow named `Prepare Release` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: version-this input represents version number and it must be supplied. The workflow has one job. The job id of the 1st job is `create`. This job will run on ubuntu-latest runner. The job `create` has 2 steps. The 1st step is named ``. The 2nd step is named `Push Tag`. "}
{"id": "63c4966d33b087f6bde2bebf", "level": "level4", "llm_response": "```yaml\nname: CodeQL\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    id: analyse\n    runs-on: ubuntu-20.04\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n    - name: Setup Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: '1.16'\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v1\n      with:\n        languages: go\n    - name: Autobuild\n      run: go build -v ./...\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v1\n```", "answer": "```yaml name: \"CodeQL\"\n\non:\n  workflow_dispatch:\n  push:\n    branches: [main]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [main]\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    name: Analyse\n    runs-on: ubuntu-20.04\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n      with:\n        # We must fetch at least the immediate parents so that if this is\n        # a pull request then we can checkout the head.\n        fetch-depth: 2\n\n    # If this run was triggered by a pull request event, then checkout\n    # the head of the pull request instead of the merge commit.\n    - run: git checkout HEAD^2\n      if: ${{ github.event_name == 'pull_request' }}\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      # Override language selection by uncommenting this and choosing your languages\n      with:\n        languages: go\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) The workflow would run whenever there is a pull_request event targeting: a branch named main. 4) the scheduled time has come: at 05:00 am, only on sunday. The workflow has one job. The 1st job is named `Analyse` and its job id is `analyse`. This job will run on ubuntu-20.04 runner. The job `analyse` has 5 steps. The 1st step is named `Checkout repository`. The 2nd step is named ``. The 3rd step is named `Initialize CodeQL`. The 4th step is named `Autobuild`. The 5th step is named `Perform CodeQL Analysis`. "}
{"id": "63c496581e3364807577a144", "level": "level4", "llm_response": "```yaml\nname: Remove ALL artifacts\n\non:\n  workflow_dispatch:\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: Remove ALL artifacts\n        run: |\n          rm -rf *\n```", "answer": "```yaml name: Remove ALL artifacts\n\non:\n  workflow_dispatch: # only manually\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - name: Remove ALL artifacts\n        uses: c-hive/gha-remove-artifacts@v1\n        with:\n          age: '0 days'\n          skip-tags: true\n          skip-recent: 0\n```", "prompt": "Generate a GitHub Workflow named `Remove ALL artifacts` for a GitHub repository whose primary programming language is C. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `remove-all-artifacts`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 10. The job `remove-all-artifacts` has one step. The 1st step is named `Remove ALL artifacts`. "}
{"id": "63c494e18052faa2781adf45", "level": "level4", "llm_response": "```yaml\nname: Deploy to GH Pages\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - docs/**\n      - !.github/workflows/deploy-storybook.yml\n      - .storybook/**\n      - .wordpress-org/**\n      - __mocks__/**\n      - __static__/**\n      - bin/**\n      - tests/**\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    id: build-storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build storybook\n        run: npm run build-storybook\n\n      - name: Upload storybook\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./storybook-static\n\n  deploy-gh-pages:\n    id: deploy-gh-pages\n    needs: build-storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    permissions:\n      contents: write\n\n    steps:\n      - name: Harden Runner\n        run: chmod -R a+rwx $GITHUB_WORKSPACE\n\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Download storybook files\n        run: cp -r ${{ github.workspace }}/storybook-static/. .\n\n      - name: Move storybook assets\n        run: mv .storybook-static/* .\n\n      - name: Commit updates\n        run: |\n          git config --global user.name 'github-actions[bot]'\n          git config --global user.email 'github-actions[bot]@users.noreply.github.com'\n          git add .\n          git commit -m \"Deploy storybook to GitHub Pages\"\n          git push origin gh-pages\n```", "answer": "```yaml name: Deploy to GH Pages\n\non:\n  push:\n    # Don't run for irrelevant changes.\n    paths-ignore:\n      - 'docs/**'\n      - '!.github/workflows/deploy-storybook.yml'\n      - '.storybook/**'\n      - '.wordpress-org/**'\n      - '__mocks__/**'\n      - '__static__/**'\n      - 'bin/**'\n      - 'tests/**'\n    branches:\n      - main\n\npermissions:\n  contents: read\n\n# Cancels all previous workflow runs for pull requests that have not completed.\nconcurrency:\n  # The concurrency group contains the workflow name and the (target) branch name.\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    name: Build storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Setup Node\n        uses: actions/setup-node@8c91899e586c5b171469028077307d293428b516\n        with:\n          node-version-file: '.nvmrc'\n          cache: npm\n\n      - name: Install dependencies\n        run: npm ci\n        env:\n          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true\n\n      - name: Build storyook\n        run: npm run storybook:build\n\n      - name: Upload storybook\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: storybook-files\n          path: build/storybook\n\n  deploy-gh-pages:\n    name: Deploy storybook\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write # for Git to git push\n    timeout-minutes: 10\n    needs: [build-storybook]\n    steps:\n      - name: Harden Runner\n        uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n        with:\n          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs\n\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n        with:\n          ref: gh-pages\n          token: ${{ secrets.GOOGLEFORCREATORS_BOT_TOKEN }}\n\n      - name: Download storybook files\n        uses: actions/download-artifact@fb598a63ae348fa914e94cd0ff38f362e927b741\n        with:\n          name: storybook-files\n          path: storybook-files\n\n      - name: Move storybook assets\n        run: |\n          mkdir -p storybook\n          rm -rf storybook/*\n          mv storybook-files/* storybook/\n\n      - name: Commit updates\n        run: |\n          git add .\n          git status\n          git diff --staged --quiet && echo 'No changes to commit; exiting!' && exit 0\n          git commit -m \"Deploy storybook for ${{ github.sha }}\"\n          git pull --rebase --no-edit --quiet\n          git push origin gh-pages\n        env:\n          GIT_AUTHOR_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_AUTHOR_NAME: googleforcreators-bot\n          GIT_COMMITTER_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_COMMITTER_NAME: googleforcreators-bot\n```", "prompt": "Generate a GitHub Workflow named `Deploy to GH Pages` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**, !.github/workflows/deploy-storybook.yml, .storybook/**, .wordpress-org/**, __mocks__/**, __static__/**, bin/** or tests/**), the workflow will not run. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.head_ref || github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `Build storybook` and its job id is `build-storybook`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 10. The job `build-storybook` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Setup Node`. The 3rd step is named `Install dependencies`. The 4th step is named `Build storyook`. The 5th step is named `Upload storybook`. The 2nd job is named `Deploy storybook` and its job id is `deploy-gh-pages`. Before this job runs, `build-storybook` must complete successfully. This job will run on ubuntu-latest runner. The job `deploy-gh-pages` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `deploy-gh-pages`. The maximum number of minutes to run the job is 10. The job `deploy-gh-pages` has 5 steps. The 1st step is named `Harden Runner`. The 2nd step is named `Checkout`. The 3rd step is named `Download storybook files`. The 4th step is named `Move storybook assets`. The 5th step is named `Commit updates`. "}
{"id": "63c496571899db58864d2453", "level": "level4", "llm_response": "```yaml\nname: Lint Checks\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  contents: read\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: Step 4\n        run: echo \"Step 4\"\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Rustfmt check\n        run: cargo fmt -- --check\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Cargo update check\n        run: cargo update\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Cargo doc check\n        run: cargo doc --no-deps\n```", "answer": "```yaml # Syntax reference:\n# https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions\n\nname: Lint Checks\npermissions: read-all\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    types: [opened, synchronize]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          persist-credentials: false\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n      - run: pip install flake8\n      - run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude src/external\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Rustfmt check\n        run: (cd src && cargo fmt -- --check)\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Cargo update check\n        run: |\n          # This will return an error if any versions of local crates in the Cargo.lock\n          # are out of date compared to the crate versions in Cargo.toml. This can fail\n          # if the Shadow version is bumped without using Cargo to update the lock file.\n          (cd src && cargo update --locked --workspace)\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Cargo doc check\n        run: |\n          cmake -S . -B build\n          (cd src && RUSTDOCFLAGS='-D warnings' cargo doc)\n```", "prompt": "Generate a GitHub Workflow named `Lint Checks` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `CARGO_TERM_COLOR` is set to `always`. The workflow has 4 jobs. The job id of the 1st job is `lint-python`. This job will run on ubuntu-latest runner. The job `lint-python` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The job id of the 2nd job is `lint-rust`. This job will run on ubuntu-latest runner. The job `lint-rust` has 2 steps. The 1st step is named ``. The 2nd step is named `Rustfmt check`. The job id of the 3rd job is `lint-cargo-lock`. This job will run on ubuntu-latest runner. The job `lint-cargo-lock` has 2 steps. The 1st step is named ``. The 2nd step is named `Cargo update check`. The job id of the 4th job is `lint-cargo-doc`. This job will run on ubuntu-latest runner. The job `lint-cargo-doc` has 2 steps. The 1st step is named ``. The 2nd step is named `Cargo doc check`. "}
{"id": "63c4956e7843b61269a0794c", "level": "level4", "llm_response": "```yaml\nname: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\njobs:\n  black:\n    id: black\n    runs-on: ubuntu-latest\n    steps:\n      - name: ''\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Black\n        run: black .\n\n  flake8:\n    id: flake8\n    runs-on: ubuntu-latest\n    steps:\n      - name: ''\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install flake8\n      - name: Lint examples\n        run: flake8 examples\n      - name: Lint scripts\n        run: flake8 scripts\n      - name: Lint tests\n        run: flake8 tests\n      - name: Lint moviepy\n        run: flake8 moviepy\n\n  isort:\n    id: isort\n    runs-on: ubuntu-latest\n    steps:\n      - name: ''\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Check imports\n        run: isort --check .\n```", "answer": "```yaml name: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\n\njobs:\n  black:\n    runs-on: ubuntu-latest\n    name: Black\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n      - name: Black\n        uses: psf/black@22.3.0  # already includes args \"--check --diff\"\n  flake8:\n    runs-on: ubuntu-latest\n    name: Flake8\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade wheel pip\n          pip install .[lint]\n      - name: Lint examples\n        run: flake8 examples --show-source\n      - name: Lint scripts\n        run: flake8 setup.py docs/conf.py scripts --show-source\n      - name: Lint tests\n        run: flake8 tests --show-source\n      - name: Lint moviepy\n        run: flake8 moviepy --show-source\n  isort:\n    runs-on: ubuntu-latest\n    name: isort\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Check imports\n        run: isort --check-only moviepy tests examples docs/conf.py scripts\n```", "prompt": "Generate a GitHub Workflow named `Code Format Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. The workflow has 3 jobs. The 1st job is named `Black` and its job id is `black`. This job will run on ubuntu-latest runner. The job `black` has 3 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Black`. The 2nd job is named `Flake8` and its job id is `flake8`. This job will run on ubuntu-latest runner. The job `flake8` has 7 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Install dependencies`. The 4th step is named `Lint examples`. The 5th step is named `Lint scripts`. The 6th step is named `Lint tests`. The 7th step is named `Lint moviepy`. The 3rd job is named `isort` and its job id is `isort`. This job will run on ubuntu-latest runner. The job `isort` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Python`. The 3rd step is named `Install dependencies`. The 4th step is named `Check imports`. "}
{"id": "63c493ea8052faa2781a7e17", "level": "level4", "llm_response": "```yaml\nname: master\n\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  test:\n    id: test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust:\n          - 1.31.0\n          - stable\n    steps:\n      - name: Step 1\n      - name: Step 2\n      - name: Step 3\n      - name: Step 4\n```", "answer": "```yaml name: master\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0' # 00:00 Sunday\n\njobs:\n\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust: [1.31.0, stable]\n    steps:\n      - uses: actions/checkout@v3\n      - uses: dtolnay/rust-toolchain@master\n        with:\n          toolchain: ${{ matrix.rust }}\n      - run: cargo build\n      - run: ./ci/test_full.sh\n```", "prompt": "Generate a GitHub Workflow named `master` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The 1st job is named `Test` and its job id is `test`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `rust` has 2 values: 1.31.0 and stable. The job `test` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c495668052faa2781b18dd", "level": "level4", "llm_response": "```yaml\nname: release management\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Update draft release\n        run: echo \"Updating draft release...\"\n```", "answer": "```yaml name: release management\non:\n  push:\n    branches: [master]\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: toolmantim/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `release management` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `update-draft-release`. This job will run on ubuntu-latest runner. The job `update-draft-release` has one step. The 1st step is named ``. "}
{"id": "63c494608052faa2781aac1c", "level": "level4", "llm_response": "```yaml\nname: ASF-ci\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: True\n  DOTNET_NOLOGO: True\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        configuration: [Debug, Release]\n        os: [macos-latest, ubuntu-latest, windows-latest]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --version\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build --configuration ${{ matrix.configuration }}\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test --configuration ${{ matrix.configuration }}\n\n    - name: Upload latest strings for translation on Crowdin\n      run: |\n        # Add your Crowdin upload command here\n        echo \"Uploading strings to Crowdin...\"\n```", "answer": "```yaml name: ASF-ci\n\non: [push, pull_request]\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: true\n  DOTNET_NOLOGO: true\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    strategy:\n      fail-fast: false\n      matrix:\n        configuration: [Debug, Release]\n        os: [macos-latest, ubuntu-latest, windows-latest]\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n      with:\n        submodules: recursive\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v3.0.2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --info\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test ArchiSteamFarm.Tests -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Upload latest strings for translation on Crowdin\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && matrix.configuration == 'Release' && startsWith(matrix.os, 'ubuntu-') }}\n      uses: crowdin/github-action@1.4.16\n      with:\n        crowdin_branch_name: main\n        config: '.github/crowdin.yml'\n        project_id: ${{ secrets.ASF_CROWDIN_PROJECT_ID }}\n        token: ${{ secrets.ASF_CROWDIN_API_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `ASF-ci` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow sets 3 environment variables to use: `DOTNET_CLI_TELEMETRY_OPTOUT` is set to `True`, `DOTNET_NOLOGO` is set to `True` and `DOTNET_SDK_VERSION` is set to `6.0.x`. The workflow has one job. The job id of the 1st job is `main`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `configuration` has 2 values: Debug and Release. The variable `os` has 3 values: macos-latest, ubuntu-latest and windows-latest. The job `main` has 6 steps. The 1st step is named `Checkout code`. The 2nd step is named `Setup .NET Core`. The 3rd step is named `Verify .NET Core`. The 4th step is named `Build ${{ matrix.configuration }} ArchiSteamFarm and other projects`. The 5th step is named `Run ${{ matrix.configuration }} ArchiSteamFarm.Tests`. The 6th step is named `Upload latest strings for translation on Crowdin`. "}
{"id": "63c495da7843b61269a0a66e", "level": "level4", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        go: [1.19]\n        os: [ubuntu-20.04, ubuntu-22.04, macos-11, macos-12, windows-2019, windows-2022]\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: ${{ matrix.go }}\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    strategy:\n      matrix:\n        go:\n          - 1.19\n        os:\n          - ubuntu-20.04\n          - ubuntu-22.04\n          - macos-11\n          - macos-12\n          - windows-2019\n          - windows-2022\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: ${{ matrix.go }}\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `main`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `go` has one value: 1.19. The variable `os` has 6 values: ubuntu-20.04, ubuntu-22.04, macos-11, macos-12, windows-2019 and windows-2022. The job `main` has 4 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Go`. The 3rd step is named `Build`. The 4th step is named `Test`. "}
{"id": "63c494247843b612699ff48a", "level": "level4", "llm_response": "```yaml\nname: Rust\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Rust\n      uses: actions-rs/toolchain@v1\n      with:\n        toolchain: stable\n        profile: minimal\n        override: true\n\n    - name: Check Cargo availability\n      run: cargo --version\n\n    - name: Check Rustup default toolchain\n      run: rustup default\n\n    - name: Build without default features\n      run: cargo build --no-default-features\n\n    - name: Build with default features\n      run: cargo build\n```", "answer": "```yaml name: Rust\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@master\n      - uses: hecrj/setup-rust-action@master\n        with:\n          rust-version: stable\n      - name: Check Cargo availability\n        run: cargo --version\n      - name: Check Rustup default toolchain\n        run: rustup default | grep stable\n      - name: Build without default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check --no-default-features\n      - name: Build with default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check\n```", "prompt": "Generate a GitHub Workflow named `Rust` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Check Cargo availability`. The 4th step is named `Check Rustup default toolchain`. The 5th step is named `Build without default features`. The 6th step is named `Build with default features`. "}
{"id": "63c494fd7843b61269a04a9b", "level": "level4", "llm_response": "```yaml\nname: Automatic Releases\n\non:\n  milestone:\n    closed:\n      types: [closed]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Call reusable workflow\n        uses: doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0\n        secrets:\n          GIT_AUTHOR_EMAIL: ${{ secrets.GIT_AUTHOR_EMAIL }}\n          GIT_AUTHOR_NAME: ${{ secrets.GIT_AUTHOR_NAME }}\n          ORGANIZATION_ADMIN_TOKEN: ${{ secrets.ORGANIZATION_ADMIN_TOKEN }}\n          SIGNING_SECRET_KEY: ${{ secrets.SIGNING_SECRET_KEY }}\n```", "answer": "```yaml name: \"Automatic Releases\"\n\non:\n  milestone:\n    types:\n      - \"closed\"\n\njobs:\n  release:\n    name: \"Git tag, release & create merge-up PR\"\n    uses: \"doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0\"\n    secrets:\n      GIT_AUTHOR_EMAIL: ${{ secrets.GIT_AUTHOR_EMAIL }}\n      GIT_AUTHOR_NAME: ${{ secrets.GIT_AUTHOR_NAME }}\n      ORGANIZATION_ADMIN_TOKEN: ${{ secrets.ORGANIZATION_ADMIN_TOKEN }}\n      SIGNING_SECRET_KEY: ${{ secrets.SIGNING_SECRET_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Automatic Releases` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: a milestone is closed. The workflow has one job. The 1st job is named `Git tag, release & create merge-up PR` and its job id is `release`. This job will call a reusable workflow located at `doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0`. The job will pass 4 secrets to the called workflow: the secret `GIT_AUTHOR_EMAIL` is `${{ secrets.GIT_AUTHOR_EMAIL }}`, the secret `GIT_AUTHOR_NAME` is `${{ secrets.GIT_AUTHOR_NAME }}`, the secret `ORGANIZATION_ADMIN_TOKEN` is `${{ secrets.ORGANIZATION_ADMIN_TOKEN }}` and the secret `SIGNING_SECRET_KEY` is `${{ secrets.SIGNING_SECRET_KEY }}`. "}
{"id": "63c4957d8052faa2781b22ad", "level": "level4", "llm_response": "```yaml\nname: nix-build\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main, 'release-v**' ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Rust\n      uses: actions-rs/toolchain@v1\n      with:\n        toolchain: stable\n        profile: minimal\n        override: true\n\n    - name: Build centrifuge-chain\n      run: cargo build --release\n```", "answer": "```yaml name: nix-build\non:\n  pull_request:\n  push:\n    branches: [main, 'release-v**']\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Nix Flakes doesn't work on shallow clones\n          fetch-depth: 0\n      - uses: cachix/install-nix-action@v17\n        with:\n          install_url: https://releases.nixos.org/nix/nix-2.10.3/install\n      - uses: cachix/cachix-action@v10\n        with:\n          name: centrifuge-chain\n          authToken: \"${{ secrets.CACHIX_AUTH_TOKEN }}\"\n      - name: Build centrifuge-chain\n        run: nix build --no-allow-dirty -L```", "prompt": "Generate a GitHub Workflow named `nix-build` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches release-v**. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Build centrifuge-chain`. "}
{"id": "63c4968a6fc19abdf9c9ca16", "level": "level4", "llm_response": "```yaml\nname: conda builds\n\non:\n  pull_request:\n    paths:\n      - conda-environment.yml\n      - .github/workflows/test_conda-build.yml\n  schedule:\n    - cron: '17 22 * * 6'\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: checkout cylc-flow\n        run: git checkout .\n      - name: build conda env\n        run: conda env update --file conda-environment.yml --prune\n      - name: check for activate scripts\n        run: |\n          if [ -f \"activate.sh\" ]; then\n            echo \"Activate script found\"\n          else\n            echo \"Activate script not found\"\n          fi\n```", "answer": "```yaml name: conda builds\n\non:\n  pull_request:\n    paths:\n      - 'conda-environment.yml'\n      - '.github/workflows/test_conda-build.yml'\n  schedule:\n    - cron: '17 22 * * 6'  # Every Saturday at 22:17\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: checkout cylc-flow\n        uses: actions/checkout@v3\n\n      - name: build conda env\n        run: |\n          # write environment file\n          env_file='conda-environment.yml'\n          echo \"  - pip\"  >> \"$env_file\"  # list pip as a dependency\n          echo \"  - pip:\" >> \"$env_file\"  # add a pip section\n          echo \"    - .\"  >> \"$env_file\"  # install cylc-flow (pip install .)\n          cat \"$env_file\"\n          # install environment\n          conda env create \\\n            -f \"$env_file\" \\\n            --prefix cylc-dev\n          . /usr/share/miniconda/etc/profile.d/conda.sh\n          # check cylc-flow was installed correctly\n          conda run --prefix cylc-dev cylc version --long\n\n      - name: check for activate scripts\n        run: |\n          # https://github.com/cylc/cylc-flow/issues/3704#issuecomment-897442365\n          # locate all activate scripts\n          find ./cylc-dev/ -name \"activate.d\" | tee > activates.txt\n          # ignore the conda activate script itself\n          sed -i '/cylc-dev\\/etc\\/conda\\/activate.d/d' activates.txt\n          # check to make sure no packages have contributed new activate scripts\n          # (we rely on having a conda activate-less environment)\n          if [[ $(cat activates.txt | wc -l) -ne 0 ]]; then\n              echo '::error::Found activate scripts in installation.'\n              cat activates.txt >&2\n              exit 1\n          fi\n```", "prompt": "Generate a GitHub Workflow named `conda builds` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(conda-environment.yml or .github/workflows/test_conda-build.yml), the workflow runs. 2) the scheduled time has come: at 10:17 pm, only on saturday. 3) someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `test_conda_install`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 10. The job `test_conda_install` has 3 steps. The 1st step is named `checkout cylc-flow`. The 2nd step is named `build conda env`. The 3rd step is named `check for activate scripts`. "}
{"id": "63c496411e3364807577968e", "level": "level4", "llm_response": "```yaml\nname: Add to project\n\non:\n  issues:\n    types: [opened, transferred]\n\njobs:\n  add-to-project:\n    id: add-to-project\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Add issue to project\n        id: add_project\n\n      - name: Set Team\n```", "answer": "```yaml name: Add to project\n\non:\n  issues:\n    types: [opened,transferred]\n\njobs:\n  add-to-project:\n    name: Add issue to project\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/add-to-project@main\n        id: add_project\n        with:\n          project-url: ${{ secrets.PROJECT_PLANNING }}\n          github-token: ${{ secrets.BOT_TOKEN_PROJECT }}\n      - name: Set Team\n        env:\n          GITHUB_TOKEN: ${{ secrets.BOT_TOKEN_PROJECT }}\n        run: |\n          gh api graphql -f query='\n          mutation(\n              $project: ID!\n              $item: ID!\n              $status_field: ID!\n              $status_value: String!\n            )  {\n            updateProjectV2ItemFieldValue(\n              input: {\n               projectId: $project\n                itemId: $item\n                fieldId: $status_field\n                value: { \n                  singleSelectOptionId: $status_value\n                  }\n              }\n            ) {\n              projectV2Item {\n                id\n              }\n            }\n          }' -f project=${{ secrets.PROJECT_PLANNING_ID }} -f item=${{ steps.add_project.outputs.itemId }} -f status_field=${{ secrets.PLANNING_TEAM_FIELD_ID }} -f status_value=ed46988b --silent```", "prompt": "Generate a GitHub Workflow named `Add to project` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: an issue is opened or an issue is transferred to another repository. The workflow has one job. The 1st job is named `Add issue to project` and its job id is `add-to-project`. This job will run on ubuntu-latest runner. The job `add-to-project` has 2 steps. The 1st step is named `` and its id is `add_project`. The 2nd step is named `Set Team`. "}
{"id": "63c494c17843b61269a0331c", "level": "level4", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - dev\n  pull_request:\n    branches:\n      - dev\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n    strategy:\n      matrix:\n        language: [java]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n      - name: Autobuild\n        run: |\n          # Add commands to automatically build your project\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"dev\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"dev\" ]\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n    - run: ./mvnw -q -Dmaven.test.skip=true -Dscala.version=2.12.8 -Dscala.binary.version=2.12 clean install || ./mvnw -q -Dmaven.test.skip=true clean install\n  \n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Vue. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 04:20 pm, only on friday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has one value: java. The job `analyze` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `actions` scope, read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `security-events` scope. This permission setting only applies to the job `analyze`. The job `analyze` has 5 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named `Autobuild`. The 4th step is named ``. The 5th step is named `Perform CodeQL Analysis`. "}
{"id": "63c496861e3364807577b319", "level": "level4", "llm_response": "```yaml\nname: documentation\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  skip_duplicate_jobs:\n    runs-on: ubuntu-latest\n    outputs:\n      should_skip: ${{ steps.skip_check.outputs.should_skip }}\n    steps:\n      - name: skip_check\n        id: skip_check\n        run: echo \"::set-output name=should_skip::false\"\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: skip_duplicate_jobs\n    if: ${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}\n    steps:\n      - name: ''\n      - name: Create output directories\n      - name: Copy index.html\n      - name: Generate reference\n        id: adocbuild\n      - name: Deploy \ud83d\ude80\n```", "answer": "```yaml # adapted from:\n#\n# * base code: https://peterevans.dev/posts/github-actions-how-to-automate-code-formatting-in-pull-requests/\n# * fix push auth: https://github.com/ad-m/github-push-action\n# * checkout PR head commit https://github.com/actions/checkout#checkout-pull-request-head-commit-instead-of-merge-commit\nname: documentation\non:\n  push:\n    branches:\n      - master\njobs:\n  skip_duplicate_jobs:\n    runs-on: ubuntu-latest\n    outputs:\n      should_skip: ${{ steps.skip_check.outputs.should_skip }}\n    steps:\n      - id: skip_check\n        uses: fkirc/skip-duplicate-actions@master\n        with:\n          concurrent_skipping: 'same_content'\n          skip_after_successful_duplicate: 'true'\n          paths: '[\"doc/**\"]'\n  deploy:\n    needs: skip_duplicate_jobs\n    if: ${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2.3.1\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Create output directories\n        run: mkdir -p output/reference\n\n      - name: Copy index.html\n        run: cp website/index.html output/index.html\n\n      - name: Generate reference\n        id: adocbuild\n        uses: tonynv/asciidoctor-action@master\n        with:\n            program: asciidoctor doc/index.adoc -o output/reference/index.html\n\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.1.7\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: output # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `documentation` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has 2 jobs. The job id of the 1st job is `skip_duplicate_jobs`. This job will run on ubuntu-latest runner. The job `skip_duplicate_jobs` has one step. The 1st step is named `` and its id is `skip_check`. This job has an output: `should_skip` is defined as ${{ steps.skip_check.outputs.should_skip }}. The job id of the 2nd job is `deploy`. Before this job runs, `skip_duplicate_jobs` must complete successfully. This job will run only if the condition(${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}) is met. This job will run on ubuntu-latest runner. The job `deploy` has 5 steps. The 1st step is named ``. The 2nd step is named `Create output directories`. The 3rd step is named `Copy index.html`. The 4th step is named `Generate reference` and its id is `adocbuild`. The 5th step is named `Deploy \ud83d\ude80`. "}
{"id": "63c496496fc19abdf9c9b198", "level": "level4", "llm_response": "```yaml\nname: Run checks\n\non:\n  pull_request:\n\njobs:\n  go-checks:\n    id: go-checks\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v2\n\n      - name: Test Go Modules Vendor\n        run: go mod vendor\n\n      - name: Test Go Modules\n        run: go mod tidy\n\n      - name: Test Go Standard\n        run: go test -v ./...\n\n  action-checks:\n    id: action-checks\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v2\n\n      - name: Install dockerfile_lint\n        run: |\n          curl -L https://github.com/bitrise-io/dockerfile-lint/releases/download/v0.14.0/dockerfile-lint_0.14.0_linux_amd64.tar.gz | tar xz\n          sudo mv dockerfile-lint /usr/local/bin/\n\n      - name: Lint\n        run: dockerfile-lint Dockerfile\n\n      - name: Test\n        run: make test\n\n      - name: Docker Build\n        run: docker build -t my-app .\n\n      - name: Check all versions\n        run: ./check-versions.sh\n```", "answer": "```yaml on: pull_request\nname: Run checks\njobs:\n  go-checks:\n    name: Run go checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Test Go Modules Vendor\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules_vendored\n    - name: Test Go Modules\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules\n    - name: Test Go Standard\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_standard\n  action-checks:\n    permissions:\n      contents: read\n    name: Run action checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Install dockerfile_lint\n      run: sudo npm i -g dockerfile_lint\n    - name: Lint\n      run: make lint\n    - name: Test\n      run: make test\n    - name: Docker Build\n      run: make build\n    - name: Check all versions\n      run: make docker-check\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Run go checks` and its job id is `go-checks`. This job will run on ubuntu-latest runner. The job `go-checks` has 4 steps. The 1st step is named ``. The 2nd step is named `Test Go Modules Vendor`. The 3rd step is named `Test Go Modules`. The 4th step is named `Test Go Standard`. The 2nd job is named `Run action checks` and its job id is `action-checks`. This job will run on ubuntu-latest runner. The job `action-checks` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `action-checks`. The job `action-checks` has 6 steps. The 1st step is named ``. The 2nd step is named `Install dockerfile_lint`. The 3rd step is named `Lint`. The 4th step is named `Test`. The 5th step is named `Docker Build`. The 6th step is named `Check all versions`. "}
{"id": "63c4964f6fc19abdf9c9b3d1", "level": "level4", "llm_response": "```yaml\nname: Package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [clone]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    env:\n      PIPENV_VENV_IN_PROJECT: 1\n      PIPENV_IGNORE_VIRTUALENVS: 1\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Setup Python Environment\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n    - name: Build LabelImg\n      run: |\n        # Add build commands here\n    - name: Package LabelImg\n      run: |\n        # Add package commands here\n    - name: Archive macOS app\n      uses: actions/upload-artifact@v2\n      with:\n        name: labelimg-macos\n        path: path/to/labelimg.app\n    - name: Cleanup\n\n  package-windows:\n    runs-on: windows-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Setup Python Environment\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n    - name: Build LabelImg\n      run: |\n        # Add build commands here\n    - name: Package LabelImg\n      run: |\n        # Add package commands here\n    - name: Cleanup\n\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n    - name: Setup Python Environment\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n    - name: Build LabelImg\n      run: |\n        # Add build commands here\n    - name: Package LabelImg\n      run: |\n        # Add package commands here\n    - name: Cleanup\n```", "answer": "```yaml name: Package\non: [push, pull_request]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    env:\n      PIPENV_VENV_IN_PROJECT: 1\n      PIPENV_IGNORE_VIRTUALENVS: 1\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pipenv\n          pipenv install pyqt5 lxml\n          pipenv run pip install pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pipenv run make qt5py3\n          rm -rf build dist\n      - name: Package LabelImg\n        run: |\n          pipenv run python setup.py py2app\n          open dist/labelImg.app\n      - name: Archive macOS app\n        run: |\n          cd dist/\n          tar czf labelImg.tgz labelImg.app\n      - uses: actions/upload-artifact@v3\n        with:\n          name: macOS artifact\n          path: dist/labelImg.tgz\n  package-windows:\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Windows artifact\n          path: dist/labelImg.exe\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Linux artifact\n          path: dist/labelImg\n```", "prompt": "Generate a GitHub Workflow named `Package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has 3 jobs. The job id of the 1st job is `package-macos`. This job will run on macos-latest runner. The job sets 2 environment variables to use: `PIPENV_VENV_IN_PROJECT` is set to `1` and `PIPENV_IGNORE_VIRTUALENVS` is set to `1`. The job `package-macos` has 6 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named `Archive macOS app`. The 6th step is named ``. The job id of the 2nd job is `package-windows`. This job will run on windows-latest runner. The job `package-windows` has 5 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named ``. The job id of the 3rd job is `package-linux`. This job will run on ubuntu-latest runner. The job `package-linux` has 5 steps. The 1st step is named ``. The 2nd step is named `Setup Python Environment`. The 3rd step is named `Build LabelImg`. The 4th step is named `Package LabelImg`. The 5th step is named ``. "}
{"id": "63c495c68052faa2781b4230", "level": "level4", "llm_response": "```yaml\nname: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n  label:\n\njobs:\n  issueHandler:\n    id: issueHandler\n    runs-on: windows-latest\n    steps:\n    - name: ''\n    - name: Issue Handler\n```", "answer": "```yaml name: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n\njobs:\n  issueHandler:\n    runs-on: windows-latest\n    name: Issue Handler\n    steps:\n      - uses: actions/checkout@v3\n      - name: Issue Handler\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: github.event.action == 'opened' || (github.event.action == 'labeled' && contains(github.event.issue.labels.*.name, 'verify'))\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Issues` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: an issue is opened or a label is added to an issue. The workflow has one job. The 1st job is named `Issue Handler` and its job id is `issueHandler`. This job will run on windows-latest runner. The job `issueHandler` has 2 steps. The 1st step is named ``. The 2nd step is named `Issue Handler`. "}
{"id": "63c494c78052faa2781ad471", "level": "level4", "llm_response": "```yaml\nname: cla\n\non:\n  issue_comment:\n    types: [created]\n  pull_request:\n    types: [opened, closed, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Get Team Members\n      id: team\n      run: |\n        # Add your code here to get team members\n\n    - name: CLA Assistant\n      run: |\n        # Add your code here to handle CLA assistant logic\n```", "answer": "```yaml name: \"cla\"\non:\n  issue_comment:\n    types: [created]\n  pull_request_target:\n    types: [opened, closed, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Get Team Members\"\n        id: team\n        # github-script, v6.1.0\n        uses: actions/github-script@7a5c598405937d486b0331594b5da2b14db670da\n        with:\n          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n          result-encoding: string\n          script: |\n            const members = await github.paginate(\n              github.rest.orgs.listMembers,\n              { org: \"skalenetwork\" },\n            );\n            return members.map(m => m.login).join(\",\");\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        # Beta Release, v2.1.3-beta\n        uses: cla-assistant/github-action@ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          PERSONAL_ACCESS_TOKEN : ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: 'signatures/version1/cla.json'\n          path-to-document: 'https://skale.network/cla.txt'\n          remote-organization-name: 'skalenetwork'\n          remote-repository-name: cla-sigs\n          allowlist: '${{ steps.team.outputs.result }},*[bot]'\n```", "prompt": "Generate a GitHub Workflow named `cla` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `cla`. This job will run on ubuntu-latest runner. The job `cla` has 2 steps. The 1st step is named `Get Team Members` and its id is `team`. The 2nd step is named `CLA Assistant`. "}
{"id": "63c495f07843b61269a0af74", "level": "level4", "llm_response": "```yaml\nname: Acquire activation file\n\non:\n  workflow_dispatch:\n\njobs:\n  activation:\n    runs-on: ubuntu-latest\n    id: activation\n    steps:\n      - name: Request manual activation file\n        id: getManualLicenseFile\n        run: echo \"Requesting manual activation file...\"\n      - name: Expose as artifact\n        run: echo \"Exposing the activation file as an artifact...\"\n```", "answer": "```yaml \ufeffname: Acquire activation file\non:\n  workflow_dispatch: {}\njobs:\n  activation:\n    name: Request manual activation file\n    runs-on: ubuntu-latest\n    steps:\n      - name: Request manual activation file\n        id: getManualLicenseFile\n        uses: game-ci/unity-request-activation-file@v2\n      - name: Expose as artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: ${{ steps.getManualLicenseFile.outputs.filePath }}\n          path: ${{ steps.getManualLicenseFile.outputs.filePath }}\n```", "prompt": "Generate a GitHub Workflow named `Acquire activation file` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Request manual activation file` and its job id is `activation`. This job will run on ubuntu-latest runner. The job `activation` has 2 steps. The 1st step is named `Request manual activation file` and its id is `getManualLicenseFile`. The 2nd step is named `Expose as artifact`. "}
{"id": "63c4967d33b087f6bde2c593", "level": "level4", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n    paths-ignore:\n      - assets/**\n      - .vscode/**\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v2\n\n      - name: Install\n        run: npm install\n\n      - name: Check\n        run: npm run check\n\n      - name: Lint\n        run: npm run lint\n\n      - name: Test\n        run: npm run test\n\n  deploy-site:\n    id: deploy-site\n    runs-on: ubuntu-latest\n    environment: github-pages\n\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v2\n\n      - name: Install\n        run: npm install\n\n      - name: Build Site\n        run: npm run build\n\n      - name: Deploy Website\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./dist\n```", "answer": "```yaml name: Release\n\non:\n  push:\n    paths-ignore:\n      - 'assets/**'\n      - '.vscode/**'\n    branches:\n      - master\n\njobs:\n  check:\n    name: Run checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Check\n        run: yarn check\n\n      - name: Lint\n        run: yarn lint\n\n      - name: Test\n        run: yarn test\n\n  deploy-site:\n    name: Deploy site\n    runs-on: ubuntu-latest\n    environment: github-pages\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Build Site\n        shell: bash\n        run: |\n          yarn --cwd apps/site ci:build\n\n      - name: Deploy Website\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./apps/site/out\n          cname: tamagui.dev\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. When all the path names of push event match patterns in the paths-ignore filter(assets/** or .vscode/**), the workflow will not run. The workflow has 2 jobs. The 1st job is named `Run checks` and its job id is `check`. This job will run on ubuntu-latest runner. The job `check` has 5 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install`. The 3rd step is named `Check`. The 4th step is named `Lint`. The 5th step is named `Test`. The 2nd job is named `Deploy site` and its job id is `deploy-site`. This job will run on ubuntu-latest runner. This job references github-pages environment. The job `deploy-site` has 4 steps. The 1st step is named `Checkout Repo`. The 2nd step is named `Install`. The 3rd step is named `Build Site`. The 4th step is named `Deploy Website`. "}
{"id": "63c495418052faa2781b099b", "level": "level4", "llm_response": "```yaml\nname: 60 Days Stale Check\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check for stale issues and pull requests\n        run: |\n          gh issue list --state open --label stale --since 60d --json number,title,state | jq -r '.[] | \"Issue #\\(.number) - \\(.title) - \\(.state)\"'\n```", "answer": "```yaml name: 60 Days Stale Check\non:\n  schedule:\n    - cron: '00 00 * * *' # Run each day at 00:00 UTC\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/stale@v3.0.14\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          stale-issue-message: 'This issue is stale because it has been open 60 days with no activity.'\n          stale-pr-message: 'This PR is stale because it has been open 60 days with no activity.'\n          days-before-stale: -1 # 60 days before marking anything stale - Turned off\n          days-before-close: -1 # Do not close anything automatically\n          stale-issue-label: 'stale'\n          stale-pr-label: 'stale'\n          exempt-pr-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n          exempt-issue-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n```", "prompt": "Generate a GitHub Workflow named `60 Days Stale Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `stale`. This job will run on ubuntu-latest runner. The job `stale` has one step. The 1st step is named ``. "}
{"id": "63c496731e3364807577abab", "level": "level4", "llm_response": "```yaml\nname: Automatically crawl CVEs\n\non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n  schedule:\n    - cron: '15 * * * *'\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repo\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Configure pip caching\n        uses: actions/cache@v2\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n      - name: Install Python dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Crawl CVEs\n        run: |\n          python crawl_cves.py\n      - name: Commit and push Github page (if changed)\n        run: |\n          git config --global user.name 'github-actions[bot]'\n          git config --global user.email 'github-actions[bot]@users.noreply.github.com'\n          git add .\n          git commit -m \"Update CVEs\"\n          git push origin master\n```", "answer": "```yaml name: Automatically crawl CVEs \non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n    branches:\n      - master\n  schedule:\n    - cron: '15 * * * *'\n\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Check out repo\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.8\n      - uses: actions/cache@v2\n        name: Configure pip caching\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install Python dependencies\n        run: |\n          python -m pip install -r requirements.txt\n\n      - name: Crawl CVEs\n        run: |-\n          python main.py -g \"${{ secrets.CRAWL_PWD }}\" --gtk ${{ secrets.GRAPAQL_TOKEN }}\n\n      # \u82e5\u8be5\u65f6\u95f4\u6bb5\u6ca1\u6709 CVE\uff0c \u5219 file://cache/mail.dat \u6587\u4ef6\u4e0d\u4f1a\u751f\u6210\uff0c\u6b64\u65f6\u4e0d\u4f1a\u53d1\u9001\u90ae\u4ef6\n      # - name: Send mail\n      #   if: ${{ secrets.CRAWL_PWD != '' && github.event_name != 'pull_request' }}\n      #   uses: lyy289065406/action-send-mail@master\n      #   with:\n      #     server_address: ${{ secrets.MAIL_SMTP }}\n      #     server_port: 465\n      #     username: ${{ secrets.MAIL_USER }}\n      #     password: ${{ secrets.MAIL_PASS }}\n      #     from: ${{ secrets.MAIL_USER }}\n      #     to: file://cache/mail_recvs.dat\n      #     body: file://cache/mail_content.dat\n      #     content_type: text/html\n      #     subject: \u5a01\u80c1\u60c5\u62a5\u64ad\u62a5\n\n      # \u5982\u679c\u4e0d\u5e0c\u671b\u6c61\u67d3 commit \u8bb0\u5f55\uff0cuser.email \u548c user.name \u968f\u4fbf\u586b\u5373\u53ef\n      # Github Runner \u662f\u6709\u6743\u9650\u63d0\u4ea4\u5230\u4ed3\u5e93\u7684\uff0c\u53ea\u8981 user \u4e0d\u662f owner \uff0c\u5f53\u6b21 commit \u4e0d\u4f1a\u88ab\u8bb0\u5f55\n      - name: Commit and push Github page (if changed)\n        if: ${{ github.event_name != 'pull_request' }}\n        run: |-\n          git diff\n          git config --global user.email \"github-bot@example.com\"\n          git config --global user.name \"Github-Bot\"\n          git add -A\n          git commit -m \"Updated by Github Bot\" || exit 0\n          git push origin master\n\n```", "prompt": "Generate a GitHub Workflow named `Automatically crawl CVEs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch named master. 2) someone manually triggers the workflow. 3) the scheduled time has come: at 15 minutes past the hour. The workflow has one job. The job id of the 1st job is `build-and-deploy`. This job will run on ubuntu-latest runner. The job `build-and-deploy` has 6 steps. The 1st step is named `Check out repo`. The 2nd step is named `Set up Python`. The 3rd step is named `Configure pip caching`. The 4th step is named `Install Python dependencies`. The 5th step is named `Crawl CVEs`. The 6th step is named `Commit and push Github page (if changed)`. "}
{"id": "63c496891e3364807577b43b", "level": "level4", "llm_response": "```yaml\nname: Build Docker\n\non:\n  push:\n    branches:\n      - trunk\n    paths:\n      - 'tools/docker/**'\n      - '.github/workflows/build-docker.yml'\n  pull_request:\n    branches:\n      - trunk\n    paths:\n      - 'tools/docker/**'\n      - '.github/workflows/build-docker.yml'\n\nconcurrency:\n  group: 'build-docker-${{ github.event_name }}-${{ github.ref }}'\n  cancel-in-progress: true\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    timeout-minutes: 60\n    steps:\n      - name: ''\n        run: echo \"Hello, World!\"\n      - name: Set up qemu\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y qemu binfmt-support\n          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n      - name: Set up Docker Buildx\n        run: |\n          docker buildx create --use --name mybuilder\n          docker buildx inspect --bootstrap\n      - name: Log in to Docker Hub\n        run: echo \"${{ secrets.DOCKER_HUB_PASSWORD }}\" | docker login -u \"${{ secrets.DOCKER_HUB_USERNAME }}\" --password-stdin\n      - name: Log in to GitHub Packages\n        run: echo \"${{ secrets.GITHUB_TOKEN }}\" | docker login docker.pkg.github.com -u \"${{ github.actor }}\" --password-stdin\n      - name: Fetch build args\n        id: buildargs\n        run: echo \"::set-output name=buildargs::--build-arg VERSION=${{ github.ref_name }}\"\n      - name: Extract Docker metadata\n        id: meta\n        run: echo \"::set-output name=image::ghcr.io/${{ github.repository }}:latest\"\n      - name: Build and push Docker image\n        run: |\n          docker buildx build --platform linux/amd64,linux/arm64 --push --tag ${{ steps.meta.outputs.image }} ${{ steps.buildargs.outputs.buildargs }} .\n```", "answer": "```yaml name: Build Docker\non:\n  push:\n    branches: [ 'trunk' ]\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n  pull_request:\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\nconcurrency:\n  group: build-docker-${{ github.event_name }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    name: Build and publish Jetpack Dev Environment\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    timeout-minutes: 60  # 2021-10-26: Build for arm64 is S-L-O-W. Sigh.\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up qemu\n        uses: docker/setup-qemu-action@v2\n        with:\n          platforms: arm64\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: matticbot\n          password: ${{ secrets.DOCKER_HUB_MATTICBOT_TOKEN }}\n\n      - name: Log in to GitHub Packages\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Fetch build args\n        id: buildargs\n        run: |\n          source .github/versions.sh\n          source .github/files/gh-funcs.sh\n\n          gh_set_output php-version \"$PHP_VERSION\"\n          gh_set_output composer-version \"$COMPOSER_VERSION\"\n          gh_set_output node-version \"$NODE_VERSION\"\n          gh_set_output pnpm-version \"$PNPM_VERSION\"\n\n          # We're not git-tagging for the env. Just tag all trunk builds as latest.\n          if [[ \"$GITHUB_EVENT_NAME\" == \"push\" ]]; then\n            gh_set_output tags \"type=raw,latest\"\n            gh_set_output images $'automattic/jetpack-wordpress-dev\\nghcr.io/automattic/jetpack-wordpress-dev'\n          elif [[ \"$GITHUB_EVENT_NAME\" == \"pull_request\" ]]; then\n            gh_set_output tags \"type=ref,event=pr\"\n            gh_set_output images \"ghcr.io/automattic/jetpack-wordpress-dev\"\n          else\n            echo \"Unknown GITHUB_EVENT_NAME $GITHUB_EVENT_NAME\"\n            exit 1\n          fi\n\n      - name: Extract Docker metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          flavor: latest=false\n          tags: ${{ steps.buildargs.outputs.tags }}\n          images: ${{ steps.buildargs.outputs.images }}\n          labels: |\n            org.opencontainers.image.title=Jetpack Development Environment\n            org.opencontainers.image.description=Unified environment for developing in the Jetpack Monorepo using Docker containers.\n            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/trunk/tools/docker/README.md\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v3\n        with:\n          context: tools/docker\n          platforms: linux/amd64,linux/arm64\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          build-args: |\n            PHP_VERSION=${{ steps.buildargs.outputs.php-version }}\n            COMPOSER_VERSION=${{ steps.buildargs.outputs.composer-version }}\n            NODE_VERSION=${{ steps.buildargs.outputs.node-version }}\n            PNPM_VERSION=${{ steps.buildargs.outputs.pnpm-version }}\n```", "prompt": "Generate a GitHub Workflow named `Build Docker` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named trunk. Only if at least one path of push event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. 2) Only if at least one path of pull_request event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. Only a single workflow using the build-docker-${{ github.event_name }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Build and publish Jetpack Dev Environment` and its job id is `build`. This job will run on ubuntu-latest runner. The job `build` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `packages` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `build`. The maximum number of minutes to run the job is 60. The job `build` has 8 steps. The 1st step is named ``. The 2nd step is named `Set up qemu`. The 3rd step is named `Set up Docker Buildx`. The 4th step is named `Log in to Docker Hub`. The 5th step is named `Log in to GitHub Packages`. The 6th step is named `Fetch build args` and its id is `buildargs`. The 7th step is named `Extract Docker metadata` and its id is `meta`. The 8th step is named `Build and push Docker image`. "}
{"id": "63c494318052faa2781a9bf5", "level": "level4", "llm_response": "```yaml\nname: Test a branch on canary\n\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n        type: string\n\npermissions:\n  contents: read\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\n\ndefaults:\n  run:\n    shell: pwsh\n\njobs:\n  update_tag:\n    id: update_tag\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n    - name: Step 1\n      run: |\n        # Add your step 1 commands here\n\n    - name: Step 2\n      run: |\n        # Add your step 2 commands here\n\n    - name: Update the rc tag\n      run: |\n        # Add your update rc tag commands here\n\n    - name: Canary test\n      run: |\n        # Add your canary test commands here\n```", "answer": "```yaml name: Test a branch on canary\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\ndefaults:\n  run:\n    shell: pwsh\n\npermissions:  # added using https://github.com/step-security/secure-workflows\n  contents: read\n\njobs:\n  update_tag:\n    name: Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n    - uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34 # v1\n      with:\n        allowed-endpoints: \n          api.github.com:443\n          github.com:443\n\n    - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 # v2\n    - name: Update the rc tag\n      uses: step-security/publish-action@b438f840875fdcb7d1de4fc3d1d30e86cf6acb5d\n      with:\n        rc-sha: ${{ env.COMMIT_SHA }}\n        rc: true\n\n    - name: Canary test\n      uses: docker://ghcr.io/step-security/integration-test/int:latest\n      env:\n        PAT: ${{ secrets.PAT }}\n        canary: true\n```", "prompt": "Generate a GitHub Workflow named `Test a branch on canary` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: COMMIT_SHA-this input represents commit sha to be tested and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `COMMIT_SHA` is set to `${{ github.event.inputs.COMMIT_SHA }}`. For all run steps in the workflow, default shell is set to pwsh. The workflow has one job. The 1st job is named `Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit` and its job id is `update_tag`. This job will run on ubuntu-latest runner. The job `update_tag` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `update_tag`. The job `update_tag` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Update the rc tag`. The 4th step is named `Canary test`. "}
{"id": "63c4964733b087f6bde2ad41", "level": "level4", "llm_response": "```yaml\nname: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - py-*\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [macos-latest, windows-latest]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.x'\n\n    - name: Fix README symlink\n      run: |\n        # Add your fix README symlink commands here\n\n    - name: Publish wheel\n      run: |\n        # Add your publish wheel commands here\n```", "answer": "```yaml name: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - py-*\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, windows-latest]\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.7'\n\n      - name: Fix README symlink\n        run: |\n          rm py-polars/README.md\n          cp README.md py-polars/README.md\n\n      - name: Publish wheel\n        uses: messense/maturin-action@v1\n        env:\n          MATURIN_PASSWORD: ${{ secrets.PYPI_PASS }}\n          RUSTFLAGS: -C target-feature=+fxsr,+sse,+sse2,+sse3,+sse4.1,+sse4.2\n        with:\n          rust-toolchain: nightly-2022-10-06\n          maturin-version: '0.13.5'\n          command: publish\n          args: -m py-polars/Cargo.toml --no-sdist --skip-existing -o wheels -i python -u ritchie46\n```", "prompt": "Generate a GitHub Workflow named `Create Python release windows macos` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches py-*. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The job id of the 1st job is `win-macos`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `os` has 2 values: macos-latest and windows-latest. The job `win-macos` has 4 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Fix README symlink`. The 4th step is named `Publish wheel`. "}
{"id": "63c496566fc19abdf9c9b6ef", "level": "level4", "llm_response": "```yaml\nname: automerge\n\non:\n  pull_request:\n    types:\n      - labeled\n\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: enable automerge\n        run: echo \"Automerge enabled\"\n```", "answer": "```yaml name: automerge\non:\n  pull_request_target:\n    types:\n      - labeled\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: enable automerge\n        if: contains( github.event.pull_request.labels.*.name, 'automerge')\n        uses: peter-evans/enable-pull-request-automerge@v2\n        with:\n          token: ${{ secrets.PAT }}\n          pull-request-number: ${{ github.event.pull_request.number }}\n          merge-method: rebase\n```", "prompt": "Generate a GitHub Workflow named `automerge` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: a label is added to a pull request. The workflow has one job. The job id of the 1st job is `automerge`. This job will run on ubuntu-latest runner. The job `automerge` has one step. The 1st step is named `enable automerge`. "}
{"id": "63c4941d8052faa2781a937b", "level": "level4", "llm_response": "```yaml\nname: update-flake-lock\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Nix\n        run: |\n          sh <(curl -L https://nixos.org/nix/install) --daemon\n          . ~/.nix-profile/etc/profile.d/nix.sh\n      - name: Update flake.lock\n        run: nix flake lock\n```", "answer": "```yaml name: update-flake-lock\non:\n  workflow_dispatch: # allows manual triggering\n  schedule:\n    - cron: '0 0 * * 0' # runs weekly on Sunday at 00:00\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Install Nix\n        uses: cachix/install-nix-action@v18\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n      - name: Update flake.lock\n        uses: DeterminateSystems/update-flake-lock@v14\n        with:\n          # we update nixos-common-styles manual\n          # and the rest of the inputs are content inputs\n          inputs: nixpkgs\n```", "prompt": "Generate a GitHub Workflow named `update-flake-lock` for a GitHub repository whose primary programming language is Less. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The job id of the 1st job is `lockfile`. This job will run on ubuntu-latest runner. The job `lockfile` has 3 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Install Nix`. The 3rd step is named `Update flake.lock`. "}
{"id": "63c4965533b087f6bde2b378", "level": "level4", "llm_response": "```yaml\nname: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    id: packagist\n    runs-on: ubuntu-latest\n    steps:\n      - name: Update Packagist\n        # Add your step commands here\n```", "answer": "```yaml name: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    name: Update Packagist\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update Packagist\n        run: |\n          curl -X POST \"https://packagist.org/api/update-package?username=svix&apiToken=$PACKAGIST_API_KEY\" \\\n            -H 'content-type: application/json' \\\n            -d '{\"repository\":{\"url\":\"https://packagist.org/packages/svix/svix\"}}'\n        env:\n          PACKAGIST_API_KEY: ${{ secrets.PACKAGIST_API_KEY }}```", "prompt": "Generate a GitHub Workflow named `PHP Release` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Update Packagist` and its job id is `packagist`. This job will run on ubuntu-latest runner. The job `packagist` has one step. The 1st step is named `Update Packagist`. "}
{"id": "63c4959c7843b61269a08c30", "level": "level4", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    permissions:\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Run analysis\n      run: cargo scorecard\n\n    - name: Upload artifact\n      uses: actions/upload-artifact@v2\n      with:\n        name: scorecard-report\n        path: target/scorecard-report.json\n\n    - name: Upload to code-scanning\n      uses: github/codeql-action/upload-sarif@v2\n      with:\n        sarif_file: target/scorecard-report.sarif\n```", "answer": "```yaml name: Scorecards supply-chain security\n# Run only manually, because the answers don't change often and the results have \n# many unhelpful positives.\n  \non:\n  workflow_dispatch: \n  # Only the default branch is supported.\n  # branch_protection_rule:\n  # schedule:\n  #   - cron: '38 17 * * 6'\n  # push:\n  #  branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c8416b0b2bf627c349ca92fc8e3de51a64b005cf # v1.0.2\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. This job will run on ubuntu-latest runner. The job `analysis` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `security-events` scope, read access is granted to the GITHUB_TOKEN in the `actions` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. "}
{"id": "63c495547843b61269a06e6c", "level": "level4", "llm_response": "```yaml\nname: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 1 * * *'\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\njobs:\n  recreate:\n    runs-on: ubuntu-22.04\n    if: github.repository == 'Homebrew/homebrew-core'\n    strategy:\n      matrix:\n        runner_name: [linux-self-hosted-1]\n    env:\n      RUNNER_LABEL: TODO\n\n    steps:\n    - name: Set up Cloud SDK\n    - name: Wait for idle runner\n      id: killable\n    - name: Kill runner and create a new one\n```", "answer": "```yaml name: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    # Once each 24 hours, at 1 during the night\n    - cron: \"0 1 * * *\"\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  recreate:\n    if: github.repository == 'Homebrew/homebrew-core'\n    runs-on: ubuntu-22.04\n    env:\n      # TODO agree on one label for all runners\n      RUNNER_LABEL: TODO\n    strategy:\n      matrix:\n        runner_name:\n          - linux-self-hosted-1\n    steps:\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.2.1\n        with:\n          project_id: ${{ secrets.GCP_PROJECT_ID }}\n          service_account_key: ${{ secrets.GCP_SA_KEY }}\n          export_default_credentials: true\n\n      - name: Wait for idle runner\n        id: killable\n        uses: Homebrew/actions/wait-for-idle-runner@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n      - name: Kill runner and create a new one\n        if: ${{ steps.killable.outputs.runner-found == 'true' && steps.killable.outputs.runner-idle == 'true' }}\n        uses: Homebrew/actions/create-gcloud-instance@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          gcp_project_id: ${{ secrets.GCP_PROJECT_ID }}\n          gcp_service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n          gcp_sa_key: ${{ secrets.GCP_SA_KEY }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Recreate Linux self-hosted runners on schedule` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 01:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the recreate-linux-runners concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `recreate`. This job will run only if the condition(github.repository == 'Homebrew/homebrew-core') is met. This job will run on ubuntu-22.04 runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `runner_name` has one value: linux-self-hosted-1. The job sets an environment variable to use: `RUNNER_LABEL` is set to `TODO`. The job `recreate` has 3 steps. The 1st step is named `Set up Cloud SDK`. The 2nd step is named `Wait for idle runner` and its id is `killable`. The 3rd step is named `Kill runner and create a new one`. "}
{"id": "63c4942a8052faa2781a9911", "level": "level4", "llm_response": "```yaml\nname: Integration tests\n\non:\n  push:\n    branches:\n      - main\n      - dev\n  workflow_dispatch:\n\njobs:\n  integration_tests:\n    id: integration_tests\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@v2\n\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n\n      - name: Run tests\n        run: go test ./...\n\n      - name: Upload test results\n        uses: actions/upload-artifact@v2\n        with:\n          name: test-results\n          path: ./test-results.xml\n```", "answer": "```yaml name: Integration tests\non:\n  workflow_dispatch: null\n  push:\n    branches:\n      - main\n      - dev\njobs:\n  integration_tests:\n    name: Run integration tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f # pin@v2\n      - uses: actions/setup-go@37335c7bb261b353407cff977110895fa0b4f7d8 # pin@v2\n        with:\n          go-version: '1.18'\n      - run: go version\n      - run: make testacc\n        env:\n          LINODE_TOKEN: ${{ secrets.DX_LINODE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Integration tests` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main or a branch named dev. The workflow has one job. The 1st job is named `Run integration tests` and its job id is `integration_tests`. This job will run on ubuntu-latest runner. The job `integration_tests` has 4 steps. The 1st step is named `Clone Repository`. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. "}
{"id": "63c4942a8052faa2781a9910", "level": "level4", "llm_response": "```yaml\nname: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n    if: github.event.issue.pull_request\n    steps:\n      - name: Generate App Installation Token\n        id: generate_token\n        run: echo \"::set-output name=token::$(openssl rand -hex 20)\"\n      - name: Slash Command Dispatch\n        run: |\n          curl -X POST \\\n            -H \"Authorization: Bearer ${{ steps.generate_token.outputs.token }}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d '{\"text\": \"/command\"}' \\\n            https://api.github.com/repos/owner/repo/dispatches\n```", "answer": "```yaml name: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.issue.pull_request }}\n    steps:\n      - name: Generate App Installation Token\n        id: generate_token\n        uses: tibdex/github-app-token@v1\n        with:\n          app_id: ${{ secrets.DX_ACCTEST_APP_ID }}\n          private_key: ${{ secrets.DX_ACCTEST_PRIV_KEY }}\n\n      - name: Slash Command Dispatch\n        uses: peter-evans/slash-command-dispatch@v1\n        env:\n          TOKEN: ${{ steps.generate_token.outputs.token }}\n        with:\n          token: ${{ env.TOKEN }}\n          reaction-token: ${{ secrets.GITHUB_TOKEN }}\n          issue-type: pull-request\n          commands: acctest\n          named-args: true\n          permission: write\n```", "prompt": "Generate a GitHub Workflow named `AccTest Command` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `acctest-command`. This job will run only if the condition(${{ github.event.issue.pull_request }}) is met. This job will run on ubuntu-latest runner. The job `acctest-command` has 2 steps. The 1st step is named `Generate App Installation Token` and its id is `generate_token`. The 2nd step is named `Slash Command Dispatch`. "}
{"id": "63c4940f7843b612699feb8d", "level": "level4", "llm_response": "```yaml\nname: Go Coverage\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run tests and generate coverage\n        run: go test -coverprofile=coverage.out ./...\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v2\n        with:\n          file: ./coverage.out\n          fail_ci_if_error: true\n```", "answer": "```yaml # add public code coverage reports\non:\n  push:\n    branches:\n    - main\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - run: \"make test-cover\"\n    - uses: codecov/codecov-action@v2\n    with:\n      file: ./coverage.out\n      fail_ci_if_error: true\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `coverage`. This job will run on ubuntu-latest runner. The job `coverage` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The job will pass 2 inputs to the called workflow: the input `file` is `./coverage.out` and the input `fail_ci_if_error` is `True`. "}
{"id": "63c496a06fc19abdf9c9d2e3", "level": "level4", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '18 9 * * 4'\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    permissions:\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Run analysis\n        run: cargo scorecard\n\n      - name: Upload artifact\n        uses: actions/upload-artifact@v2\n        with:\n          name: scorecard-report\n          path: report.html\n\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: report.sarif\n```", "answer": "```yaml # This file is part of ICU4X. For terms of use, please see the file\n# called LICENSE at the top level of the ICU4X source tree\n# (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).\n\nname: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '18 9 * * 4'\n  push:\n    branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c1aec4ac820532bab364f02a81873c555a0ba3a1 # v1.0.4\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 09:18 am, only on thursday. 3) The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. This job will run on ubuntu-latest runner. The job `analysis` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `security-events` scope, read access is granted to the GITHUB_TOKEN in the `actions` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. The 2nd step is named `Run analysis`. The 3rd step is named `Upload artifact`. The 4th step is named `Upload to code-scanning`. "}
{"id": "63c495257843b61269a05b79", "level": "level4", "llm_response": "```yaml\nname: Update translation templates\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-templates:\n    id: update-templates\n    runs-on: ubuntu-20.04\n\n    steps:\n      - name: Install git\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y git\n\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Install deps\n        run: |\n          sudo pacman -Syu --noconfirm\n          sudo pacman -S --noconfirm meson ninja\n\n      - name: Change git permissions\n        run: |\n          git config --global user.name \"github-actions[bot]\"\n          git config --global user.email \"github-actions[bot]@users.noreply.github.com\"\n\n      - name: Run meson targets\n        run: |\n          meson build\n          ninja -C build\n\n      - name: Check for non-timestamp diff\n        run: |\n          git diff --cached --name-only | grep -v 'po/.*\\.po' && echo \"Non-timestamp diff found\" && exit 1 || echo \"No non-timestamp diff found\"\n\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v3\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          commit-message: \"Update translation templates\"\n          branch: \"update-templates\"\n          title: \"Update translation templates\"\n          body: \"Automatically updated translation templates using GitHub Actions.\"\n```", "answer": "```yaml on:\n  push:\n    branches: [ master ]\n\nname: Update translation templates\njobs:\n  update-templates:\n    name: Update translation templates\n    runs-on: ubuntu-20.04\n    container:\n      image: archlinux\n    steps:\n      # install git first otherwise checkout will not give us an actual git repo\n      - name: Install git\n        run: pacman -Syu --noconfirm git\n    \n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n\n      - name: Install deps\n        run: |\n          # install general build deps\n          pacman -Syu --noconfirm ninja gcc pkgconf python3 python-pip which\n          # install easyeffects deps\n          source ./PKGBUILD && pacman -Syu --noconfirm --needed --asdeps \"${makedepends[@]}\" \"${depends[@]}\"\n          \n      # workaround upstream permissions issue github.com/peter-evans/create-pull-request/issues/1170\n      - name: Change git permissions\n        run: git config --global --add safe.directory \"$GITHUB_WORKSPACE\"\n\n      - name: Run meson targets\n        run: |\n          meson build\n          cd build\n          ../util/update_translation_templates.sh\n          cd ..\n\n      - name: Check for non-timestamp diff\n        run: |\n          # see https://stackoverflow.com/a/26622262\n          DIFF_LINES=$(git diff --unified=0 | grep '^[+-]' | grep -Ev '^(--- a/|\\+\\+\\+ b/)')\n\n          if [[ $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\") != \"$DIFF_LINES\" ]]; then\n            echo \"The calculated diff includes modifications besides just timestamp changes (POT-Creation-Date).\"\n            echo \"Letting the PR continue as this is a valid reason to open a PR.\"\n          else\n            echo \"The calculated diff just has timestamp changes (POT-Creation-Date).\"\n            echo \"Restoring original files since this is not a valid reason to open a PR.\"\n            git restore .\n          fi\n\n          echo \"All diff lines count: $(echo \"$DIFF_LINES\" | wc -l)\"\n          echo \"Diff lines count where POT-Creation-Date was changed: $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\" | wc -l)\"\n\n      # TODO it would be ideal to refresh metainfo fully by copying release notes from the upcoming release in NEWS.yaml to metainfo, and then running the above update template script,\n      # however this is not possible without putting a dummy release in the metainfo with said upcoming release notes which would later have to be adjusted to the real release.\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4.1.3\n        with:\n          title: Update translation templates\n          body: Ensure to merge all other Pull Requests before merging this. Conflicts here will automatically be resolved in case of changes in master.\n          commit-message: Update translation templates\n          # email sets \"EasyEffects Bot\" user as commit author\n          committer: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          author: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          branch: automatically-update-translation-templates\n          # the easyeffects_bot secret/token is only valid for a fork\n          # note the machine user (easyeffects-bot) must have already forked the repository  where the action is running for this to work\n          push-to-fork: easyeffects-bot/easyeffects\n          token: ${{ secrets.EASYEFFECTS_BOT }}\n```", "prompt": "Generate a GitHub Workflow named `Update translation templates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The 1st job is named `Update translation templates` and its job id is `update-templates`. This job will run on ubuntu-20.04 runner. The job creates a Docker container that uses `archlinux` image. The job `update-templates` has 7 steps. The 1st step is named `Install git`. The 2nd step is named `Checkout`. The 3rd step is named `Install deps`. The 4th step is named `Change git permissions`. The 5th step is named `Run meson targets`. The 6th step is named `Check for non-timestamp diff`. The 7th step is named `Create Pull Request`. "}
{"id": "63c4967d1899db58864d33af", "level": "level4", "llm_response": "```yaml\nname: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      package_name:\n        description: 'Package name'\n        required: true\n        default: 'generateblocks'\n\njobs:\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: NPM install\n      run: npm install\n\n    - name: NPM build\n      run: npm run build\n\n    - name: Grunt action-package\n      run: grunt action-package\n\n    - name: Build zip file\n      run: zip -r ${inputs.package_name}.zip .\n```", "answer": "```yaml name: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      name:\n        description: 'Package name'\n        default: 'generateblocks'\n        required: true\n\njobs:\n\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n          cache: 'npm'\n\n      - name: NPM install\n        run: npm install\n\n      - name: NPM build\n        run: npm run build\n\n      - name: Grunt action-package\n        run: npm run action-package\n\n      - name: Build zip file\n        uses: actions/upload-artifact@v3.1.0\n        with:\n          name: ${{ github.event.inputs.name }}\n          path: |\n            package/\n          retention-days: 1\n```", "prompt": "Generate a GitHub Workflow named `Build package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: name-this input represents package name, its default value is generateblocks and it must be supplied. The workflow has one job. The job id of the 1st job is `build-package`. This job will run on ubuntu-latest runner. The job `build-package` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `NPM install`. The 4th step is named `NPM build`. The 5th step is named `Grunt action-package`. The 6th step is named `Build zip file`. "}
{"id": "63c494637843b61269a00d3a", "level": "level4", "llm_response": "```yaml\nname: olm\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\n\nenv:\n  GO_VERSION: 1.19\n  KIND_IMG_TAG: v1.25.0\n\njobs:\n  main:\n    runs-on: ubuntu-22.04\n\n    steps:\n    - name: Checkout code\n    - name: Download binaries\n    - name: Install dependencies\n    - name: Create and verify bundle\n    - name: Create and set up K8s KinD Cluster\n    - name: Run the tests\n```", "answer": "```yaml name: olm\non:\n  push:\n    branches:\n      - main\n  pull_request:\nenv:\n  GO_VERSION: '1.19'\n  KIND_IMG_TAG: v1.25.0\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\njobs:\n  main:\n    name: tests\n    runs-on: ubuntu-22.04\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Download binaries\n      run: |\n        mkdir -p ${GITHUB_WORKSPACE}/build\n        echo \"${GITHUB_WORKSPACE}/build\" >> ${GITHUB_PATH}\n        make operator-sdk\n        make opm\n\n    - uses: actions/setup-go@268d8c0ca0432bb2cf416faae41297df9d262d7f\n      with:\n        go-version: ${{ env.GO_VERSION }}\n    - name: Install dependencies\n      run: |\n        sudo apt update\n        sudo apt install -y libseccomp-dev libelf-dev libapparmor-dev\n        sudo hack/install-libbpf.sh\n\n    - name: Create and verify bundle\n      run: |\n        make verify-bundle\n\n    - name: Create and set up K8s KinD Cluster\n      run: |\n        ./hack/kind-with-registry.sh\n\n    - name: Run the tests\n      run: ./hack/ci/e2e-olm.sh\n```", "prompt": "Generate a GitHub Workflow named `olm` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: none access is granted to the GITHUB_TOKEN in the `actions` scope, none access is granted to the GITHUB_TOKEN in the `checks` scope, none access is granted to the GITHUB_TOKEN in the `contents` scope, none access is granted to the GITHUB_TOKEN in the `deployments` scope, none access is granted to the GITHUB_TOKEN in the `id-token` scope, none access is granted to the GITHUB_TOKEN in the `issues` scope, none access is granted to the GITHUB_TOKEN in the `discussions` scope, none access is granted to the GITHUB_TOKEN in the `packages` scope, none access is granted to the GITHUB_TOKEN in the `pull-requests` scope, none access is granted to the GITHUB_TOKEN in the `repository-projects` scope, none access is granted to the GITHUB_TOKEN in the `security-events` scope and none access is granted to the GITHUB_TOKEN in the `statuses` scope. This permission setting applies to all jobs in the workflow. The workflow sets 2 environment variables to use: `GO_VERSION` is set to `1.19` and `KIND_IMG_TAG` is set to `v1.25.0`. The workflow has one job. The 1st job is named `tests` and its job id is `main`. This job will run on ubuntu-22.04 runner. The job `main` has 7 steps. The 1st step is named ``. The 2nd step is named `Download binaries`. The 3rd step is named ``. The 4th step is named `Install dependencies`. The 5th step is named `Create and verify bundle`. The 6th step is named `Create and set up K8s KinD Cluster`. The 7th step is named `Run the tests`. "}
{"id": "63c494c78052faa2781ad49a", "level": "level4", "llm_response": "```yaml\nname: Pull Request Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n    steps:\n      - name: Triage pull request\n        run: |\n          # Add your triage logic here\n```", "answer": "```yaml name: \"Pull Request Labeler\"\non:\n  - pull_request_target\n\njobs:\n  triage:\n    permissions:\n      contents: read\n      pull-requests: write\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/labeler@v4\n        with:\n          repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Pull Request Labeler` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `triage`. This job will run on ubuntu-latest runner. The job `triage` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `triage`. The job `triage` has one step. The 1st step is named ``. "}
{"id": "63c495928052faa2781b2bc0", "level": "level4", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n    steps:\n      - name: Apply labels to pull request\n        uses: actions/labeler@v3\n        with:\n          github-token: ${{ github.token }}\n          labels: |\n            - \"erlang\"\n            - \"pull-request\"\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n    - uses: rhysd/changelog-from-release/action@v2\n      with:\n        file: CHANGELOG.md\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. This job will run on ubuntu-latest runner. The job `label` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `label`. The job `label` has one step. The 1st step is named ``. "}
{"id": "63c494608052faa2781aabf2", "level": "level4", "llm_response": "```yaml\nname: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    id: configlet\n    uses: exercism/github-actions/.github/workflows/configlet.yml@main\n```", "answer": "```yaml name: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    uses: exercism/github-actions/.github/workflows/configlet.yml@main\n```", "prompt": "Generate a GitHub Workflow named `Configlet` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. 3) someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `configlet`. This job will call a reusable workflow located at `exercism/github-actions/.github/workflows/configlet.yml@main`. "}
{"id": "63c4949e7843b61269a025e6", "level": "level4", "llm_response": "```yaml\nname: TagBot\n\non:\n  issue_comment:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    steps:\n    - name: Step 1\n      run: echo \"Hello, world!\"\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. This job will run only if the condition(github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot') is met. This job will run on ubuntu-latest runner. The job `TagBot` has one step. The 1st step is named ``. "}
{"id": "63c495d98052faa2781b4aa8", "level": "level4", "llm_response": "```yaml\nname: NMake\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  nmake:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        name: [ 'Windows NMake x86', 'Windows NMake x64 compat', 'Windows NMake x64 Symbol Prefix', 'Windows NMake x64 Symbol Prefix Compat', 'Windows NMake x64', 'Windows NMake ARM No Test', 'Windows NMake ARM64 No Test' ]\n        os: [ 'windows-2022' ]\n        makefile: [ 'win32/Makefile.msc', 'win32/Makefile.arm', 'win32/Makefile.a64' ]\n        arch: [ 'x86', 'x86_amd64', 'x86_arm', 'x86_arm64' ]\n        additional-args: [ '', 'ZLIB_COMPAT=yes', 'SYMBOL_PREFIX=zTest_', 'ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_' ]\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Setup development environment\n      run: |\n        # Setup environment for the given architecture and makefile\n        # This is a placeholder command and should be replaced with actual setup commands\n\n    - name: Compile source code\n      run: |\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}\n\n    - name: Run test cases\n      run: |\n        # Run test cases for the given architecture and makefile\n        # This is a placeholder command and should be replaced with actual test commands\n```", "answer": "```yaml name: NMake\non: [push, pull_request]\njobs:\n  nmake:\n    name: ${{ matrix.name }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - name: Windows NMake x86\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86\n\n          - name: Windows NMake x64 compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes\n\n          - name: Windows NMake x64 Symbol Prefix\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64 Symbol Prefix Compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n\n          - name: Windows NMake ARM No Test\n            os: windows-2022\n            makefile: win32/Makefile.arm\n            arch: x86_arm\n\n          - name: Windows NMake ARM64 No Test\n            os: windows-2022\n            makefile: win32/Makefile.a64\n            arch: x86_arm64\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Setup development environment\n      uses: ilammy/msvc-dev-cmd@v1.10.0\n      with:\n        arch: ${{ matrix.arch }}\n\n    - name: Compile source code\n      shell: cmd\n      run: nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}\n\n    - name: Run test cases\n      shell: cmd\n      # Don't run tests on Windows ARM\n      if: contains(matrix.arch, 'arm') == false\n      run: |\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} test\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} testdll\n```", "prompt": "Generate a GitHub Workflow named `NMake` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `nmake`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. For each object in the [{'name': 'Windows NMake x86', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86'}, {'name': 'Windows NMake x64 compat', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86_amd64', 'additional-args': 'ZLIB_COMPAT=yes'}, {'name': 'Windows NMake x64 Symbol Prefix', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86_amd64', 'additional-args': 'SYMBOL_PREFIX=zTest_'}, {'name': 'Windows NMake x64 Symbol Prefix Compat', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86_amd64', 'additional-args': 'ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_'}, {'name': 'Windows NMake x64', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86_amd64'}, {'name': 'Windows NMake ARM No Test', 'os': 'windows-2022', 'makefile': 'win32/Makefile.arm', 'arch': 'x86_arm'}, {'name': 'Windows NMake ARM64 No Test', 'os': 'windows-2022', 'makefile': 'win32/Makefile.a64', 'arch': 'x86_arm64'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `nmake` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Setup development environment`. The 3rd step is named `Compile source code`. The 4th step is named `Run test cases`. "}
{"id": "63c493b77843b612699fd377", "level": "level4", "llm_response": "```yaml\nname: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - public/**\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout \ud83d\udece\ufe0f\n      uses: actions/checkout@v2\n\n    - name: Install Nix\n      run: |\n        sh -c \"$(curl -L https://nixos.org/nix/install)\"\n\n    - name: Build\n      run: |\n        nix build\n\n    - name: Deploy \ud83d\ude80\n      run: |\n        nix deploy\n```", "answer": "```yaml name: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - \"public/**\"\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install Nix\n        uses: cachix/install-nix-action@v15\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build\n        run: nix build .#website\n\n      - name: Deploy \ud83d\ude80\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./result\n          cname: mdzk.app\n```", "prompt": "Generate a GitHub Workflow named `Publish website` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(public/**), the workflow runs. The workflow has one job. The job id of the 1st job is `deploy-website`. This job will run on ubuntu-latest runner. The job `deploy-website` has 4 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. The 2nd step is named `Install Nix`. The 3rd step is named `Build`. The 4th step is named `Deploy \ud83d\ude80`. "}
{"id": "63c4946f7843b61269a011d1", "level": "level4", "llm_response": "```yaml\nname: I2::Dev::Nightly::Publish\n\non:\n  workflow_dispatch:\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Build Docker image\n        run: docker build -t iroha2:dev-nightly .\n\n      - name: Push Docker image to Docker Hub\n        run: docker push iroha2:dev-nightly\n        env:\n          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "answer": "```yaml name: I2::Dev::Nightly::Publish\n\non: workflow_dispatch\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n    container:\n      image: 7272721/i2-ci:nightly\n    steps:\n      - uses: actions/checkout@v3\n      - uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push iroha2:dev-nightly image\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          tags: hyperledger/iroha2:dev-nightly-${{ github.sha }}\n          labels: commit=${{ github.sha }}\n          build-args: TAG=dev\n```", "prompt": "Generate a GitHub Workflow named `I2::Dev::Nightly::Publish` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `dockerhub`. This job will run on ubuntu-latest runner. The job creates a Docker container that uses `7272721/i2-ci:nightly` image. The job `dockerhub` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Build and push iroha2:dev-nightly image`. "}
{"id": "63c4941b7843b612699ff0aa", "level": "level4", "llm_response": "```yaml\nname: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - zap/zap.gradle.kts\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: ''\n        run: |\n          # Add your first step commands here\n      - name: Setup Java\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n      - name: Build and Release\n        run: |\n          # Add your build and release commands here\n```", "answer": "```yaml name: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - 'zap/zap.gradle.kts'\n\njobs:\n  release:\n    name: Build and Release\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n        persist-credentials: false\n    - name: Setup Java\n      uses: actions/setup-java@v3\n      with:\n        distribution: 'temurin'\n        java-version: 11\n    - name: Build and Release\n      env:\n        INSTALL4J_LICENSE: ${{ secrets.INSTALL4J_LICENSE }}\n        ZAPBOT_TOKEN: ${{ secrets.ZAPBOT_TOKEN }}\n        ZAP_RELEASE: 1\n        ZAP_JAVA_VERSION: 11\n      run: ./gradlew \"-Dorg.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m\" :zap:createMainRelease\n```", "prompt": "Generate a GitHub Workflow named `Release Main Version` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(zap/zap.gradle.kts), the workflow runs. The workflow has one job. The 1st job is named `Build and Release` and its job id is `release`. This job will run on ubuntu-latest runner. The job `release` has 3 steps. The 1st step is named ``. The 2nd step is named `Setup Java`. The 3rd step is named `Build and Release`. "}
{"id": "63c494a97843b61269a02a52", "level": "level4", "llm_response": "```yaml\nname: pytorch1_8_1-cuda11_1\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: 'cu111'\n      remote_runtime_docker: 'bladedisc:latest-runtime-torch1.8.1-cu111'\n      develop_base_image: 'nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04'\n      runtime_base_image: 'nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04'\n      extra_envs: '-e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111'\n      exec_command: 'bash ./scripts/ci/test_pytorch_blade.sh'\n      deploy_command: 'TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh'\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "answer": "```yaml name: pytorch1_8_1-cuda11_1\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu111\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.8.1-cu111\n      develop_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_8_1-cuda11_1` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will call a reusable workflow located at `./.github/workflows/resuable_gpu_build.yml`. The job will pass 7 inputs to the called workflow: the input `cuda_version` is `cu111`, the input `remote_runtime_docker` is `bladedisc:latest-runtime-torch1.8.1-cu111`, the input `develop_base_image` is `nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04`, the input `runtime_base_image` is `nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04`, the input `extra_envs` is `-e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111`, the input `exec_command` is `bash ./scripts/ci/test_pytorch_blade.sh` and the input `deploy_command` is `TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh`. The job will pass 4 secrets to the called workflow: the secret `ALIYUN_DOCKER_USERNAME` is `${{ secrets.ALIYUN_DOCKER_USERNAME }}`, the secret `ALIYUN_DOCKER_PASSWORD` is `${{ secrets.ALIYUN_DOCKER_PASSWORD }}`, the secret `DOCKER_USERNAME` is `${{ secrets.DOCKER_USERNAME }}` and the secret `DOCKER_PASSWORD` is `${{ secrets.DOCKER_PASSWORD }}`. "}
{"id": "63c493ff8052faa2781a8681", "level": "level4", "llm_response": "```yaml\nname: Check License Lines\n\non:\n  push:\n    branches: [ '*' ]\n\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Check License Lines\n      run: |\n        # Add your license check command here\n        echo \"Checking license lines...\"\n```", "answer": "```yaml name: Check License Lines\non:\n  push:\n    branches: '**'\n#  pull_request:\n#    branches:\n#      - main\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Check License Lines\n        uses: kt3k/license_checker@v1.0.6```", "prompt": "Generate a GitHub Workflow named `Check License Lines` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch whose name matches * or a branch whose name matches *. The workflow has one job. The job id of the 1st job is `check-license-lines`. This job will run on ubuntu-latest runner. The job `check-license-lines` has 2 steps. The 1st step is named ``. The 2nd step is named `Check License Lines`. "}
{"id": "63c494888052faa2781abb68", "level": "level4", "llm_response": "```yaml\nname: MERGE_MASTER_TO_DEVELOP\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n      - name: Checkout develop\n        uses: actions/checkout@v2\n        with:\n          ref: develop\n\n      - name: Merge master to develop and push\n        run: |\n          git merge master\n          git push origin develop\n\n      - name: Notify failure on Slack\n        if: failure()\n        run: |\n          curl -X POST -H 'Content-type: application/json' --data '{\"text\":\"Merge from master to develop failed\"}' $SLACK_WEBHOOK_URL\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n```", "answer": "```yaml name: MERGE_MASTER_TO_DEVELOP\non:\n  push:\n    branches:\n    - \"master\"\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n    - name: Checkout develop\n      uses: actions/checkout@v3\n      with:\n        ref: develop\n        fetch-depth: 0\n    - name: Merge master to develop and push\n      run: |\n        git config user.name '${{ secrets.BPMN_IO_USERNAME }}'\n        git config user.email '${{ secrets.BPMN_IO_EMAIL }}'\n        git merge -m 'Merge master to develop' --no-edit origin/master\n        git push\n\n    - name: Notify failure on Slack\n      if: failure()\n      uses: slackapi/slack-github-action@v1.15.0\n      with:\n        channel-id: ${{ secrets.SLACK_CHANNEL_ID }}\n        slack-message: \"Automatic merge of <https://github.com/${{ github.repository }}/tree/${{ github.ref }}|${{ github.ref }}> to <https://github.com/${{ github.repository }}/tree/develop|${{ github.repository }}#develop> failed.\"\n      env:\n        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `MERGE_MASTER_TO_DEVELOP` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `Merge_master_to_develop`. This job will run on ubuntu-latest runner. The job `Merge_master_to_develop` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `Merge_master_to_develop`. The job `Merge_master_to_develop` has 3 steps. The 1st step is named `Checkout develop`. The 2nd step is named `Merge master to develop and push`. The 3rd step is named `Notify failure on Slack`. "}
{"id": "63c494298052faa2781a987a", "level": "level4", "llm_response": "```yaml\nname: Hypothesis Tests\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 6 * * *'\n\npermissions:\n  issues: write\n\nenv:\n  python_version: '3.10'\n\njobs:\n  hypothesis:\n    runs-on: ubuntu-22.04\n    timeout-minutes: 90\n\n    steps:\n      - name: ''\n      - name: Install Linux Dependencies\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y build-essential libssl-dev zlib1g-dev libncurses5-dev libncursesw5-dev libreadline-dev libsqlite3-dev libgdbm-dev libdb5.3-dev libbz2-dev libexpat1-dev liblzma-dev tk-dev libffi-dev\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ env.python_version }}\n      - name: Use Python Dependency Cache\n        uses: actions/cache@v3\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n      - name: Use Hypothesis Cache\n        uses: actions/cache@v3\n        with:\n          path: ~/.cache/hypothesis\n          key: ${{ runner.os }}-hypothesis-${{ hashFiles('**/test_*.py') }}\n          restore-keys: |\n            ${{ runner.os }}-hypothesis-\n      - name: Install Dependencies and Test\n        run: |\n          pip install -r requirements.txt\n          pytest\n      - name: Test with Hypothesis\n        run: |\n          pytest --hypothesis-show-statistics\n      - name: Create Issue on Failure\n        if: failure()\n        run: |\n          echo \"::add-matcher::octocat/issue-comment.json\"\n          echo \"Creating issue on failure\"\n          curl -s -X POST \\\n            -H \"Authorization: token ${{ github.token }}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d '{\"title\": \"Test Failure\", \"body\": \"A test has failed. Please check the logs for details.\"}' \\\n            https://api.github.com/repos/${{ github.repository }}/issues\n```", "answer": "```yaml name: Hypothesis Tests\non:\n  workflow_dispatch:\n  schedule:\n    # min hour dom month dow\n    - cron:  '0 6 * * *'\nenv:\n  python_version: '3.10'\n\npermissions:\n  issues: write\n\njobs:\n\n  hypothesis:\n    runs-on: ubuntu-22.04\n    timeout-minutes: 90\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Install Linux Dependencies\n        uses: ./.github/actions/linux_dependencies\n      - name: Set up Python\n        uses: actions/setup-python@v4.3.0\n        with:\n          python-version: ${{ env.python_version }}\n      - name: Use Python Dependency Cache\n        uses: actions/cache@v3.0.11\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}-20.04\n      - name: Use Hypothesis Cache\n        uses: pat-s/always-upload-cache@v3.0.1\n        with:\n          path: .hypothesis\n          key: ${{ runner.os }}-hypothesis\n      - name: Install Dependencies and Test\n        uses: ./.github/actions/setup_and_test\n      - name: Test with Hypothesis\n        run: xvfb-run poetry run pytest -m hypothesis --hypothesis-profile=ci\n        shell: bash\n      - uses: nashmaniac/create-issue-action@v1.1\n        if: failure()\n        name: Create Issue on Failure\n        with:\n          title: Hypothesis tests failed\n          token: ${{secrets.GITHUB_TOKEN}}\n          labels: bug,hypothesis\n          body: |\n            Test run failed for commit ${{github.sha}}.\n            See https://github.com/gaphor/gaphor/actions/workflows/hypothesis-test.yml.\n```", "prompt": "Generate a GitHub Workflow named `Hypothesis Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 06:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `python_version` is set to `3.10`. The workflow has one job. The job id of the 1st job is `hypothesis`. This job will run on ubuntu-22.04 runner. The maximum number of minutes to run the job is 90. The job `hypothesis` has 8 steps. The 1st step is named ``. The 2nd step is named `Install Linux Dependencies`. The 3rd step is named `Set up Python`. The 4th step is named `Use Python Dependency Cache`. The 5th step is named `Use Hypothesis Cache`. The 6th step is named `Install Dependencies and Test`. The 7th step is named `Test with Hypothesis`. The 8th step is named `Create Issue on Failure`. "}
{"id": "63c495038052faa2781aede8", "level": "level4", "llm_response": "```yaml\nname: Python package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  windows:\n    id: windows\n    runs-on: windows-latest\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n      fail-fast: true\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Create Conda environment with the right deps\n      run: |\n        conda create -n testenv python=${{ matrix.python-version }} -y\n        conda activate testenv\n        conda install -c conda-forge pytest -y\n\n    - name: Install dependencies\n      run: |\n        pip install -r requirements.txt\n\n    - name: Run Tests\n      run: pytest\n\n    - name: Conda info\n      run: conda info\n\n    - name: Conda list\n      run: conda list\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Python package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  windows:\n    name: Windows Tests\n    runs-on: \"windows-latest\"\n    strategy:\n      fail-fast: True\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: conda-incubator/setup-miniconda@v2\n        with:\n          auto-update-conda: true\n          python-version: ${{ matrix.python-version }}\n          channels: conda-forge\n        env:\n          ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n      - name: Create Conda environment with the rights deps\n        shell: bash -l {0}\n        run: |\n          conda create -n zarr-env python==${{matrix.python-version}} numcodecs pip nodejs\n      - name: Install dependencies\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          python -m pip install --upgrade pip\n          python -m pip install -U pip setuptools wheel\n          python -m pip install -r requirements_dev_numpy.txt -r requirements_dev_minimal.txt -r requirements_dev_optional.txt\n          python -m pip install .\n          python -m pip freeze\n          npm install -g azurite\n      - name: Run Tests\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          mkdir ~/blob_emulator\n          azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n          pytest -sv --timeout=300\n        env:\n          ZARR_TEST_ABS: 1\n          ZARR_V3_EXPERIMENTAL_API: 1\n      - name: Conda info\n        shell: bash -l {0}\n        run: conda info\n      - name: Conda list\n        shell: pwsh\n        run: conda list\n```", "prompt": "Generate a GitHub Workflow named `Python package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Windows Tests` and its job id is `windows`. This job will run on windows-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `python-version` has 3 values: 3.8, 3.9 and 3.10. If any job run in the matrix fails, all in-progress and queued jobs in the matrix will be canceled. The job `windows` has 7 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Create Conda environment with the rights deps`. The 4th step is named `Install dependencies`. The 5th step is named `Run Tests`. The 6th step is named `Conda info`. The 7th step is named `Conda list`. "}
{"id": "63c494347843b612699ffaac", "level": "level4", "llm_response": "```yaml\nname: Monitor CI Scaler\n\non:\n  schedule:\n    - cron: '0 5 * * *'\n    - cron: '0 17 * * *'\n\njobs:\n  MonitorCI:\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v2\n      - name: setup environment\n        run: |\n          # Add steps to set up the environment\n          echo \"Setting up Rust environment...\"\n          rustup install stable\n          rustup default stable\n      - name: check scaler\n        run: |\n          # Add steps to check the CI scaler\n          echo \"Checking CI scaler status...\"\n          # Example command to check scaler status\n          ./check_scaler.sh\n```", "answer": "```yaml name: Monitor CI Scaler\n\non:\n  # workflow_dispatch:\n  schedule:\n    - cron: '0 5,17 * * *'\n\njobs:\n  MonitorCI:\n    name: monitor ci scaler\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v1\n        with:\n          submodules: recursive\n      - name: setup environment\n        run: bash ./scripts/dev_setup.sh  -b -t -y\n      - name: check scaler\n        run: python3 ./scripts/monitor_autoscaler_recreate.py\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Monitor CI Scaler` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: the scheduled time has come: at 05:00 am and 05:00 pm. The workflow has one job. The 1st job is named `monitor ci scaler` and its job id is `MonitorCI`. This job will run on ubuntu-latest runner. The job `MonitorCI` has 3 steps. The 1st step is named `checkout`. The 2nd step is named `setup environment`. The 3rd step is named `check scaler`. "}
{"id": "63c494cf8052faa2781ad80f", "level": "level4", "llm_response": "```yaml\nname: Release Documentation\n\non:\n  release:\n    types: [published, prereleased, drafted]\n\nenv:\n  GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  java-build:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        java: [8]\n        os: [ubuntu-22.04]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Cache Gradle dependencies\n      uses: actions/cache@v2\n      with:\n        path: ~/.gradle/caches\n        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle') }}\n        restore-keys: |\n          ${{ runner.os }}-gradle-\n\n    - name: Cache Gradle wrappers\n      uses: actions/cache@v2\n      with:\n        path: .gradle/wrapper\n        key: ${{ runner.os }}-gradle-wrapper-${{ hashFiles('gradle/wrapper/gradle-wrapper.properties') }}\n        restore-keys: |\n          ${{ runner.os }}-gradle-wrapper-\n\n    - name: Setup java\n      uses: actions/setup-java@v2\n      with:\n        java-version: ${{ matrix.java }}\n        distribution:adopt\n\n    - name: Build with Gradle\n      run: ./gradlew build\n```", "answer": "```yaml name: Release Documentation\non:\n  release:\n    types: [published]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  GRADLE_OPTS: '-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail'\n\njobs:\n  java-build:\n    name: Publish Release Documentation\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        java: [ '8' ]\n        os: ['ubuntu-22.04' ]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Cache Gradle dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/caches\n          key: ${{ runner.os }}-gradle-caches-${{ hashFiles('**/*.gradle') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-caches-\n      - name: Cache Gradle wrappers\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-wrapper\n      - name: Setup java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: ${{ matrix.java }}\n      - name: Build with Gradle\n        run: ./gradlew tutorialPublish -Paeron.ci.apiKey=${{ secrets.WIKI_PAGE_TOKEN }} --stacktrace\n```", "prompt": "Generate a GitHub Workflow named `Release Documentation` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow sets an environment variable to use: `GRADLE_OPTS` is set to `-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail`. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Publish Release Documentation` and its job id is `java-build`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `java` has one value: 8. The variable `os` has one value: ubuntu-22.04. The job `java-build` has 5 steps. The 1st step is named `Checkout code`. The 2nd step is named `Cache Gradle dependencies`. The 3rd step is named `Cache Gradle wrappers`. The 4th step is named `Setup java`. The 5th step is named `Build with Gradle`. "}
{"id": "63c4967d6fc19abdf9c9c492", "level": "level4", "llm_response": "```yaml\nname: gradio-ui\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\nenv:\n  CI: 'True'\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: '1'\n  NODE_OPTIONS: '--max-old-space-size=4096'\n\nconcurrency:\n  group: 'deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}'\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    id: static-checks\n    runs-on: ubuntu-22.04\n    defaults:\n      run:\n        working-directory: ui\n\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: install dependencies\n        run: echo \"Install dependencies\"\n      - name: formatting check\n        run: echo \"Formatting check\"\n      - name: typecheck\n        run: echo \"Typecheck\"\n      - name: unit tests\n        run: echo \"Unit tests\"\n\n  functional-test:\n    id: functional-test\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ui\n\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: Install Python\n        run: echo \"Install Python\"\n      - name: Step 5\n        run: echo \"Step 5\"\n      - name: Step 6\n        run: echo \"Step 6\"\n      - name: Step 7\n        run: echo \"Step 7\"\n      - name: Step 8\n        run: echo \"Step 8\"\n      - name: Step 9\n        run: echo \"Step 9\"\n      - name: Upload failed tests screenshots\n        run: echo \"Upload failed tests screenshots\"\n```", "answer": "```yaml name: gradio-ui\n\non:\n  push:\n    branches:\n      - \"main\"\n  pull_request:\n\ndefaults:\n  run:\n    working-directory: ui\n\nenv:\n  CI: true\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: \"1\"\n  NODE_OPTIONS: \"--max-old-space-size=4096\"\n\nconcurrency:\n  group: deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    name: static checks\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: install dependencies\n        run: pnpm i --frozen-lockfile\n      - name: formatting check\n        run: pnpm format:check\n      - name: typecheck\n        run: pnpm ts:check\n      - name: unit tests\n        run: pnpm test:run\n  functional-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: Install Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.x'\n      - run: cd .. && bash scripts/install_gradio.sh\n      - run: pip install -r ../demo/outbreak_forecast/requirements.txt\n      - run: pnpm install --frozen-lockfile\n      - run: pnpm exec playwright install chromium\n      - run: pnpm test:browser:full\n      - name: Upload failed tests screenshots\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          retention-days: 3\n          name: test-failure-${{ github.run_id }}\n          path: ui/packages/app/test-results\n```", "prompt": "Generate a GitHub Workflow named `gradio-ui` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow sets 3 environment variables to use: `CI` is set to `True`, `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` is set to `1` and `NODE_OPTIONS` is set to `--max-old-space-size=4096`. For all run steps in the workflow, default working directory is set to ui. Only a single workflow using the deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `static checks` and its job id is `quick-checks`. This job will run on ubuntu-22.04 runner. The job `quick-checks` has 7 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `install dependencies`. The 5th step is named `formatting check`. The 6th step is named `typecheck`. The 7th step is named `unit tests`. The job id of the 2nd job is `functional-test`. This job will run on ubuntu-latest runner. The job `functional-test` has 10 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Install Python`. The 5th step is named ``. The 6th step is named ``. The 7th step is named ``. The 8th step is named ``. The 9th step is named ``. The 10th step is named `Upload failed tests screenshots`. "}
{"id": "63c496851899db58864d368d", "level": "level4", "llm_response": "```yaml\nname: Bump repositories\n\non:\n  schedule:\n    - cron: '0 20 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Bump cos \ud83d\udd27\n      run: echo \"Bumping cos \ud83d\udd27\"\n\n    - name: Create Pull Request\n      run: echo \"Creating Pull Request\"\n```", "answer": "```yaml name: Bump repositories\non: \n schedule:\n   - cron: 0 20 * * *\n workflow_dispatch:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Bump cos \ud83d\udd27\n      run: |\n           docker run --name=yq -v \"${PWD}\":/workdir mikefarah/yq\n           docker cp yq:/usr/bin/yq ./\n           export YQ=$PWD/yq\n           sudo -E bash ./.github/bump_repositories.sh\n           rm -rf yq\n    - name: Create Pull Request\n      uses: peter-evans/create-pull-request@v4\n      with:\n        token: ${{ secrets.PAT_TOKEN }}\n        push-to-fork: ci-robbot/c3os\n        commit-message: \":arrow_up: Update repositories\"\n        title: \"Repositories bump\"\n        body: \"Bump of luet repositories\"\n```", "prompt": "Generate a GitHub Workflow named `Bump repositories` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 08:00 pm. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 3 steps. The 1st step is named ``. The 2nd step is named `Bump cos \ud83d\udd27`. The 3rd step is named `Create Pull Request`. "}
{"id": "63c4945a7843b61269a00a52", "level": "level4", "llm_response": "```yaml\nname: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v2\n\n    - name: Set up QEMU\n      uses: docker/setup-qemu-action@v1\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v1\n\n    - name: Build and export to Docker\n      run: |\n        docker buildx build --platform linux/amd64,linux/arm64 -t $TEST_TAG . --push\n\n    - name: Run\n      run: |\n        docker run --rm $TEST_TAG\n```", "answer": "```yaml name: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      - name: Build and export to Docker\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          load: true\n          push: false\n          tags: ${{ env.TEST_TAG }}\n      - name: Run\n        run: |\n          docker run --rm ${{ env.TEST_TAG }} ci\n```", "prompt": "Generate a GitHub Workflow named `ci` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow sets an environment variable to use: `TEST_TAG` is set to `protoc-gen-validate:${{ github.sha }}`. The workflow has one job. The job id of the 1st job is `docker`. This job will run on ubuntu-latest runner. The job `docker` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up QEMU`. The 3rd step is named `Set up Docker Buildx`. The 4th step is named `Build and export to Docker`. The 5th step is named `Run`. "}
{"id": "63c49698b008460c1df15629", "level": "level4", "llm_response": "```yaml\nname: Auto Assign PR to Author\n\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    runs-on: ubuntu-latest\n\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: 'Auto Assign PR to Author'\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    permissions:\n      contents: read  # for kentaro-m/auto-assign-action to fetch config file\n      pull-requests: write  # for kentaro-m/auto-assign-action to assign PR reviewers\n    runs-on: ubuntu-latest\n    steps:\n      - uses: kentaro-m/auto-assign-action@v1.2.1\n```", "prompt": "Generate a GitHub Workflow named `Auto Assign PR to Author` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by an event: a pull request is created. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `add-reviews`. This job will run on ubuntu-latest runner. The job `add-reviews` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `add-reviews`. The job `add-reviews` has one step. The 1st step is named ``. "}
{"id": "63c494a87843b61269a02a08", "level": "level4", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n        run: echo \"Step 1\"\n      - name: Step 2\n        run: echo \"Step 2\"\n      - name: Step 3\n        run: echo \"Step 3\"\n      - name: Step 4\n        run: echo \"Step 4\"\n      - name: Step 5\n        run: echo \"Step 5\"\n```", "answer": "```yaml name: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-python@v4\n        with:\n          python-version: 3.x\n      - run: pip install -r requirements/build-docs.txt\n      - run: linkcheckMarkdown docs/ -v -r\n      - run: mkdocs build --verbose\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `docs`. This job will run on ubuntu-latest runner. The job `docs` has 5 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. "}
{"id": "63c4956d7843b61269a07890", "level": "level4", "llm_response": "```yaml\nname: Issue Comments for merge\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [commented]\n\njobs:\n  check_comments_merge:\n    id: check_comments_merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        run: echo \"Checking for merge command\"\n\n  merge:\n    id: merge\n    runs-on: ubuntu-latest\n    needs: check_comments_merge\n    steps:\n      - name: Merge Pull Request\n        run: echo \"Merging pull request\"\n\n  commentFeedback:\n    id: commentFeedback\n    runs-on: ubuntu-latest\n    needs: merge\n    steps:\n      - name: Add reaction on success\n        run: echo \"Adding reaction on success\"\n```", "answer": "```yaml on: issue_comment\nname: Issue Comments for merge\njobs:\n  check_comments_merge:\n    name: Check comments for /merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        uses: xt0rted/slash-command-action@v1.1.0\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          command: merge\n          reaction: \"true\"\n          reaction-type: \"eyes\"\n          allow-edits: \"false\"\n          permission-level: admin\n  merge:\n    runs-on: ubuntu-latest\n    needs: [check_comments_merge]\n    steps:\n      - name: Merge Pull Request\n        uses: juliangruber/merge-pull-request-action@v1.1.0\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          number: ${{ github.event.issue.number }}\n          method: merge\n  commentFeedback:\n    runs-on: ubuntu-latest\n    needs: [merge]\n    steps:\n      - name: Add reaction on success\n        uses: peter-evans/create-or-update-comment@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}\n          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}\n          reaction-type: hooray\n```", "prompt": "Generate a GitHub Workflow named `Issue Comments for merge` for a GitHub repository whose primary programming language is HCL. This workflow will be triggered by an event: activity related to an issue or pull request comment occurs. The workflow has 3 jobs. The 1st job is named `Check comments for /merge` and its job id is `check_comments_merge`. This job will run on ubuntu-latest runner. The job `check_comments_merge` has one step. The 1st step is named `Check for Command`. The job id of the 2nd job is `merge`. Before this job runs, `check_comments_merge` must complete successfully. This job will run on ubuntu-latest runner. The job `merge` has one step. The 1st step is named `Merge Pull Request`. The job id of the 3rd job is `commentFeedback`. Before this job runs, `merge` must complete successfully. This job will run on ubuntu-latest runner. The job `commentFeedback` has one step. The 1st step is named `Add reaction on success`. "}
{"id": "63c495888052faa2781b2739", "level": "level4", "llm_response": "```yaml\nname: \u2744\ufe0f Lint\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    id: misc\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v2\n      - name: spell check\n        run: |\n          # Add spell check command here\n      - name: Merge conflict\n        run: |\n          # Add merge conflict command here\n      - name: Plugin Code\n        run: |\n          # Add plugin code command here\n\n  ci-eclint:\n    id: ci-eclint\n    runs-on: ubuntu-latest\n    timeout-minutes: 5\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v2\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install eclint\n        run: |\n          npm install -g eclint\n      - name: Run eclint\n        run: |\n          eclint check .\n```", "answer": "```yaml name: \u2744\ufe0f Lint\n\non: [push, pull_request]\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    name: misc checker\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v3.1.0\n      - name: spell check\n        run: |\n          pip install codespell==2.1.0\n          git grep --cached -l '' | xargs codespell --ignore-words=.ignore_words\n      - name: Merge conflict\n        run: |\n          bash ./utils/check-merge-conflict.sh\n      - name: Plugin Code\n        run: |\n          bash ./utils/check-plugins-code.sh\n\n  ci-eclint:\n    runs-on: ubuntu-latest\n    timeout-minutes: 5\n\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v3.1.0\n\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v3.5.1\n        with:\n          node-version: '12'\n\n      - name: Install eclint\n        run: |\n          sudo npm install -g eclint\n\n      - name: Run eclint\n        run: |\n          eclint check\n```", "prompt": "Generate a GitHub Workflow named `\u2744\ufe0f Lint` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `misc checker` and its job id is `misc`. This job will run on ubuntu-latest runner. The job `misc` has 4 steps. The 1st step is named `Check out code.`. The 2nd step is named `spell check`. The 3rd step is named `Merge conflict`. The 4th step is named `Plugin Code`. The job id of the 2nd job is `ci-eclint`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 5. The job `ci-eclint` has 4 steps. The 1st step is named `Check out code`. The 2nd step is named `Setup Nodejs env`. The 3rd step is named `Install eclint`. The 4th step is named `Run eclint`. "}
{"id": "63c4951b8052faa2781af857", "level": "level4", "llm_response": "```yaml\nname: Docs Build\n\non:\n  push:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  docs-build:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n\n      - name: Install deps\n        run: npm install\n\n      - name: Build docs\n        run: npm run build:docs\n\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs\n```", "answer": "```yaml name: Docs Build\n\non:\n  # allows to manually run the job at any time\n  workflow_dispatch:\n  \n  # run on every push on the master branch\n  push:\n    branches:\n      - master\n\njobs:\n  docs-build:\n    timeout-minutes: 10\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Install deps\n        run: |\n          npm install vuepress -D\n          npm install macaca-ecosystem -D\n\n      - name: Build docs\n        run: npm run docs:build\n\n      - name: Deploy to GitHub Pages\n        if: success()\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs_dist\n```", "prompt": "Generate a GitHub Workflow named `Docs Build` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `docs-build`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 10. The job `docs-build` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set node version to 16`. The 3rd step is named `Install deps`. The 4th step is named `Build docs`. The 5th step is named `Deploy to GitHub Pages`. "}
{"id": "63c494027843b612699fe5e4", "level": "level4", "llm_response": "```yaml\nname: CLA\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Run Scala checks\n      run: sbt claCheck\n```", "answer": "```yaml name: CLA\non: [pull_request]\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v1\n    - run: ./ci/check-cla.sh \"${{ github.event.pull_request.user.login }}\"\n```", "prompt": "Generate a GitHub Workflow named `CLA` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check`. This job will run on ubuntu-latest runner. The job `check` has 2 steps. The 1st step is named ``. The 2nd step is named ``. "}
{"id": "63c496831e3364807577b1f9", "level": "level4", "llm_response": "```yaml\nname: Fastlane Metadata\n\non:\n  push:\n    branches:\n      - main\n      - '[0-9]+\\.[0-9]+\\.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n  pull_request:\n    branches:\n      - main\n      - '[0-9]+\\.[0-9]+\\.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n\njobs:\n  validate:\n    id: validate\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    steps:\n      - name: Step 1\n        run: echo \"Running Step 1\"\n      - name: Step 2\n        run: echo \"Running Step 2\"\n\n  play-store-upload:\n    id: play-store-upload\n    needs: validate\n    if: github.event_name == 'push'\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    steps:\n      - name: Step 1\n        run: echo \"Running Step 1\"\n      - name: Step 2\n        run: echo \"Running Step 2\"\n      - name: Step 3\n        run: echo \"Running Step 3\"\n      - name: Step 4\n        run: echo \"Running Step 4\"\n      - name: Step 5\n        run: echo \"Running Step 5\"\n      - name: Step 6\n        run: echo \"Running Step 6\"\n```", "answer": "```yaml name: Fastlane Metadata\non:\n  push:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n  pull_request:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n\njobs:\n  validate:\n    name: Validate\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    steps:\n      - uses: actions/checkout@v3\n      - uses: ashutoshgngwr/validate-fastlane-supply-metadata@v2\n        with:\n          usePlayStoreLocales: true\n\n  play-store-upload:\n    name: Play Store Upload\n    needs: validate\n    if: github.event_name == 'push'\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    steps:\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n      - uses: actions/checkout@v3\n      - run: bundle install\n      - run: echo \"$SERVICE_ACCOUNT_KEY\" > service-account-key.json\n        env:\n          SERVICE_ACCOUNT_KEY: ${{ secrets.SERVICE_ACCOUNT_KEY }}\n      - run: bundle exec fastlane upload_metadata\n      - if: ${{ always() }}\n        run: rm -f service-account-key.json\n```", "prompt": "Generate a GitHub Workflow named `Fastlane Metadata` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of push event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of pull_request event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. The workflow has 2 jobs. The 1st job is named `Validate` and its job id is `validate`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 15. The job `validate` has 2 steps. The 1st step is named ``. The 2nd step is named ``. The 2nd job is named `Play Store Upload` and its job id is `play-store-upload`. Before this job runs, `validate` must complete successfully. This job will run only if the condition(github.event_name == 'push') is met. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 30. The job `play-store-upload` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named ``. "}
{"id": "63c496701e3364807577aa6c", "level": "level4", "llm_response": "```yaml\nname: dds-rtps\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  Linux:\n    runs-on: ubuntu-20.04\n    steps:\n    - name: checkout OpenDDS\n      run: git clone https://github.com/objectcomputing/OpenDDS.git\n    - name: checkout dds-rtps\n      run: git clone https://github.com/omg-dds/dds-rtps.git\n    - name: checkout ACE_TAO\n      run: git clone https://github.com/objectcomputing/ACE_TAO.git\n    - name: get ACE_TAO commit\n      run: echo \"ACE_TAO_COMMIT=$(git rev-parse HEAD)\" >> $GITHUB_ENV\n    - name: get compiler version\n      run: gcc --version\n    - name: checkout MPC\n      run: git clone https://github.com/gcc-mirror/gcc-mirror.git\n    - name: configure OpenDDS\n      run: cd OpenDDS && ./configure\n    - name: build OpenDDS\n      run: cd OpenDDS && make\n    - name: build shape_main\n      run: cd dds-rtps && make shape_main\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v2\n      with:\n        name: shape_main\n        path: dds-rtps/shape_main\n```", "answer": "```yaml name: \"omg-dds/dds-rtps\"\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n\n  Linux:\n    runs-on: ubuntu-20.04\n    steps:\n    - name: checkout OpenDDS\n      uses: actions/checkout@v3\n      with:\n        path: OpenDDS\n        submodules: true\n    - name: checkout dds-rtps\n      uses: actions/checkout@v3\n      with:\n        repository: omg-dds/dds-rtps\n        path: dds-rtps\n    - name: checkout ACE_TAO\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/ACE_TAO\n        ref: Latest_Micro\n        path: OpenDDS/ACE_TAO\n    - name: get ACE_TAO commit\n      shell: bash\n      run: |\n        cd OpenDDS/ACE_TAO\n        export ACE_COMMIT=$(git rev-parse HEAD)\n        echo \"ACE_COMMIT=$ACE_COMMIT\" >> $GITHUB_ENV\n    - name: get compiler version\n      shell: bash\n      run: |\n        export COMPILER_VERSION=$(g++ --version 2>&1 | head -n 1)\n        echo \"COMPILER_VERSION=$COMPILER_VERSION\" >> $GITHUB_ENV\n    - name: checkout MPC\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/MPC\n        path: OpenDDS/ACE_TAO/ACE/MPC\n    - name: configure OpenDDS\n      run: |\n        cd OpenDDS\n        ./configure --optimize --no-debug --static --no-inline\n        tools/scripts/show_build_config.pl\n    - uses: ammaraskar/gcc-problem-matcher@0.1\n    - name: build OpenDDS\n      shell: bash\n      run: |\n        cd OpenDDS\n        make -j4 OpenDDS_Rtps_Udp\n    - name: build shape_main\n      shell: bash\n      run: |\n        cd dds-rtps/srcCxx\n        . ../../OpenDDS/setenv.sh\n        mwc.pl -type gnuace\n        make -sj4\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: ${{ github.job }}_artifact\n        path: dds-rtps/srcCxx/shape_main\n```", "prompt": "Generate a GitHub Workflow named `omg-dds/dds-rtps` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `Linux`. This job will run on ubuntu-20.04 runner. The job `Linux` has 11 steps. The 1st step is named `checkout OpenDDS`. The 2nd step is named `checkout dds-rtps`. The 3rd step is named `checkout ACE_TAO`. The 4th step is named `get ACE_TAO commit`. The 5th step is named `get compiler version`. The 6th step is named `checkout MPC`. The 7th step is named `configure OpenDDS`. The 8th step is named ``. The 9th step is named `build OpenDDS`. The 10th step is named `build shape_main`. The 11th step is named `upload shape_main artifact`. "}
{"id": "63c495277843b61269a05c66", "level": "level4", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        package: [packages/freezed, packages/freezed_annotation]\n        channel: [master, stable]\n        dependencies: [get, downgrade]\n      exclude:\n        - channel: master\n          dependencies: downgrade\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Dart\n        uses: subosito/flutter-action@v1\n        with:\n          flutter-version: 2.5.3\n\n      - name: Removing example folder\n        run: rm -rf example\n\n      - name: Install dependencies\n        run: dart pub get\n\n      - name: Check format\n        run: dart format --set-exit-if-changed .\n\n      - name: Generate\n        run: dart run build_runner build\n\n      - name: Analyze\n        run: dart analyze\n\n      - name: Run tests\n        run: dart test\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    # runs the CI everyday at 10AM\n    - cron: \"0 10 * * *\"\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        package:\n          - packages/freezed\n          - packages/freezed_annotation\n        channel:\n          - master\n          - stable\n        dependencies:\n          - get\n          - downgrade\n        exclude:\n          - channel: master\n            dependencies: downgrade\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: subosito/flutter-action@v2\n        with:\n          channel: ${{ matrix.channel }}\n          cache: ${{ matrix.channel == 'stable' }}\n\n      # It is executed separately\n      - name: Removing example folder\n        run: rm -rf example\n        working-directory: ${{ matrix.package }}\n\n      - name: Install dependencies\n        run: |\n          flutter pub ${{ matrix.dependencies }}\n        working-directory: ${{ matrix.package }}\n\n      - name: Check format\n        # Check format only on master\n        if: matrix.channel == 'master'\n        run: flutter format --set-exit-if-changed .\n        working-directory: ${{ matrix.package }}\n\n      - name: Generate\n        run: |\n          if grep -q build_runner \"pubspec.yaml\"; then\n            flutter pub run build_runner build --delete-conflicting-outputs\n          fi\n        working-directory: ${{ matrix.package }}\n\n      - name: Analyze\n        run: flutter analyze\n        working-directory: ${{ matrix.package }}\n\n      - name: Run tests\n        run: |\n          if grep -q \"name: example\" \"pubspec.yaml\"; then\n            flutter test\n          else\n            dart test\n          fi\n        working-directory: ${{ matrix.package }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `freezed`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `package` has 2 values: packages/freezed and packages/freezed_annotation. The variable `channel` has 2 values: master and stable. The variable `dependencies` has 2 values: get and downgrade. If combinations of variables partially match one of the objects [{'channel': 'master', 'dependencies': 'downgrade'}], combinations should be excluded from the matrix. The job `freezed` has 8 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Removing example folder`. The 4th step is named `Install dependencies`. The 5th step is named `Check format`. The 6th step is named `Generate`. The 7th step is named `Analyze`. The 8th step is named `Run tests`. "}
{"id": "63c4968933b087f6bde2ca37", "level": "level4", "llm_response": "```yaml\nname: e2e-kind-upgrades\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Mount bazel cache\n        run: echo \"Mounting bazel cache\"\n\n      - name: End-to-end (k3d)\n        run: echo \"Running end-to-end tests with k3d\"\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: e2e-kind-upgrades\n\non:\n  # Triggers the workflow on push or pull request events but only for the master branch\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: End-to-end (k3d)\n        run: make test/e2e/k3d-upgrades\n```", "prompt": "Generate a GitHub Workflow named `e2e-kind-upgrades` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. 3) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `e2e-kind-upgrades`. This job will run on ubuntu-latest runner. The job `e2e-kind-upgrades` has 3 steps. The 1st step is named ``. The 2nd step is named `Mount bazel cache`. The 3rd step is named `End-to-end (k3d)`. "}
{"id": "63c494147843b612699fedb4", "level": "level4", "llm_response": "```yaml\nname: test-chart-testing-action\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install chart-testing\n        run: |\n          # Add installation commands for chart-testing here\n      - name: Check install!\n        run: |\n          # Add check install commands here\n      - name: Check root directory\n        run: |\n          # Add check root directory commands here\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install chart-testing\n        run: |\n          # Add installation commands for custom chart-testing here\n      - name: Check install!\n        run: |\n          # Add check install commands here\n      - name: Check root directory\n        run: |\n          # Add check root directory commands here\n```", "answer": "```yaml name: test-chart-testing-action\n\non: [pull_request]\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n\n    name: Install chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.7.1' ]]; then\n          echo 'should be v3.7.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n\n    name: Install Custom chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n      with:\n        version: 'v3.5.1'\n        yamllint_version: '1.27.1'\n        yamale_version: '3.0.4'\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.5.1' ]]; then\n          echo 'should be v3.5.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n```", "prompt": "Generate a GitHub Workflow named `test-chart-testing-action` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Install chart-testing and test presence in path` and its job id is `test_ct_action`. This job will run on ubuntu-latest runner. The job `test_ct_action` has 4 steps. The 1st step is named ``. The 2nd step is named `Install chart-testing`. The 3rd step is named `Check install!`. The 4th step is named `Check root directory`. The 2nd job is named `Install Custom chart-testing and test presence in path` and its job id is `test_ct_action_custom`. This job will run on ubuntu-latest runner. The job `test_ct_action_custom` has 4 steps. The 1st step is named ``. The 2nd step is named `Install chart-testing`. The 3rd step is named `Check install!`. The 4th step is named `Check root directory`. "}
{"id": "63c494fc8052faa2781aead3", "level": "level4", "llm_response": "```yaml\nname: Update Release List\n\non:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [completed]\n    branches: [master]\n\npermissions:\n  contents: write\n\nenv:\n  USER_NAME: ctags-win32 CI\n  USER_EMAIL: ctags-win32-ci@users.noreply.github.com\n  COL_RED: \u001b[31m\n  COL_GREEN: \u001b[32m\n  COL_YELLOW: \u001b[33m\n  COL_RESET: \u001b[m\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n\n    steps:\n    - name: Step 1\n      run: echo \"Step 1\"\n    - name: Step 2\n      run: echo \"Step 2\"\n    - name: Update Release List\n      run: echo \"Updating release list\"\n```", "answer": "```yaml name: Update Release List\n\non:\n  #release:\n  #  types: [published]\n  workflow_run:\n    workflows: [\"Build\"]\n    branches: [master]\n    types: [completed]\n\npermissions:\n  contents: write # to update wiki\n\nenv:\n  # Account for committing\n  USER_NAME: \"ctags-win32 CI\"\n  USER_EMAIL: \"ctags-win32-ci@users.noreply.github.com\"\n\n  # Escape sequences\n  COL_RED: \"\\x1b[31m\"\n  COL_GREEN: \"\\x1b[32m\"\n  COL_YELLOW: \"\\x1b[33m\"\n  COL_RESET: \"\\x1b[m\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        path: main\n\n    - uses: actions/checkout@v3\n      with:\n        repository: \"${{ github.repository }}.wiki\"\n        path: wiki\n\n    - name: Update Release List\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      run: |\n        cd main\n        latest=$(cat ctagsver.txt)\n        cd ../wiki\n        ../main/scripts/update-release-list.py\n        git add Releases-in-*.md\n        if git diff HEAD --quiet; then\n          echo ${COL_YELLOW}No updates.${COL_RESET}\n        else\n          git config --local user.name ${USER_NAME}\n          git config --local user.email ${USER_EMAIL}\n          git commit -a -m \"Update Release List to ${latest}\"\n          git push origin HEAD\n        fi\n```", "prompt": "Generate a GitHub Workflow named `Update Release List` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the workflow named Build is completed on a branch whose name matches master. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets 6 environment variables to use: `USER_NAME` is set to `ctags-win32 CI`, `USER_EMAIL` is set to `ctags-win32-ci@users.noreply.github.com`, `COL_RED` is set to `\u001b[31m`, `COL_GREEN` is set to `\u001b[32m`, `COL_YELLOW` is set to `\u001b[33m` and `COL_RESET` is set to `\u001b[m`. The workflow has one job. The job id of the 1st job is `update`. This job will run only if the condition(${{ github.event.workflow_run.conclusion == 'success' }}) is met. This job will run on ubuntu-latest runner. The job `update` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named `Update Release List`. "}
{"id": "63c4969c1899db58864d4153", "level": "level4", "llm_response": "```yaml\nname: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    id: backend-tests\n    runs-on: ubuntu-latest\n    steps:\n      - uses: ./.github/workflows/partial-backend.yml\n\n  frontend-tests:\n    id: frontend-tests\n    runs-on: ubuntu-latest\n    steps:\n      - uses: ./.github/workflows/partial-frontend.yml\n\n  build-release:\n    id: build-release\n    needs: [backend-tests, frontend-tests]\n    runs-on: ubuntu-latest\n    steps:\n      - uses: ./.github/workflows/partial-builder.yml\n        with:\n          tag: nightly\n        secrets:\n          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}\n          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}\n\n  notify-discord:\n    id: notify-discord\n    needs: build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        run: echo \"Notifying Discord about the release\"\n\n  deploy-demo:\n    id: deploy-demo\n    needs: build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clean and Deploy Demo\n        run: echo \"Cleaning and deploying the demo\"\n```", "answer": "```yaml name: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    name: \"Backend Server Tests\"\n    uses: ./.github/workflows/partial-backend.yml\n\n  frontend-tests:\n    name: \"Frontend and End-to-End Tests\"\n    uses: ./.github/workflows/partial-frontend.yml\n\n  build-release:\n    name: Build Tagged Release\n    uses: ./.github/workflows/partial-builder.yml\n    needs:\n      - frontend-tests\n      - backend-tests\n    with:\n      tag: nightly\n    secrets:\n      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}\n      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}\n\n  notify-discord:\n    name: Notify Discord\n    needs:\n      - build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        env:\n          DISCORD_WEBHOOK: ${{ secrets.DISCORD_NIGHTLY_WEBHOOK }}\n        uses: Ilshidur/action-discord@0.3.2\n        with:\n          args: \"\ud83d\ude80  A New build of mealie:api-nightly and mealie:frontend-nightly is available\"\n\n  deploy-demo:\n    runs-on: ubuntu-latest\n    name: Deploy Demo\n    needs:\n      - build-release\n    steps:\n      - name: Clean and Deploy Demo\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.DEMO_SERVER_IP }}\n          username: ${{ secrets.DEMO_SERVER_USER }}\n          key: ${{ secrets.DEMO_SERVER_SSH_KEY }}\n          port: ${{ secrets.DEMO_SERVER_PORT }}\n          script_stop: true\n          script: |\n            cd ~/docker/mealie-next\n            docker-compose pull\n            docker-compose down -v\n            docker-compose up -d\n```", "prompt": "Generate a GitHub Workflow named `Docker Nightly Production` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named mealie-next. Only a single workflow using the nightly-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 5 jobs. The 1st job is named `Backend Server Tests` and its job id is `backend-tests`. This job will call a reusable workflow located at `./.github/workflows/partial-backend.yml`. The 2nd job is named `Frontend and End-to-End Tests` and its job id is `frontend-tests`. This job will call a reusable workflow located at `./.github/workflows/partial-frontend.yml`. The 3rd job is named `Build Tagged Release` and its job id is `build-release`. Before this job runs, `frontend-tests` and `backend-tests` must complete successfully. This job will call a reusable workflow located at `./.github/workflows/partial-builder.yml`. The job will pass an input to the called workflow: the input `tag` is `nightly`. The job will pass 2 secrets to the called workflow: the secret `DOCKERHUB_USERNAME` is `${{ secrets.DOCKERHUB_USERNAME }}` and the secret `DOCKERHUB_TOKEN` is `${{ secrets.DOCKERHUB_TOKEN }}`. The 4th job is named `Notify Discord` and its job id is `notify-discord`. Before this job runs, `build-release` must complete successfully. This job will run on ubuntu-latest runner. The job `notify-discord` has one step. The 1st step is named `Discord notification`. The 5th job is named `Deploy Demo` and its job id is `deploy-demo`. Before this job runs, `build-release` must complete successfully. This job will run on ubuntu-latest runner. The job `deploy-demo` has one step. The 1st step is named `Clean and Deploy Demo`. "}
{"id": "63c494037843b612699fe649", "level": "level4", "llm_response": "```yaml\nname: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version'\n        required: true\n      tag:\n        description: 'Tag'\n        required: true\n        default: 'latest'\n\npermissions:\n  contents: write\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    environment: release\n    steps:\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Update tag\n        run: echo \"Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}\"\n```", "answer": "```yaml name: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: Version\n        required: true\n      tag:\n        description: Tag\n        default: latest\n        required: true\n\npermissions: {}\njobs:\n  build:\n    name: Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}\n    environment: release\n    runs-on: ubuntu-latest\n    steps:\n    - name: Setup Node\n      uses: actions/setup-node@v3\n    - name: Update tag\n      env:\n        \"npm_config_//registry.npmjs.org/:_authToken\": ${{ secrets.NPM_TOKEN }}\n      run: |\n        npm dist-tag add pnpm@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n        npm dist-tag add @pnpm/exe@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n```", "prompt": "Generate a GitHub Workflow named `Tag` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives 2 inputs: version-this input represents version and it must be supplied; tag-this input represents tag, its default value is latest and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: the workflow disables permissions for the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}` and its job id is `build`. This job will run on ubuntu-latest runner. This job references release environment. The job `build` has 2 steps. The 1st step is named `Setup Node`. The 2nd step is named `Update tag`. "}
{"id": "63c4949a8052faa2781ac0b0", "level": "level4", "llm_response": "```yaml\nname: Node.js CI\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: Cache pnpm modules\n        uses: actions/cache@v2\n        with:\n          path: ~/.pnpm-store\n          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-pnpm-\n\n      - name: Install dependencies\n        run: pnpm install\n\n      - name: Run tests\n        run: pnpm test\n\n      - name: Build project\n        run: pnpm run build\n```", "answer": "```yaml # This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Node.js CI\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: Cache pnpm modules\n        uses: actions/cache@v3\n        env:\n          cache-name: cache-pnpm-modules\n        with:\n          path: ~/.pnpm-store\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n      - uses: actions/cache@v3\n        with:\n          path: |\n            ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}\n          restore-keys: |\n            ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-\n      - uses: pnpm/action-setup@v2.2.4\n        with:\n          version: 7.x.x\n          run_install: true\n      - name: Build project\n        run: |\n          yarn build\n          yarn lint\n        env:\n          CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node.js CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `node-version` has one value: 16.x. The job `build` has 6 steps. The 1st step is named ``. The 2nd step is named `Use Node.js ${{ matrix.node-version }}`. The 3rd step is named `Cache pnpm modules`. The 4th step is named ``. The 5th step is named ``. The 6th step is named `Build project`. "}
{"id": "63c4967e1899db58864d33dd", "level": "level4", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n  pull_request_target:\n    types: [opened, edited, synchronize]\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    id: lint-commit-message\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Commit Message\n      run: |\n        # Add your commit message linting logic here\n\n    - name: File names\n      run: |\n        # Add your file names linting logic here\n\n    - name: Functions\n      run: |\n        # Add your functions linting logic here\n\n    - name: Logging messages should not have trailing newlines\n      run: |\n        # Add your logging messages linting logic here\n\n  lint-go:\n    id: lint-go\n    runs-on: ubuntu-latest\n\n    permissions:\n      contents: read\n      pull-requests: read\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: golangci-lint\n      run: |\n        # Add your golangci-lint logic here\n```", "answer": "```yaml #\n# DO NOT EDIT THIS FILE\n#\n# It is automatically copied from https://github.com/pion/.goassets repository.\n# If this repository should have package specific CI config,\n# remove the repository name from .goassets/.github/workflows/assets-sync.yml.\n#\n# If you want to update the shared CI config, send a PR to\n# https://github.com/pion/.goassets instead of this repository.\n#\n\nname: Lint\non:\n  pull_request:\n    types:\n      - opened\n      - edited\n      - synchronize\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    name: Metadata\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n        - uses: actions/checkout@v3\n          with:\n            fetch-depth: 0\n\n        - name: Commit Message\n          run: .github/lint-commit-message.sh\n\n        - name: File names\n          run: .github/lint-filename.sh\n\n        - name: Functions\n          run: .github/lint-disallowed-functions-in-library.sh\n\n        - name: Logging messages should not have trailing newlines\n          run: .github/lint-no-trailing-newline-in-log-messages.sh\n\n  lint-go:\n    name: Go\n    permissions:\n      contents: read\n      pull-requests: read\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: golangci-lint\n        uses: golangci/golangci-lint-action@v3\n        with:\n          version: v1.45.2\n          args: $GOLANGCI_LINT_EXRA_ARGS\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created, the title or body of a pull request is edited or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `Metadata` and its job id is `lint-commit-message`. This job will run on ubuntu-latest runner. The job `lint-commit-message` has 5 steps. The 1st step is named ``. The 2nd step is named `Commit Message`. The 3rd step is named `File names`. The 4th step is named `Functions`. The 5th step is named `Logging messages should not have trailing newlines`. The 2nd job is named `Go` and its job id is `lint-go`. This job will run on ubuntu-latest runner. The job `lint-go` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope and read access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `lint-go`. The job `lint-go` has 2 steps. The 1st step is named ``. The 2nd step is named `golangci-lint`. "}
{"id": "63c4947b8052faa2781ab631", "level": "level4", "llm_response": "```yaml\nname: Publish Test Results\n\non:\n  workflow_run:\n    workflows: [CI]\n    types: [completed]\n\njobs:\n  test-results:\n    id: test-results\n    runs-on: ubuntu-latest\n    if: github.event.workflow_run.conclusion != 'skipped'\n    steps:\n    - name: Download and Extract Artifacts\n      run: |\n        # Add commands to download and extract artifacts here\n    - name: Publish Test Results\n      run: |\n        # Add commands to publish test results here\n```", "answer": "```yaml # Publishing of unit test results has to be a separate workflow in order to support forked PRs\n# See https://github.com/EnricoMi/publish-unit-test-result-action#support-fork-repositories-and-dependabot-branches\nname: Publish Test Results\non:\n  workflow_run:\n    workflows: [CI]\n    types:\n      - completed\njobs:\n  test-results:\n    name: Test Results\n    runs-on: ubuntu-latest\n    if: github.event.workflow_run.conclusion != 'skipped'\n\n    steps:\n      - name: Download and Extract Artifacts\n        env:\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n        run: |\n          mkdir -p artifacts && cd artifacts\n\n          artifacts_url=${{ github.event.workflow_run.artifacts_url }}\n\n          gh api \"$artifacts_url\" -q '.artifacts[] | [.name, .archive_download_url] | @tsv' | while read artifact\n          do\n            IFS=$'\\t' read name url <<< \"$artifact\"\n            gh api $url > \"$name.zip\"\n            unzip -d \"$name\" \"$name.zip\"\n          done\n\n      - name: Publish Test Results\n        uses: EnricoMi/publish-unit-test-result-action@v2\n        with:\n          commit: ${{ github.event.workflow_run.head_sha }}\n          event_file: artifacts/Event File/event.json\n          event_name: ${{ github.event.workflow_run.event }}\n          junit_files: |\n            artifacts/**/surefire-reports/*.xml\n            artifacts/**/failsafe-reports/TEST-*.xml\n```", "prompt": "Generate a GitHub Workflow named `Publish Test Results` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: the workflow named CI is completed. The workflow has one job. The 1st job is named `Test Results` and its job id is `test-results`. This job will run only if the condition(github.event.workflow_run.conclusion != 'skipped') is met. This job will run on ubuntu-latest runner. The job `test-results` has 2 steps. The 1st step is named `Download and Extract Artifacts`. The 2nd step is named `Publish Test Results`. "}
{"id": "63c4964a1e33648075779a84", "level": "level4", "llm_response": "```yaml\nname: Publish Terminal.Gui\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  publish:\n    id: publish\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Install and calculate the new version with GitVersion\n        uses: gittools/actions/gitversion@v0.9.9\n        with:\n          mode: ContinuousIntegration\n\n      - name: Determine Version\n        id: gitversion\n        run: echo \"::set-output name=version::$(gitversion | jq -r '.SemVer')\"\n\n      - name: Display GitVersion outputs\n        run: echo \"GitVersion Version: $(gitversion | jq -r '.SemVer')\"\n\n      - name: Setup dotnet\n        uses: actions/setup-dotnet@v2\n        with:\n          dotnet-version: '6.0'\n\n      - name: Install dependencies\n        run: dotnet restore\n\n      - name: Build Release\n        run: dotnet build --configuration Release\n\n      - name: Pack\n        run: dotnet pack --configuration Release --output ./artifacts\n\n      - name: Test to generate Code Coverage Report\n        run: dotnet test --configuration Release --collect \"XPlat Code Coverage\" --verbosity normal --logger \"trx;LogFileName=TestResults.trx\"\n\n      - name: Create Test Coverage Badge\n        id: create_coverage_badge\n        run: |\n          dotnet tool install -g dotnet-reportgenerator-globaltool\n          reportgenerator -reports:TestResults.trx -targetdir:./coverage -reporttypes:Badges\n\n      - name: Print Code Coverage\n        run: echo \"::set-output name=coverage_badge::$(cat ./coverage/Badges/coverage-badge.svg | base64)\"\n\n      - name: Publish to NuGet.org\n        uses: .github/actions/publish-nuget\n        with:\n          nuget_api_key: ${{ secrets.NUGET_API_KEY }}\n          package_path: ./artifacts/*.nupkg\n          version: ${{ steps.gitversion.outputs.version }}\n          release_notes: ${{ github.event.release.body }}\n          icon_url: ${{ steps.create_coverage_badge.outputs.coverage_badge }}\n```", "answer": "```yaml name: Publish Terminal.Gui\non:\n  push:\n    tags:\n      - v*\n\njobs:\n\n  publish:\n    name: Build and Publish to Nuget.org\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0 #fetch-depth is needed for GitVersion\n\n    - name: Install and calculate the new version with GitVersion \n      uses: gittools/actions/gitversion/setup@v0.9.13\n      with:\n        versionSpec: 5.x\n\n    - name: Determine Version\n      uses: gittools/actions/gitversion/execute@v0.9.13\n      id: gitversion # step id used as reference for output values\n\n    - name: Display GitVersion outputs\n      run: |\n        echo \"Version: ${{ steps.gitversion.outputs.SemVer }}\"\n        echo \"CommitsSinceVersionSource: ${{ steps.gitversion.outputs.CommitsSinceVersionSource }}\"\n\n    - name: Setup dotnet\n      uses: actions/setup-dotnet@v3.0.1\n      with:\n        dotnet-version: 6.0.100\n\n    - name: Install dependencies\n      run: dotnet restore\n\n    - name: Build Release\n      run: |\n        dotnet-gitversion /updateprojectfiles\n        dotnet build --no-restore -c Release\n\n    - name: Pack\n      run: dotnet pack -c Release --include-symbols -p:Version='${{ steps.gitversion.outputs.SemVer }}' \n\n    - name: Test to generate Code Coverage Report\n      run: |\n        dotnet test --verbosity normal --collect:\"XPlat Code Coverage\" --settings UnitTests/coverlet.runsettings\n        mv -v UnitTests/TestResults/*/*.* UnitTests/TestResults/\n\n    - name: Create Test Coverage Badge\n      uses: simon-k/dotnet-code-coverage-badge@v1.0.0\n      id: create_coverage_badge\n      with:\n        label: Unit Test Coverage\n        color: brightgreen\n        path: UnitTests/TestResults/coverage.opencover.xml\n        gist-filename: code-coverage.json\n        # https://gist.github.com/migueldeicaza/90ef67a684cb71db1817921a970f8d27\n        gist-id: 90ef67a684cb71db1817921a970f8d27\n        gist-auth-token: ${{ secrets.GIST_AUTH_TOKEN }}   \n\n    - name: Print Code Coverage\n      run: |\n        echo \"Code coverage percentage: ${{steps.create_coverage_badge.outputs.percentage}}%\"\n        echo \"Badge data: ${{steps.create_coverage_badge.outputs.badge}}\"\n        \n    #- name: Prep GitHub Packages\n    #  run: dotnet nuget add source --username tig --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/tig/index.json\"\n\n    #- name: Publish to GitHub packages \n    #  run: dotnet nuget push NStack/bin/Release/*.nupkg --api-key ${{ secrets.GITHUB_TOKEN }}  --source \"github\"\n\n    - name: Publish to NuGet.org\n      run: dotnet nuget push Terminal.Gui/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json\n```", "prompt": "Generate a GitHub Workflow named `Publish Terminal.Gui` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Build and Publish to Nuget.org` and its job id is `publish`. This job will run on ubuntu-latest runner. The job `publish` has 12 steps. The 1st step is named ``. The 2nd step is named `Install and calculate the new version with GitVersion`. The 3rd step is named `Determine Version` and its id is `gitversion`. The 4th step is named `Display GitVersion outputs`. The 5th step is named `Setup dotnet`. The 6th step is named `Install dependencies`. The 7th step is named `Build Release`. The 8th step is named `Pack`. The 9th step is named `Test to generate Code Coverage Report`. The 10th step is named `Create Test Coverage Badge` and its id is `create_coverage_badge`. The 11th step is named `Print Code Coverage`. The 12th step is named `Publish to NuGet.org`. "}
{"id": "63c4950a7843b61269a0501c", "level": "level4", "llm_response": "```yaml\nname: Integration test on schedule (minimal)\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false\n\njobs:\n  start-integration-test-minimal:\n    id: start-integration-test-minimal\n    uses: ./.github/workflows/integration.yml\n    with:\n      install_profile: minimal\n      cluster_region: ams3\n      kubernetes_versions: ['1.22', '1.23']\n    secrets:\n      special_case_secrets: inherit\n```", "answer": "```yaml name: Integration test on schedule (minimal)\nconcurrency: ${{ github.workflow }}-${{ github.ref }}\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  start-integration-test-minimal:\n    name: Start integration test (minimal)\n    uses: ./.github/workflows/integration.yml\n    secrets: inherit\n    with:\n      install_profile: minimal\n      cluster_region: ams3\n      kubernetes_versions: \"['1.22', '1.23']\"\n```", "prompt": "Generate a GitHub Workflow named `Integration test on schedule (minimal)` for a GitHub repository whose primary programming language is Mustache. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Start integration test (minimal)` and its job id is `start-integration-test-minimal`. This job will call a reusable workflow located at `./.github/workflows/integration.yml`. The job will pass 3 inputs to the called workflow: the input `install_profile` is `minimal`, the input `cluster_region` is `ams3` and the input `kubernetes_versions` is `['1.22', '1.23']`. The job will pass a secret to the called workflow: the secret `special_case_secrets` is `inherit`. "}
{"id": "63c494b08052faa2781aca76", "level": "level4", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: macos-11\n    strategy:\n      matrix:\n        language: [cpp]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v1\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v1\n```", "answer": "```yaml name: 'CodeQL'\n\non:\n  push:\n    branches: [master]\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: macos-11\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: ['cpp']\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n        with:\n          languages: ${{ matrix.language }}\n\n      - run: >-\n          env NSUnbufferedIO=YES\n          xcodebuild\n          -workspace Sentry.xcworkspace\n          -scheme Sentry\n          -configuration Release\n          -destination platform=\"iOS Simulator,OS=latest,name=iPhone 11 Pro\"\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 04:40 am, only on saturday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on macos-11 runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has one value: cpp. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. The 2nd step is named `Initialize CodeQL`. The 3rd step is named ``. The 4th step is named `Perform CodeQL Analysis`. "}
{"id": "63c496891e3364807577b43d", "level": "level4", "llm_response": "```yaml\nname: Check Actions rate limit\n\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check rate limit\n        run: |\n          curl -s -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" https://api.github.com/rate_limit | jq .\n```", "answer": "```yaml name: Check Actions rate limit\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    name: Check Actions rate limit\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check rate limit\n        env:\n          TOKEN: ${{ github.token }}\n        run: |\n          curl -v --no-progress-meter --header \"Authorization: Bearer $TOKEN\" https://api.github.com/rate_limit\n```", "prompt": "Generate a GitHub Workflow named `Check Actions rate limit` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Check Actions rate limit` and its job id is `check`. This job will run on ubuntu-latest runner. The job `check` has one step. The 1st step is named `Check rate limit`. "}
{"id": "63c4969e1899db58864d41ee", "level": "level4", "llm_response": "```yaml\nname: Auto message on Creating Issue\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Create comment for issue\n        run: echo \"Hello! Welcome to our repository. We appreciate your contribution.\" | gh issue comment ${{ github.event.issue.number }} --repo ${{ github.repository }}\n```", "answer": "```yaml name: Auto message on Creating Issue.\n\non:\n\n  issues:\n\n    types: [opened]\n\njobs:\n\n  greeting:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - name: Create comment for issue\n\n      if: github.event_name =='issues' \n\n      uses: peter-evans/create-or-update-comment@v1\n\n      with:\n\n        issue-number: ${{tojson(github.event.issue.number)}}\n\n        body: |\n\n            Hi \ud83d\ude04, @${{ github.actor }} Thanks for creating an issue at FunwithPhysics. We request you to follow the contributing guidelines. \n```", "prompt": "Generate a GitHub Workflow named `Auto message on Creating Issue.` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `greeting`. This job will run on ubuntu-latest runner. The job `greeting` has one step. The 1st step is named `Create comment for issue`. "}
{"id": "63c496941899db58864d3d85", "level": "level4", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n```", "answer": "```yaml name: release-please\non:\n   push:\n      branches:\n         - master\njobs:\n   release-please:\n      runs-on: ubuntu-latest\n      steps:\n         - uses: GoogleCloudPlatform/release-please-action@v2\n           with:\n            token: ${{ secrets.GITHUB_TOKEN }}\n            release-type: simple\n            version-file: \"./version.txt\"\n            package-name: release-please-action\n            default-branch: master\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is Swift. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. This job will run on ubuntu-latest runner. The job `release-please` has one step. The 1st step is named ``. "}
{"id": "63c496486fc19abdf9c9b0d5", "level": "level4", "llm_response": "```yaml\nname: Dependencies\n\non:\n  schedule:\n    - cron: '0 12 * * 1'\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    id: upgrade\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n      - name: Install dependencies\n        run: npm install\n      - name: Upgrade dependencies\n        run: npm update\n      - name: Check for breaking changes\n        run: npm outdated\n      - name: Commit and push changes\n        run: |\n          git add package.json package-lock.json\n          git commit -m \"Upgrade dependencies\"\n          git push\n```", "answer": "```yaml name: Dependencies\n\non:\n  schedule:\n    - cron: \"0 12 * * 1\"\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    name: Upgrade dependencies\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2\n        with:\n          version: latest\n      - uses: actions/setup-node@v3\n        with:\n          cache: \"pnpm\"\n          node-version-file: \".nvmrc\"\n          registry-url: \"https://npm.pkg.github.com\"\n      - run: rm -rf pnpm-lock.yaml **/node_modules/\n      - run: pnpm install\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_GITHUB_TOKEN }}\n      - uses: EndBug/add-and-commit@v9\n        with:\n          message: \"chore(deps): upgrade versions\"\n```", "prompt": "Generate a GitHub Workflow named `Dependencies` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 pm, only on monday. 2) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Upgrade dependencies` and its job id is `upgrade`. This job will run on ubuntu-latest runner. The job `upgrade` has 6 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named ``. The 5th step is named ``. The 6th step is named ``. "}
{"id": "63c4954d8052faa2781b0e83", "level": "level4", "llm_response": "```yaml\nname: xgo\n\non:\n  push:\n    branches:\n      - master\n    tags:\n      - v*\n    paths-ignore:\n      - '**.md'\n  pull_request:\n    branches:\n      - master\n    paths-ignore:\n      - '**.md'\n\nconcurrency:\n  group: xgo-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n\n      - name: Build artifacts\n        run: docker build -t my-image .\n\n      - name: Move artifacts\n        run: mv /path/to/artifacts /path/to/new/location\n\n      - name: Upload artifacts\n        uses: actions/upload-artifact@v2\n        with:\n          name: my-artifact\n          path: /path/to/new/location\n\n      - name: GitHub Release\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: Release ${{ github.ref }}\n          draft: false\n          prerelease: false\n```", "answer": "```yaml name: xgo\n\nconcurrency:\n  group: xgo-${{ github.ref }}\n  cancel-in-progress: true\n\non:\n  push:\n    branches:\n      - 'master'\n    tags:\n      - 'v*'\n    paths-ignore:\n      - '**.md'\n  pull_request:\n    branches:\n      - 'master'\n    paths-ignore:\n      - '**.md'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n      -\n        name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      -\n        name: Build artifacts\n        uses: docker/bake-action@v2\n        with:\n          targets: artifact-all\n      -\n        name: Move artifacts\n        run: |\n          mv ./dist/**/* ./dist/\n      -\n        name: Upload artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: xgo\n          path: ./dist/*\n          if-no-files-found: error\n      -\n        name: GitHub Release\n        uses: softprops/action-gh-release@v1\n        if: startsWith(github.ref, 'refs/tags/v')\n        with:\n          draft: true\n          files: |\n            dist/*.tar.gz\n            dist/*.zip\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `xgo` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a tag whose name matches v*. When all the path names of push event match patterns in the paths-ignore filter(**.md), the workflow will not run. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. When all the path names of pull_request event match patterns in the paths-ignore filter(**.md), the workflow will not run. Only a single workflow using the xgo-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 6 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up Docker Buildx`. The 3rd step is named `Build artifacts`. The 4th step is named `Move artifacts`. The 5th step is named `Upload artifacts`. The 6th step is named `GitHub Release`. "}
{"id": "63c494a48052faa2781ac54e", "level": "level4", "llm_response": "```yaml\nname: lint\n\non:\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - 'docs/**'\n  push:\n    branches: [ main ]\n    paths-ignore:\n      - 'docs/**'\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run cspell\n        run: cspell .\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install dependencies\n        run: npm install\n      - name: Run lint\n        run: npm run lint\n```", "answer": "```yaml name: lint\non: # rebuild any PRs and main branch changes\n  pull_request:\n    paths-ignore:\n      - \"docs/**\"\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - \"docs/**\"\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx cspell \"**\" --dot --no-progress\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: yarn\n      - run: yarn lint\n```", "prompt": "Generate a GitHub Workflow named `lint` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) When all the path names of pull_request event match patterns in the paths-ignore filter(docs/**), the workflow will not run. 2) The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**), the workflow will not run. The workflow has 2 jobs. The job id of the 1st job is `cspell`. This job will run on ubuntu-latest runner. The job `cspell` has 2 steps. The 1st step is named ``. The 2nd step is named ``. The job id of the 2nd job is `lint`. This job will run on ubuntu-latest runner. The job `lint` has 3 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. "}
{"id": "63c4957d8052faa2781b229c", "level": "level4", "llm_response": "```yaml\nname: Build site nightly\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  dot-release:\n    id: dot-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: curl\n```", "answer": "```yaml # Copyright 2022 The Knative Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nname: Build site nightly\n\non:\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  dot-release:\n    name: dot-release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: curl\n        env:\n          NETLIFY_BUILD_HOOK: ${{ secrets.NETLIFY_BUILD_HOOK }}\n        uses: wei/curl@v1\n        with:\n          args: -X POST -d '{}' \"$NETLIFY_BUILD_HOOK\"\n```", "prompt": "Generate a GitHub Workflow named `Build site nightly` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `dot-release` and its job id is `dot-release`. This job will run on ubuntu-latest runner. The job `dot-release` has one step. The 1st step is named `curl`. "}
{"id": "63c496891e3364807577b43a", "level": "level4", "llm_response": "```yaml\nname: Jetpack block performance\n\non:\n  schedule:\n    - cron: '0 */12 * * *'\n\njobs:\n  block-performance:\n    id: block-performance\n    runs-on: ubuntu-latest\n    timeout-minutes: 50\n    steps:\n      - name: Step 1\n      - name: Step 2\n      - name: Step 3\n      - name: Build Gutenberg\n      - name: Step 5\n      - name: Setup tools for J\n      - name: Build Production Jetpack\n      - name: Environment set-up\n      - name: Run performance tests\n      - name: Environment tear-down\n      - name: Upload test artifacts\n\n  test-reports:\n    id: test-reports\n    needs: block-performance\n    if: ${{ ! cancelled() }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Repository Dispatch\n\n  slack-notification:\n    id: slack-notification\n    needs: block-performance\n    if: ${{ ! cancelled() }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Step 1\n      - name: Set up tools\n      - name: Build action\n      - name: Send notification\n```", "answer": "```yaml name: Jetpack block performance\n\non:\n  schedule:\n    - cron:  '0 */12 * * *'\n\njobs:\n  block-performance:\n    name: \"Performance tests\"\n    runs-on: ubuntu-latest\n    timeout-minutes: 50  # 2021-12-13: Successful runs seem to take 40 minutes\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n\n      - uses: actions/checkout@v3\n        with:\n          repository: 'WordPress/gutenberg'\n          path: 'gutenberg'\n\n      - name: Build Gutenberg\n        working-directory: gutenberg\n        run: |\n          npm ci\n          npm run build\n\n      - uses: actions/cache@v3\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('gutenberg/**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - name: Setup tools for J\n        uses: ./.github/actions/tool-setup\n\n      - name: Build Production Jetpack\n        run: |\n          pnpm install\n          pnpm jetpack build plugins/jetpack -v --production\n\n      - name: Environment set-up\n        working-directory: tools/e2e-commons\n        env:\n          CONFIG_KEY: ${{ secrets.E2E_CONFIG_KEY }}\n        run: |\n          # Gutenberg Performance tests require disable-animations.php test plugin to be available on a site. Below we inject the mapping for that plugin into a Docker config file\n\n          echo \"e2e:\" >> ../docker/jetpack-docker-config.yml\n          echo \"  volumeMappings:\" >> ../docker/jetpack-docker-config.yml\n          echo \"    gutenberg/packages/e2e-tests/plugins/disable-animations.php: /var/www/html/wp-content/plugins/disable-animations.php\" >> ../docker/jetpack-docker-config.yml\n\n          mkdir results\n          pnpm config:decrypt\n          pnpm env:start\n\n      - name: Run performance tests\n        working-directory: tools/e2e-commons\n        run: |\n          node ./bin/performance.js\n\n      - name: Environment tear-down\n        if: ${{ always() }}\n        working-directory: tools/e2e-commons\n        continue-on-error: true\n        run: |\n          pnpm run tunnel:off\n          # Update permissions to workaround https://github.com/actions/cache/issues/753\n          sudo chown -R runner:docker \"$GITHUB_WORKSPACE/tools/docker\"\n\n      - name: Upload test artifacts\n        if: ${{ always() }}\n        continue-on-error: true\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-output-block-perf\n          path: tools/e2e-commons/results\n\n  test-reports:\n    name: \"Trigger test report workflow\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: block-performance\n\n    steps:\n      - name: Repository Dispatch\n        uses: peter-evans/repository-dispatch@v2\n        with:\n          token: ${{ secrets.E2E_TEST_REPORTS_TOKEN }}\n          repository: automattic/jetpack-e2e-reports\n          event-type: block-perf\n          client-payload: '{\"run_id\": \"${{github.run_id}}\", \"repository\": \"${{github.repository}}\"}'\n\n  slack-notification:\n    name: \"Slack notification\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: [block-performance]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up tools\n        uses: ./.github/actions/tool-setup\n\n      - name: Build action\n        env:\n          COMPOSER_ROOT_VERSION: dev-trunk\n        run: |\n          pnpm install\n          composer install\n          composer build-development\n        working-directory: ./projects/github-actions/test-results-to-slack\n\n      - name: \"Send notification\"\n        uses: ./projects/github-actions/test-results-to-slack\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          slack_token: ${{ secrets.SLACK_TOKEN }}\n          slack_channel: ${{ secrets.SLACK_E2E_CHANNEL }}\n          slack_icon_emoji: \":jetpack:\"\n          suite_name: \"blocks performance\"\n```", "prompt": "Generate a GitHub Workflow named `Jetpack block performance` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: the scheduled time has come: every 12 hours. The workflow has 3 jobs. The 1st job is named `Performance tests` and its job id is `block-performance`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 50. The job `block-performance` has 11 steps. The 1st step is named ``. The 2nd step is named ``. The 3rd step is named ``. The 4th step is named `Build Gutenberg`. The 5th step is named ``. The 6th step is named `Setup tools for J`. The 7th step is named `Build Production Jetpack`. The 8th step is named `Environment set-up`. The 9th step is named `Run performance tests`. The 10th step is named `Environment tear-down`. The 11th step is named `Upload test artifacts`. The 2nd job is named `Trigger test report workflow` and its job id is `test-reports`. Before this job runs, `block-performance` must complete successfully. This job will run only if the condition(${{ ! cancelled() }}) is met. This job will run on ubuntu-latest runner. The job `test-reports` has one step. The 1st step is named `Repository Dispatch`. The 3rd job is named `Slack notification` and its job id is `slack-notification`. Before this job runs, `block-performance` must complete successfully. This job will run only if the condition(${{ ! cancelled() }}) is met. This job will run on ubuntu-latest runner. The job `slack-notification` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up tools`. The 3rd step is named `Build action`. The 4th step is named `Send notification`. "}
{"id": "63c4968633b087f6bde2c8ea", "level": "level4", "llm_response": "```yaml\nname: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - '[0-9]+.[0-9]+.[0-9]+'\n      - '[0-9]+.[0-9]+.[0-9]+rc[0-9]+'\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment: [py36, py37, flake8]\n        python: [3.6, 3.7]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Install tox\n        run: pip install tox\n      - name: Run tox\n        run: tox -e ${{ matrix.environment }}\n```", "answer": "```yaml name: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - \"[0-9]+.[0-9]+.[0-9]+\"\n      - \"[0-9]+.[0-9]+.[0-9]+rc[0-9]+\"\n\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment:\n          - \"py36\"\n          - \"py37\"\n          - \"flake8\"\n\n        include:\n          - environment: \"py36\"\n            python: \"3.6\"\n          - environment: \"py37\"\n            python: \"3.7\"\n          - environment: \"flake8\"\n            python: \"3.7\"\n\n    container:\n      image: python:${{ matrix.python }}\n\n    steps:\n      - uses: actions/checkout@master\n      - name: Install tox\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install tox\n      - name: Run tox\n        run: |\n          tox -e ${{ matrix.environment }}\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a tag whose name matches [0-9]+.[0-9]+.[0-9]+ or a tag whose name matches [0-9]+.[0-9]+.[0-9]+rc[0-9]+. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `tox`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `environment` has 3 values: py36, py37 and flake8. For each object in the [{'environment': 'py36', 'python': '3.6'}, {'environment': 'py37', 'python': '3.7'}, {'environment': 'flake8', 'python': '3.7'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job creates a Docker container that uses `python:${{ matrix.python }}` image. The job `tox` has 3 steps. The 1st step is named ``. The 2nd step is named `Install tox`. The 3rd step is named `Run tox`. "}
{"id": "63c494187843b612699fef56", "level": "level4", "llm_response": "```yaml\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Enable debug mode'\n        required: false\n        type: boolean\n        default: false\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: false\n\njobs:\n  fork_update_pr:\n    id: fork_update_pr\n    runs-on: ubuntu-latest\n    if: github.repository_owner != 'HariSekhon'\n    steps:\n      - name: Call reusable workflow\n        uses: HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master\n        with:\n          debug: ${{ github.event.inputs.debug }}\n```", "answer": "```yaml #\n#  Author: Hari Sekhon\n#  Date: Tue Feb 4 09:53:28 2020 +0000\n#\n#  vim:ts=2:sts=2:sw=2:et\n#\n#  https://github.com/HariSekhon/Kubernetes-configs\n#\n#  If you're using my code you're welcome to connect with me on LinkedIn and optionally send me feedback\n#\n#  https://www.linkedin.com/in/HariSekhon\n#\n\n---\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        required: false\n        default: false\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: false\n\njobs:\n  fork_update_pr:\n    # github.event.repository context not available in scheduled workflows\n    #if: github.event.repository.fork == true\n    if: github.repository_owner != 'HariSekhon'\n    name: Fork Update PR\n    uses: HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master\n    with:\n      debug: ${{ github.event.inputs.debug }}\n```", "prompt": "Generate a GitHub Workflow named `Fork Update PR` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, it is optional and its default value is False. 2) the scheduled time has come: at 10:00 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.ref }}-${{ github.workflow }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Fork Update PR` and its job id is `fork_update_pr`. This job will run only if the condition(github.repository_owner != 'HariSekhon') is met. This job will call a reusable workflow located at `HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master`. The job will pass an input to the called workflow: the input `debug` is `${{ github.event.inputs.debug }}`. "}
{"id": "63c494e67843b61269a04123", "level": "level4", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n    branches: [ '**' ]\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Setup Flutter\n      run: |\n        echo \"Setting up Flutter...\"\n        # Add Flutter setup steps here\n\n    - name: Checkout OneSignal-Flutter-SDK\n      run: |\n        echo \"Checking out OneSignal-Flutter-SDK...\"\n        # Add checkout steps here\n\n    - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n      run: |\n        echo \"Installing dependencies...\"\n        # Add dependency installation steps here\n\n    - name: Static Analysis\n      run: |\n        echo \"Running static analysis...\"\n        # Add static analysis steps here\n\n    - name: Ensure the Dart code is formatted correctly\n      run: |\n        echo \"Ensuring Dart code is formatted correctly...\"\n        # Add formatting check steps here\n\n    - name: Run Flutter unit tests\n      run: |\n        echo \"Running Flutter unit tests...\"\n        # Add unit test execution steps here\n```", "answer": "```yaml name: CI\non:\n  pull_request:\n    branches:\n      - '**'\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '2.10.4'\n          channel: 'stable'\n\n      - name: Checkout OneSignal-Flutter-SDK\n        uses: actions/checkout@v3\n\n      - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n        run: flutter pub get\n\n      - name: Static Analysis\n        run: flutter analyze\n\n      - name: Ensure the Dart code is formatted correctly\n        run: flutter format --set-exit-if-changed --dry-run .\n\n      - name: Run Flutter unit tests\n        run: flutter test\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch whose name matches **. When all the path names of pull_request event match patterns in the paths-ignore filter(.github/**, .vscode/** or README.md), the workflow will not run. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 6 steps. The 1st step is named `Setup Flutter`. The 2nd step is named `Checkout OneSignal-Flutter-SDK`. The 3rd step is named `Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6`. The 4th step is named `Static Analysis`. The 5th step is named `Ensure the Dart code is formatted correctly`. The 6th step is named `Run Flutter unit tests`. "}
{"id": "63c4957b8052faa2781b219f", "level": "level4", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - '**.go'\n  pull_request:\n    branches:\n      - main\n    paths:\n      - '**.go'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Go\n        uses: actions/setup-go@v2\n        with:\n          go-version: '1.17'\n      - name: Build\n        run: go build -v ./...\n      - name: Test\n        run: go test -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - '**.go'\n  pull_request:\n    branches: [ main ]\n    paths:\n      - '**.go'\n\njobs:\n\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: 1.18\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -cover -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(**.go), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. Only if at least one path of pull_request event matches a pattern in the paths filter(**.go), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 4 steps. The 1st step is named ``. The 2nd step is named `Set up Go`. The 3rd step is named `Build`. The 4th step is named `Test`. "}
{"id": "63c495928052faa2781b2bc1", "level": "level4", "llm_response": "```yaml\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Create Release\n        id: create_release\n        run: |\n          echo \"Creating release...\"\n          # Add your release creation logic here\n```", "answer": "```yaml \n# https://github.com/actions/create-release\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    name: Create Release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Create Release\n        id: create_release\n        uses: actions/create-release@latest\n        env:\n          GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: ${{ github.ref }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Create Release` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Create Release` and its job id is `build`. This job will run on ubuntu-latest runner. The job `build` has 2 steps. The 1st step is named `Checkout code`. The 2nd step is named `Create Release` and its id is `create_release`. "}
{"id": "63c496686fc19abdf9c9bea4", "level": "level4", "llm_response": "```yaml\nname: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update release draft\n        run: echo \"This step updates the next repository release\"\n```", "answer": "```yaml name: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.ADMIN_GITHUB_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Drafts/updates the next repository release` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. This job will run on ubuntu-latest runner. The job `update_release_draft` has one step. The 1st step is named ``. "}
{"id": "63c494768052faa2781ab616", "level": "level4", "llm_response": "```yaml\nname: Static analysis\n\non:\n  pull_request:\n\njobs:\n  static-psalm-analysis:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ocp-version: [v20.0.7, v21.0.0, dev-stable22, dev-stable23, dev-master]\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v2\n\n    - name: Set up PHP\n      uses: shivammathur/setup-php@v2\n      with:\n        php-version: '7.4'\n        extensions: pdo_mysql, opcache\n\n    - name: Install dependencies\n      run: composer install --no-interaction --prefer-dist\n\n    - name: Run coding standards check\n      run: vendor/bin/php-cs-fixer fix --dry-run --using-cache=no\n```", "answer": "```yaml name: Static analysis\n\non: [pull_request]\n\njobs:\n  static-psalm-analysis:\n      runs-on: ubuntu-latest\n      strategy:\n          matrix:\n              ocp-version: [ 'v20.0.7', 'v21.0.0', 'dev-stable22', 'dev-stable23', 'dev-master' ]\n      name: Nextcloud ${{ matrix.ocp-version }}\n      steps:\n          - name: Checkout\n            uses: actions/checkout@master\n          - name: Set up php\n            uses: shivammathur/setup-php@master\n            with:\n                php-version: 7.4\n                tools: composer:v1\n                coverage: none\n          - name: Install dependencies\n            run: composer i\n          - name: Install dependencies\n            run: composer require --dev christophwurst/nextcloud:${{ matrix.ocp-version }}\n          - name: Run coding standards check\n            run: composer run psalm\n```", "prompt": "Generate a GitHub Workflow named `Static analysis` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Nextcloud ${{ matrix.ocp-version }}` and its job id is `static-psalm-analysis`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `ocp-version` has 5 values: v20.0.7, v21.0.0, dev-stable22, dev-stable23 and dev-master. The job `static-psalm-analysis` has 5 steps. The 1st step is named `Checkout`. The 2nd step is named `Set up php`. The 3rd step is named `Install dependencies`. The 4th step is named `Install dependencies`. The 5th step is named `Run coding standards check`. "}
{"id": "63c4951f8052faa2781af9e5", "level": "level4", "llm_response": "```yaml\nname: IRC Notification\n\non:\n  push:\n  tag:\n  repository_dispatch:\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - name: irc push\n      run: echo \"Sending IRC notification\"\n```", "answer": "```yaml name: \"IRC Notification\"\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: irc push\n        uses: vmiklos/notify-irc@bfd6f632b683859f6cd074e2ee9db68bef204f7d\n        if: github.event_name == 'push' && github.event.ref == 'refs/heads/master' && github.repository == 'CollaboraOnline/online'\n        with:\n          channel: \"#cool-dev\"\n          nickname: github-online\n          message: |\n            ${{ toJson(github.event) }}\n```", "prompt": "Generate a GitHub Workflow named `IRC Notification` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `test`. This job will run on ubuntu-latest runner. The job `test` has one step. The 1st step is named `irc push`. "}
{"id": "63c493ee7843b612699fde0c", "level": "level4", "llm_response": "```yaml\nname: nf-core AWS test\n\non:\n  workflow_dispatch:\n\njobs:\n  run-tower:\n    runs-on: ubuntu-latest\n    if: github.repository == 'nf-core/mag'\n    steps:\n      - name: Launch workflow via tower\n        run: echo \"Launching AWS tests via Tower\"\n```", "answer": "```yaml name: nf-core AWS test\n# This workflow can be triggered manually with the GitHub actions workflow dispatch button.\n# It runs the -profile 'test' on AWS batch\n\non:\n  workflow_dispatch:\njobs:\n  run-tower:\n    name: Run AWS tests\n    if: github.repository == 'nf-core/mag'\n    runs-on: ubuntu-latest\n    steps:\n      # Launch workflow using Tower CLI tool action\n      - name: Launch workflow via tower\n        uses: nf-core/tower-action@v3\n        with:\n          workspace_id: ${{ secrets.TOWER_WORKSPACE_ID }}\n          access_token: ${{ secrets.TOWER_ACCESS_TOKEN }}\n          compute_env: ${{ secrets.TOWER_COMPUTE_ENV }}\n          workdir: s3://${{ secrets.AWS_S3_BUCKET }}/work/mag/work-${{ github.sha }}\n          parameters: |\n            {\n              \"outdir\": \"s3://${{ secrets.AWS_S3_BUCKET }}/mag/results-test-${{ github.sha }}\"\n            }\n          profiles: test,aws_tower\n```", "prompt": "Generate a GitHub Workflow named `nf-core AWS test` for a GitHub repository whose primary programming language is Nextflow. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Run AWS tests` and its job id is `run-tower`. This job will run only if the condition(github.repository == 'nf-core/mag') is met. This job will run on ubuntu-latest runner. The job `run-tower` has one step. The 1st step is named `Launch workflow via tower`. "}
{"id": "63c496981899db58864d3f73", "level": "level4", "llm_response": "```yaml\nname: Triage tasks\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: triage-${{ github.event.number }}\n  cancel-in-progress: true\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check commit format\n        run: |\n          # Add your commit format check command here\n          echo \"Checking commit format...\"\n\n      - name: Label pull request\n        run: |\n          # Add your label pull request command here\n          echo \"Labeling pull request...\"\n```", "answer": "```yaml name: Triage tasks\n\non: pull_request_target\n\nconcurrency:\n  group: \"triage-${{ github.event.number }}\"\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check commit format\n        uses: Homebrew/actions/check-commit-format@master\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n      - name: Label pull request\n        uses: Homebrew/actions/label-pull-requests@master\n        if: always()\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n          def: |\n            - label: new cask\n              status: added\n              path: Casks/.+\n\n            - label: marked for removal/rejection\n              status: removed\n              path: Casks/.+\n\n            - label: documentation\n              path: (.*\\.md|\\.github/ISSUE_TEMPLATE/.*\\.yml)\n\n            - label: bump-cask-pr\n              pr_body_content: Created with `brew bump-cask-pr`\n\n            - label: missing description\n              path: Casks/.+\n              missing_content: \\n  desc .+\\n\n\n            - label: appcast migration needed\n              path: Casks/.+\n              content: \\n  appcast .+\\n\n```", "prompt": "Generate a GitHub Workflow named `Triage tasks` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the triage-${{ github.event.number }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `triage`. This job will run on ubuntu-latest runner. The job `triage` has 2 steps. The 1st step is named `Check commit format`. The 2nd step is named `Label pull request`. "}
{"id": "63c494a27843b61269a02781", "level": "level4", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 8 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n    steps:\n      - name: Mark stale issues and pull requests\n        run: |\n          gh issue list --state open --label \"stale\" -R your-repo-name --json number | jq -r '.[].number' | xargs -I {} gh issue edit {} --lock\n          gh pr list --state open --label \"stale\" -R your-repo-name --json number | jq -r '.[].number' | xargs -I {} gh pr edit {} --lock\n```", "answer": "```yaml # This workflow warns and then closes issues and PRs that have had no activity for a specified amount of time.\n#\n# You can adjust the behavior by modifying this file.\n# For more information, see:\n# https://github.com/actions/stale\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '16 8 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v5\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        ascending: true\n        stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-pr-message: 'This PR has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-issue-label: 'no-issue-activity'\n        stale-pr-label: 'no-pr-activity'\n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by an event: the scheduled time has come: at 08:16 am. The workflow has one job. The job id of the 1st job is `stale`. This job will run on ubuntu-latest runner. The job `stale` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `stale`. The job `stale` has one step. The 1st step is named ``. "}
{"id": "63c4963d6fc19abdf9c9abf2", "level": "level4", "llm_response": "```yaml\nname: Submit to Web Store\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Cache pnpm modules\n      uses: actions/cache@v2\n      with:\n        path: ~/.pnpm-store\n        key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}\n        restore-keys: |\n          ${{ runner.os }}-pnpm-\n\n    - name: Install dependencies\n      run: pnpm install\n\n    - name: Build and zip extension artifact\n      run: |\n        pnpm run build\n        zip -r extension.zip dist\n\n    - name: Browser Platform Publish\n      uses: webextension-publish-action@v1\n      with:\n        credentials: ${{ secrets.BROWSER_PLATFORM_PUBLISH_CREDENTIALS }}\n        manifest: dist/manifest.json\n        zip: extension.zip\n```", "answer": "```yaml name: \"Submit to Web Store\"\r\non:\r\n  workflow_dispatch:\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Cache pnpm modules\r\n        uses: actions/cache@v3\r\n        with:\r\n          path: ~/.pnpm-store\r\n          key: ${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}\r\n          restore-keys: |\r\n            ${{ runner.os }}-\r\n      - uses: pnpm/action-setup@v2.2.1\r\n        with:\r\n          version: 7.1.0\r\n          run_install: true\r\n      - name: Build and zip extension artifact\r\n        run: pnpm build -- --zip\r\n      - name: Browser Platform Publish\r\n        uses: PlasmoHQ/bpp@v2\r\n        with:\r\n          keys: ${{ secrets.SUBMIT_KEYS }}\r\n          artifact: build/chrome-mv3-prod.zip\r\n```", "prompt": "Generate a GitHub Workflow named `Submit to Web Store` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 5 steps. The 1st step is named ``. The 2nd step is named `Cache pnpm modules`. The 3rd step is named ``. The 4th step is named `Build and zip extension artifact`. The 5th step is named `Browser Platform Publish`. "}
{"id": "63c494a97843b61269a02a50", "level": "level5", "llm_response": "```yaml\nname: pytorch1_7_1-cuda11_0\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu110\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.7.1-cu110\n      develop_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "answer": "```yaml name: pytorch1_7_1-cuda11_0\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu110\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.7.1-cu110\n      develop_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_7_1-cuda11_0` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will call a reusable workflow located at `./.github/workflows/resuable_gpu_build.yml`. The job will pass 7 inputs to the called workflow: the input `cuda_version` is `cu110`, the input `remote_runtime_docker` is `bladedisc:latest-runtime-torch1.7.1-cu110`, the input `develop_base_image` is `nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04`, the input `runtime_base_image` is `nvidia/cuda:11.0.3-cudnn8-devel-ubuntu18.04`, the input `extra_envs` is `-e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.7.1+cu110`, the input `exec_command` is `bash ./scripts/ci/test_pytorch_blade.sh` and the input `deploy_command` is `TORCH_VERSION=1.7.1+cu110 bash ./scripts/ci/deploy_pytorch_blade.sh`. The job will pass 4 secrets to the called workflow: the secret `ALIYUN_DOCKER_USERNAME` is `${{ secrets.ALIYUN_DOCKER_USERNAME }}`, the secret `ALIYUN_DOCKER_PASSWORD` is `${{ secrets.ALIYUN_DOCKER_PASSWORD }}`, the secret `DOCKER_USERNAME` is `${{ secrets.DOCKER_USERNAME }}` and the secret `DOCKER_PASSWORD` is `${{ secrets.DOCKER_PASSWORD }}`. "}
{"id": "63c496986fc19abdf9c9cf90", "level": "level5", "llm_response": "```yaml\nname: Issue Check\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Close Issue\n      if: startsWith(github.event.issue.body, '**Describe the bug**') == false\n      uses: peter-evans/close-issue@v1\n      with:\n        comment: \"Hello, Please use the Github template to report an issue. If this is a feature request, please take a look at the readme. <br/> Thanks, <br/> Ombi Bot\"\n\n    - name: Create comment\n      if: startsWith(github.event.issue.body, '**Describe the bug**') == true\n      uses: peter-evans/create-or-update-comment@v1\n      with:\n        issue-number: ${{ github.event.issue.number }}\n        body: \"Hi!<br/>Thanks for the issue report. Before a real human comes by, please make sure you used our bug report format.<br/>Have you looked at the wiki yet? [https://docs.ombi.app/](https://docs.ombi.app/)<br/>Before posting make sure you also read our [FAQ](https://docs.ombi.app/info/faq/).<br/> Make the title describe your issue. Having 'not working' or 'I get this bug' for 100 issues, isn't really helpful.<br/> If we need more information or there is some progress we tag the issue or update the tag and keep you updated.<br/> Thanks!<br/> Ombi Bot.\"\n```", "answer": "```yaml name: 'Issue Check'\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  issueCheck:\n    runs-on: ubuntu-latest\n    steps:\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == false\n        name: Close Issue\n        uses: peter-evans/close-issue@v1\n        with:\n          comment: |\n            Hello, Please use the Github template to report an issue. If this is a feature request, please take a look at the readme. <br/> Thanks, <br/> Ombi Bot\n\n      - if: startsWith(github.event.issue.body , '**Describe the bug**') == true\n        name: Create comment\n        uses: peter-evans/create-or-update-comment@v1\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            Hi!\n            <br/>Thanks for the issue report. Before a real human comes by, please make sure you used our bug report format.\n            <br/>Have you looked at the wiki yet? https://docs.ombi.app/\n            <br/>Before posting make sure you also read our [FAQ](https://docs.ombi.app/info/faq/).\n            <br/> Make the title describe your issue. Having 'not working' or 'I get this bug' for 100 issues, isn't really helpful.\n            <br/> If we need more information or there is some progress we tag the issue or update the tag and keep you updated.\n            <br/> Thanks!\n            <br/> Ombi Bot.\n```", "prompt": "Generate a GitHub Workflow named `Issue Check` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `issueCheck`. This job will run on ubuntu-latest runner. The job `issueCheck` has 2 steps. The 1st step is named `Close Issue`. This step will run only if the condition(startsWith(github.event.issue.body , '**Describe the bug**') == false) is met. This step runs action `peter-evans/close-issue` tagged as v1. The step defines an input parameter for the action: `comment` is set to `Hello, Please use the Github template to report an issue. If this is a feature request, please take a look at the readme. <br/> Thanks, <br/> Ombi Bot\n`. The 2nd step is named `Create comment`. This step will run only if the condition(startsWith(github.event.issue.body , '**Describe the bug**') == true) is met. This step runs action `peter-evans/create-or-update-comment` tagged as v1. The step defines 2 input parameters for the action: `issue-number` is set to `${{ github.event.issue.number }}` and `body` is set to `Hi!\n<br/>Thanks for the issue report. Before a real human comes by, please make sure you used our bug report format.\n<br/>Have you looked at the wiki yet? https://docs.ombi.app/\n<br/>Before posting make sure you also read our [FAQ](https://docs.ombi.app/info/faq/).\n<br/> Make the title describe your issue. Having 'not working' or 'I get this bug' for 100 issues, isn't really helpful.\n<br/> If we need more information or there is some progress we tag the issue or update the tag and keep you updated.\n<br/> Thanks!\n<br/> Ombi Bot.\n`. "}
{"id": "63c494da7843b61269a03d4f", "level": "level5", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: false\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout \ud83d\udece\ufe0f\n      uses: actions/checkout@v3\n\n    - name: Install \ud83c\udf31\n      run: |\n        sudo apt-get install -y pandoc\n\n    - name: Build \ud83d\udd27\n      run: |\n        ./run build itch\n\n    - name: Deploy \ud83d\ude80\n      uses: JamesIves/github-pages-deploy-action@v4\n      with:\n        folder: build\n```", "answer": "```yaml name: Build and Deploy\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\nenv:\n  BUTLER_API_KEY: ${{ secrets.BUTLER_API_KEY }}\n  ITCHIO_USERNAME: ${{ secrets.ITCHIO_USERNAME }}\n  ITCHIO_GAME: ${{ secrets.ITCHIO_GAME }}\n\njobs:\n  build-and-deploy:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n      - name: Install \ud83c\udf31\n        run: |\n          sudo apt-get install -y pandoc\n      - name: Build \ud83d\udd27\n        run: |\n          ./run build itch\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4\n        with:\n          folder: build\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is GDScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets 3 environment variables to use: `BUTLER_API_KEY` is set to `${{ secrets.BUTLER_API_KEY }}`, `ITCHIO_USERNAME` is set to `${{ secrets.ITCHIO_USERNAME }}` and `ITCHIO_GAME` is set to `${{ secrets.ITCHIO_GAME }}`. The workflow has one job. The job id of the 1st job is `build-and-deploy`. This job will run on ubuntu-latest runner. Only a single job using the ci-${{ github.ref }} concurrency group will run at a time. The job `build-and-deploy` has 4 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Install \ud83c\udf31`. This step runs a script: `sudo apt-get install -y pandoc\n`. The 3rd step is named `Build \ud83d\udd27`. This step runs a script: `./run build itch\n`. The 4th step is named `Deploy \ud83d\ude80`. This step runs action `JamesIves/github-pages-deploy-action` tagged as v4. The step defines an input parameter for the action: `folder` is set to `build`. "}
{"id": "63c4968933b087f6bde2ca3a", "level": "level5", "llm_response": "```yaml\nname: Nightly Smoketest\n\non:\n  schedule:\n    - cron: '0 3 * * 1-5'\n  workflow_dispatch:\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        NODE_VERSION: [1.19.16, 1.20.15, 1.21.9, 1.22.6, 1.23.3]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Mount bazel cache\n      uses: actions/cache@v3\n      with:\n        path: ~/.cache/bazel\n        key: bazel\n\n    - name: Bank Workload\n      env:\n        NODE_VERSION: ${{ matrix.NODE_VERSION }}\n      run: make test/smoketest\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# This workflow tests that we can stand up a CRDB cluster with the operator and execute SQL in the cluster. It uses the\n# steps that are outlined in our public docs to ensure that the flow we're recommending always works.\nname: Nightly Smoketest\n\non:\n  schedule:\n    # runs at 3am UTC Mon-Fri\n    # ref: <min> <hr> <month-day> <month> <weekday>\n    - cron: '0 3 * * 1-5'\n\n  # allows running from the actions tab in GitHub\n  workflow_dispatch: ~\n\njobs:\n  smoketest:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        # supported Kubenetes versions\n        NODE_VERSION: [1.19.16, 1.20.15, 1.21.9, 1.22.6, 1.23.3]\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: Bank Workload\n        env:\n          NODE_VERSION: ${{ matrix.NODE_VERSION }}\n        run: make test/smoketest\n```", "prompt": "Generate a GitHub Workflow named `Nightly Smoketest` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am, monday through friday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `smoketest`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `NODE_VERSION` has 5 values: 1.19.16, 1.20.15, 1.21.9, 1.22.6 and 1.23.3. The job `smoketest` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Mount bazel cache`. This step runs action `actions/cache` tagged as v3. The step defines 2 input parameters for the action: `path` is set to `~/.cache/bazel` and `key` is set to `bazel`. The 3rd step is named `Bank Workload`. The step sets an environment variable to use: `NODE_VERSION` is set to `${{ matrix.NODE_VERSION }}`. This step runs a script: `make test/smoketest`. "}
{"id": "63c496686fc19abdf9c9be9c", "level": "level5", "llm_response": "```yaml\nname: Unit testing (Ubuntu)\n\non:\n  push:\n    branches:\n      - main\n      - ver_*\n      - dev\n    paths:\n      - '**.py'\n  pull_request:\n    branches:\n      - main\n      - ver_*\n      - dev\n    paths:\n      - '**.py'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.6, 3.7, 3.8, 3.9, 3.10]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        python -m pip install pytest coverage\n        pip install -r requirements.txt\n\n    - name: Test with pytest\n      env:\n        DEBUG_API_ID: ${{ secrets.DEBUG_API_ID }}\n        DEBUG_API_SECRET: ${{ secrets.DEBUG_API_SECRET }}\n        CROSS_DEBUG_KEY: ${{ secrets.CROSS_DEBUG_KEY }}\n        CROSS_DEBUG_SECRET: ${{ secrets.CROSS_DEBUG_SECRET }}\n      run: |\n        coverage run --source=src --omit=src/falconpy/debug.py -m pytest -s --ignore-glob=**/manual/*\n        coverage report\n```", "answer": "```yaml name: Unit testing (Ubuntu)\non:\n  push:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n  pull_request:\n    paths:\n      - '**.py'\n    branches: \n      - main\n      - 'ver_*'\n      - dev\n\njobs:\n  build:\n    strategy:\n      matrix:\n        # os: [macos-latest, windows-latest, ubuntu-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10']  # , '3.11-dev'\n    # runs-on: ${{ matrix.os }}\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        python -m pip install pytest coverage\n        pip install -r requirements.txt\n    - name: Test with pytest\n      env:\n        DEBUG_API_ID: ${{ secrets.DEBUG_API_ID }}\n        DEBUG_API_SECRET: ${{ secrets.DEBUG_API_SECRET }}\n        CROSS_DEBUG_KEY: ${{ secrets.CROSS_DEBUG_KEY }}\n        CROSS_DEBUG_SECRET: ${{ secrets.CROSS_DEBUG_SECRET }}\n      run: |\n        coverage run --source=src --omit=src/falconpy/debug.py -m pytest -s --ignore-glob=**/manual/*\n        coverage report\n```", "prompt": "Generate a GitHub Workflow named `Unit testing (Ubuntu)` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of push event matches a pattern in the paths filter(**.py), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main, a branch whose name matches ver_* or a branch named dev. Only if at least one path of pull_request event matches a pattern in the paths filter(**.py), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `python-version` has 5 values: 3.6, 3.7, 3.8, 3.9 and 3.10. The job `build` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Python ${{ matrix.python-version }}`. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `${{ matrix.python-version }}`. The 3rd step is named `Install dependencies`. This step runs a script: `python -m pip install --upgrade pip\npython -m pip install pytest coverage\npip install -r requirements.txt\n`. The 4th step is named `Test with pytest`. The step sets 4 environment variables to use: `DEBUG_API_ID` is set to `${{ secrets.DEBUG_API_ID }}`, `DEBUG_API_SECRET` is set to `${{ secrets.DEBUG_API_SECRET }}`, `CROSS_DEBUG_KEY` is set to `${{ secrets.CROSS_DEBUG_KEY }}` and `CROSS_DEBUG_SECRET` is set to `${{ secrets.CROSS_DEBUG_SECRET }}`. This step runs a script: `coverage run --source=src --omit=src/falconpy/debug.py -m pytest -s --ignore-glob=**/manual/*\ncoverage report\n`. "}
{"id": "63c49698b008460c1df15628", "level": "level5", "llm_response": "```yaml\nname: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\npermissions:\n  contents: read\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\njobs:\n  add_to_gh_projects:\n    id: add_to_gh_projects\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Add labeled issues to GH projects\n        uses: gradle/build-tool-issue-automation-actions/add-labeled-issues@v1\n```", "answer": "```yaml name: add-to-gh-projects\n\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [opened, labeled]\n\nenv:\n  GITHUB_TOKEN: ${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}\n\npermissions:\n  contents: read\n\njobs:\n  add_to_gh_projects:\n    name: Adds issues to GH projects\n    runs-on: ubuntu-latest\n    steps:\n      - name: Add labeled issues to GH projects\n        uses: gradle/build-tool-issue-automation-actions/add-labeled-issues@v1\n```", "prompt": "Generate a GitHub Workflow named `add-to-gh-projects` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by multiple events: 1) an issue is opened or a label is added to an issue. 2) a pull request is created or a label is added to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.BOT_GRADLE_GH_ORG_BOARD_ACCESS_TOKEN }}`. The workflow has one job. The 1st job is named `Adds issues to GH projects` and its job id is `add_to_gh_projects`. This job will run on ubuntu-latest runner. The job `add_to_gh_projects` has one step. The 1st step is named `Add labeled issues to GH projects`. This step runs action `gradle/build-tool-issue-automation-actions/add-labeled-issues` tagged as v1. "}
{"id": "63c494f67843b61269a0479e", "level": "level5", "llm_response": "```yaml\nname: Sync-To-Gitlab\n\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request:\n    branches:\n      - master\n      - master-template\n    types:\n      - closed\n  workflow_dispatch:\n\njobs:\n  sync:\n    id: sync\n    runs-on: ubuntu-latest\n    concurrency: ${{ github.workflow }}-${{ github.ref_name }}\n    if: github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch'\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Mirror\n        env:\n          input_git_config_user_name: ${{ secrets.GITLAB_USERNAME }}\n          input_git_config_user_email: ${{ secrets.GITLAB_EMAIL }}\n          input_git_remote_url: ${{ secrets.GITLAB_URL }}\n          input_git_push_options: --force\n        run: |\n          git config --global user.name \"${{ env.input_git_config_user_name }}\"\n          git config --global user.email \"${{ env.input_git_config_user_email }}\"\n          git clone \"https://github.com/${{ github.repository }}.git\" \"git\"\n          cd git\n          git remote set-url origin \"${{ env.input_git_remote_url }}\"\n          git push ${{ env.input_git_push_options }} origin ${{ github.ref_name }}:${{ github.ref_name }}\n```", "answer": "```yaml name: Sync-To-Gitlab\nrun-name: Sync-To-Gitlab ${{ github.sha }}\non:\n  push:\n    branches:\n      - master\n      - master-template\n  pull_request_target:\n    types:\n      - closed\n    branches:\n      - master\n      - master-template\n  workflow_dispatch:\n\n\njobs:\n  sync:\n    concurrency:\n      group: ${{ github.workflow }}-${{ github.ref_name }}\n      cancel-in-progress: true\n    name: \"Sync To Gitlab\"\n    if: github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Mirror\n        env:\n          input_git_config_user_name: ${{ secrets.GITLAB_USERNAME }}\n          input_git_config_user_email: ${{ secrets.GITLAB_EMAIL }}\n          input_git_remote_url: ${{ secrets.GITLAB_URL }}\n          input_git_push_options: --force\n        run: |\n          git config --global user.name \"${{ env.input_git_config_user_name }}\"\n          git config --global user.email \"${{ env.input_git_config_user_email }}\"\n          git clone \"https://github.com/${{ github.repository }}.git\" \"git\"\n          cd git\n          git remote set-url origin \"${{ env.input_git_remote_url }}\"\n          git push ${{ env.input_git_push_options }} origin ${{ github.ref_name }}:${{ github.ref_name }}\n#      - name: Mirror + trigger CI\n#        uses: SvanBoxel/gitlab-mirror-and-ci-action@master\n#        with:\n#          args: \"https://gitlab.com/Zerek-Cheng/Simple-Assets-Platform\"\n#        env:\n#          FORCE_PUSH: \"true\"\n#          GITLAB_HOSTNAME: \"gitlab.com\"\n#          GITLAB_USERNAME: \"Zerek-Cheng\"\n#          GITLAB_PASSWORD: ${{ secrets.GITLAB_PASSWORD }}\n#          GITLAB_PROJECT_ID: \"40146411\"\n#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Sync-To-Gitlab` for a GitHub repository whose primary programming language is Java. The name for workflow runs is set to `Sync-To-Gitlab ${{ github.sha }}`. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named master-template. 2) a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named master-template. 3) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Sync To Gitlab` and its job id is `sync`. This job will run only if the condition(github.event.pull_request.merged == true || github.event_name == 'push' || github.event_name == 'workflow_dispatch') is met. This job will run on ubuntu-latest runner. Only a single job using the ${{ github.workflow }}-${{ github.ref_name }} concurrency group will run at a time. When this job is queued, any currently running job in the same concurrency group will be canceled. The job `sync` has 2 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Mirror`. The step sets 4 environment variables to use: `input_git_config_user_name` is set to `${{ secrets.GITLAB_USERNAME }}`, `input_git_config_user_email` is set to `${{ secrets.GITLAB_EMAIL }}`, `input_git_remote_url` is set to `${{ secrets.GITLAB_URL }}` and `input_git_push_options` is set to `--force`. This step runs a script: `git config --global user.name \"${{ env.input_git_config_user_name }}\"\ngit config --global user.email \"${{ env.input_git_config_user_email }}\"\ngit clone \"https://github.com/${{ github.repository }}.git\" \"git\"\ncd git\ngit remote set-url origin \"${{ env.input_git_remote_url }}\"\ngit push ${{ env.input_git_push_options }} origin ${{ github.ref_name }}:${{ github.ref_name }}\n`. "}
{"id": "63c496561899db58864d23de", "level": "level5", "llm_response": "```yaml\nname: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  sqlite:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: sqlite\n```", "answer": "```yaml name: Molecule - Sqlite\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.sqlite.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/sqlite/**\n      - roles/sqlite/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  sqlite:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: sqlite\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Sqlite` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.sqlite.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/sqlite/** or roles/sqlite/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `sqlite`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 2 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}` and the input `scenario` is `sqlite`. "}
{"id": "63c494078052faa2781a8a1f", "level": "level5", "llm_response": "```yaml\nname: CLA Assistant\n\non:\n  issue_comment:\n    types: [created]\n  pull_request:\n    types: [opened, closed, synchronize]\n  pull_request_target:\n    types: [opened, closed, synchronize]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n    if: |\n      (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') ||\n      github.event_name == 'pull_request_target'\n    steps:\n      - name: CLA Assistant\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        uses: cla-assistant/github-action@v2.1.3-beta\n        with:\n          path-to-signatures: .cla/v1/signatures.json\n          path-to-document: https://github.com/christian-schlichtherle/truelicense/blob/develop/CLA.md\n          branch: develop\n          allowlist: bot*\n```", "answer": "```yaml name: \"CLA Assistant\"\non:\n  issue_comment:\n    types: [ created ]\n  pull_request_target:\n    types: [ opened,closed,synchronize ]\n\njobs:\n  CLAssistant:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        uses: cla-assistant/github-action@v2.1.3-beta\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # the below token should have repo scope and must be manually added by you in the repository's secret\n          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: '.cla/v1/signatures.json'\n          path-to-document: 'https://github.com/christian-schlichtherle/truelicense/blob/develop/CLA.md'\n          branch: 'develop'\n          allowlist: bot*\n\n          #below are the optional inputs - If the optional inputs are not given, then default values will be taken\n          #remote-organization-name: enter the remote organization name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #remote-repository-name:  enter the  remote repository name where the signatures should be stored (Default is storing the signatures in the same repository)\n          #create-file-commit-message: 'For example: Creating file for storing CLA Signatures'\n          #signed-commit-message: 'For example: $contributorName has signed the CLA in #$pullRequestNo'\n          #custom-notsigned-prcomment: 'pull request comment with Introductory message to ask new contributors to sign'\n          #custom-pr-sign-comment: 'The signature to be committed in order to sign the CLA'\n          #custom-allsigned-prcomment: 'pull request comment when all contributors has signed, defaults to **CLA Assistant Lite bot** All Contributors have signed the CLA.'\n          #lock-pullrequest-aftermerge: false - if you don't want this bot to automatically lock the pull request after merging (default - true)\n          #use-dco-flag: true - If you are using DCO instead of CLA\n```", "prompt": "Generate a GitHub Workflow named `CLA Assistant` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `CLAssistant`. This job will run on ubuntu-latest runner. The job `CLAssistant` has one step. The 1st step is named `CLA Assistant`. This step will run only if the condition((github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target') is met. The step sets 2 environment variables to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}` and `PERSONAL_ACCESS_TOKEN` is set to `${{ secrets.PERSONAL_ACCESS_TOKEN }}`. This step runs action `cla-assistant/github-action` tagged as v2.1.3-beta. The step defines 4 input parameters for the action: `path-to-signatures` is set to `.cla/v1/signatures.json`, `path-to-document` is set to `https://github.com/christian-schlichtherle/truelicense/blob/develop/CLA.md`, `branch` is set to `develop` and `allowlist` is set to `bot*`. "}
{"id": "63c494298052faa2781a98f8", "level": "level5", "llm_response": "```yaml\nname: Linux build with address sanitizer enabled\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Compiler version\n      run: gcc --version\n\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"gcc\" CXX=\"g++\" CXXFLAGS=\"-O2 -g0 -fsanitize=address,undefined -fno-sanitize-recover=all -fno-omit-frame-pointer -Wall -Wno-unknown-pragmas -Werror\"\n        make -j 2\n\n    - name: Run tests\n      run: ./test-suite/quantlib-test-suite --log_level=message\n\n    - name: Run examples\n      run: make check-examples\n```", "answer": "```yaml name: Linux build with address sanitizer enabled\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\njobs:\n  sanitize:\n    runs-on: ubuntu-latest\n    container: ghcr.io/lballabio/quantlib-devenv:rolling\n    steps:\n    - uses: actions/checkout@v3\n    - name: Compiler version\n      run: |\n        gcc --version\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"gcc\" CXX=\"g++\" CXXFLAGS=\"-O2 -g0 -fsanitize=address,undefined -fno-sanitize-recover=all -fno-omit-frame-pointer -Wall -Wno-unknown-pragmas -Werror\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --log_level=message\n    - name: Run examples\n      run: |\n        make check-examples\n```", "prompt": "Generate a GitHub Workflow named `Linux build with address sanitizer enabled` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `sanitize`. This job will run on ubuntu-latest runner. The job creates a Docker container that uses `ghcr.io/lballabio/quantlib-devenv:rolling` image. The job `sanitize` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Compiler version`. This step runs a script: `gcc --version\n`. The 3rd step is named `Build`. This step runs a script: `./autogen.sh\n./configure --disable-static CC=\"gcc\" CXX=\"g++\" CXXFLAGS=\"-O2 -g0 -fsanitize=address,undefined -fno-sanitize-recover=all -fno-omit-frame-pointer -Wall -Wno-unknown-pragmas -Werror\"\nmake -j 2\n`. The 4th step is named `Run tests`. This step runs a script: `./test-suite/quantlib-test-suite --log_level=message\n`. The 5th step is named `Run examples`. This step runs a script: `make check-examples\n`. "}
{"id": "63c493cd7843b612699fd710", "level": "level5", "llm_response": "```yaml\nname: Clean\n\non:\n  push:\n    branches: [ '*' ]\n  release:\n    types: [ 'created' ]\n  repository_dispatch:\n\njobs:\n  delete-artifacts:\n    id: delete-artifacts\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Delete artifacts\n        run: |\n          REPO=${GITHUB_API_URL}/repos/${{ github.repository }}\n\n          ghapi() { curl --silent --location --user _:$GITHUB_TOKEN \"$@\"; }\n\n          TMPFILE=/tmp/tmp.$$\n\n          declare -A ARTCOUNT\n\n          URL=$REPO/actions/artifacts\n          while [[ -n \"$URL\" ]]; do\n            JSON=$(ghapi --dump-header $TMPFILE \"$URL\")\n            URL=$(grep '^Link:' \"$TMPFILE\" | tr ',' '\\n' | grep 'rel=\"next\"' | head -1 | sed -e 's/.*<//' -e 's/>.*//')\n            rm -f $TMPFILE\n\n            COUNT=$(( $(jq <<<$JSON -r '.artifacts | length') ))\n\n            for ((i=0; $i < $COUNT; i++)); do\n              name=$(jq <<<$JSON -r \".artifacts[$i].name?\")\n              ARTCOUNT[$name]=$(( $(( ${ARTCOUNT[$name]} )) + 1))\n\n              id=$(jq <<<$JSON -r \".artifacts[$i].id?\")\n              size=$(( $(jq <<<$JSON -r \".artifacts[$i].size_in_bytes?\") ))\n              printf \"Deleting '%s' #%d, %'d bytes\\n\" $name ${ARTCOUNT[$name]} $size\n              ghapi -X DELETE $REPO/actions/artifacts/$id\n            done\n          done\n```", "answer": "```yaml # This file was automatically generated by sbt-github-actions using the\n# githubWorkflowGenerate task. You should add and commit this file to\n# your git repository. It goes without saying that you shouldn't edit\n# this file by hand! Instead, if you wish to make changes, you should\n# change your sbt build configuration to revise the workflow description\n# to meet your needs, then regenerate this file.\n\nname: Clean\n\non: push\n\njobs:\n  delete-artifacts:\n    name: Delete Artifacts\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Delete artifacts\n        run: |\n          # Customize those three lines with your repository and credentials:\n          REPO=${GITHUB_API_URL}/repos/${{ github.repository }}\n\n          # A shortcut to call GitHub API.\n          ghapi() { curl --silent --location --user _:$GITHUB_TOKEN \"$@\"; }\n\n          # A temporary file which receives HTTP response headers.\n          TMPFILE=/tmp/tmp.$$\n\n          # An associative array, key: artifact name, value: number of artifacts of that name.\n          declare -A ARTCOUNT\n\n          # Process all artifacts on this repository, loop on returned \"pages\".\n          URL=$REPO/actions/artifacts\n          while [[ -n \"$URL\" ]]; do\n\n            # Get current page, get response headers in a temporary file.\n            JSON=$(ghapi --dump-header $TMPFILE \"$URL\")\n\n            # Get URL of next page. Will be empty if we are at the last page.\n            URL=$(grep '^Link:' \"$TMPFILE\" | tr ',' '\\n' | grep 'rel=\"next\"' | head -1 | sed -e 's/.*<//' -e 's/>.*//')\n            rm -f $TMPFILE\n\n            # Number of artifacts on this page:\n            COUNT=$(( $(jq <<<$JSON -r '.artifacts | length') ))\n\n            # Loop on all artifacts on this page.\n            for ((i=0; $i < $COUNT; i++)); do\n\n              # Get name of artifact and count instances of this name.\n              name=$(jq <<<$JSON -r \".artifacts[$i].name?\")\n              ARTCOUNT[$name]=$(( $(( ${ARTCOUNT[$name]} )) + 1))\n\n              id=$(jq <<<$JSON -r \".artifacts[$i].id?\")\n              size=$(( $(jq <<<$JSON -r \".artifacts[$i].size_in_bytes?\") ))\n              printf \"Deleting '%s' #%d, %'d bytes\\n\" $name ${ARTCOUNT[$name]} $size\n              ghapi -X DELETE $REPO/actions/artifacts/$id\n            done\n          done\n```", "prompt": "Generate a GitHub Workflow named `Clean` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The 1st job is named `Delete Artifacts` and its job id is `delete-artifacts`. This job will run on ubuntu-latest runner. The job sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. The job `delete-artifacts` has one step. The 1st step is named `Delete artifacts`. This step runs a script: `# Customize those three lines with your repository and credentials:\nREPO=${GITHUB_API_URL}/repos/${{ github.repository }}\n\n# A shortcut to call GitHub API.\nghapi() { curl --silent --location --user _:$GITHUB_TOKEN \"$@\"; }\n\n# A temporary file which receives HTTP response headers.\nTMPFILE=/tmp/tmp.$$\n\n# An associative array, key: artifact name, value: number of artifacts of that name.\ndeclare -A ARTCOUNT\n\n# Process all artifacts on this repository, loop on returned \"pages\".\nURL=$REPO/actions/artifacts\nwhile [[ -n \"$URL\" ]]; do\n\n  # Get current page, get response headers in a temporary file.\n  JSON=$(ghapi --dump-header $TMPFILE \"$URL\")\n\n  # Get URL of next page. Will be empty if we are at the last page.\n  URL=$(grep '^Link:' \"$TMPFILE\" | tr ',' '\\n' | grep 'rel=\"next\"' | head -1 | sed -e 's/.*<//' -e 's/>.*//')\n  rm -f $TMPFILE\n\n  # Number of artifacts on this page:\n  COUNT=$(( $(jq <<<$JSON -r '.artifacts | length') ))\n\n  # Loop on all artifacts on this page.\n  for ((i=0; $i < $COUNT; i++)); do\n\n    # Get name of artifact and count instances of this name.\n    name=$(jq <<<$JSON -r \".artifacts[$i].name?\")\n    ARTCOUNT[$name]=$(( $(( ${ARTCOUNT[$name]} )) + 1))\n\n    id=$(jq <<<$JSON -r \".artifacts[$i].id?\")\n    size=$(( $(jq <<<$JSON -r \".artifacts[$i].size_in_bytes?\") ))\n    printf \"Deleting '%s' #%d, %'d bytes\\n\" $name ${ARTCOUNT[$name]} $size\n    ghapi -X DELETE $REPO/actions/artifacts/$id\n  done\ndone\n`. "}
{"id": "63c494167843b612699fee3f", "level": "level5", "llm_response": "```yaml\nname: Dead Link Check\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n    if: github.repository == 'apache/incubator-linkis'\n    timeout-minutes: 30\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Check for dead links\n      uses: gaurav-nelson/github-action-markdown-link-check@v1\n      with:\n        use-quiet-mode: 'no'\n        use-verbose-mode: 'yes'\n        folder-path: '../'\n        config-file: '.github/workflows/dlc.json'\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\n\nname: Dead Link Check\n\non: [push, pull_request]\n\njobs:\n  dead-links-check:\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    if: (github.repository == 'apache/incubator-linkis')\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gaurav-nelson/github-action-markdown-link-check@v1\n        with:\n          use-quiet-mode: 'no'\n          use-verbose-mode: 'yes'\n          folder-path: '../'\n          config-file: '.github/workflows/dlc.json'\n```", "prompt": "Generate a GitHub Workflow named `Dead Link Check` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `dead-links-check`. This job will run only if the condition((github.repository == 'apache/incubator-linkis')) is met. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 30. The job `dead-links-check` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `gaurav-nelson/github-action-markdown-link-check` tagged as v1. The step defines 4 input parameters for the action: `use-quiet-mode` is set to `no`, `use-verbose-mode` is set to `yes`, `folder-path` is set to `../` and `config-file` is set to `.github/workflows/dlc.json`. "}
{"id": "63c4964b33b087f6bde2aead", "level": "level5", "llm_response": "```yaml\nname: Build release\n\non:\n  push:\n    tags:\n      - 'v**'\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: ''\n      uses: actions/checkout@v3\n\n    - name: Set up JDK 11\n      uses: actions/setup-java@v3\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n        cache: 'gradle'\n\n    - name: Set up ruby env\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: '2.7.2'\n        bundler-cache: true\n\n    - name: Decode Service Account Key JSON File\n      id: service_account_json_file\n      uses: timheuer/base64-to-file@v1\n      with:\n        fileName: 'serviceAccount.json'\n        encodedString: ${{ secrets.GOOGLE_JSON }}\n\n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n\n    - name: Create local properties\n      run: touch local.properties\n\n    - name: Create maps api key\n      run: echo \"MAPS_API_KEY=${{ secrets.MAPS_API_KEY }}\" > secrets.properties\n\n    - name: Decode Keystore\n      env:\n        ENCODED_STRING: ${{ secrets.KEYSTORE }}\n      run: |\n        mkdir app/keystore\n        echo $ENCODED_STRING | base64 -di > app/keystore/keystore.jks\n\n    - name: Decode Google Services json\n      env:\n        ENCODED_STRING: ${{ secrets.GOOGLE_SERVICES }}\n      run: echo $ENCODED_STRING | base64 -di > app/google-services.json\n\n    - name: Build & deploy Android release\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n        ANDROID_JSON_KEY_FILE: ${{ steps.service_account_json_file.outputs.filePath }}\n      run: bundle exec fastlane android deploy\n```", "answer": "```yaml name: Build release\n\non:\n  push:\n    tags:\n      - v**\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: set up JDK 11\n      uses: actions/setup-java@v3\n      with:\n        java-version: '11'\n        distribution: 'adopt'\n        cache: gradle\n\n    - name: Set up ruby env\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: 2.7.2\n        bundler-cache: true\n\n    - name: Decode Service Account Key JSON File\n      uses: timheuer/base64-to-file@v1\n      id: service_account_json_file\n      with:\n        fileName: \"serviceAccount.json\"\n        encodedString: ${{ secrets.GOOGLE_JSON }}\n\n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n\n    - name: Create local properties\n      run: touch local.properties\n\n    - name: Create maps api key\n      run: echo \"MAPS_API_KEY=${{ secrets.MAPS_API_KEY }}\" > secrets.properties\n\n    - name: Decode Keystore\n      env:\n        ENCODED_STRING: ${{ secrets.KEYSTORE }}\n      run: |\n        mkdir app/keystore\n        echo $ENCODED_STRING | base64 -di > app/keystore/keystore.jks\n    - name: Decode Google Services json\n      env:\n        ENCODED_STRING: ${{ secrets.GOOGLE_SERVICES }}\n      run: |\n        echo $ENCODED_STRING | base64 -di > app/google-services.json\n        \n\n    - name: Build & deploy Android release\n      run: bundle exec fastlane android deploy\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n        ANDROID_JSON_KEY_FILE: ${{ steps.service_account_json_file.outputs.filePath }}\n\n#    - name: Build with Gradle\n#      run: ./gradlew app:bundleRelease\n#      env:\n#        KEYSTORE_PASS: ${{ secrets.KEYSTORE_PASS }}\n#        KEYSTORE_ALIAS: ${{ secrets.KEYSTORE_ALIAS }}\n#        MAPBOX_DOWNLOADS_TOKEN: ${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}\n#\n#    - name: Archive release bundle\n#      uses: actions/upload-artifact@v3\n#      with:\n#        name: bundle\n#        path: |\n#          app/build/outputs/bundle/release\n```", "prompt": "Generate a GitHub Workflow named `Build release` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v**. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 10 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `set up JDK 11`. This step runs action `actions/setup-java` tagged as v3. The step defines 3 input parameters for the action: `java-version` is set to `11`, `distribution` is set to `adopt` and `cache` is set to `gradle`. The 3rd step is named `Set up ruby env`. This step runs action `ruby/setup-ruby` tagged as v1. The step defines 2 input parameters for the action: `ruby-version` is set to `2.7.2` and `bundler-cache` is set to `True`. The 4th step is named `Decode Service Account Key JSON File` and its id is `service_account_json_file`. This step runs action `timheuer/base64-to-file` tagged as v1. The step defines 2 input parameters for the action: `fileName` is set to `serviceAccount.json` and `encodedString` is set to `${{ secrets.GOOGLE_JSON }}`. The 5th step is named `Grant execute permission for gradlew`. This step runs a script: `chmod +x gradlew`. The 6th step is named `Create local properties`. This step runs a script: `touch local.properties`. The 7th step is named `Create maps api key`. This step runs a script: `echo \"MAPS_API_KEY=${{ secrets.MAPS_API_KEY }}\" > secrets.properties`. The 8th step is named `Decode Keystore`. The step sets an environment variable to use: `ENCODED_STRING` is set to `${{ secrets.KEYSTORE }}`. This step runs a script: `mkdir app/keystore\necho $ENCODED_STRING | base64 -di > app/keystore/keystore.jks\n`. The 9th step is named `Decode Google Services json`. The step sets an environment variable to use: `ENCODED_STRING` is set to `${{ secrets.GOOGLE_SERVICES }}`. This step runs a script: `echo $ENCODED_STRING | base64 -di > app/google-services.json\n`. The 10th step is named `Build & deploy Android release`. The step sets 5 environment variables to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`, `KEYSTORE_PASS` is set to `${{ secrets.KEYSTORE_PASS }}`, `KEYSTORE_ALIAS` is set to `${{ secrets.KEYSTORE_ALIAS }}`, `MAPBOX_DOWNLOADS_TOKEN` is set to `${{ secrets.MAPBOX_DOWNLOADS_TOKEN }}` and `ANDROID_JSON_KEY_FILE` is set to `${{ steps.service_account_json_file.outputs.filePath }}`. This step runs a script: `bundle exec fastlane android deploy`. "}
{"id": "63c4956e8052faa2781b1ca5", "level": "level5", "llm_response": "```yaml\nname: Conventional PR\n\non:\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: semantic-pull-request\n        uses: amannn/action-semantic-pull-request@b7a9a97cb10fa6e1ae02647e718798175f6b1f1d\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          types: None\n          validateSingleCommit: True\n```", "answer": "```yaml name: Conventional PR\n\n# Controls when the action will run. \non:\n  pull_request:\n    branches:\n    - develop\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called \"build\"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n      - name: semantic-pull-request\n        # Internal Unity mirror available at jesseo/action-semantic-pull-request, but actions from private repos aren't supported, so continue to use the public one below\n        uses: amannn/action-semantic-pull-request@b7a9a97cb10fa6e1ae02647e718798175f6b1f1d\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          # Provide custom types if you don't want the default ones from https://www.conventionalcommits.org\n          types: # optional\n          # Configure which scopes are allowed.\n          #scopes: # optional\n          # Configure that a scope must always be provided.\n          #requireScope: # optional\n          # Configure additional validation for the subject based on a regex. E.g. '^(?![A-Z]).+$' ensures the subject doesn't start with an uppercase character.\n          #subjectPattern: # optional\n          # If `subjectPattern` is configured, you can use this property to override the default error message that is shown when the pattern doesn't match. The variables `subject` and `title` can be used within the message.\n          #subjectPatternError: # optional\n          # For work-in-progress PRs you can typically use draft pull requests from Github. However, private repositories on the free plan don't have this option and therefore this action allows you to opt-in to using the special '[WIP]' prefix to indicate this state. This will avoid the validation of the PR title and the pull request checks remain pending. Note that a second check will be reported if this is enabled.\n          #wip: # optional\n          # When using \"Squash and merge\" on a PR with only one commit, GitHub will suggest using that commit message instead of the PR title for the merge commit, and it's easy to commit this by mistake. Enable this option to also validate the commit message for one commit PRs.\n          validateSingleCommit: true # optional\n```", "prompt": "Generate a GitHub Workflow named `Conventional PR` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has one step. The 1st step is named `semantic-pull-request`. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `amannn/action-semantic-pull-request` whose commit is b7a9a97cb10fa6e1ae02647e718798175f6b1f1d. The step defines 2 input parameters for the action: `types` is set to `None` and `validateSingleCommit` is set to `True`. "}
{"id": "63c4965b33b087f6bde2b689", "level": "level5", "llm_response": "```yaml\nname: fortran-format-check\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  fortran-format-check:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash -l {0}\n    steps:\n      - name: ''\n        uses: actions/checkout@v2.3.4\n      - name: Install Conda environment from environment.yml\n        uses: mamba-org/provision-with-micromamba@main\n        with:\n          cache-downloads: true\n          cache-env: true\n      - name: Install gfortran\n        uses: modflowpy/install-gfortran-action@v1\n      - name: Print python package versions\n        run: pip list\n      - name: Set and print branch name\n        run: .github/common/git-branch-export.sh\n      - name: Fortran source format check\n        run: .github/common/fortran-format-check.sh\n```", "answer": "```yaml name: fortran-format-check\n\non:\n  push:\n    branches: [ master, develop ]\n  pull_request:\n    branches: [ develop ]\n\njobs:\n  fortan-format-check:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash -l {0}\n\n    steps:\n      - uses: actions/checkout@v2.3.4\n\n      - name: Install Conda environment from environment.yml\n        uses: mamba-org/provision-with-micromamba@main\n        with:\n            cache-downloads: true\n            cache-env: true\n\n      - name: Install gfortran\n        uses: modflowpy/install-gfortran-action@v1\n\n      - name: Print python package versions\n        run: |\n          pip list\n\n      - name: Set and print branch name\n        run: |\n          .github/common/git-branch-export.sh\n\n      - name: Fortran source format check\n        run: |\n          .github/common/fortran-format-check.sh\n```", "prompt": "Generate a GitHub Workflow named `fortran-format-check` for a GitHub repository whose primary programming language is Fortran. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named develop. The workflow has one job. The job id of the 1st job is `fortan-format-check`. This job will run on ubuntu-latest runner. For all run steps in the job, default shell is set to bash -l {0}. The job `fortan-format-check` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v2.3.4. The 2nd step is named `Install Conda environment from environment.yml`. This step runs action `mamba-org/provision-with-micromamba` from the main branch. The step defines 2 input parameters for the action: `cache-downloads` is set to `True` and `cache-env` is set to `True`. The 3rd step is named `Install gfortran`. This step runs action `modflowpy/install-gfortran-action` tagged as v1. The 4th step is named `Print python package versions`. This step runs a script: `pip list\n`. The 5th step is named `Set and print branch name`. This step runs a script: `.github/common/git-branch-export.sh\n`. The 6th step is named `Fortran source format check`. This step runs a script: `.github/common/fortran-format-check.sh\n`. "}
{"id": "63c494c88052faa2781ad4bd", "level": "level5", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - develop\n    tags:\n      - '*'\n  pull_request:\n    branches:\n      - develop\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ros_distro: [melodic, noetic]\n        node_version: [14]\n\n    if: github.actor != 'RWT-bot'\n\n    steps:\n      - name: Set TOKEN environment variable\n        run: echo \"TOKEN=${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' && secrets.RWT_BOT_PAT || github.token }}\" >> $GITHUB_ENV\n\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          token: ${{ env.TOKEN }}\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node_version }}\n\n      - name: Own /github/home\n        run: chown -hR $(whoami):$(whoami) /github/home\n\n      - name: Install apt dependencies\n        run: |\n          apt-get update\n          apt-get install -y firefox ros-$ROS_DISTRO-rosbridge-server ros-$ROS_DISTRO-tf2-web-republisher ros-$ROS_DISTRO-common-tutorials ros-$ROS_DISTRO-rospy-tutorials ros-$ROS_DISTRO-actionlib-tutorials\n\n      - name: Tests\n        run: bash -c \"source /opt/ros/$ROS_DISTRO/setup.bash && bash test/build.bash\"\n\n      - name: Commit changes\n        if: github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic'\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_message: Update Build\n          file_pattern: build/*.js\n```", "answer": "```yaml name: CI\n\non: [push, pull_request]\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  ci:\n    name: ${{ matrix.ros_distro }}\n    if: ${{ github.actor != 'RWT-bot' }}\n    runs-on: ubuntu-latest\n    container: ros:${{ matrix.ros_distro }}-ros-core\n    strategy:\n      fail-fast: false\n      matrix:\n        ros_distro: [melodic, noetic]\n        node_version: [14]\n    env:\n      ROS_DISTRO: ${{ matrix.ros_distro }}\n    steps:\n      - uses: actions/checkout@v3\n        env:\n          TOKEN: \"${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' && secrets.RWT_BOT_PAT || github.token }}\"\n        with:\n          token: ${{ env.TOKEN }}\n      - uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node_version }}\n      - name: Own /github/home\n        run: |\n          chown -hR $(whoami):$(whoami) /github/home\n      - name: Install apt dependencies\n        run: |\n          apt-get update\n          apt-get install -y firefox ros-$ROS_DISTRO-rosbridge-server ros-$ROS_DISTRO-tf2-web-republisher ros-$ROS_DISTRO-common-tutorials ros-$ROS_DISTRO-rospy-tutorials ros-$ROS_DISTRO-actionlib-tutorials\n      - name: Tests\n        run: |\n          bash -c \"source /opt/ros/$ROS_DISTRO/setup.bash && bash test/build.bash\"\n      - uses: stefanzweifel/git-auto-commit-action@v4\n        if: ${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' }}\n        with:\n          commit_message: Update Build\n          file_pattern: 'build/*.js'\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The 1st job is named `${{ matrix.ros_distro }}` and its job id is `ci`. This job will run only if the condition(${{ github.actor != 'RWT-bot' }}) is met. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `ros_distro` has 2 values: melodic and noetic. The variable `node_version` has one value: 14. The job creates a Docker container that uses `ros:${{ matrix.ros_distro }}-ros-core` image. The job sets an environment variable to use: `ROS_DISTRO` is set to `${{ matrix.ros_distro }}`. The job `ci` has 6 steps. The 1st step is named ``. The step sets an environment variable to use: `TOKEN` is set to `${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' && secrets.RWT_BOT_PAT || github.token }}`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `token` is set to `${{ env.TOKEN }}`. The 2nd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines an input parameter for the action: `node-version` is set to `${{ matrix.node_version }}`. The 3rd step is named `Own /github/home`. This step runs a script: `chown -hR $(whoami):$(whoami) /github/home\n`. The 4th step is named `Install apt dependencies`. This step runs a script: `apt-get update\napt-get install -y firefox ros-$ROS_DISTRO-rosbridge-server ros-$ROS_DISTRO-tf2-web-republisher ros-$ROS_DISTRO-common-tutorials ros-$ROS_DISTRO-rospy-tutorials ros-$ROS_DISTRO-actionlib-tutorials\n`. The 5th step is named `Tests`. This step runs a script: `bash -c \"source /opt/ros/$ROS_DISTRO/setup.bash && bash test/build.bash\"\n`. The 6th step is named ``. This step will run only if the condition(${{ github.event_name == 'push' && endsWith(github.ref, 'develop') && matrix.ros_distro == 'noetic' }}) is met. This step runs action `stefanzweifel/git-auto-commit-action` tagged as v4. The step defines 2 input parameters for the action: `commit_message` is set to `Update Build` and `file_pattern` is set to `build/*.js`. "}
{"id": "63c494287843b612699ff643", "level": "level5", "llm_response": "```yaml\nname: README to PDF\n\non:\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    id: converttopdf\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Convert README to PDF\n      uses: baileyjm02/markdown-to-pdf@v1.1.0\n      with:\n        input_dir: .\n        output_dir: .\n        build_html: False\n        table_of_contents: False\n\n    - name: Upload PDF as artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: python-engineer-roadmap\n        path: README.pdf\n\n    - name: Commit files\n      run: |\n        git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n        git config --local user.name \"github-actions[bot]\"\n        git add README.pdf\n        if ! git diff-index --quiet HEAD; then\n          git commit -m \"Generate PDF file\"\n        fi\n\n    - name: Push changes\n      uses: ad-m/github-push-action@master\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        branch: ${{ github.ref }}\n```", "answer": "```yaml name: README to PDF\n# This workflow is triggered on pushes to the repository.\non:\n#   push:\n#     branches:\n#       - main\n#     paths:\n#       - 'README.md'\n    \n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  converttopdf:\n    name: Build PDF\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: baileyjm02/markdown-to-pdf@v1.1.0\n        with:\n          input_dir: .\n          output_dir: .\n          build_html: false\n          table_of_contents: false\n      - uses: actions/upload-artifact@v3\n        with:\n          name: python-engineer-roadmap\n          path: README.pdf\n      - name: Commit files\n        run: |\n          git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n          git config --local user.name \"github-actions[bot]\"\n          git add README.pdf\n          if ! git diff-index --quiet HEAD; then\n            git commit -m \"Generate PDF file\"\n          fi\n      - name: Push changes\n        uses: ad-m/github-push-action@master\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          branch: ${{ github.ref }}\n#       - name: Commit changes\n#         uses: EndBug/add-and-commit@v9\n#         with:\n#           default_author: github_actions\n#           add: 'README.pdf'\n#           new_branch: generate-pdf\n#           push: origin generate-pdf --set-upstream --force\n```", "prompt": "Generate a GitHub Workflow named `README to PDF` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Build PDF` and its job id is `converttopdf`. This job will run on ubuntu-latest runner. The job `converttopdf` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `baileyjm02/markdown-to-pdf` tagged as v1.1.0. The step defines 4 input parameters for the action: `input_dir` is set to `.`, `output_dir` is set to `.`, `build_html` is set to `False` and `table_of_contents` is set to `False`. The 3rd step is named ``. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `python-engineer-roadmap` and `path` is set to `README.pdf`. The 4th step is named `Commit files`. This step runs a script: `git config --local user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\ngit config --local user.name \"github-actions[bot]\"\ngit add README.pdf\nif ! git diff-index --quiet HEAD; then\n  git commit -m \"Generate PDF file\"\nfi\n`. The 5th step is named `Push changes`. This step runs action `ad-m/github-push-action` from the master branch. The step defines 2 input parameters for the action: `github_token` is set to `${{ secrets.GITHUB_TOKEN }}` and `branch` is set to `${{ github.ref }}`. "}
{"id": "63c494578052faa2781aa8bb", "level": "level5", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\nenv:\n  CODECOV_TOKEN: 2fc0d617-8e9a-47d7-ab58-52fa92b23741\n  MAIN_GO_VER: 1.16\n  MAIN_HOST_OS: ubuntu-latest\n\njobs:\n  go_test_and_coverage:\n    id: go_test_and_coverage\n    runs-on: ${{ matrix.HOST_OS }}\n    strategy:\n      matrix:\n        GO_VER: [1.16]\n        HOST_OS: [ubuntu-latest]\n      max-parallel: 6\n\n    steps:\n    - name: Checkout Repository\n      uses: actions/checkout@v3\n\n    - name: Setup Go\n      id: go\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.GO_VER }}\n\n    - name: Get Dependencies\n      run: |\n        echo GO_VER = ${{ matrix.GO_VER }}\n        go get golang.org/x/tools/cmd/cover\n        go install github.com/mattn/goveralls || go get github.com/mattn/goveralls\n        go get .\n\n    - name: Show Environments\n      run: |\n        echo repo status ======== && git status\n        echo GITHUB_REF = ${{ env.GITHUB_REF }}\n        echo GITHUB_REF_NAME = ${{ env.GITHUB_REF_NAME }}\n        echo GO_VER = ${{ matrix.GO_VER }}\n        echo HOST_OS = ${{ matrix.HOST_OS }}\n        which goveralls\n        echo envs ======== && printenv\n\n    - name: Test and Generate Coverage Report\n      run: go test -v -failfast -cover -covermode=atomic -coverprofile=coverage.out\n\n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        files: ./coverage.out\n        fail_ci_if_error: true\n        flags: unittests\n        name: codecov-umbrella\n        path_to_write_report: ./coverage/codecov_report.txt\n        verbose: true\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branchs:\n    - 'master'\n    - 'feature/**'\n    - 'dev/**'\n\nenv:\n  CODECOV_TOKEN: '2fc0d617-8e9a-47d7-ab58-52fa92b23741'\n  MAIN_GO_VER: '1.16'\n  MAIN_HOST_OS: 'ubuntu-latest'\n\njobs:\n  go_test_and_coverage:\n    strategy:\n      max-parallel: 6\n      matrix:\n        GO_VER: ['1.16']\n        HOST_OS: ['ubuntu-latest']\n\n    runs-on: ${{ matrix.HOST_OS }}\n\n    steps:\n\n    - name: Checkout Repositary\n      uses: actions/checkout@v3\n\n    - name: Setup Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.GO_VER }}\n      id: go\n\n    - name: Get Dependencies\n      run: |\n        echo GO_VER = ${{ matrix.GO_VER }}\n        go get golang.org/x/tools/cmd/cover\n        go install github.com/mattn/goveralls || go get github.com/mattn/goveralls\n        go get .\n\n    - name: Show Environments\n      run: |\n        echo repo status ======== && git status\n        echo GITHUB_REF = ${{ env.GITHUB_REF }}\n        echo GITHUB_REF_NAME = ${{ env.GITHUB_REF_NAME }}\n        echo GO_VER = ${{ matrix.GO_VER }}\n        echo HOST_OS = ${{ matrix.HOST_OS }}\n        which goveralls\n        echo envs ======== && printenv\n\n    - name: Test and Generate Coverage Report\n      run: |\n        go test -v -failfast -cover -covermode=atomic -coverprofile=coverage.out\n\n    # - name: Upload Coverage to Goveralls\n    #   run: |\n    #     goveralls -coverprofile=coverage.out -repotoken ${{ env.COVERALLS_TOKEN }}\n\n    # - name: Upload Coverage to Codecov\n    #   if: ${{ matrix.GO_VER }} == ${{ env.MAIN_GO_VER }}\n    #   run: |\n    #     bash <(curl -s https://codecov.io/bash) -t ${{ env.CODECOV_TOKEN }}\n\n    # - name: Convert Coverage file to lcov format\n    #   uses: jandelgado/gcov2lcov-action@v1.0.8\n    #   with:\n    #     infile: ./coverage.out\n    #     outfile: ./coverage.lcov\n\n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v2\n      with:\n        files: ./coverage.out\n        fail_ci_if_error: true\n        flags: unittests\n        name: codecov-umbrella\n        path_to_write_report: ./coverage/codecov_report.txt\n        verbose: true\n\n    # - name: Coveralls GitHub Action\n    #   uses: coverallsapp/github-action@1.1.3\n    #   with:\n    #     path-to-lcov: ./coverage.lcov\n    #     github-token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow sets 3 environment variables to use: `CODECOV_TOKEN` is set to `2fc0d617-8e9a-47d7-ab58-52fa92b23741`, `MAIN_GO_VER` is set to `1.16` and `MAIN_HOST_OS` is set to `ubuntu-latest`. The workflow has one job. The job id of the 1st job is `go_test_and_coverage`. This job will run on ${{ matrix.HOST_OS }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `GO_VER` has one value: 1.16. The variable `HOST_OS` has one value: ubuntu-latest. The maximum number of job runs in parallel is set to 6. The job `go_test_and_coverage` has 6 steps. The 1st step is named `Checkout Repositary`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Setup Go` and its id is `go`. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `${{ matrix.GO_VER }}`. The 3rd step is named `Get Dependencies`. This step runs a script: `echo GO_VER = ${{ matrix.GO_VER }}\ngo get golang.org/x/tools/cmd/cover\ngo install github.com/mattn/goveralls || go get github.com/mattn/goveralls\ngo get .\n`. The 4th step is named `Show Environments`. This step runs a script: `echo repo status ======== && git status\necho GITHUB_REF = ${{ env.GITHUB_REF }}\necho GITHUB_REF_NAME = ${{ env.GITHUB_REF_NAME }}\necho GO_VER = ${{ matrix.GO_VER }}\necho HOST_OS = ${{ matrix.HOST_OS }}\nwhich goveralls\necho envs ======== && printenv\n`. The 5th step is named `Test and Generate Coverage Report`. This step runs a script: `go test -v -failfast -cover -covermode=atomic -coverprofile=coverage.out\n`. The 6th step is named `Upload Coverage to Codecov`. This step runs action `codecov/codecov-action` tagged as v2. The step defines 6 input parameters for the action: `files` is set to `./coverage.out`, `fail_ci_if_error` is set to `True`, `flags` is set to `unittests`, `name` is set to `codecov-umbrella`, `path_to_write_report` is set to `./coverage/codecov_report.txt` and `verbose` is set to `True`. "}
{"id": "63c495297843b61269a05d37", "level": "level5", "llm_response": "```yaml\nname: pr\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\njobs:\n  release:\n    id: release\n    uses: the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main\n    with:\n      npmTag: alpha\n      buildScript: build\n      nodeVersion: 18\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n      npmToken: ${{ secrets.NPM_TOKEN }}\n\n  algolia:\n    id: algolia\n    uses: the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main\n    with:\n      domain: https://www.the-guild.dev/graphql/shield/\n      source: Shield\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: pr\non:\n  pull_request:\n\njobs:\n  release:\n    uses: the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main\n    with:\n      npmTag: alpha\n      buildScript: build\n      nodeVersion: 18\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n      npmToken: ${{ secrets.NPM_TOKEN }}\n\n\n  algolia:\n    uses: the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main\n    with:\n      domain: https://www.the-guild.dev/graphql/shield/\n      source: 'Shield'\n      packageManager: pnpm\n    secrets:\n      githubToken: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `pr` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The job id of the 1st job is `release`. This job will call a reusable workflow located at `the-guild-org/shared-config/.github/workflows/release-snapshot.yml@main`. The job will pass 4 inputs to the called workflow: the input `npmTag` is `alpha`, the input `buildScript` is `build`, the input `nodeVersion` is `18` and the input `packageManager` is `pnpm`. The job will pass 2 secrets to the called workflow: the secret `githubToken` is `${{ secrets.GITHUB_TOKEN }}` and the secret `npmToken` is `${{ secrets.NPM_TOKEN }}`. The job id of the 2nd job is `algolia`. This job will call a reusable workflow located at `the-guild-org/shared-config/.github/workflows/algolia-integrity.yml@main`. The job will pass 3 inputs to the called workflow: the input `domain` is `https://www.the-guild.dev/graphql/shield/`, the input `source` is `Shield` and the input `packageManager` is `pnpm`. The job will pass a secret to the called workflow: the secret `githubToken` is `${{ secrets.GITHUB_TOKEN }}`. "}
{"id": "63c4959c7843b61269a08c2d", "level": "level5", "llm_response": "```yaml\nname: \"\"\n\non:\n  push:\n    paths:\n      - \".github/workflows/install.yml\"\n  schedule:\n    - cron: '17 0 * * 1'\n\npermissions:\n  contents: read\n\njobs:\n  cargo-install:\n    id: cargo-install\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: cargo install cargo-mutants\n```", "answer": "```yaml permissions:\n  contents: read\n\non:\n  push:\n    paths:\n      - \".github/workflows/install.yml\"\n  schedule:\n    - cron: \"17 0 * * 1\"\n\njobs:\n  cargo-install:\n    runs-on: ubuntu-latest\n    steps:\n      - name: cargo-install\n        run: |\n          cargo install cargo-mutants\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/install.yml), the workflow runs. 2) the scheduled time has come: at 12:17 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `cargo-install`. This job will run on ubuntu-latest runner. The job `cargo-install` has one step. The 1st step is named `cargo-install`. This step runs a script: `cargo install cargo-mutants\n`. "}
{"id": "63c4968e1899db58864d3b1c", "level": "level5", "llm_response": "```yaml\nname: HTML5 check\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n\njobs:\n  HTML5-check:\n    uses: easystats/workflows/.github/workflows/html-5-check.yaml@main\n```", "answer": "```yaml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n\nname: HTML5 check\n\njobs:\n  HTML5-check:\n    uses: easystats/workflows/.github/workflows/html-5-check.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `HTML5 check` for a GitHub repository whose primary programming language is R. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch named master. The workflow has one job. The job id of the 1st job is `HTML5-check`. This job will call a reusable workflow located at `easystats/workflows/.github/workflows/html-5-check.yaml@main`. "}
{"id": "63c496861e3364807577b31b", "level": "level5", "llm_response": "```yaml\nname: license-check\n\non:\n  pull_request:\n    branches: [ master ]\n\njobs:\n  license:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@master\n\n    - name: Check License Header\n      uses: apache/skywalking-eyes/header@501a28d2fb4a9b962661987e50cf0219631b32ff\n```", "answer": "```yaml name: license-check\non: pull_request\njobs:\n  license:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Check License Header\n      uses: apache/skywalking-eyes/header@501a28d2fb4a9b962661987e50cf0219631b32ff\n```", "prompt": "Generate a GitHub Workflow named `license-check` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `license`. This job will run on ubuntu-latest runner. The job `license` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` from the master branch. The 2nd step is named `Check License Header`. This step runs action `apache/skywalking-eyes/header` whose commit is 501a28d2fb4a9b962661987e50cf0219631b32ff. "}
{"id": "63c4962c6fc19abdf9c9a4e3", "level": "level5", "llm_response": "```yaml\nname: Continuous integration\n\non:\n  push:\n    branches:\n      - develop\n      - master\n  pull_request:\n    branches:\n      - develop\n      - master\n  repository_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:14-alpine\n        env:\n          POSTGRES_PASSWORD: postgres\n        ports:\n          - 5432:5432\n      redis:\n        image: redis:alpine\n        ports:\n          - 6379:6379\n      opensearch:\n        image: opensearchproject/opensearch:latest\n        env:\n          discovery.type: single-node\n          plugins.security.disabled: True\n        ports:\n          - 9200:9200\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          bundler-cache: true\n      - name: Lint with RuboCop\n        run: bundle exec rubocop --parallel\n      - name: Setup Node.js\n        uses: actions/setup-node@v3.5.1\n        with:\n          cache: yarn\n      - name: Install Node modules\n        run: bin/yarn install --frozen-lockfile\n      - name: Run ESLint\n        run: bin/yarn lint\n      - name: Run Tests\n        env:\n          DB_HOST: localhost\n          DB_USER: postgres\n          DB_PASSWORD: postgres\n          RAILS_ENV: test\n          SECRET_KEY_BASE: we-dont-need-a-secret-here\n          APP_ADMIN_EMAIL: admin@example.org\n          APP_ADMIN_PASSWORD: secret\n          APP_EMAIL: reply@example.org\n          APP_HOST: example.org\n          AWS_ACCESS_KEY_ID: my-access-key\n          AWS_SECRET_ACCESS_KEY: my-secret\n          AWS_BUCKET: my-bucket\n          AWS_REGION: eu-central-1\n          CI: True\n        run: |\n          bundle exec rake assets:precompile\n          bundle exec rake db:create db:schema:load\n          bundle exec rake spec\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      - name: Build, push and deploy the LATEST image\n        if: github.ref == 'refs/heads/develop'\n        run: |\n          export COMMIT_TIME=$(git show -s --format=%cD ${GITHUB_SHA})\n          export COMMIT_SHA=${GITHUB_SHA}\n          docker buildx build --build-arg COMMIT_TIME --build-arg COMMIT_SHA -t ghcr.io/ledermann/docker-rails/docker-rails:latest .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:latest\n          curl -X POST ${{ secrets.DEPLOY_HOOK_APP }}\n          curl -X POST ${{ secrets.DEPLOY_HOOK_WORKER }}\n      - name: Build and push the STABLE image\n        if: github.ref == 'refs/heads/master'\n        run: |\n          docker buildx build -t ghcr.io/ledermann/docker-rails/docker-rails:stable .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:stable\n```", "answer": "```yaml name: Continuous integration\non: push\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:14-alpine\n        ports: [\"5432:5432\"]\n        env:\n          POSTGRES_PASSWORD: postgres\n\n      redis:\n        image: redis:alpine\n        ports: [\"6379:6379\"]\n\n      opensearch:\n        image: opensearchproject/opensearch:latest\n        ports: [\"9200:9200\"]\n        env:\n          discovery.type: single-node\n          plugins.security.disabled: true\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          bundler-cache: true\n\n      - name: Lint with RuboCop\n        run: bundle exec rubocop --parallel\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3.5.1\n        with:\n          cache: yarn\n\n      - name: Install Node modules\n        run: bin/yarn install --frozen-lockfile\n\n      - name: Run ESLint\n        run: bin/yarn lint\n\n      - name: Run Tests\n        env:\n          DB_HOST: localhost\n          DB_USER: postgres\n          DB_PASSWORD: postgres\n          RAILS_ENV: test\n          SECRET_KEY_BASE: we-dont-need-a-secret-here\n          APP_ADMIN_EMAIL: admin@example.org\n          APP_ADMIN_PASSWORD: secret\n          APP_EMAIL: reply@example.org\n          APP_HOST: example.org\n          AWS_ACCESS_KEY_ID: my-access-key\n          AWS_SECRET_ACCESS_KEY: my-secret\n          AWS_BUCKET: my-bucket\n          AWS_REGION: eu-central-1\n          CI: true\n        run: |\n          bundle exec rake assets:precompile\n          bundle exec rake db:create db:schema:load\n          bundle exec rake spec\n\n  deploy:\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master'\n    needs: test\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build, push and deploy the LATEST image\n        if: github.ref == 'refs/heads/develop'\n        run: |\n          export COMMIT_TIME=$(git show -s --format=%cD ${GITHUB_SHA})\n          export COMMIT_SHA=${GITHUB_SHA}\n          docker buildx build --build-arg COMMIT_TIME --build-arg COMMIT_SHA -t ghcr.io/ledermann/docker-rails/docker-rails:latest .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:latest\n          curl -X POST ${{ secrets.DEPLOY_HOOK_APP }}\n          curl -X POST ${{ secrets.DEPLOY_HOOK_WORKER }}\n\n      - name: Build and push the STABLE image\n        if: github.ref == 'refs/heads/master'\n        run: |\n          docker buildx build -t ghcr.io/ledermann/docker-rails/docker-rails:stable .\n          docker push ghcr.io/ledermann/docker-rails/docker-rails:stable\n```", "prompt": "Generate a GitHub Workflow named `Continuous integration` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The job id of the 1st job is `test`. This job will run on ubuntu-latest runner. The job defines a service called postgres which will be created using the Docker image `postgres:14-alpine`. The service container sets an environment variable to use: `POSTGRES_PASSWORD` is set to `postgres`. For communication, the port 5432 on the Docker host is mapped to port 5432 on the service container. The job defines a service called redis which will be created using the Docker image `redis:alpine`. For communication, the port 6379 on the Docker host is mapped to port 6379 on the service container. The job defines a service called opensearch which will be created using the Docker image `opensearchproject/opensearch:latest`. The service container sets 2 environment variables to use: `discovery.type` is set to `single-node` and `plugins.security.disabled` is set to `True`. For communication, the port 9200 on the Docker host is mapped to port 9200 on the service container. The job `test` has 7 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Ruby`. This step runs action `ruby/setup-ruby` tagged as v1. The step defines an input parameter for the action: `bundler-cache` is set to `True`. The 3rd step is named `Lint with RuboCop`. This step runs a script: `bundle exec rubocop --parallel`. The 4th step is named `Setup Node.js`. This step runs action `actions/setup-node` tagged as v3.5.1. The step defines an input parameter for the action: `cache` is set to `yarn`. The 5th step is named `Install Node modules`. This step runs a script: `bin/yarn install --frozen-lockfile`. The 6th step is named `Run ESLint`. This step runs a script: `bin/yarn lint`. The 7th step is named `Run Tests`. The step sets 14 environment variables to use: `DB_HOST` is set to `localhost`, `DB_USER` is set to `postgres`, `DB_PASSWORD` is set to `postgres`, `RAILS_ENV` is set to `test`, `SECRET_KEY_BASE` is set to `we-dont-need-a-secret-here`, `APP_ADMIN_EMAIL` is set to `admin@example.org`, `APP_ADMIN_PASSWORD` is set to `secret`, `APP_EMAIL` is set to `reply@example.org`, `APP_HOST` is set to `example.org`, `AWS_ACCESS_KEY_ID` is set to `my-access-key`, `AWS_SECRET_ACCESS_KEY` is set to `my-secret`, `AWS_BUCKET` is set to `my-bucket`, `AWS_REGION` is set to `eu-central-1` and `CI` is set to `True`. This step runs a script: `bundle exec rake assets:precompile\nbundle exec rake db:create db:schema:load\nbundle exec rake spec\n`. The job id of the 2nd job is `deploy`. Before this job runs, `test` must complete successfully. This job will run only if the condition(github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master') is met. This job will run on ubuntu-latest runner. The job `deploy` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Login to GitHub Container Registry`. This step runs action `docker/login-action` tagged as v2. The step defines 3 input parameters for the action: `registry` is set to `ghcr.io`, `username` is set to `${{ github.repository_owner }}` and `password` is set to `${{ secrets.GITHUB_TOKEN }}`. The 3rd step is named `Build, push and deploy the LATEST image`. This step will run only if the condition(github.ref == 'refs/heads/develop') is met. This step runs a script: `export COMMIT_TIME=$(git show -s --format=%cD ${GITHUB_SHA})\nexport COMMIT_SHA=${GITHUB_SHA}\ndocker buildx build --build-arg COMMIT_TIME --build-arg COMMIT_SHA -t ghcr.io/ledermann/docker-rails/docker-rails:latest .\ndocker push ghcr.io/ledermann/docker-rails/docker-rails:latest\ncurl -X POST ${{ secrets.DEPLOY_HOOK_APP }}\ncurl -X POST ${{ secrets.DEPLOY_HOOK_WORKER }}\n`. The 4th step is named `Build and push the STABLE image`. This step will run only if the condition(github.ref == 'refs/heads/master') is met. This step runs a script: `docker buildx build -t ghcr.io/ledermann/docker-rails/docker-rails:stable .\ndocker push ghcr.io/ledermann/docker-rails/docker-rails:stable\n`. "}
{"id": "63c495707843b61269a07a00", "level": "level5", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '43 20 * * 1'\n  push:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    permissions:\n      security-events: write\n      id-token: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@a12a3943b4bdde767164f792f33f40b04645d846\n        with:\n          persist-credentials: 'false'\n\n      - name: Run analysis\n        uses: ossf/scorecard-action@3e15ea8318eee9b333819ec77a36aca8d39df13e\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          publish_results: true\n\n      - name: Upload artifact\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5\n        with:\n          sarif_file: results.sarif\n```", "answer": "```yaml name: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '43 20 * * 1'\n  push:\n    branches: [ master ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      # Used to receive a badge. (Upcoming feature)\n      id-token: write\n      actions: read\n      contents: read\n    \n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@a12a3943b4bdde767164f792f33f40b04645d846 # v3.0.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@3e15ea8318eee9b333819ec77a36aca8d39df13e # v1.1.1\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # (Optional) Read-only PAT token. Uncomment the `repo_token` line below if:\n          # - you want to enable the Branch-Protection check on a *public* repository, or\n          # - you are installing Scorecards on a *private* repository\n          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action#authentication-with-pat.\n          # repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n\n          # Publish the results for public repositories to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results. \n          # For private repositories, `publish_results` will automatically be set to `false`, regardless \n          # of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF\n      # format to the repository Actions tab.\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8 # v3.1.0\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n      \n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 08:43 pm, only on monday. 3) The workflow would run whenever there is a push event to: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. This job will run on ubuntu-latest runner. The job `analysis` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `security-events` scope, write access is granted to the GITHUB_TOKEN in the `id-token` scope, read access is granted to the GITHUB_TOKEN in the `actions` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. This step runs action `actions/checkout` whose commit is a12a3943b4bdde767164f792f33f40b04645d846. The step defines an input parameter for the action: `persist-credentials` is set to `False`. The 2nd step is named `Run analysis`. This step runs action `ossf/scorecard-action` whose commit is 3e15ea8318eee9b333819ec77a36aca8d39df13e. The step defines 3 input parameters for the action: `results_file` is set to `results.sarif`, `results_format` is set to `sarif` and `publish_results` is set to `True`. The 3rd step is named `Upload artifact`. This step runs action `actions/upload-artifact` whose commit is 3cea5372237819ed00197afe530f5a7ea3e805c8. The step defines 3 input parameters for the action: `name` is set to `SARIF file`, `path` is set to `results.sarif` and `retention-days` is set to `5`. The 4th step is named `Upload to code-scanning`. This step runs action `github/codeql-action/upload-sarif` whose commit is 5f532563584d71fdef14ee64d17bafb34f751ce5. The step defines an input parameter for the action: `sarif_file` is set to `results.sarif`. "}
{"id": "63c495c68052faa2781b4231", "level": "level5", "llm_response": "```yaml\nname: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pullRequestHandler:\n    id: pullRequestHandler\n    runs-on: windows-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Pull Request Validation\n      if: startsWith(github.event.comment.body, '/verify')\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        SKIP_UPDATED: 1\n      uses: Ash258/Scoop-GithubActions@stable-win\n```", "answer": "```yaml name: Commented Pull Request\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  pullRequestHandler:\n    name: Pull Request Validator\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Pull Request Validation\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: startsWith(github.event.comment.body, '/verify')\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          SKIP_UPDATED: '1'\n```", "prompt": "Generate a GitHub Workflow named `Commented Pull Request` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The 1st job is named `Pull Request Validator` and its job id is `pullRequestHandler`. This job will run on windows-latest runner. The job `pullRequestHandler` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Pull Request Validation`. This step will run only if the condition(startsWith(github.event.comment.body, '/verify')) is met. The step sets 2 environment variables to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}` and `SKIP_UPDATED` is set to `1`. This step runs action `Ash258/Scoop-GithubActions` from the stable-win branch. "}
{"id": "63c4969e1899db58864d41ef", "level": "level5", "llm_response": "```yaml\nname: Auto message on pr merge\n\non:\n  pull_request:\n    types: [closed]\n\njobs:\n  auto-response:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set up environment\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        uses: derekprior/add-autoresponse@master\n        with:\n          respondableId: ${{ github.event.pull_request.node_id }}\n          response: \"Thank you @${{ github.event.pull_request.user.login }} for taking out your valuable time in order to contribute to our project. Looking forward for more such amazing contributions :).\"\n          author: ${{ github.event.pull_request.user.login }}\n          exemptedAuthors: \"Amit366\"\n```", "answer": "```yaml name: Auto message on pr merge\n\non:\n\n  pull_request_target:\n\n    types: [closed]\n\njobs:\n\n  auto-response:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - uses: derekprior/add-autoresponse@master\n\n      env:\n\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      with:\n\n        respondableId: ${{ github.event.pull_request.node_id }}\n\n        response: \"Thank you @${{ github.event.pull_request.user.login }} for taking out your valuable time in order to contribute to our project. Looking forward for more such amazing contributions :).\"\n\n        author: ${{ github.event.pull_request.user.login }}\n\n        exemptedAuthors: \"Amit366\"\n```", "prompt": "Generate a GitHub Workflow named `Auto message on pr merge` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a pull request is closed. The workflow has one job. The job id of the 1st job is `auto-response`. This job will run on ubuntu-latest runner. The job `auto-response` has one step. The 1st step is named ``. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `derekprior/add-autoresponse` from the master branch. The step defines 4 input parameters for the action: `respondableId` is set to `${{ github.event.pull_request.node_id }}`, `response` is set to `Thank you @${{ github.event.pull_request.user.login }} for taking out your valuable time in order to contribute to our project. Looking forward for more such amazing contributions :).`, `author` is set to `${{ github.event.pull_request.user.login }}` and `exemptedAuthors` is set to `Amit366`. "}
{"id": "63c4966b33b087f6bde2bde4", "level": "level5", "llm_response": "```yaml\nname: tests\n\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    runs-on: ${{ matrix.os }}\n\n    strategy:\n      matrix:\n        name: [3.11-dev, Linux, Windows, Mac, 3.9, PyPy]\n        python: [3.11-dev, 3.10, 3.10, 3.10, 3.9, pypy-3.9]\n        os: [ubuntu-latest, ubuntu-latest, windows-latest, macos-latest, ubuntu-latest, ubuntu-latest]\n        tox: [py311, py310, py310, py310, py39, pypy39]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python }}\n\n      - name: Install system dependencies\n        run: sudo apt-get install libxml2-dev libxslt1-dev --yes\n        if: matrix.python == '3.11-dev'\n\n      - name: Update pip\n        run: |\n          pip install -U wheel\n          pip install -U setuptools\n          python -m pip install -U pip\n\n      - name: Install tox\n        run: pip install tox\n\n      - name: Run tox\n        run: tox -e ${{ matrix.tox }}\n```", "answer": "```yaml name: tests\non:\n  push:\n    branches:\n      - master\n      - develop\n  pull_request:\n    branches:\n      - master\n      - develop\n\njobs:\n  tests:\n    name: ${{ matrix.name }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - {name: '3.11-dev', python: '3.11-dev', os: ubuntu-latest, tox: py311}\n          - {name: Linux, python: '3.10', os: ubuntu-latest, tox: py310}\n          - {name: Windows, python: '3.10', os: windows-latest, tox: py310}\n          - {name: Mac, python: '3.10', os: macos-latest, tox: py310}\n          - {name: '3.9', python: '3.9', os: ubuntu-latest, tox: py39}\n          - {name: 'PyPy', python: 'pypy-3.9', os: ubuntu-latest, tox: pypy39}\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python }}\n      - name: install system dependencies\n        run: sudo apt-get install libxml2-dev libxslt1-dev --yes\n        if: ${{ matrix.python == '3.11-dev' }}\n      - name: update pip\n        run: |\n          pip install -U wheel\n          pip install -U setuptools\n          python -m pip install -U pip\n      - run: pip install tox\n      - run: tox -e ${{ matrix.tox }}\n```", "prompt": "Generate a GitHub Workflow named `tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a branch named develop. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master or a branch named develop. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `tests`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. For each object in the [{'name': '3.11-dev', 'python': '3.11-dev', 'os': 'ubuntu-latest', 'tox': 'py311'}, {'name': 'Linux', 'python': '3.10', 'os': 'ubuntu-latest', 'tox': 'py310'}, {'name': 'Windows', 'python': '3.10', 'os': 'windows-latest', 'tox': 'py310'}, {'name': 'Mac', 'python': '3.10', 'os': 'macos-latest', 'tox': 'py310'}, {'name': '3.9', 'python': '3.9', 'os': 'ubuntu-latest', 'tox': 'py39'}, {'name': 'PyPy', 'python': 'pypy-3.9', 'os': 'ubuntu-latest', 'tox': 'pypy39'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `tests` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-python` tagged as v3. The step defines an input parameter for the action: `python-version` is set to `${{ matrix.python }}`. The 3rd step is named `install system dependencies`. This step will run only if the condition(${{ matrix.python == '3.11-dev' }}) is met. This step runs a script: `sudo apt-get install libxml2-dev libxslt1-dev --yes`. The 4th step is named `update pip`. This step runs a script: `pip install -U wheel\npip install -U setuptools\npython -m pip install -U pip\n`. The 5th step is named ``. This step runs a script: `pip install tox`. The 6th step is named ``. This step runs a script: `tox -e ${{ matrix.tox }}`. "}
{"id": "63c495c88052faa2781b42d4", "level": "level5", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n    strategy:\n      matrix:\n        language: [java]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: ${{ matrix.language }}\n          queries: security-and-quality,security-extended\n\n      - name: Compile Java\n        run: JAVA_OPTS=\"-Xmx1000M\" ./gradlew --no-scan compileJava\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n    paths-ignore:\n      - '**/*.json'\n      - '**/*.md'\n      - '**/*.properties'\n      - '**/*.txt'\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        queries: security-and-quality,security-extended\n\n    # Autobuild failed (OOM)\n    # Hence, supply memory args for gradle build\n    - run: |\n        JAVA_OPTS=\"-Xmx1000M\" ./gradlew --no-scan compileJava\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. When all the path names of pull_request event match patterns in the paths-ignore filter(**/*.json, **/*.md, **/*.properties or **/*.txt), the workflow will not run. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has one value: java. The job `analyze` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `actions` scope, read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `security-events` scope. This permission setting only applies to the job `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Initialize CodeQL`. This step runs action `github/codeql-action/init` tagged as v2. The step defines 2 input parameters for the action: `languages` is set to `${{ matrix.language }}` and `queries` is set to `security-and-quality,security-extended`. The 3rd step is named ``. This step runs a script: `JAVA_OPTS=\"-Xmx1000M\" ./gradlew --no-scan compileJava\n`. The 4th step is named `Perform CodeQL Analysis`. This step runs action `github/codeql-action/analyze` tagged as v2. "}
{"id": "63c495e48052faa2781b4f0b", "level": "level5", "llm_response": "```yaml\nname: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n\ninputs:\n  from-this:\n    description: 'Generate from this release/commit'\n    required: false\n    default: ''\n  to-this:\n    description: 'Generate until this release/commit'\n    required: false\n    default: 'HEAD'\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n    if: github.repository_owner == 'Mudlet'\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Install Lua 5.1.5\n      uses: leafo/gh-actions-lua@v9\n      with:\n        luaVersion: 5.1.5\n\n    - name: Install Luarocks\n      uses: leafo/gh-actions-luarocks@v4\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install argparse\n        luarocks install lunajson\n\n    - name: Calculate from and to releases\n      run: |\n        if [[ -z \"${{ github.event.inputs.from }}\" ]] ; then\n            FROM_RELEASE=$(git tag --sort=committerdate | tail -1)\n        else\n            FROM_RELEASE=${{ github.event.inputs.from }}\n        fi\n\n        if [[ -z \"${{ github.event.inputs.to }}\" ]] ; then\n            TO_RELEASE=\"HEAD\"\n        else\n            TO_RELEASE=${{ github.event.inputs.to }}\n        fi\n\n        echo \"Generating a changelog from $FROM_RELEASE until $TO_RELEASE\"\n\n        echo \"FROM_RELEASE=$FROM_RELEASE\" >> $GITHUB_ENV\n        echo \"TO_RELEASE=$TO_RELEASE\" >> $GITHUB_ENV\n\n    - name: Generate changelog\n      run: |\n        changelog=$(lua CI/generate-changelog.lua -m release --start-commit $FROM_RELEASE --end-commit $TO_RELEASE)\n        echo \"$changelog\" >> changelog.html\n\n        echo \"[INFO] Changelog generated (from $FROM_RELEASE to $TO_RELEASE). If it's too big, Github won't show it, so it's available as an artifact as well at: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts\"\n        echo \"[INFO] Changelog is:\"\n        echo $changelog\n\n    - name: Upload changelog as html\n      uses: actions/upload-artifact@v3\n      with:\n        name: changelog.html\n        path: changelog.html\n```", "answer": "```yaml name: Generate a changelog\n\non:\n  schedule:\n    - cron: '0 3 * * *'\n  workflow_dispatch:\n    inputs:\n      from:\n        description: 'Generate from this release/commit (defaults to the latest release)'\n        required: false\n        # default is calculated dynamically\n      to:\n        description: 'Generate until this release/commit (defaults to latest development)'\n        required: false\n        default: 'HEAD'\n\njobs:\n  generate-changelog:\n    runs-on: ubuntu-latest\n    if: ${{ github.repository_owner == 'Mudlet' }}\n\n    steps:\n    - name: Checkout Mudlet repository\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Install Lua 5.1.5\n      uses: leafo/gh-actions-lua@v9\n      with:\n        luaVersion: \"5.1.5\"\n\n    - name: Install Luarocks\n      uses: leafo/gh-actions-luarocks@v4\n\n    - name: Install Lua dependencies\n      run: |\n        luarocks install argparse\n        luarocks install lunajson\n\n    - name: Calculate from and to releases\n      run: |\n        if [[ -z \"${{ github.event.inputs.from }}\" ]] ; then\n            FROM_RELEASE=$(git tag --sort=committerdate | tail -1)\n        else\n            FROM_RELEASE=${{ github.event.inputs.from }}\n        fi\n\n        if [[ -z \"${{ github.event.inputs.to }}\" ]] ; then\n            TO_RELEASE=\"HEAD\"\n        else\n            TO_RELEASE=${{ github.event.inputs.to }}\n        fi\n\n        echo \"Generating a changelog from $FROM_RELEASE until $TO_RELEASE\"\n\n        echo \"FROM_RELEASE=$FROM_RELEASE\" >> $GITHUB_ENV\n        echo \"TO_RELEASE=$TO_RELEASE\" >> $GITHUB_ENV\n\n    - name: Generate changelog\n      run: |\n        changelog=$(lua CI/generate-changelog.lua -m release --start-commit $FROM_RELEASE --end-commit $TO_RELEASE)\n        echo \"$changelog\" >> changelog.html\n\n        echo \"[INFO] Changelog generated (from $FROM_RELEASE to $TO_RELEASE). If it's too big, Github won't show it, so it's available as an artifact as well at: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts\"\n        echo \"[INFO] Changelog is:\"\n        echo $changelog\n\n    - name: Upload changelog as html\n      uses: actions/upload-artifact@v3\n      with:\n        name: changelog.html\n        path: changelog.html\n```", "prompt": "Generate a GitHub Workflow named `Generate a changelog` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 03:00 am. 2) someone manually triggers the workflow. This workflow receives 2 inputs: from-this input represents generate from this release/commit (defaults to the latest release) and it is optional; to-this input represents generate until this release/commit (defaults to latest development), it is optional and its default value is HEAD. The workflow has one job. The job id of the 1st job is `generate-changelog`. This job will run only if the condition(${{ github.repository_owner == 'Mudlet' }}) is met. This job will run on ubuntu-latest runner. The job `generate-changelog` has 7 steps. The 1st step is named `Checkout Mudlet repository`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Install Lua 5.1.5`. This step runs action `leafo/gh-actions-lua` tagged as v9. The step defines an input parameter for the action: `luaVersion` is set to `5.1.5`. The 3rd step is named `Install Luarocks`. This step runs action `leafo/gh-actions-luarocks` tagged as v4. The 4th step is named `Install Lua dependencies`. This step runs a script: `luarocks install argparse\nluarocks install lunajson\n`. The 5th step is named `Calculate from and to releases`. This step runs a script: `if [[ -z \"${{ github.event.inputs.from }}\" ]] ; then\n    FROM_RELEASE=$(git tag --sort=committerdate | tail -1)\nelse\n    FROM_RELEASE=${{ github.event.inputs.from }}\nfi\n\nif [[ -z \"${{ github.event.inputs.to }}\" ]] ; then\n    TO_RELEASE=\"HEAD\"\nelse\n    TO_RELEASE=${{ github.event.inputs.to }}\nfi\n\necho \"Generating a changelog from $FROM_RELEASE until $TO_RELEASE\"\n\necho \"FROM_RELEASE=$FROM_RELEASE\" >> $GITHUB_ENV\necho \"TO_RELEASE=$TO_RELEASE\" >> $GITHUB_ENV\n`. The 6th step is named `Generate changelog`. This step runs a script: `changelog=$(lua CI/generate-changelog.lua -m release --start-commit $FROM_RELEASE --end-commit $TO_RELEASE)\necho \"$changelog\" >> changelog.html\n\necho \"[INFO] Changelog generated (from $FROM_RELEASE to $TO_RELEASE). If it's too big, Github won't show it, so it's available as an artifact as well at: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts\"\necho \"[INFO] Changelog is:\"\necho $changelog\n`. The 7th step is named `Upload changelog as html`. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `changelog.html` and `path` is set to `changelog.html`. "}
{"id": "63c494347843b612699ffa9f", "level": "level5", "llm_response": "```yaml\nname: Release Charts\n\non:\n  push:\n    tags:\n      - chart-v*\n\njobs:\n  build:\n    runs-on: ubuntu-20.04\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n      - name: Check chart version\n        run: |\n          tag_version=${GITHUB_REF##*/chart-v}\n          chart_version=$(cat charts/moco/Chart.yaml | grep 'version:' | sed 's/version:\\s//')\n          if [ \"$tag_version\" != \"$chart_version\" ]; then\n            echo \"Different versions: tag \\\"$tag_version\\\", chart \\\"$chart_version\\\"\"\n            exit 1\n          fi\n      - name: Packaging the chart\n        run: helm package ./charts/moco/\n      - name: Upload helm-charts artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: helm-charts\n          path: ./moco-*.tgz\n          retention-days: 1\n\n  publish:\n    runs-on: ubuntu-20.04\n    needs: build\n    steps:\n      - name: Checkout gh-pages\n        uses: actions/checkout@v3\n        with:\n          ref: gh-pages\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n      - name: Download helm-charts artifact\n        uses: actions/download-artifact@v3\n        with:\n          name: helm-charts\n      - name: Update charts index\n        run: helm repo index --url https://cybozu-go.github.io/moco/ --merge index.yaml .\n      - name: Add changes\n        run: git add .\n      - name: Check diffs\n        run: |\n          diffs=$(git status -s)\n          if [ \"$diffs\" = \"\" ]; then\n            echo \"NO_DIFF=1\" >> $GITHUB_ENV\n          else\n            printf \"%s\\n\" \"$diffs\"\n          fi\n      - name: Commit changes\n        if: env.NO_DIFF != '1'\n        run: |\n          git config --global user.name 'Cybozu Neco'\n          git config --global user.email 'cybozu-neco@users.noreply.github.com'\n          git commit -m 'update'\n      - name: Push to gh-pages\n        if: env.NO_DIFF != '1'\n        run: git push origin gh-pages\n```", "answer": "```yaml name: Release Charts\n\non:\n  push:\n    tags:\n      - 'chart-v*'\n\njobs:\n  build:\n    runs-on: ubuntu-20.04\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - name: Check chart version\n        run: |\n          tag_version=${GITHUB_REF##*/chart-v}\n          chart_version=$(cat charts/moco/Chart.yaml | grep 'version:' | sed 's/version:\\s//')\n          if [ \"$tag_version\" != \"$chart_version\" ]; then\n            echo \"Different versions: tag \\\"$tag_version\\\", chart \\\"$chart_version\\\"\"\n            exit 1\n          fi\n      - name: Packaging the chart\n        run: helm package ./charts/moco/\n\n      - uses: actions/upload-artifact@v3\n        with:\n          name: helm-charts\n          path: ./moco-*.tgz\n          retention-days: 1\n\n  publish:\n    name: Publish charts on GitHub Pages\n    runs-on: ubuntu-20.04\n    needs: build\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          ref: gh-pages\n\n      - name: Set up Helm\n        uses: azure/setup-helm@v1\n        with:\n          version: v3.6.3\n\n      - uses: actions/download-artifact@v3\n        with:\n          name: helm-charts\n\n      - name: Update charts index\n        run: helm repo index --url https://cybozu-go.github.io/moco/ --merge index.yaml .\n\n      - run: git add .\n\n      - name: Check diffs\n        run: |\n          diffs=$(git status -s)\n          if [ \"$diffs\" = \"\" ]; then\n            echo \"NO_DIFF=1\" >> $GITHUB_ENV\n          else\n            printf \"%s\\n\" \"$diffs\"\n          fi\n      - name: Commit changes\n        if: env.NO_DIFF != '1'\n        run: |\n          git config --global user.name 'Cybozu Neco'\n          git config --global user.email 'cybozu-neco@users.noreply.github.com'\n          git commit -m 'update'\n      - name: Push to gh-pages\n        if: env.NO_DIFF != '1'\n        run: git push origin gh-pages\n```", "prompt": "Generate a GitHub Workflow named `Release Charts` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches chart-v*. The workflow has 2 jobs. The job id of the 1st job is `build`. This job will run on ubuntu-20.04 runner. The job `build` has 5 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Set up Helm`. This step runs action `azure/setup-helm` tagged as v1. The step defines an input parameter for the action: `version` is set to `v3.6.3`. The 3rd step is named `Check chart version`. This step runs a script: `tag_version=${GITHUB_REF##*/chart-v}\nchart_version=$(cat charts/moco/Chart.yaml | grep 'version:' | sed 's/version:\\s//')\nif [ \"$tag_version\" != \"$chart_version\" ]; then\n  echo \"Different versions: tag \\\"$tag_version\\\", chart \\\"$chart_version\\\"\"\n  exit 1\nfi\n`. The 4th step is named `Packaging the chart`. This step runs a script: `helm package ./charts/moco/`. The 5th step is named ``. This step runs action `actions/upload-artifact` tagged as v3. The step defines 3 input parameters for the action: `name` is set to `helm-charts`, `path` is set to `./moco-*.tgz` and `retention-days` is set to `1`. The 2nd job is named `Publish charts on GitHub Pages` and its job id is `publish`. Before this job runs, `build` must complete successfully. This job will run on ubuntu-20.04 runner. The job `publish` has 8 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `ref` is set to `gh-pages`. The 2nd step is named `Set up Helm`. This step runs action `azure/setup-helm` tagged as v1. The step defines an input parameter for the action: `version` is set to `v3.6.3`. The 3rd step is named ``. This step runs action `actions/download-artifact` tagged as v3. The step defines an input parameter for the action: `name` is set to `helm-charts`. The 4th step is named `Update charts index`. This step runs a script: `helm repo index --url https://cybozu-go.github.io/moco/ --merge index.yaml .`. The 5th step is named ``. This step runs a script: `git add .`. The 6th step is named `Check diffs`. This step runs a script: `diffs=$(git status -s)\nif [ \"$diffs\" = \"\" ]; then\n  echo \"NO_DIFF=1\" >> $GITHUB_ENV\nelse\n  printf \"%s\\n\" \"$diffs\"\nfi\n`. The 7th step is named `Commit changes`. This step will run only if the condition(env.NO_DIFF != '1') is met. This step runs a script: `git config --global user.name 'Cybozu Neco'\ngit config --global user.email 'cybozu-neco@users.noreply.github.com'\ngit commit -m 'update'\n`. The 8th step is named `Push to gh-pages`. This step will run only if the condition(env.NO_DIFF != '1') is met. This step runs a script: `git push origin gh-pages`. "}
{"id": "63c495ca8052faa2781b43be", "level": "level5", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Bump version and push tag\n        id: tagging\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          INITIAL_VERSION: 1.0.0\n          DEFAULT_BUMP: none\n        uses: anothrNick/github-tag-action@1.52.0\n\n      - name: Set up QEMU\n        if: steps.tagging.outputs.part\n        uses: docker/setup-qemu-action@v2\n\n      - name: Set up Docker Buildx\n        if: steps.tagging.outputs.part\n        uses: docker/setup-buildx-action@v2\n\n      - name: Login to DockerHub\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Login to Quay.io\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          registry: quay.io\n          username: ${{ secrets.QUAY_BOT_USERNAME }}\n          password: ${{ secrets.QUAY_BOT_PASSWORD }}\n\n      - name: Build and push\n        id: docker_build\n        if: steps.tagging.outputs.part\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          platforms: linux/amd64,linux/arm64,linux/arm/v7,linux/ppc64le,linux/s390x\n          tags: docker.io/kiwigrid/k8s-sidecar:latest\n                docker.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n                quay.io/kiwigrid/k8s-sidecar:latest\n                quay.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n\n      - name: Build Changelog\n        id: build_changelog\n        if: steps.tagging.outputs.part\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        uses: mikepenz/release-changelog-builder-action@v3\n        with:\n          configuration: .github/workflows/release-notes-config.json\n\n      - name: Create Github Release\n        if: steps.tagging.outputs.part\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        uses: actions/create-release@v1\n        with:\n          tag_name: ${{ steps.tagging.outputs.tag }}\n          release_name: v${{ steps.tagging.outputs.tag }}\n          body: ${{ steps.build_changelog.outputs.changelog }}\n          draft: false\n          prerelease: false\n```", "answer": "```yaml name: Release\non:\n  push:\n    branches:\n      - master\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: '0'\n      - name: Bump version and push tag\n        id: tagging\n        uses: anothrNick/github-tag-action@1.52.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          INITIAL_VERSION: 1.0.0\n          DEFAULT_BUMP: none\n      -\n        name: \"Set up QEMU\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-qemu-action@v2\n      -\n        name: \"Set up Docker Buildx\"\n        if: steps.tagging.outputs.part\n        uses: docker/setup-buildx-action@v2\n      -\n        name: \"Login to DockerHub\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      -\n        name: \"Login to Quay.io\"\n        if: steps.tagging.outputs.part\n        uses: docker/login-action@v2\n        with:\n          registry: quay.io\n          username: ${{ secrets.QUAY_BOT_USERNAME }}\n          password: ${{ secrets.QUAY_BOT_PASSWORD }}\n      -\n        name: \"Build and push\"\n        if: steps.tagging.outputs.part\n        id: docker_build\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          platforms: linux/amd64,linux/arm64,linux/arm/v7,linux/ppc64le,linux/s390x\n          tags: |\n            docker.io/kiwigrid/k8s-sidecar:latest\n            docker.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n            quay.io/kiwigrid/k8s-sidecar:latest\n            quay.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n      - name: \"Build Changelog\"\n        if: steps.tagging.outputs.part\n        id: build_changelog\n        uses: mikepenz/release-changelog-builder-action@v3\n        with:\n          configuration: \".github/workflows/release-notes-config.json\"\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      - name: \"Create Github Release\"\n        if: steps.tagging.outputs.part\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token\n        with:\n          tag_name: ${{ steps.tagging.outputs.tag }}\n          release_name: v${{ steps.tagging.outputs.tag }}\n          body: ${{ steps.build_changelog.outputs.changelog }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 9 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Bump version and push tag` and its id is `tagging`. The step sets 3 environment variables to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`, `INITIAL_VERSION` is set to `1.0.0` and `DEFAULT_BUMP` is set to `none`. This step runs action `anothrNick/github-tag-action` tagged as 1.52.0. The 3rd step is named `Set up QEMU`. This step will run only if the condition(steps.tagging.outputs.part) is met. This step runs action `docker/setup-qemu-action` tagged as v2. The 4th step is named `Set up Docker Buildx`. This step will run only if the condition(steps.tagging.outputs.part) is met. This step runs action `docker/setup-buildx-action` tagged as v2. The 5th step is named `Login to DockerHub`. This step will run only if the condition(steps.tagging.outputs.part) is met. This step runs action `docker/login-action` tagged as v2. The step defines 2 input parameters for the action: `username` is set to `${{ secrets.DOCKER_USERNAME }}` and `password` is set to `${{ secrets.DOCKER_PASSWORD }}`. The 6th step is named `Login to Quay.io`. This step will run only if the condition(steps.tagging.outputs.part) is met. This step runs action `docker/login-action` tagged as v2. The step defines 3 input parameters for the action: `registry` is set to `quay.io`, `username` is set to `${{ secrets.QUAY_BOT_USERNAME }}` and `password` is set to `${{ secrets.QUAY_BOT_PASSWORD }}`. The 7th step is named `Build and push` and its id is `docker_build`. This step will run only if the condition(steps.tagging.outputs.part) is met. This step runs action `docker/build-push-action` tagged as v3. The step defines 3 input parameters for the action: `push` is set to `True`, `platforms` is set to `linux/amd64,linux/arm64,linux/arm/v7,linux/ppc64le,linux/s390x` and `tags` is set to `docker.io/kiwigrid/k8s-sidecar:latest\ndocker.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\nquay.io/kiwigrid/k8s-sidecar:latest\nquay.io/kiwigrid/k8s-sidecar:${{ steps.tagging.outputs.tag }}\n`. The 8th step is named `Build Changelog` and its id is `build_changelog`. This step will run only if the condition(steps.tagging.outputs.part) is met. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `mikepenz/release-changelog-builder-action` tagged as v3. The step defines an input parameter for the action: `configuration` is set to `.github/workflows/release-notes-config.json`. The 9th step is named `Create Github Release`. This step will run only if the condition(steps.tagging.outputs.part) is met. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `actions/create-release` tagged as v1. The step defines 5 input parameters for the action: `tag_name` is set to `${{ steps.tagging.outputs.tag }}`, `release_name` is set to `v${{ steps.tagging.outputs.tag }}`, `body` is set to `${{ steps.build_changelog.outputs.changelog }}`, `draft` is set to `False` and `prerelease` is set to `False`. "}
{"id": "63c494007843b612699fe516", "level": "level5", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  repository_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-20.04\n    strategy:\n      matrix:\n        py: [3.7]\n        pylint: [==2.9.6]\n        go: [1.18, 1.19]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.py }}\n\n    - name: Install pylint\n      run: pip install --user pylint${{ matrix.pylint }}\n\n    - name: pylint\n      run: pylint adapters/python/martian_shell.py\n                  adapters/python/martian.py\n                  test/martian_test.py\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: 'lts/*'\n        cache: 'npm'\n        cache-dependency-path: 'web/martian/yarn.lock\n                              tools/syntax/vscode/yarn.lock'\n\n    - name: Make all\n      run: make all tarball\n\n    - name: Darwin build\n      run: GOOS=darwin go build ./cmd/...\n\n    - name: Integration tests\n      run: make longtests\n\n  bazel:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.x'\n\n    - name: Set up Go\n      id: setup_go\n      uses: actions/setup-go@v3\n      with:\n        go-version: '>=1.19'\n\n    - name: Show bazel variables\n      run: |\n        bazel info\n        echo \"bazel_repository_cache=$(bazel info repository_cache)\" >> $GITHUB_ENV\n        echo \"bazel_output_base=$(bazel info output_base)\" >> $GITHUB_ENV\n\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v3\n      with:\n        path: ${{ env.bazel_output_base }}/external\n        key: bazel-build-cache-${{steps.setup_go.outputs.go-version}}-${{hashFiles('deps.bzl', 'WORKSPACE')}}\n        restore-keys: bazel-build-cache-${{steps.setup_go.outputs.go-version}}\n                           bazel-build-cache-\n\n    - name: Cache bazel external repositories\n      uses: actions/cache@v3\n      with:\n        path: ${{ env.bazel_repository_cache }}\n        key: bazel-repo-cache-${{hashFiles('deps.bzl', 'WORKSPACE', 'web/martian/yarn.lock')}}\n        restore-keys: bazel-repo-cache-\n\n    - name: test\n      run: bazel test --nobuild_tests_only \\\n                     --verbose_failures \\\n                     --discard_analysis_cache \\\n                     --notrack_incremental_state \\\n                     --nokeep_state_after_build \\\n                     //...\n\n    - name: Show build timing summary\n      run: bazel analyze-profile ${{ env.bazel_output_base }}/command.profile.gz\n```", "answer": "```yaml name:\n  Test\n\non:\n  push\n\npermissions:\n  contents: read\n\njobs:\n  make:\n    runs-on: ubuntu-20.04\n    strategy:\n      matrix:\n        py: [\"3.7\"]\n        pylint: [\"==2.9.6\"]\n        go: [ \"1.18\", \"1.19\" ]\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.py }}\n    - name: Install pylint\n      run: pip install --user pylint${{ matrix.pylint }}\n    - name: pylint\n      run: |\n        pylint adapters/python/martian_shell.py\n        pylint adapters/python/martian.py\n        pylint test/martian_test.py\n    - uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n    - uses: actions/setup-node@v3\n      with:\n        node-version: \"lts/*\"\n        cache: \"npm\"\n        cache-dependency-path: |\n          web/martian/yarn.lock\n          tools/syntax/vscode/yarn.lock\n    - name: make all\n      run: make all tarball\n    - name: darwin build\n      run: GOOS=darwin go build ./cmd/...\n    - name: Integration tests\n      run: make longtests\n\n  bazel:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: \"3.x\"\n    - uses: actions/setup-go@v3\n      id: setup_go\n      with:\n        go-version: \">=1.19\"\n    - name: Show bazel variables\n      run: |\n        bazel info\n        echo \"bazel_repository_cache=$(bazel info repository_cache)\" >> $GITHUB_ENV\n        echo \"bazel_output_base=$(bazel info output_base)\" >> $GITHUB_ENV\n    - name: Cache bazel build of external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_output_base }}/external\n        key: bazel-build-cache-${{steps.setup_go.outputs.go-version}}-${{hashFiles('deps.bzl', 'WORKSPACE')}}\n        restore-keys: |\n          bazel-build-cache-${{steps.setup_go.outputs.go-version}}\n          bazel-build-cache-\n    - name: Cache bazel external repositories\n      uses: actions/cache@v3\n      with:\n        path: |\n          ${{ env.bazel_repository_cache }}\n        key: bazel-repo-cache-${{hashFiles('deps.bzl', 'WORKSPACE', 'web/martian/yarn.lock')}}\n        restore-keys: |\n          bazel-repo-cache-\n    - name: test\n      run: |\n        bazel test --nobuild_tests_only \\\n                   --verbose_failures \\\n                   --discard_analysis_cache \\\n                   --notrack_incremental_state \\\n                   --nokeep_state_after_build \\\n                   //...\n    - name: Show build timing summary\n      run: bazel analyze-profile ${{ env.bazel_output_base }}/command.profile.gz\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `make`. This job will run on ubuntu-20.04 runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `py` has one value: 3.7. The variable `pylint` has one value: ==2.9.6. The variable `go` has 2 values: 1.18 and 1.19. The job `make` has 9 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `${{ matrix.py }}`. The 3rd step is named `Install pylint`. This step runs a script: `pip install --user pylint${{ matrix.pylint }}`. The 4th step is named `pylint`. This step runs a script: `pylint adapters/python/martian_shell.py\npylint adapters/python/martian.py\npylint test/martian_test.py\n`. The 5th step is named ``. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `${{ matrix.go }}`. The 6th step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines 3 input parameters for the action: `node-version` is set to `lts/*`, `cache` is set to `npm` and `cache-dependency-path` is set to `web/martian/yarn.lock\ntools/syntax/vscode/yarn.lock\n`. The 7th step is named `make all`. This step runs a script: `make all tarball`. The 8th step is named `darwin build`. This step runs a script: `GOOS=darwin go build ./cmd/...`. The 9th step is named `Integration tests`. This step runs a script: `make longtests`. The job id of the 2nd job is `bazel`. This job will run on ubuntu-latest runner. The job `bazel` has 8 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `3.x`. The 3rd step is named `` and its id is `setup_go`. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `>=1.19`. The 4th step is named `Show bazel variables`. This step runs a script: `bazel info\necho \"bazel_repository_cache=$(bazel info repository_cache)\" >> $GITHUB_ENV\necho \"bazel_output_base=$(bazel info output_base)\" >> $GITHUB_ENV\n`. The 5th step is named `Cache bazel build of external repositories`. This step runs action `actions/cache` tagged as v3. The step defines 3 input parameters for the action: `path` is set to `${{ env.bazel_output_base }}/external\n`, `key` is set to `bazel-build-cache-${{steps.setup_go.outputs.go-version}}-${{hashFiles('deps.bzl', 'WORKSPACE')}}` and `restore-keys` is set to `bazel-build-cache-${{steps.setup_go.outputs.go-version}}\nbazel-build-cache-\n`. The 6th step is named `Cache bazel external repositories`. This step runs action `actions/cache` tagged as v3. The step defines 3 input parameters for the action: `path` is set to `${{ env.bazel_repository_cache }}\n`, `key` is set to `bazel-repo-cache-${{hashFiles('deps.bzl', 'WORKSPACE', 'web/martian/yarn.lock')}}` and `restore-keys` is set to `bazel-repo-cache-\n`. The 7th step is named `test`. This step runs a script: `bazel test --nobuild_tests_only \\\n           --verbose_failures \\\n           --discard_analysis_cache \\\n           --notrack_incremental_state \\\n           --nokeep_state_after_build \\\n           //...\n`. The 8th step is named `Show build timing summary`. This step runs a script: `bazel analyze-profile ${{ env.bazel_output_base }}/command.profile.gz`. "}
{"id": "63c494257843b612699ff4b7", "level": "level5", "llm_response": "```yaml\nname: functional-identity\n\non:\n  pull_request:\n    paths:\n      - '**/identity/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-identity:\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    strategy:\n      matrix:\n        name: [master]\n        openstack_version: [master]\n        ubuntu_version: [20.04]\n        additional_values: \n          - name: yoga\n            openstack_version: stable/yoga\n            ubuntu_version: 20.04\n          - name: xena\n            openstack_version: stable/xena\n            ubuntu_version: 20.04\n          - name: wallaby\n            openstack_version: stable/wallaby\n            ubuntu_version: 20.04\n          - name: victoria\n            openstack_version: stable/victoria\n            ubuntu_version: 20.04\n          - name: ussuri\n            openstack_version: stable/ussuri\n            ubuntu_version: 18.04\n          - name: train\n            openstack_version: stable/train\n            ubuntu_version: 18.04\n\n    steps:\n    - name: Checkout Gophercloud\n      uses: actions/checkout@v3\n\n    - name: Deploy devstack\n      uses: EmilienM/devstack-action@v0.9\n      with:\n        branch: ${{ matrix.openstack_version }}\n\n    - name: Checkout go\n      uses: actions/setup-go@v3\n      with:\n        go-version: '^1.15'\n\n    - name: Run Gophercloud acceptance tests\n      env:\n        DEVSTACK_PATH: ${{ github.workspace }}/devstack\n        ACCEPTANCE_TESTS_FILTER: '^.*identity.*$'\n      run: ./script/acceptancetest\n\n    - name: Generate logs on failure\n      if: failure()\n      run: ./script/collectlogs\n\n    - name: Upload logs artifacts on failure\n      if: failure()\n      uses: actions/upload-artifact@v3\n      with:\n        name: functional-identity-${{ matrix.name }}\n        path: /tmp/devstack-logs/*\n```", "answer": "```yaml name: functional-identity\non:\n  pull_request:\n    paths:\n      - '**identity**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-identity:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: \"^.*identity.*$\"\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-identity-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-identity` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**identity**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Keystone and run identity acceptance tests` and its job id is `functional-identity`. This job will run on ubuntu-${{ matrix.ubuntu_version }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `name` has one value: master. The variable `openstack_version` has one value: master. The variable `ubuntu_version` has one value: 20.04. For each object in the [{'name': 'yoga', 'openstack_version': 'stable/yoga', 'ubuntu_version': '20.04'}, {'name': 'xena', 'openstack_version': 'stable/xena', 'ubuntu_version': '20.04'}, {'name': 'wallaby', 'openstack_version': 'stable/wallaby', 'ubuntu_version': '20.04'}, {'name': 'victoria', 'openstack_version': 'stable/victoria', 'ubuntu_version': '20.04'}, {'name': 'ussuri', 'openstack_version': 'stable/ussuri', 'ubuntu_version': '18.04'}, {'name': 'train', 'openstack_version': 'stable/train', 'ubuntu_version': '18.04'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `functional-identity` has 6 steps. The 1st step is named `Checkout Gophercloud`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Deploy devstack`. This step runs action `EmilienM/devstack-action` tagged as v0.9. The step defines an input parameter for the action: `branch` is set to `${{ matrix.openstack_version }}`. The 3rd step is named `Checkout go`. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `^1.15`. The 4th step is named `Run Gophercloud acceptance tests`. The step sets 2 environment variables to use: `DEVSTACK_PATH` is set to `${{ github.workspace }}/devstack` and `ACCEPTANCE_TESTS_FILTER` is set to `^.*identity.*$`. This step runs a script: `./script/acceptancetest`. The 5th step is named `Generate logs on failure`. This step will run only if the condition(failure()) is met. This step runs a script: `./script/collectlogs`. The 6th step is named `Upload logs artifacts on failure`. This step will run only if the condition(failure()) is met. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `functional-identity-${{ matrix.name }}` and `path` is set to `/tmp/devstack-logs/*`. "}
{"id": "63c495038052faa2781aede6", "level": "level5", "llm_response": "```yaml\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n        numpy_version: [\">=1.22.0\", \"==1.20.*\"]\n      exclude:\n        - python-version: 3.10\n          numpy_version: \"==1.20.*\"\n\n    services:\n      redis:\n        image: redis\n        ports:\n          - 6379:6379\n        options: --health-cmd \"redis-cli ping\" --health-interval 10s --health-timeout 5s --health-retries 5\n      mongodb:\n        image: mongo:4.4.11\n        ports:\n          - 27017:27017\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Setup Miniconda\n      uses: conda-incubator/setup-miniconda@master\n      with:\n        channels: conda-forge\n        python-version: ${{ matrix.python-version }}\n      env:\n        ACTIONS_ALLOW_UNSECURE_COMMANDS: True\n\n    - name: Create Conda environment with the rights deps\n      run: bash -l -c \"conda create -n zarr-env python==${{matrix.python-version}} bsddb3 numcodecs lmdb pip nodejs flake8 mypy\nconda activate zarr-env\nnpm install -g azurite\"\n      shell: bash -l {0}\n\n    - name: Install dependencies\n      run: bash -l -c \"conda activate zarr-env\npython -m pip install --upgrade pip\npython -m pip install -U pip setuptools wheel codecov line_profiler\npython -m pip install -rrequirements_dev_minimal.txt numpy${{matrix.numpy_version}} -rrequirements_dev_optional.txt pymongo redis\npython -m pip install .\npython -m pip freeze\"\n      shell: bash -l {0}\n\n    - name: Tests\n      env:\n        COVERAGE_FILE: .coverage.${{matrix.python-version}}.${{matrix.numpy_version}}\n        ZARR_TEST_ABS: 1\n        ZARR_TEST_MONGO: 1\n        ZARR_TEST_REDIS: 1\n        ZARR_V3_EXPERIMENTAL_API: 1\n      run: bash -l -c \"conda activate zarr-env\nmkdir ~/blob_emulator\nazurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\npytest --cov=zarr --cov-config=.coveragerc --doctest-plus --cov-report xml --cov=./ --timeout=300\"\n      shell: bash -l {0}\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        verbose: true\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Linux Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n        numpy_version: ['>=1.22.0', '==1.20.*']\n        exclude:\n          - python-version: '3.10'\n            numpy_version: '==1.20.*'\n    services:\n      redis:\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n      mongodb:\n        image: mongo:4.4.11\n        ports:\n          - 27017:27017\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Setup Miniconda\n      uses: conda-incubator/setup-miniconda@master\n      with:\n          channels: conda-forge\n          python-version: ${{ matrix.python-version }}\n      env:\n        ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n    # Runs a set of commands using the runners shell\n    - name: Create Conda environment with the rights deps\n      shell: \"bash -l {0}\"\n      run: |\n        conda create -n zarr-env python==${{matrix.python-version}} bsddb3 numcodecs lmdb pip nodejs flake8 mypy\n        conda activate zarr-env\n        npm install -g azurite\n    - name: Install dependencies\n      shell: \"bash -l {0}\"\n      run: |\n        conda activate zarr-env\n        python -m pip install --upgrade pip\n        python -m pip install -U pip setuptools wheel codecov line_profiler\n        python -m pip install -rrequirements_dev_minimal.txt numpy${{matrix.numpy_version}} -rrequirements_dev_optional.txt pymongo redis\n        python -m pip install .\n        python -m pip freeze\n    - name: Tests\n      shell: \"bash -l {0}\"\n      env:\n        COVERAGE_FILE: .coverage.${{matrix.python-version}}.${{matrix.numpy_version}}\n        ZARR_TEST_ABS: 1\n        ZARR_TEST_MONGO: 1\n        ZARR_TEST_REDIS: 1\n        ZARR_V3_EXPERIMENTAL_API: 1\n      run: |\n        conda activate zarr-env\n        mkdir ~/blob_emulator\n        azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n        pytest --cov=zarr --cov-config=.coveragerc --doctest-plus --cov-report xml --cov=./ --timeout=300\n    - uses: codecov/codecov-action@v3\n      with:\n        #token: ${{ secrets.CODECOV_TOKEN }} # not required for public repos\n          #files: ./coverage1.xml,./coverage2.xml # optional\n          #flags: unittests # optional\n          #name: codecov-umbrella # optional\n          #fail_ci_if_error: true # optional (default = false)\n        verbose: true # optional (default = false)\n```", "prompt": "Generate a GitHub Workflow named `Linux Testing` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `python-version` has 3 values: 3.8, 3.9 and 3.10. The variable `numpy_version` has 2 values: >=1.22.0 and ==1.20.*. If combinations of variables partially match one of the objects [{'python-version': '3.10', 'numpy_version': '==1.20.*'}], combinations should be excluded from the matrix. The job defines a service called redis which will be created using the Docker image `redis`. For communication, the port 6379 on the Docker host is mapped to port 6379 on the service container. It configures additional Docker container resource options: --health-cmd \"redis-cli ping\" --health-interval 10s --health-timeout 5s --health-retries 5. The job defines a service called mongodb which will be created using the Docker image `mongo:4.4.11`. For communication, the port 27017 on the Docker host is mapped to port 27017 on the service container. The job `build` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Setup Miniconda`. The step sets an environment variable to use: `ACTIONS_ALLOW_UNSECURE_COMMANDS` is set to `True`. This step runs action `conda-incubator/setup-miniconda` from the master branch. The step defines 2 input parameters for the action: `channels` is set to `conda-forge` and `python-version` is set to `${{ matrix.python-version }}`. The 3rd step is named `Create Conda environment with the rights deps`. This step uses a custom shell bash -l {0} to run a script: `conda create -n zarr-env python==${{matrix.python-version}} bsddb3 numcodecs lmdb pip nodejs flake8 mypy\nconda activate zarr-env\nnpm install -g azurite\n`. The 4th step is named `Install dependencies`. This step uses a custom shell bash -l {0} to run a script: `conda activate zarr-env\npython -m pip install --upgrade pip\npython -m pip install -U pip setuptools wheel codecov line_profiler\npython -m pip install -rrequirements_dev_minimal.txt numpy${{matrix.numpy_version}} -rrequirements_dev_optional.txt pymongo redis\npython -m pip install .\npython -m pip freeze\n`. The 5th step is named `Tests`. The step sets 5 environment variables to use: `COVERAGE_FILE` is set to `.coverage.${{matrix.python-version}}.${{matrix.numpy_version}}`, `ZARR_TEST_ABS` is set to `1`, `ZARR_TEST_MONGO` is set to `1`, `ZARR_TEST_REDIS` is set to `1` and `ZARR_V3_EXPERIMENTAL_API` is set to `1`. This step uses a custom shell bash -l {0} to run a script: `conda activate zarr-env\nmkdir ~/blob_emulator\nazurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\npytest --cov=zarr --cov-config=.coveragerc --doctest-plus --cov-report xml --cov=./ --timeout=300\n`. The 6th step is named ``. This step runs action `codecov/codecov-action` tagged as v3. The step defines an input parameter for the action: `verbose` is set to `True`. "}
{"id": "63c4967e33b087f6bde2c5c4", "level": "level5", "llm_response": "```yaml\nname: Build and Deploy\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install and Build \ud83d\udd27\n        run: |\n          npm install\n          npm run build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.0.0\n        with:\n          branch: gh-pages\n          folder: dist\n```", "answer": "```yaml name: Build and Deploy\non:\n  push:\n    branches:\n    - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n        \n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install\n          npm run build\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.0.0\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist #  The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Build and Deploy` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `build-and-deploy`. This job will run on ubuntu-latest runner. The job `build-and-deploy` has 3 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. This step runs action `actions/checkout` tagged as v2.3.1. The 2nd step is named `Install and Build \ud83d\udd27`. This step runs a script: `npm install\nnpm run build\n`. The 3rd step is named `Deploy \ud83d\ude80`. This step runs action `JamesIves/github-pages-deploy-action` tagged as 4.0.0. The step defines 2 input parameters for the action: `branch` is set to `gh-pages` and `folder` is set to `dist`. "}
{"id": "63c496926fc19abdf9c9cd93", "level": "level5", "llm_response": "```yaml\nname: Contributor License Agreement (CLA)\n\non:\n  pull_request:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.issue.pull_request && !github.event.issue.pull_request.merged_at && contains(github.event.comment.body, 'signed') || github.event.pull_request && !github.event.pull_request.merged }}\n    steps:\n      - name: Check CLA\n        uses: Shopify/shopify-cla-action@v1\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          cla-token: ${{ secrets.CLA_TOKEN }}\n```", "answer": "```yaml name: Contributor License Agreement (CLA)\n\non:\n  pull_request_target:\n    types: [opened, synchronize]\n  issue_comment:\n    types: [created]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    if: |\n      (github.event.issue.pull_request \n        && !github.event.issue.pull_request.merged_at\n        && contains(github.event.comment.body, 'signed')\n      ) \n      || (github.event.pull_request && !github.event.pull_request.merged)\n    steps:\n      - uses: Shopify/shopify-cla-action@v1\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          cla-token: ${{ secrets.CLA_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Contributor License Agreement (CLA)` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) a pull request is created or a pull request's head branch is updated. 2) a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `cla`. This job will run only if the condition((github.event.issue.pull_request \n  && !github.event.issue.pull_request.merged_at\n  && contains(github.event.comment.body, 'signed')\n) \n|| (github.event.pull_request && !github.event.pull_request.merged)\n) is met. This job will run on ubuntu-latest runner. The job `cla` has one step. The 1st step is named ``. This step runs action `Shopify/shopify-cla-action` tagged as v1. The step defines 2 input parameters for the action: `github-token` is set to `${{ secrets.GITHUB_TOKEN }}` and `cla-token` is set to `${{ secrets.CLA_TOKEN }}`. "}
{"id": "63c496836fc19abdf9c9c720", "level": "level5", "llm_response": "```yaml\nname: TagBot\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: TagBot\n        uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: TagBot\non:\n  schedule:\n    - cron: 0 0 * * *\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `TagBot`. This job will run on ubuntu-latest runner. The job `TagBot` has one step. The 1st step is named ``. This step runs action `JuliaRegistries/TagBot` tagged as v1. The step defines an input parameter for the action: `token` is set to `${{ secrets.GITHUB_TOKEN }}`. "}
{"id": "63c496741e3364807577abc2", "level": "level5", "llm_response": "```yaml\nname: TagBot\n\non:\n  issue_comment:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    steps:\n    - uses: JuliaRegistries/TagBot@v1\n      with:\n        token: ${{ secrets.GITHUB_TOKEN }}\n        ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. This job will run only if the condition(github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot') is met. This job will run on ubuntu-latest runner. The job `TagBot` has one step. The 1st step is named ``. This step runs action `JuliaRegistries/TagBot` tagged as v1. The step defines 2 input parameters for the action: `token` is set to `${{ secrets.GITHUB_TOKEN }}` and `ssh` is set to `${{ secrets.DOCUMENTER_KEY }}`. "}
{"id": "63c495f37843b61269a0b108", "level": "level5", "llm_response": "```yaml\nname: PR Approval Bypass Notifier\n\non:\n  pull_request:\n    branches:\n      - main\n    types: [closed]\n\npermissions:\n  pull-requests: read\n\njobs:\n  approval:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Fail If No Approval\n        if: github.event.pull_request.merged\n        env:\n          AUTH_HEADER: Authorization: token ${{ secrets.GITHUB_TOKEN }}\n          JSON_HEADER: Content-Type: application/json\n          REVIEWS_URL: https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews\n        run: |\n          curl -sSL -H \"${JSON_HEADER}\" -H \"${AUTH_HEADER}\" \"${REVIEWS_URL}\" \\\n            | jq -e '. | map({user: .user.login, state: .state})\n                       | reduce .[] as $x ({}; .[$x.user] = $x.state)\n                       | to_entries | map(.value)\n                       | contains([\"APPROVED\"]) and (contains([\"CHANGES_REQUESTED\"]) | not)'\n\n      - name: Slack Notification\n        if: failure()\n        run: |\n          jq --null-input '{ text: \"Oh no! The following PR was merged without approval: w${{github.event.pull_request.html_url}}\" }' \\\n          | curl -sSL -X POST -H 'Content-Type: application/json' -d @- '${{ secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK }}'\n```", "answer": "```yaml name: PR Approval Bypass Notifier\non:\n  pull_request:\n    types:\n      - closed\n    branches:\n      - main\npermissions:\n  pull-requests: read\njobs:\n  approval:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Fail If No Approval\n        if: ${{ github.event.pull_request.merged }}\n        env:\n          AUTH_HEADER: 'Authorization: token ${{ secrets.GITHUB_TOKEN }}'\n          JSON_HEADER: 'Content-Type: application/json'\n          REVIEWS_URL: 'https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews'\n        run: |\n          curl -sSL -H \"${JSON_HEADER}\" -H \"${AUTH_HEADER}\" \"${REVIEWS_URL}\" \\\n            | jq -e '. | map({user: .user.login, state: .state})\n                       | reduce .[] as $x ({}; .[$x.user] = $x.state)\n                       | to_entries | map(.value)\n                       | contains([\"APPROVED\"]) and (contains([\"CHANGES_REQUESTED\"]) | not)'\n      - name: Slack Notification\n        if: ${{ failure() }}\n        run: |\n          jq --null-input '{ text: \"Oh no! The following PR was merged without approval: w${{github.event.pull_request.html_url}}\" }' \\\n          | curl -sSL -X POST -H 'Content-Type: application/json' -d @- '${{ secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK }}'\n```", "prompt": "Generate a GitHub Workflow named `PR Approval Bypass Notifier` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is closed. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `approval`. This job will run on ubuntu-latest runner. The job `approval` has 2 steps. The 1st step is named `Fail If No Approval`. This step will run only if the condition(${{ github.event.pull_request.merged }}) is met. The step sets 3 environment variables to use: `AUTH_HEADER` is set to `Authorization: token ${{ secrets.GITHUB_TOKEN }}`, `JSON_HEADER` is set to `Content-Type: application/json` and `REVIEWS_URL` is set to `https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews`. This step runs a script: `curl -sSL -H \"${JSON_HEADER}\" -H \"${AUTH_HEADER}\" \"${REVIEWS_URL}\" \\\n  | jq -e '. | map({user: .user.login, state: .state})\n             | reduce .[] as $x ({}; .[$x.user] = $x.state)\n             | to_entries | map(.value)\n             | contains([\"APPROVED\"]) and (contains([\"CHANGES_REQUESTED\"]) | not)'\n`. The 2nd step is named `Slack Notification`. This step will run only if the condition(${{ failure() }}) is met. This step runs a script: `jq --null-input '{ text: \"Oh no! The following PR was merged without approval: w${{github.event.pull_request.html_url}}\" }' \\\n| curl -sSL -X POST -H 'Content-Type: application/json' -d @- '${{ secrets.SLACK_MERGE_WITHOUT_APPROVAL_WEBHOOK }}'\n`. "}
{"id": "63c496561e3364807577a06a", "level": "level5", "llm_response": "```yaml\nname: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '30 17 * * *'\n\nenv:\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n\n      - name: Install dependencies\n        run: yarn\n\n      - name: Run script\n        run: yarn rq\n```", "answer": "```yaml name: Gather RQ statistical data and write it to google sheet\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"30 17 * * *\"\n#  push:\n#    branches:\n#      - main\n\nenv:\n  # please change to your own config.\n  RQ_COOKIE: ${{ secrets.RQ_COOKIE }}\n  RQ_CSRF_TOKEN: ${{ secrets.RQ_CSRF_TOKEN }}\n  RQ_USERID: ${{ secrets.RQ_USERID }}\n  GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}\n  GOOGLE_API_CLIENT_EMAIL: ${{ secrets.GOOGLE_API_CLIENT_EMAIL }}\n  GOOGLE_API_PRIVATE_KEY: ${{ secrets.GOOGLE_API_PRIVATE_KEY }}\n  BARK_KEY: ${{ secrets.BARK_KEY }}\n  GARMIN_USERNAME: ${{ secrets.GARMIN_USERNAME }}\n  GARMIN_PASSWORD: ${{ secrets.GARMIN_PASSWORD }}\n  GARMIN_GLOBAL_USERNAME: ${{ secrets.GARMIN_GLOBAL_USERNAME }}\n  GARMIN_GLOBAL_PASSWORD: ${{ secrets.GARMIN_GLOBAL_PASSWORD }}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    name: Gather RQ statistical data and write it to google sheet\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n      - run: yarn\n      - run: yarn rq\n```", "prompt": "Generate a GitHub Workflow named `Gather RQ statistical data and write it to google sheet` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 05:30 pm. The workflow sets 11 environment variables to use: `RQ_COOKIE` is set to `${{ secrets.RQ_COOKIE }}`, `RQ_CSRF_TOKEN` is set to `${{ secrets.RQ_CSRF_TOKEN }}`, `RQ_USERID` is set to `${{ secrets.RQ_USERID }}`, `GOOGLE_SHEET_ID` is set to `${{ secrets.GOOGLE_SHEET_ID }}`, `GOOGLE_API_CLIENT_EMAIL` is set to `${{ secrets.GOOGLE_API_CLIENT_EMAIL }}`, `GOOGLE_API_PRIVATE_KEY` is set to `${{ secrets.GOOGLE_API_PRIVATE_KEY }}`, `BARK_KEY` is set to `${{ secrets.BARK_KEY }}`, `GARMIN_USERNAME` is set to `${{ secrets.GARMIN_USERNAME }}`, `GARMIN_PASSWORD` is set to `${{ secrets.GARMIN_PASSWORD }}`, `GARMIN_GLOBAL_USERNAME` is set to `${{ secrets.GARMIN_GLOBAL_USERNAME }}` and `GARMIN_GLOBAL_PASSWORD` is set to `${{ secrets.GARMIN_GLOBAL_PASSWORD }}`. The workflow has one job. The 1st job is named `Gather RQ statistical data and write it to google sheet` and its job id is `build`. This job will run on ubuntu-latest runner. The job `build` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines 2 input parameters for the action: `node-version` is set to `14` and `cache` is set to `yarn`. The 3rd step is named ``. This step runs a script: `yarn`. The 4th step is named ``. This step runs a script: `yarn rq`. "}
{"id": "63c4957d8052faa2781b22a0", "level": "level5", "llm_response": "```yaml\nname: Close stale\n\non:\n  schedule:\n    - cron: '0 1 * * *'\n\njobs:\n  stale:\n    id: stale\n    uses: knative/actions/.github/workflows/stale.yaml@main\n```", "answer": "```yaml # Copyright 2020 The Knative Authors.\n# SPDX-License-Identifier: Apache-2.0\n\n# This file is automagically synced here from github.com/knative-sandbox/knobots\nname: 'Close stale'\n\non:\n  schedule:\n  - cron: '0 1 * * *'\n\njobs:\n\n  stale:\n    uses: knative/actions/.github/workflows/stale.yaml@main\n```", "prompt": "Generate a GitHub Workflow named `Close stale` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 01:00 am. The workflow has one job. The job id of the 1st job is `stale`. This job will call a reusable workflow located at `knative/actions/.github/workflows/stale.yaml@main`. "}
{"id": "63c4959f7843b61269a08d83", "level": "level5", "llm_response": "```yaml\nname: CompatHelper\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: [1.2.0]\n        julia-arch: [x86]\n        os: [ubuntu-latest]\n\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n\n      - name: CompatHelper.main()\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          COMPATHELPER_PRIV: ${{ secrets.TAGBOT }}\n        run: julia -e 'using CompatHelper; CompatHelper.main()'\n```", "answer": "```yaml name: CompatHelper\n\non:\n  schedule:\n    - cron: '00 00 * * *'\n  workflow_dispatch:\n\njobs:\n  CompatHelper:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: [1.2.0]\n        julia-arch: [x86]\n        os: [ubuntu-latest]\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n      - name: CompatHelper.main()\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          COMPATHELPER_PRIV: ${{ secrets.TAGBOT }}\n        run: julia -e 'using CompatHelper; CompatHelper.main()'\n```", "prompt": "Generate a GitHub Workflow named `CompatHelper` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `CompatHelper`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `julia-version` has one value: 1.2.0. The variable `julia-arch` has one value: x86. The variable `os` has one value: ubuntu-latest. The job `CompatHelper` has 2 steps. The 1st step is named `Pkg.add(\"CompatHelper\")`. This step runs a script: `julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'`. The 2nd step is named `CompatHelper.main()`. The step sets 2 environment variables to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}` and `COMPATHELPER_PRIV` is set to `${{ secrets.TAGBOT }}`. This step runs a script: `julia -e 'using CompatHelper; CompatHelper.main()'`. "}
{"id": "63c494358052faa2781a9de3", "level": "level5", "llm_response": "```yaml\nname: JumpServer repos generic handler\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  release:\n    types: [created]\n\njobs:\n  generic_handler:\n    id: generic_handler\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Set up JumpServer generic handler\n      env:\n        GITHUB_TOKEN: ${{ secrets.PRIVATE_TOKEN }}\n      uses: jumpserver/action-generic-handler@master\n```", "answer": "```yaml on: [push, pull_request, release]\n\nname: JumpServer repos generic handler\n\njobs:\n  generic_handler:\n    name: Run generic handler\n    runs-on: ubuntu-latest\n    steps:\n      - uses: jumpserver/action-generic-handler@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.PRIVATE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `JumpServer repos generic handler` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. 3) release activity in the repository occurs. The workflow has one job. The 1st job is named `Run generic handler` and its job id is `generic_handler`. This job will run on ubuntu-latest runner. The job `generic_handler` has one step. The 1st step is named ``. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.PRIVATE_TOKEN }}`. This step runs action `jumpserver/action-generic-handler` from the master branch. "}
{"id": "63c494998052faa2781ac05b", "level": "level5", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - dev\n  pull_request:\n    branches:\n      - dev\n  schedule:\n    - cron: '6 13 * * *'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n    strategy:\n      matrix:\n        language: [java, javascript]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: ${{ matrix.language }}\n      - name: Autobuild\n        run: |\n          cd etc/build\n          npm install workbox-cli@6.3.0 --global\n          ant\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ dev ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ dev ]\n  schedule:\n    - cron: '06 13 * * *'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java', 'javascript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://git.io/codeql-language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      run: |\n        cd etc/build\n        npm install workbox-cli@6.3.0 --global\n        ant\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 01:06 pm. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has 2 values: java and javascript. The job `analyze` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `actions` scope, read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `security-events` scope. This permission setting only applies to the job `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Initialize CodeQL`. This step runs action `github/codeql-action/init` tagged as v2. The step defines an input parameter for the action: `languages` is set to `${{ matrix.language }}`. The 3rd step is named `Autobuild`. This step runs a script: `cd etc/build\nnpm install workbox-cli@6.3.0 --global\nant\n`. The 4th step is named `Perform CodeQL Analysis`. This step runs action `github/codeql-action/analyze` tagged as v2. "}
{"id": "63c494298052faa2781a98fa", "level": "level5", "llm_response": "```yaml\nname: Check test times\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Cache\n      uses: hendrikmuhs/ccache-action@v1.2\n      with:\n        key: linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-${{ hashFiles('**/*.hpp', '**/*.cpp') }}\n        restore-keys: |\n          linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-\n          linux-ci-build-times-${{ github.ref }}-\n          linux-ci-build-times-refs/heads/master-\n          linux-ci-build-times-\n\n    - name: Setup\n      run: |\n        sudo apt update\n        sudo apt install -y libboost-dev autoconf automake libtool ccache\n\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"ccache gcc\" CXX=\"ccache g++\" CXXFLAGS=\"-O2 -g0\"\n        make -j 2\n\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,faster.xml:HRF,message -- --faster\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,fast.xml:HRF,message -- --fast\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,all.xml:HRF,message\n\n    - name: Save test times\n      uses: actions/upload-artifact@v3\n      with:\n        name: test-reports\n        path: ./all.xml\n\n    - name: Check test times\n      run: |\n        python ./tools/check_test_times.py\n```", "answer": "```yaml name: Check test times\non: [push, pull_request]\njobs:\n  check-test-times:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Cache\n      uses: hendrikmuhs/ccache-action@v1.2\n      with:\n        key: linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-${{ hashFiles('**/*.hpp', '**/*.cpp') }}\n        restore-keys: |\n          linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-\n          linux-ci-build-times-${{ github.ref }}-\n          linux-ci-build-times-refs/heads/master-\n          linux-ci-build-times-\n    - name: Setup\n      run: |\n        sudo apt update\n        sudo apt install -y libboost-dev autoconf automake libtool ccache\n    - name: Build\n      run: |\n        ./autogen.sh\n        ./configure --disable-static CC=\"ccache gcc\" CXX=\"ccache g++\" CXXFLAGS=\"-O2 -g0\"\n        make -j 2\n    - name: Run tests\n      run: |\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,faster.xml:HRF,message -- --faster\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,fast.xml:HRF,message -- --fast\n        ./test-suite/quantlib-test-suite --logger=JUNIT,warning,all.xml:HRF,message\n    - name: Save test times\n      uses: actions/upload-artifact@v3\n      with:\n        name: test-reports\n        path: ./all.xml\n    - name: Check test times\n      run: |\n        python ./tools/check_test_times.py\n```", "prompt": "Generate a GitHub Workflow named `Check test times` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check-test-times`. This job will run on ubuntu-latest runner. The job `check-test-times` has 7 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Cache`. This step runs action `hendrikmuhs/ccache-action` tagged as v1.2. The step defines 2 input parameters for the action: `key` is set to `linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-${{ hashFiles('**/*.hpp', '**/*.cpp') }}` and `restore-keys` is set to `linux-ci-build-times-${{ github.ref }}-${{ github.head_ref }}-\nlinux-ci-build-times-${{ github.ref }}-\nlinux-ci-build-times-refs/heads/master-\nlinux-ci-build-times-\n`. The 3rd step is named `Setup`. This step runs a script: `sudo apt update\nsudo apt install -y libboost-dev autoconf automake libtool ccache\n`. The 4th step is named `Build`. This step runs a script: `./autogen.sh\n./configure --disable-static CC=\"ccache gcc\" CXX=\"ccache g++\" CXXFLAGS=\"-O2 -g0\"\nmake -j 2\n`. The 5th step is named `Run tests`. This step runs a script: `./test-suite/quantlib-test-suite --logger=JUNIT,warning,faster.xml:HRF,message -- --faster\n./test-suite/quantlib-test-suite --logger=JUNIT,warning,fast.xml:HRF,message -- --fast\n./test-suite/quantlib-test-suite --logger=JUNIT,warning,all.xml:HRF,message\n`. The 6th step is named `Save test times`. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `test-reports` and `path` is set to `./all.xml`. The 7th step is named `Check test times`. This step runs a script: `python ./tools/check_test_times.py\n`. "}
{"id": "63c496981899db58864d3f6f", "level": "level5", "llm_response": "```yaml\nname: Re-run Workflow\n\non:\n  workflow_run:\n    workflows: [\"CI\"]\n    types: [completed]\n  pull_request:\n    types: [closed, labeled, unlabeled]\n  schedule:\n    - cron: '30 */3 * * *'\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    runs-on: ubuntu-latest\n    if: |\n      startsWith(github.repository, 'Homebrew/') &&\n      (\n        github.event.label.name == 'ci-requeue' ||\n        github.event.label.name == 'ci-retry' ||\n        github.event.label.name == 'ci-skip-appcast' ||\n        github.event.label.name == 'ci-skip-install' ||\n        github.event.label.name == 'ci-syntax-only' ||\n        !github.event.label.name\n      )\n    steps:\n      - name: Re-run CI workflow\n        uses: reitermarkus/rerun-workflow@c8d5bc3526acb50c12004f31c0dcb1598c87e32d\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n          once-label: ci-requeue\n          continuous-label: ci-retry\n          trigger-labels: ci-skip-appcast,ci-skip-install,ci-syntax-only\n          workflow: ci.yml\n```", "answer": "```yaml name: Re-run Workflow\n\non:\n  workflow_run:\n    workflows:\n      - CI\n    types:\n      - completed\n  pull_request_target:\n    types:\n      - closed\n      - labeled\n      - unlabeled\n  schedule:\n    - cron: '30 */3 * * *' # every 3 hours (30 minutes past the hour)\n\npermissions:\n  contents: read\n\njobs:\n  rerun-workflow:\n    if: >\n      startsWith(github.repository, 'Homebrew/') &&\n      (\n        github.event.label.name == 'ci-requeue' ||\n        github.event.label.name == 'ci-retry' ||\n        github.event.label.name == 'ci-skip-appcast' ||\n        github.event.label.name == 'ci-skip-install' ||\n        github.event.label.name == 'ci-syntax-only' ||\n        !github.event.label.name\n      )\n    runs-on: ubuntu-latest\n    steps:\n      - name: Re-run CI workflow\n        uses: reitermarkus/rerun-workflow@c8d5bc3526acb50c12004f31c0dcb1598c87e32d\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n          once-label: ci-requeue\n          continuous-label: ci-retry\n          trigger-labels: ci-skip-appcast,ci-skip-install,ci-syntax-only\n          workflow: ci.yml\n```", "prompt": "Generate a GitHub Workflow named `Re-run Workflow` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) the workflow named CI is completed. 2) a pull request is closed, a label is added to a pull request or a label is removed from a pull request. 3) the scheduled time has come: at 30 minutes past the hour, every 3 hours. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `rerun-workflow`. This job will run only if the condition(startsWith(github.repository, 'Homebrew/') && (\n  github.event.label.name == 'ci-requeue' ||\n  github.event.label.name == 'ci-retry' ||\n  github.event.label.name == 'ci-skip-appcast' ||\n  github.event.label.name == 'ci-skip-install' ||\n  github.event.label.name == 'ci-syntax-only' ||\n  !github.event.label.name\n)\n) is met. This job will run on ubuntu-latest runner. The job `rerun-workflow` has one step. The 1st step is named `Re-run CI workflow`. This step runs action `reitermarkus/rerun-workflow` whose commit is c8d5bc3526acb50c12004f31c0dcb1598c87e32d. The step defines 5 input parameters for the action: `token` is set to `${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}`, `once-label` is set to `ci-requeue`, `continuous-label` is set to `ci-retry`, `trigger-labels` is set to `ci-skip-appcast,ci-skip-install,ci-syntax-only` and `workflow` is set to `ci.yml`. "}
{"id": "63c493bc7843b612699fd432", "level": "level5", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n  push:\n    branches: [ main ]\n  repository_dispatch:\n\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n      - name: Install dependencies\n        run: npm ci || npm install\n      - name: Run XO\n        run: npx xo\n\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Install dependencies\n        run: npm ci || npm install\n      - name: Build project\n        run: npm run build\n```", "answer": "```yaml env: {}\n\n# FILE GENERATED WITH: npx ghat fregante/ghatemplates/node\n# SOURCE: https://github.com/fregante/ghatemplates\n# OPTIONS: {\"exclude\":[\"jobs.Test\"]}\n\nname: CI\non:\n  - pull_request\n  - push\njobs:\n  Lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n      - name: install\n        run: npm ci || npm install\n      - name: XO\n        run: npx xo\n  Build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: install\n        run: npm ci || npm install\n      - name: build\n        run: npm run build\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) a commit or tag is pushed, or a repository is cloned. The workflow has 2 jobs. The job id of the 1st job is `Lint`. This job will run on ubuntu-latest runner. The job `Lint` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines an input parameter for the action: `node-version` is set to `16`. The 3rd step is named `install`. This step runs a script: `npm ci || npm install`. The 4th step is named `XO`. This step runs a script: `npx xo`. The job id of the 2nd job is `Build`. This job will run on ubuntu-latest runner. The job `Build` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `install`. This step runs a script: `npm ci || npm install`. The 3rd step is named `build`. This step runs a script: `npm run build`. "}
{"id": "63c493f47843b612699fe037", "level": "level5", "llm_response": "```yaml\nname: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        branch: [master, 1.24, 1.23, 1.22]\n        channel: [latest/edge, 1.24, 1.23, 1.22]\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3.1.0\n      with:\n        ref: ${{ matrix.branch }}\n\n    - name: Update image list\n      run: ./build-scripts/update-images.sh ${{ matrix.channel }} build-scripts/images.txt\n\n    - name: Create pull request\n      uses: peter-evans/create-pull-request@v4\n      with:\n        commit-message: update list of images used by ${{ matrix.channel }}\n        title: \"[${{ matrix.channel }}] Update MicroK8s images\"\n        body: update list of images used by ${{ matrix.channel }}\n        reviewers: neoaggelos,ktsakalozos\n        branch: auto-update-images/${{ matrix.branch }}\n        delete-branch: True\n        base: ${{ matrix.branch }}\n```", "answer": "```yaml name: Update list of images\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: \"0 10 * * *\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        include:\n          - { branch: master, channel: latest/edge }\n          - { branch: 1.24, channel: 1.24 }\n          - { branch: 1.23, channel: 1.23 }\n          - { branch: 1.22, channel: 1.22 }\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ matrix.branch }}\n      - name: Update image list\n        run: |\n          ./build-scripts/update-images.sh ${{ matrix.channel }} build-scripts/images.txt\n      - name: Create pull request\n        uses: peter-evans/create-pull-request@v4\n        with:\n          commit-message: update list of images used by ${{ matrix.channel }}\n          title: \"[${{ matrix.channel }}] Update MicroK8s images\"\n          body: update list of images used by ${{ matrix.channel }}\n          reviewers: neoaggelos,ktsakalozos\n          branch: auto-update-images/${{ matrix.branch }}\n          delete-branch: true\n          base: ${{ matrix.branch }}\n```", "prompt": "Generate a GitHub Workflow named `Update list of images` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `update`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. For each object in the [{'branch': 'master', 'channel': 'latest/edge'}, {'branch': 1.24, 'channel': 1.24}, {'branch': 1.23, 'channel': 1.23}, {'branch': 1.22, 'channel': 1.22}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `update` has 3 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3.1.0. The step defines an input parameter for the action: `ref` is set to `${{ matrix.branch }}`. The 2nd step is named `Update image list`. This step runs a script: `./build-scripts/update-images.sh ${{ matrix.channel }} build-scripts/images.txt\n`. The 3rd step is named `Create pull request`. This step runs action `peter-evans/create-pull-request` tagged as v4. The step defines 7 input parameters for the action: `commit-message` is set to `update list of images used by ${{ matrix.channel }}`, `title` is set to `[${{ matrix.channel }}] Update MicroK8s images`, `body` is set to `update list of images used by ${{ matrix.channel }}`, `reviewers` is set to `neoaggelos,ktsakalozos`, `branch` is set to `auto-update-images/${{ matrix.branch }}`, `delete-branch` is set to `True` and `base` is set to `${{ matrix.branch }}`. "}
{"id": "63c494368052faa2781a9e20", "level": "level5", "llm_response": "```yaml\nname: build\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - 'v*'\n  pull_request:\n\npermissions:\n  contents: write\n  id-token: write\n  packages: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: 1.17\n\n    - name: Cache Go modules\n      uses: actions/cache@v3\n      with:\n        path: ~/go/pkg/mod\n        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}\n        restore-keys: ${{ runner.os }}-go-\n\n    - name: CI\n      run: |\n        go mod tidy\n        go test -v ./...\n        go build -o tt .\n\n    - name: Cosign Installer\n      uses: sigstore/cosign-installer@v2.8.1\n\n    - name: Run GoReleaser\n      if: success() && startsWith(github.ref, 'refs/tags/')\n      env:\n        GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n        FURY_TOKEN: ${{ secrets.FURY_TOKEN }}\n        GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}\n        TWITTER_CONSUMER_KEY: ${{ secrets.TWITTER_CONSUMER_KEY }}\n        TWITTER_CONSUMER_SECRET: ${{ secrets.TWITTER_CONSUMER_SECRET }}\n        TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}\n        TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}\n        COSIGN_PWD: ${{ secrets.COSIGN_PWD }}\n        AUR_KEY: ${{ secrets.AUR_KEY }}\n      uses: goreleaser/goreleaser-action@v3\n      with:\n        distribution: goreleaser-pro\n        version: latest\n        args: release --rm-dist\n```", "answer": "```yaml name: build\n\non:\n  push:\n    branches:\n      - 'main'\n    tags:\n      - 'v*'\n  pull_request:\n\npermissions:\n   contents: write\n   id-token: write\n   packages: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      -\n        name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: 1.17\n      -\n        name: Cache Go modules\n        uses: actions/cache@v3\n        with:\n          path: ~/go/pkg/mod\n          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}\n          restore-keys: |\n            ${{ runner.os }}-go-\n      -\n        name: CI\n        run: |\n          go mod tidy\n          go test -v ./...\n          go build -o tt .\n      - uses: sigstore/cosign-installer@v2.8.1\n      -\n        name: Run GoReleaser\n        uses: goreleaser/goreleaser-action@v3\n        if: success() && startsWith(github.ref, 'refs/tags/')\n        with:\n          distribution: goreleaser-pro\n          version: latest\n          args: release --rm-dist\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n          FURY_TOKEN: ${{ secrets.FURY_TOKEN }}\n          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}\n          TWITTER_CONSUMER_KEY: ${{ secrets.TWITTER_CONSUMER_KEY }}\n          TWITTER_CONSUMER_SECRET: ${{ secrets.TWITTER_CONSUMER_SECRET }}\n          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}\n          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}\n          COSIGN_PWD: ${{ secrets.COSIGN_PWD }}\n          AUR_KEY: ${{ secrets.AUR_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a tag whose name matches v*. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope, write access is granted to the GITHUB_TOKEN in the `id-token` scope and write access is granted to the GITHUB_TOKEN in the `packages` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 6 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Set up Go`. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `1.17`. The 3rd step is named `Cache Go modules`. This step runs action `actions/cache` tagged as v3. The step defines 3 input parameters for the action: `path` is set to `~/go/pkg/mod`, `key` is set to `${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}` and `restore-keys` is set to `${{ runner.os }}-go-\n`. The 4th step is named `CI`. This step runs a script: `go mod tidy\ngo test -v ./...\ngo build -o tt .\n`. The 5th step is named ``. This step runs action `sigstore/cosign-installer` tagged as v2.8.1. The 6th step is named `Run GoReleaser`. This step will run only if the condition(success() && startsWith(github.ref, 'refs/tags/')) is met. The step sets 9 environment variables to use: `GITHUB_TOKEN` is set to `${{ secrets.GH_PAT }}`, `FURY_TOKEN` is set to `${{ secrets.FURY_TOKEN }}`, `GORELEASER_KEY` is set to `${{ secrets.GORELEASER_KEY }}`, `TWITTER_CONSUMER_KEY` is set to `${{ secrets.TWITTER_CONSUMER_KEY }}`, `TWITTER_CONSUMER_SECRET` is set to `${{ secrets.TWITTER_CONSUMER_SECRET }}`, `TWITTER_ACCESS_TOKEN` is set to `${{ secrets.TWITTER_ACCESS_TOKEN }}`, `TWITTER_ACCESS_TOKEN_SECRET` is set to `${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}`, `COSIGN_PWD` is set to `${{ secrets.COSIGN_PWD }}` and `AUR_KEY` is set to `${{ secrets.AUR_KEY }}`. This step runs action `goreleaser/goreleaser-action` tagged as v3. The step defines 3 input parameters for the action: `distribution` is set to `goreleaser-pro`, `version` is set to `latest` and `args` is set to `release --rm-dist`. "}
{"id": "63c493b77843b612699fd355", "level": "level5", "llm_response": "```yaml\nname: docs\n\non:\n  push:\n    branches:\n      - develop\n      - release\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n\nconcurrency:\n  group: docs\n  cancel-in-progress: false\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Track Docs Branch\n        run: git branch docs -t origin/docs\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: 3.x\n\n      - name: Cache dependencies\n        uses: actions/cache@v3\n        with:\n          key: ${{ github.ref }}\n          path: .cache\n\n      - name: Set up pnpm\n        uses: pnpm/action-setup@v2.2.2\n        with:\n          version: 7\n\n      - name: Lint Docs\n        run: pnpm i && pnpm lint\n\n      - name: Update pip\n        run: python -m pip install -U pip setuptools\n\n      - name: Set Git author\n        run: |\n          git config user.name \"github-actions[bot]\"\n          git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n\n      - name: Install native dependencies\n        run: sudo apt-get install libcairo2-dev libfreetype6-dev libffi-dev libjpeg-dev libpng-dev libz-dev\n\n      - name: Install wheel\n        run: pip install wheel\n\n      - name: Install Material for MkDocs Insiders\n        if: github.repository_owner == 'mastercomfig' && github.event_name != 'pull_request'\n        env:\n          GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n        run: pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git\n\n      - name: Install dependencies\n        run: pip install -r docs/requirements.txt\n\n      - name: Update from Remote\n        run: git fetch --tags -f\n\n      - name: Build docs (latest)\n        if: github.event_name == 'push' && github.ref == 'refs/heads/release'\n        env:\n          GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n        run: mike deploy --alias-type copy -b docs -up $(git describe --tags --abbrev=0) latest page\n\n      - name: Build docs (develop)\n        if: github.event_name == 'push' && github.ref == 'refs/heads/develop'\n        env:\n          GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n        run: mike deploy --alias-type copy -b docs -p dev\n\n      - name: Build docs\n        if: github.event_name == 'pull_request'\n        run: mike deploy --config-file mkdocs.base.yml -u $(git describe --tags) latest\n```", "answer": "```yaml name: docs\n\nconcurrency: docs\n\non:\n  push:\n    branches: [ develop, release ]\n    paths:\n      - docs/**\n      - mkdocs.yml\n      - .github/workflows/docs.yml\n  pull_request:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Track Docs Branch\n      run: git branch docs -t origin/docs\n    - uses: actions/setup-python@v4\n      with:\n        python-version: 3.x\n    - uses: actions/cache@v3\n      with:\n        key: ${{ github.ref }}\n        path: .cache\n    - uses: pnpm/action-setup@v2.2.2\n      with:\n        version: 7\n    - name: Lint Docs\n      run: |\n        pnpm i\n        pnpm lint\n    - name: Update pip\n      run: python -m pip install -U pip setuptools\n    - name: Set Git author\n      run: |\n        git config user.name \"github-actions[bot]\"\n        git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n    - name: Install native dependencies\n      run: sudo apt-get install libcairo2-dev libfreetype6-dev libffi-dev libjpeg-dev libpng-dev libz-dev\n    - name: Install wheel\n      run: pip install wheel\n    - name: Install Material for MkDocs Insiders\n      run: pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git\n      if: ${{ github.repository_owner == 'mastercomfig' && github.event_name != 'pull_request' }}\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Install dependencies\n      run: pip install -r docs/requirements.txt\n    - name: Update from Remote\n      run: git fetch --tags -f\n    - name: Build docs (latest)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/release' }}\n      run: mike deploy --alias-type copy -b docs -up $(git describe --tags --abbrev=0) latest page\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs (develop)\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/develop' }}\n      run: mike deploy --alias-type copy -b docs -p dev\n      env:\n        GH_TOKEN: ${{secrets.PRIVATE_REPO_TOKEN}}\n    - name: Build docs\n      if: ${{ github.event_name == 'pull_request' }}\n      run: mike deploy --config-file mkdocs.base.yml -u $(git describe --tags) latest\n```", "prompt": "Generate a GitHub Workflow named `docs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named develop or a branch named release. Only if at least one path of push event matches a pattern in the paths filter(docs/**, mkdocs.yml or .github/workflows/docs.yml), the workflow runs. 2) there is activity relating to a pull request. Only a single workflow using the docs concurrency group will run at a time. The workflow has one job. The job id of the 1st job is `deploy`. This job will run on ubuntu-latest runner. The job `deploy` has 16 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Track Docs Branch`. This step runs a script: `git branch docs -t origin/docs`. The 3rd step is named ``. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `3.x`. The 4th step is named ``. This step runs action `actions/cache` tagged as v3. The step defines 2 input parameters for the action: `key` is set to `${{ github.ref }}` and `path` is set to `.cache`. The 5th step is named ``. This step runs action `pnpm/action-setup` tagged as v2.2.2. The step defines an input parameter for the action: `version` is set to `7`. The 6th step is named `Lint Docs`. This step runs a script: `pnpm i\npnpm lint\n`. The 7th step is named `Update pip`. This step runs a script: `python -m pip install -U pip setuptools`. The 8th step is named `Set Git author`. This step runs a script: `git config user.name \"github-actions[bot]\"\ngit config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n`. The 9th step is named `Install native dependencies`. This step runs a script: `sudo apt-get install libcairo2-dev libfreetype6-dev libffi-dev libjpeg-dev libpng-dev libz-dev`. The 10th step is named `Install wheel`. This step runs a script: `pip install wheel`. The 11th step is named `Install Material for MkDocs Insiders`. This step will run only if the condition(${{ github.repository_owner == 'mastercomfig' && github.event_name != 'pull_request' }}) is met. The step sets an environment variable to use: `GH_TOKEN` is set to `${{secrets.PRIVATE_REPO_TOKEN}}`. This step runs a script: `pip install git+https://${GH_TOKEN}@github.com/squidfunk/mkdocs-material-insiders.git`. The 12th step is named `Install dependencies`. This step runs a script: `pip install -r docs/requirements.txt`. The 13th step is named `Update from Remote`. This step runs a script: `git fetch --tags -f`. The 14th step is named `Build docs (latest)`. This step will run only if the condition(${{ github.event_name == 'push' && github.ref == 'refs/heads/release' }}) is met. The step sets an environment variable to use: `GH_TOKEN` is set to `${{secrets.PRIVATE_REPO_TOKEN}}`. This step runs a script: `mike deploy --alias-type copy -b docs -up $(git describe --tags --abbrev=0) latest page`. The 15th step is named `Build docs (develop)`. This step will run only if the condition(${{ github.event_name == 'push' && github.ref == 'refs/heads/develop' }}) is met. The step sets an environment variable to use: `GH_TOKEN` is set to `${{secrets.PRIVATE_REPO_TOKEN}}`. This step runs a script: `mike deploy --alias-type copy -b docs -p dev`. The 16th step is named `Build docs`. This step will run only if the condition(${{ github.event_name == 'pull_request' }}) is met. This step runs a script: `mike deploy --config-file mkdocs.base.yml -u $(git describe --tags) latest`. "}
{"id": "63c495a68052faa2781b342a", "level": "level5", "llm_response": "```yaml\nname: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches:\n      - master\n      - '1.x'\n      - release\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    if: github.repository == 'jdbc-observations/datasource-proxy'\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Maven Central Repository\n        uses: actions/setup-java@v3\n        with:\n          java-version: '8'\n          distribution: 'temurin'\n          server-id: 'ossrh'\n          server-username: 'MAVEN_USERNAME'\n          server-password: 'MAVEN_PASSWORD'\n          gpg-private-key: ${{ secrets.MAVEN_GPG_PRIVATE_KEY }}\n          gpg-passphrase: ${{ secrets.MAVEN_GPG_PASSPHRASE }}\n\n      - name: Publish package\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}\n          MAVEN_GPG_PASSPHRASE: ${{ secrets.MAVEN_GPG_PASSPHRASE }}\n        run: ./mvnw --batch-mode deploy -DskipTests=true -Pgithub-ossrh\n```", "answer": "```yaml name: Release to Maven Central (Deploy Snapshot or Stage Release)\n\non:\n  push:\n    branches: [master, 1.x, release]\n\njobs:\n  release:\n    if: github.repository == 'jdbc-observations/datasource-proxy'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Maven Central Repository\n        uses: actions/setup-java@v3\n        with:\n          java-version: 8\n          distribution: temurin\n          server-id: ossrh\n          server-username: MAVEN_USERNAME\n          server-password: MAVEN_PASSWORD\n          gpg-private-key: ${{ secrets.MAVEN_GPG_PRIVATE_KEY }}\n          gpg-passphrase: MAVEN_GPG_PASSPHRASE\n      - name: Publish package\n        run: ./mvnw --batch-mode deploy -DskipTests=true -Pgithub-ossrh\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}\n          MAVEN_GPG_PASSPHRASE: ${{ secrets.MAVEN_GPG_PASSPHRASE }}\n\n```", "prompt": "Generate a GitHub Workflow named `Release to Maven Central (Deploy Snapshot or Stage Release)` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master, a branch named 1.x or a branch named release. The workflow has one job. The job id of the 1st job is `release`. This job will run only if the condition(github.repository == 'jdbc-observations/datasource-proxy') is met. This job will run on ubuntu-latest runner. The job `release` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Maven Central Repository`. This step runs action `actions/setup-java` tagged as v3. The step defines 7 input parameters for the action: `java-version` is set to `8`, `distribution` is set to `temurin`, `server-id` is set to `ossrh`, `server-username` is set to `MAVEN_USERNAME`, `server-password` is set to `MAVEN_PASSWORD`, `gpg-private-key` is set to `${{ secrets.MAVEN_GPG_PRIVATE_KEY }}` and `gpg-passphrase` is set to `MAVEN_GPG_PASSPHRASE`. The 3rd step is named `Publish package`. The step sets 3 environment variables to use: `MAVEN_USERNAME` is set to `${{ secrets.OSSRH_USERNAME }}`, `MAVEN_PASSWORD` is set to `${{ secrets.OSSRH_PASSWORD }}` and `MAVEN_GPG_PASSPHRASE` is set to `${{ secrets.MAVEN_GPG_PASSPHRASE }}`. This step runs a script: `./mvnw --batch-mode deploy -DskipTests=true -Pgithub-ossrh`. "}
{"id": "63c494257843b612699ff4be", "level": "level5", "llm_response": "```yaml\nname: functional-orchestration\n\non:\n  pull_request:\n    paths:\n      - 'orchestration/**'\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  functional-orchestration:\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    strategy:\n      matrix:\n        name: [master]\n        openstack_version: [master]\n        ubuntu_version: [20.04]\n        include:\n          - name: yoga\n            openstack_version: stable/yoga\n          - name: xena\n            openstack_version: stable/xena\n          - name: wallaby\n            openstack_version: stable/wallaby\n          - name: victoria\n            openstack_version: stable/victoria\n          - name: ussuri\n            openstack_version: stable/ussuri\n            ubuntu_version: 18.04\n          - name: train\n            openstack_version: stable/train\n            ubuntu_version: 18.04\n\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n          conf_overrides: |\n            enable_plugin heat https://opendev.org/openstack/heat ${{ matrix.openstack_version }}\n          enabled_services: h-eng,h-api,h-api-cfn,h-api-cw\n\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n\n      - name: Run Gophercloud acceptance tests\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: '^.*orchestration.*$'\n        run: ./script/acceptancetest\n\n      - name: Generate logs on failure\n        if: failure()\n        run: ./script/collectlogs\n\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-orchestration-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "answer": "```yaml name: functional-orchestration\non:\n  pull_request:\n    paths:\n      - '**orchestration**'\n  schedule:\n    - cron: '0 0 * * *'\njobs:\n  functional-orchestration:\n    strategy:\n      fail-fast: false\n      matrix:\n        name: [\"master\"]\n        openstack_version: [\"master\"]\n        ubuntu_version: [\"20.04\"]\n        include:\n          - name: \"yoga\"\n            openstack_version: \"stable/yoga\"\n            ubuntu_version: \"20.04\"\n          - name: \"xena\"\n            openstack_version: \"stable/xena\"\n            ubuntu_version: \"20.04\"\n          - name: \"wallaby\"\n            openstack_version: \"stable/wallaby\"\n            ubuntu_version: \"20.04\"\n          - name: \"victoria\"\n            openstack_version: \"stable/victoria\"\n            ubuntu_version: \"20.04\"\n          - name: \"ussuri\"\n            openstack_version: \"stable/ussuri\"\n            ubuntu_version: \"18.04\"\n          - name: \"train\"\n            openstack_version: \"stable/train\"\n            ubuntu_version: \"18.04\"\n    runs-on: ubuntu-${{ matrix.ubuntu_version }}\n    name: Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests\n    steps:\n      - name: Checkout Gophercloud\n        uses: actions/checkout@v3\n      - name: Deploy devstack\n        uses: EmilienM/devstack-action@v0.9\n        with:\n          branch: ${{ matrix.openstack_version }}\n          conf_overrides: |\n            enable_plugin heat https://opendev.org/openstack/heat ${{ matrix.openstack_version }}\n          enabled_services: 'h-eng,h-api,h-api-cfn,h-api-cw'\n      - name: Checkout go\n        uses: actions/setup-go@v3\n        with:\n          go-version: '^1.15'\n      - name: Run Gophercloud acceptance tests\n        run: ./script/acceptancetest\n        env:\n          DEVSTACK_PATH: ${{ github.workspace }}/devstack\n          ACCEPTANCE_TESTS_FILTER: ^.*orchestration.*$\n      - name: Generate logs on failure\n        run: ./script/collectlogs\n        if: failure()\n      - name: Upload logs artifacts on failure\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          name: functional-orchestration-${{ matrix.name }}\n          path: /tmp/devstack-logs/*\n```", "prompt": "Generate a GitHub Workflow named `functional-orchestration` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(**orchestration**), the workflow runs. 2) the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `Deploy OpenStack ${{ matrix.name }} with Heat and run orchestration acceptance tests` and its job id is `functional-orchestration`. This job will run on ubuntu-${{ matrix.ubuntu_version }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `name` has one value: master. The variable `openstack_version` has one value: master. The variable `ubuntu_version` has one value: 20.04. For each object in the [{'name': 'yoga', 'openstack_version': 'stable/yoga', 'ubuntu_version': '20.04'}, {'name': 'xena', 'openstack_version': 'stable/xena', 'ubuntu_version': '20.04'}, {'name': 'wallaby', 'openstack_version': 'stable/wallaby', 'ubuntu_version': '20.04'}, {'name': 'victoria', 'openstack_version': 'stable/victoria', 'ubuntu_version': '20.04'}, {'name': 'ussuri', 'openstack_version': 'stable/ussuri', 'ubuntu_version': '18.04'}, {'name': 'train', 'openstack_version': 'stable/train', 'ubuntu_version': '18.04'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `functional-orchestration` has 6 steps. The 1st step is named `Checkout Gophercloud`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Deploy devstack`. This step runs action `EmilienM/devstack-action` tagged as v0.9. The step defines 3 input parameters for the action: `branch` is set to `${{ matrix.openstack_version }}`, `conf_overrides` is set to `enable_plugin heat https://opendev.org/openstack/heat ${{ matrix.openstack_version }}\n` and `enabled_services` is set to `h-eng,h-api,h-api-cfn,h-api-cw`. The 3rd step is named `Checkout go`. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `^1.15`. The 4th step is named `Run Gophercloud acceptance tests`. The step sets 2 environment variables to use: `DEVSTACK_PATH` is set to `${{ github.workspace }}/devstack` and `ACCEPTANCE_TESTS_FILTER` is set to `^.*orchestration.*$`. This step runs a script: `./script/acceptancetest`. The 5th step is named `Generate logs on failure`. This step will run only if the condition(failure()) is met. This step runs a script: `./script/collectlogs`. The 6th step is named `Upload logs artifacts on failure`. This step will run only if the condition(failure()) is met. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `functional-orchestration-${{ matrix.name }}` and `path` is set to `/tmp/devstack-logs/*`. "}
{"id": "63c495167843b61269a0553c", "level": "level5", "llm_response": "```yaml\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Call reusable workflow\n        uses: actions/github-script@v5\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            github.workflows.get({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              ref: 'openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master'\n            }).then(workflow => {\n              github.actions.createWorkflowDispatch({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                workflow_id: workflow.id,\n                ref: 'master',\n                inputs: {\n                  GITHUB_APP_ID: ${{ secrets.GRAPHQL_AUTH_APP_ID }},\n                  GITHUB_APP_PRIVATE_KEY: ${{ secrets.GRAPHQL_AUTH_APP_PEM }},\n                  SLACK_BOT_TOKEN: ${{ secrets.SLACK_ISSUE_BOT_TOKEN }}\n                }\n              });\n            });\n```", "answer": "```yaml # Run the workflow that adds new tickets that are either:\n# - labelled \"DEPR\"\n# - title starts with \"[DEPR]\"\n# - body starts with \"Proposal Date\" (this is the first template field)\n# to the org-wide DEPR project board\n\nname: Add newly created DEPR issues to the DEPR project board\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  routeissue:\n    uses: openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master\n    secrets:\n      GITHUB_APP_ID: ${{ secrets.GRAPHQL_AUTH_APP_ID }}\n      GITHUB_APP_PRIVATE_KEY: ${{ secrets.GRAPHQL_AUTH_APP_PEM }}\n      SLACK_BOT_TOKEN: ${{ secrets.SLACK_ISSUE_BOT_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Add newly created DEPR issues to the DEPR project board` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `routeissue`. This job will call a reusable workflow located at `openedx/.github/.github/workflows/add-depr-ticket-to-depr-board.yml@master`. The job will pass 3 secrets to the called workflow: the secret `GITHUB_APP_ID` is `${{ secrets.GRAPHQL_AUTH_APP_ID }}`, the secret `GITHUB_APP_PRIVATE_KEY` is `${{ secrets.GRAPHQL_AUTH_APP_PEM }}` and the secret `SLACK_BOT_TOKEN` is `${{ secrets.SLACK_ISSUE_BOT_TOKEN }}`. "}
{"id": "63c495e88052faa2781b50cc", "level": "level5", "llm_response": "```yaml\nname: TagBot\n\non:\n  issues:\n    types: [comment_created]\n  pull_request:\n    types: [comment_created]\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    steps:\n      - name: TagBot\n        uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. This job will run only if the condition(github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot') is met. This job will run on ubuntu-latest runner. The job `TagBot` has one step. The 1st step is named ``. This step runs action `JuliaRegistries/TagBot` tagged as v1. The step defines 2 input parameters for the action: `token` is set to `${{ secrets.GITHUB_TOKEN }}` and `ssh` is set to `${{ secrets.DOCUMENTER_KEY }}`. "}
{"id": "63c496876fc19abdf9c9c8bb", "level": "level5", "llm_response": "```yaml\nname: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: '*/30 * * * *'\n\njobs:\n  build-feeds:\n    id: build-feeds\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n\n      - name: Install Dependencies\n        run: yarn\n\n      - name: Checkout Data Source Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n        with:\n          repository: smartcontractkit/reference-data-directory\n          path: data-source\n          token: ${{ secrets.GH_API_KEY }}\n\n      - name: Process Data\n        run: yarn process\n\n      - name: Deploy to Firebase\n        env:\n          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n          PROJECT_ID: cl-docs-addresses\n        uses: w9jds/firebase-action@94389a881adad57284e35860f5d258ab262dcd91\n        with:\n          args: -c firebase-addresses.json deploy --only hosting\n```", "answer": "```yaml name: Build and Publish Feed Resources\n\non:\n  schedule:\n    - cron: \"*/30 * * * *\"\n\njobs:\n  build-feeds:\n    name: Update latest feed data from source repo\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n      - name: Install Dependencies\n        run: yarn\n      - name: Checkout Data Source Repo\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n        with:\n          repository: smartcontractkit/reference-data-directory\n          path: data-source\n          token: ${{ secrets.GH_API_KEY }}\n      # - name: Read Data Source\n      #   run: cat data-source/package.json\n      - name: Process Data\n        run: yarn process\n      - name: Deploy to Firebase\n        uses: w9jds/firebase-action@94389a881adad57284e35860f5d258ab262dcd91\n        with:\n\n          args: -c firebase-addresses.json deploy --only hosting\n        env:\n          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n          PROJECT_ID: cl-docs-addresses\n```", "prompt": "Generate a GitHub Workflow named `Build and Publish Feed Resources` for a GitHub repository whose primary programming language is Solidity. This workflow will be triggered by an event: the scheduled time has come: every 30 minutes. The workflow has one job. The 1st job is named `Update latest feed data from source repo` and its job id is `build-feeds`. This job will run on ubuntu-latest runner. The job `build-feeds` has 5 steps. The 1st step is named `Checkout Repo`. This step runs action `actions/checkout` whose commit is 5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f. The 2nd step is named `Install Dependencies`. This step runs a script: `yarn`. The 3rd step is named `Checkout Data Source Repo`. This step runs action `actions/checkout` whose commit is 5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f. The step defines 3 input parameters for the action: `repository` is set to `smartcontractkit/reference-data-directory`, `path` is set to `data-source` and `token` is set to `${{ secrets.GH_API_KEY }}`. The 4th step is named `Process Data`. This step runs a script: `yarn process`. The 5th step is named `Deploy to Firebase`. The step sets 2 environment variables to use: `FIREBASE_TOKEN` is set to `${{ secrets.FIREBASE_TOKEN }}` and `PROJECT_ID` is set to `cl-docs-addresses`. This step runs action `w9jds/firebase-action` whose commit is 94389a881adad57284e35860f5d258ab262dcd91. The step defines an input parameter for the action: `args` is set to `-c firebase-addresses.json deploy --only hosting`. "}
{"id": "63c494298052faa2781a98f7", "level": "level5", "llm_response": "```yaml\nname: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  build: ${{ github.workspace }}/build\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: windows-2022\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Setup\n      run: |\n        $Url = \"https://boostorg.jfrog.io/artifactory/main/release/1.75.0/binaries/boost_1_75_0-msvc-14.2-64.exe\"\n        (New-Object System.Net.WebClient).DownloadFile($Url, \"$env:TEMP\\boost.exe\")\n        Start-Process -Wait -FilePath \"$env:TEMP\\boost.exe\" \"/SILENT\",\"/SP-\",\"/SUPPRESSMSGBOXES\",\"/DIR=C:\\local\\boost-1.75.0\"\n\n    - name: Configure CMake\n      run: cmake -B ${{ env.build }} -DQL_USE_STD_CLASSES=ON\n      env:\n        BOOST_ROOT: C:\\local\\boost-1.75.0\n\n    - name: Initialize MSVC Code Analysis\n      id: run-analysis\n      uses: microsoft/msvc-code-analysis-action@v0.1.1\n      with:\n        cmakeBuildDirectory: ${{ env.build }}\n        buildConfiguration: Release\n        ruleset: ${{ github.workspace }}/.msvc-analysis.ruleset\n\n    - name: Upload SARIF to GitHub\n      uses: github/codeql-action/upload-sarif@v2\n      with:\n        sarif_file: ${{ steps.run-analysis.outputs.sarif }}\n\n    - name: Upload SARIF as an Artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: sarif-file\n        path: ${{ steps.run-analysis.outputs.sarif }}\n```", "answer": "```yaml name: Microsoft C++ Code Analysis\n\non:\n  schedule:\n    - cron: '0 0 * * 0'\n  workflow_dispatch:\n\nenv:\n  # Path to the CMake build directory.\n  build: '${{ github.workspace }}/build'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: windows-2022\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Setup\n        run: |\n          $Url = \"https://boostorg.jfrog.io/artifactory/main/release/1.75.0/binaries/boost_1_75_0-msvc-14.2-64.exe\"\n          (New-Object System.Net.WebClient).DownloadFile($Url, \"$env:TEMP\\boost.exe\")\n          Start-Process -Wait -FilePath \"$env:TEMP\\boost.exe\" \"/SILENT\",\"/SP-\",\"/SUPPRESSMSGBOXES\",\"/DIR=C:\\local\\boost-1.75.0\"\n\n      - name: Configure CMake\n        env:\n          BOOST_ROOT: C:\\local\\boost-1.75.0\n        run: cmake -B ${{ env.build }} -DQL_USE_STD_CLASSES=ON\n\n      - name: Initialize MSVC Code Analysis\n        uses: microsoft/msvc-code-analysis-action@v0.1.1\n        # Provide a unique ID to access the sarif output path\n        id: run-analysis\n        env:\n          CAExcludePath: C:\\local\\boost-1.75.0\n        with:\n          cmakeBuildDirectory: ${{ env.build }}\n          buildConfiguration: Release\n          ruleset: '${{ github.workspace }}/.msvc-analysis.ruleset'\n\n      - name: Upload SARIF to GitHub\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: ${{ steps.run-analysis.outputs.sarif }}\n\n      - name: Upload SARIF as an Artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: sarif-file\n          path: ${{ steps.run-analysis.outputs.sarif }}\n\n```", "prompt": "Generate a GitHub Workflow named `Microsoft C++ Code Analysis` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am, only on sunday. 2) someone manually triggers the workflow. The workflow sets an environment variable to use: `build` is set to `${{ github.workspace }}/build`. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on windows-2022 runner. The job `analyze` has 6 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Setup`. This step runs a script: `$Url = \"https://boostorg.jfrog.io/artifactory/main/release/1.75.0/binaries/boost_1_75_0-msvc-14.2-64.exe\"\n(New-Object System.Net.WebClient).DownloadFile($Url, \"$env:TEMP\\boost.exe\")\nStart-Process -Wait -FilePath \"$env:TEMP\\boost.exe\" \"/SILENT\",\"/SP-\",\"/SUPPRESSMSGBOXES\",\"/DIR=C:\\local\\boost-1.75.0\"\n`. The 3rd step is named `Configure CMake`. The step sets an environment variable to use: `BOOST_ROOT` is set to `C:\\local\\boost-1.75.0`. This step runs a script: `cmake -B ${{ env.build }} -DQL_USE_STD_CLASSES=ON`. The 4th step is named `Initialize MSVC Code Analysis` and its id is `run-analysis`. The step sets an environment variable to use: `CAExcludePath` is set to `C:\\local\\boost-1.75.0`. This step runs action `microsoft/msvc-code-analysis-action` tagged as v0.1.1. The step defines 3 input parameters for the action: `cmakeBuildDirectory` is set to `${{ env.build }}`, `buildConfiguration` is set to `Release` and `ruleset` is set to `${{ github.workspace }}/.msvc-analysis.ruleset`. The 5th step is named `Upload SARIF to GitHub`. This step runs action `github/codeql-action/upload-sarif` tagged as v2. The step defines an input parameter for the action: `sarif_file` is set to `${{ steps.run-analysis.outputs.sarif }}`. The 6th step is named `Upload SARIF as an Artifact`. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `sarif-file` and `path` is set to `${{ steps.run-analysis.outputs.sarif }}`. "}
{"id": "63c494a48052faa2781ac54a", "level": "level5", "llm_response": "```yaml\nname: cspell-action\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Run spell check\n        uses: streetsidesoftware/cspell-action@v2\n```", "answer": "```yaml name: cspell-action\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: streetsidesoftware/cspell-action@v2\n```", "prompt": "Generate a GitHub Workflow named `cspell-action` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `cspell`. This job will run on ubuntu-latest runner. The job `cspell` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `streetsidesoftware/cspell-action` tagged as v2. "}
{"id": "63c495197843b61269a056bc", "level": "level5", "llm_response": "```yaml\nname: Code Scanning - Action\n\non:\n  pull_request:\n    branches:\n      - dev\n      - master\n\njobs:\n  CodeQL-Build:\n    runs-on: ubuntu-latest\n    permissions:\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml name: \"Code Scanning - Action\"\n\non:\n  pull_request:\n    branches: [dev, master]\n    types: [opened, synchronize]\n\njobs:\n  CodeQL-Build:\n    # CodeQL runs on ubuntu-latest, windows-latest, and macos-latest\n    runs-on: ubuntu-latest\n\n    permissions:\n      # required for all workflows\n      security-events: write\n\n      # only required for workflows in private repositories\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      # Initializes the CodeQL tools for scanning.\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n        # Override language selection by uncommenting this and choosing your languages\n        # with:\n        #   languages: go, javascript, csharp, python, cpp, java\n\n      # Autobuild attempts to build any compiled languages (C/C++, C#, or Java).\n      # If this step fails, then you should remove it and run the build manually (see below).\n      # - name: Autobuild\n      #   uses: github/codeql-action/autobuild@v2\n\n      # \u2139\ufe0f Command-line programs to run using the OS shell.\n      # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n      # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following\n      #    three lines and modify them (or add more) to build your code if your\n      #    project uses a compiled language\n\n      #- run: |\n      #     make bootstrap\n      #     make release\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `Code Scanning - Action` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created or a pull request's head branch is updated. The workflow would run whenever there is a pull_request event targeting: a branch named dev or a branch named master. The workflow has one job. The job id of the 1st job is `CodeQL-Build`. This job will run on ubuntu-latest runner. The job `CodeQL-Build` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `security-events` scope, read access is granted to the GITHUB_TOKEN in the `actions` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `CodeQL-Build`. The job `CodeQL-Build` has 3 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Initialize CodeQL`. This step runs action `github/codeql-action/init` tagged as v2. The step defines an input parameter for the action: `languages` is set to `go`. The 3rd step is named `Perform CodeQL Analysis`. This step runs action `github/codeql-action/analyze` tagged as v2. "}
{"id": "63c495547843b61269a06e8e", "level": "level5", "llm_response": "```yaml\nname: Build and Release [Manual]\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    if: github.actor == 'ayuhito'\n\n    steps:\n    - name: checkout\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Enable PNPM\n      uses: pnpm/action-setup@v2\n\n    - name: Set node version to 16\n      uses: actions/setup-node@v3\n      with:\n        node-version: 16\n        cache: pnpm\n\n    - name: Install\n      run: pnpm install --frozen-lockfile\n\n    - name: Install\n      run: pnpm i\n\n    - name: Fetch API\n      env:\n        GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}\n      run: pnpm --filter scripts exec gfm generate $GOOGLE_API_KEY\n\n    - name: Parse API\n      run: pnpm --filter scripts exec gfm parse\n\n    - name: Build fonts\n      run: pnpm run build:google\n\n    - name: Generate fontlist\n      run: pnpm run util:fontlist\n\n    - name: Generate Algolia index\n      env:\n        ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }}\n      run: pnpm run util:algolia\n\n    - name: Lint files\n      run: pnpm run lint\n\n    - name: Format files\n      run: pnpm run format\n\n    - name: Stage, commit and push files\n      uses: stefanzweifel/git-auto-commit-action@v4\n      if: failure()\n      with:\n        commit_user_name: fontsource-bot\n        commit_user_email: 83556432+fontsource-bot@users.noreply.github.com\n        commit_author: fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\n        commit_message: chore(build): update packages [Manual]\n\n    - name: Check font files\n      run: pnpm run util:run-check\n\n    - name: If error, commit again before publishing\n      uses: stefanzweifel/git-auto-commit-action@v4\n      if: failure()\n      with:\n        commit_user_name: fontsource-bot\n        commit_user_email: 83556432+fontsource-bot@users.noreply.github.com\n        commit_author: fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\n        commit_message: chore(build): resolve file check errors [Manual]\n\n    - name: Configure CI Git\n      run: |\n        git config --global user.email \"83556432+fontsource-bot@users.noreply.github.com\"\n        git config --global user.name \"fontsource-bot\"\n\n    - name: Publish package\n      env:\n        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n      run: pnpm run deploy:ci\n```", "answer": "```yaml name: Build and Release [Manual]\n\non: [workflow_dispatch]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    if: github.actor == 'ayuhito'\n\n    steps:\n      - name: checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: \"0\"\n\n      - name: Enable PNPM\n        uses: pnpm/action-setup@v2\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"16\"\n          cache: \"pnpm\"\n\n      - name: Install\n        run: pnpm install --frozen-lockfile\n\n      - name: Install\n        run: pnpm i\n\n      - name: Fetch API # Calls Google Font Metadata to fetch the latest data from Google's Developer API\n        run: pnpm --filter scripts exec gfm generate $GOOGLE_API_KEY\n        env:\n          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}\n\n      - name: Parse API # Process generated API data\n        run: pnpm --filter scripts exec gfm parse\n\n      - name: Build fonts # Build all updated Google Fonts in repository\n        run: pnpm run build:google\n\n      - name: Generate fontlist # Generate FONTLIST.json and FONTLIST.md\n        run: pnpm run util:fontlist\n\n      - name: Generate Algolia index # Generate Algolia search index for website\n        run: pnpm run util:algolia\n        env:\n          ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }}\n\n      - name: Lint files\n        run: pnpm run lint\n\n      - name: Format files\n        run: pnpm run format\n\n      - name: Stage, commit and push files\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): update packages [Manual]\"\n        continue-on-error: true\n\n      - name: Check font files # Detects if all binaries are downloaded successfully and in the right place\n        run: pnpm run util:run-check\n\n      - name: If error, commit again before publishing\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_user_name: \"fontsource-bot\"\n          commit_user_email: \"83556432+fontsource-bot@users.noreply.github.com\"\n          commit_author: \"fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>\"\n          commit_message: \"chore(build): resolve file check errors [Manual]\"\n        continue-on-error: true\n\n      - name: Configure CI Git\n        run: |\n          git config --global user.email \"83556432+fontsource-bot@users.noreply.github.com\"\n          git config --global user.name \"fontsource-bot\"\n\n      - name: Publish package # Call mass-publish\n        run: pnpm run deploy:ci\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Build and Release [Manual]` for a GitHub repository whose primary programming language is CSS. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run only if the condition(github.actor == 'ayuhito') is met. This job will run on ubuntu-latest runner. The job `build` has 17 steps. The 1st step is named `checkout`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Enable PNPM`. This step runs action `pnpm/action-setup` tagged as v2. The 3rd step is named `Set node version to 16`. This step runs action `actions/setup-node` tagged as v3. The step defines 2 input parameters for the action: `node-version` is set to `16` and `cache` is set to `pnpm`. The 4th step is named `Install`. This step runs a script: `pnpm install --frozen-lockfile`. The 5th step is named `Install`. This step runs a script: `pnpm i`. The 6th step is named `Fetch API`. The step sets an environment variable to use: `GOOGLE_API_KEY` is set to `${{ secrets.GOOGLE_API_KEY }}`. This step runs a script: `pnpm --filter scripts exec gfm generate $GOOGLE_API_KEY`. The 7th step is named `Parse API`. This step runs a script: `pnpm --filter scripts exec gfm parse`. The 8th step is named `Build fonts`. This step runs a script: `pnpm run build:google`. The 9th step is named `Generate fontlist`. This step runs a script: `pnpm run util:fontlist`. The 10th step is named `Generate Algolia index`. The step sets an environment variable to use: `ALGOLIA_ADMIN_KEY` is set to `${{ secrets.ALGOLIA_ADMIN_KEY }}`. This step runs a script: `pnpm run util:algolia`. The 11th step is named `Lint files`. This step runs a script: `pnpm run lint`. The 12th step is named `Format files`. This step runs a script: `pnpm run format`. The 13th step is named `Stage, commit and push files`. This step runs action `stefanzweifel/git-auto-commit-action` tagged as v4. The step defines 4 input parameters for the action: `commit_user_name` is set to `fontsource-bot`, `commit_user_email` is set to `83556432+fontsource-bot@users.noreply.github.com`, `commit_author` is set to `fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>` and `commit_message` is set to `chore(build): update packages [Manual]`. When this step fails, the job will move on to the next step. The 14th step is named `Check font files`. This step runs a script: `pnpm run util:run-check`. The 15th step is named `If error, commit again before publishing`. This step runs action `stefanzweifel/git-auto-commit-action` tagged as v4. The step defines 4 input parameters for the action: `commit_user_name` is set to `fontsource-bot`, `commit_user_email` is set to `83556432+fontsource-bot@users.noreply.github.com`, `commit_author` is set to `fontsource-bot <83556432+fontsource-bot@users.noreply.github.com>` and `commit_message` is set to `chore(build): resolve file check errors [Manual]`. When this step fails, the job will move on to the next step. The 16th step is named `Configure CI Git`. This step runs a script: `git config --global user.email \"83556432+fontsource-bot@users.noreply.github.com\"\ngit config --global user.name \"fontsource-bot\"\n`. The 17th step is named `Publish package`. The step sets 3 environment variables to use: `GH_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`, `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}` and `NPM_TOKEN` is set to `${{ secrets.NPM_TOKEN }}`. This step runs a script: `pnpm run deploy:ci`. "}
{"id": "63c494ee8052faa2781ae44b", "level": "level5", "llm_response": "```yaml\nname: Add PR Deploy Badge\n\non:\n  deployment_status:\n    types: [created]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    if: github.event.deployment_status.state == 'success'\n    permissions:\n      pull-requests: write\n\n    steps:\n    - name: Kb Pull Request Deployment Badges\n      uses: kibibit/kb-badger-action@v2\n      with:\n        github-token: ${{ secrets.GITHUB_TOKEN }}\n        badge-left: demo\n        badge-right: application\n        badge-logo: heroku\n        badge-path: api\n        badge2-left: demo\n        badge2-right: api-docs\n        badge2-color: 85EA2D\n        badge2-logo: swagger\n        badge2-path: api/docs\n```", "answer": "```yaml name: Add PR Deploy Badge\n# https://docs.github.com/en/actions/reference/events-that-trigger-workflows\non: [deployment_status]\n\njobs:\n  badge:\n    runs-on: ubuntu-latest\n    permissions:\n      pull-requests: write\n    # only runs this job on successful deploy\n    if: github.event.deployment_status.state == 'success'\n    steps:\n    - name: Kb Pull Request Deployment Badges\n      uses: kibibit/kb-badger-action@v2\n      with:\n        github-token: ${{secrets.GITHUB_TOKEN}}\n        badge-left: demo\n        badge-right: application\n        badge-logo: heroku\n        badge-path: api\n        badge2-left: demo\n        badge2-right: api-docs\n        badge2-color: 85EA2D\n        badge2-logo: swagger\n        badge2-path: api/docs\n```", "prompt": "Generate a GitHub Workflow named `Add PR Deploy Badge` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a new deployment status is created. The workflow has one job. The job id of the 1st job is `badge`. This job will run only if the condition(github.event.deployment_status.state == 'success') is met. This job will run on ubuntu-latest runner. The job `badge` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `badge`. The job `badge` has one step. The 1st step is named `Kb Pull Request Deployment Badges`. This step runs action `kibibit/kb-badger-action` tagged as v2. The step defines 10 input parameters for the action: `github-token` is set to `${{secrets.GITHUB_TOKEN}}`, `badge-left` is set to `demo`, `badge-right` is set to `application`, `badge-logo` is set to `heroku`, `badge-path` is set to `api`, `badge2-left` is set to `demo`, `badge2-right` is set to `api-docs`, `badge2-color` is set to `85EA2D`, `badge2-logo` is set to `swagger` and `badge2-path` is set to `api/docs`. "}
{"id": "63c4968b33b087f6bde2caaa", "level": "level5", "llm_response": "```yaml\nname: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n    tags: [ '*' ]\n  repository_dispatch:\n\nenv:\n  DOTNET_SDK_VERSION: \"6.0.x\"\n\njobs:\n  publish:\n    runs-on: windows-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.0.2\n      with:\n        submodules: recursive\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v2.1.0\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --info\n\n    - name: Restore packages in preparation for ASFEnhance publishing\n      run: dotnet restore ASFEnhance -p:ContinuousIntegrationBuild=true --nologo\n\n    - name: Publish ASFEnhance on Windows\n      run: |\n        $script = \"./build.ps1\"\n        Set-Location ${{ github.workspace }};\n        powershell $script;\n\n    - name: Upload ASFEnhance-zh-Hans\n      uses: actions/upload-artifact@v3.0.0\n      with:\n        name: ASFEnhance-zh-Hans\n        path: dist/ASFEnhance-zh-Hans.zip\n      if: always()\n\n    - name: Upload ASFEnhance-en-US\n      uses: actions/upload-artifact@v3.0.0\n      with:\n        name: ASFEnhance-en-US\n        path: dist/ASFEnhance-en-US.zip\n      if: always()\n```", "answer": "```yaml name: AutoBuild-Dev\n\non:\n  workflow_dispatch:\n  push:\n\nenv:\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  publish:\n    runs-on: windows-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.0.2\n        with:\n          submodules: recursive\n\n      - name: Setup .NET Core\n        uses: actions/setup-dotnet@v2.1.0\n        with:\n          dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n      - name: Verify .NET Core\n        run: dotnet --info\n\n      - name: Restore packages in preparation for ASFEnhance publishing\n        run: dotnet restore ASFEnhance -p:ContinuousIntegrationBuild=true --nologo\n\n      - name: Publish ASFEnhance on Windows\n        shell: pwsh\n        run: |\n          $script = \"./build.ps1\";\n          Set-Location ${{ github.workspace }};\n          powershell $script;\n\n      - name: Upload ASFEnhance-zh-Hans\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-zh-Hans\n          path: dist/ASFEnhance-zh-Hans.zip\n\n      - name: Upload ASFEnhance-en-US\n        continue-on-error: true\n        uses: actions/upload-artifact@v3.0.0\n        with:\n          name: ASFEnhance-en-US\n          path: dist/ASFEnhance-en-US.zip\n```", "prompt": "Generate a GitHub Workflow named `AutoBuild-Dev` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) a commit or tag is pushed, or a repository is cloned. The workflow sets an environment variable to use: `DOTNET_SDK_VERSION` is set to `6.0.x`. The workflow has one job. The job id of the 1st job is `publish`. This job will run on windows-latest runner. The job `publish` has 7 steps. The 1st step is named `Checkout code`. This step runs action `actions/checkout` tagged as v3.0.2. The step defines an input parameter for the action: `submodules` is set to `recursive`. The 2nd step is named `Setup .NET Core`. This step runs action `actions/setup-dotnet` tagged as v2.1.0. The step defines an input parameter for the action: `dotnet-version` is set to `${{ env.DOTNET_SDK_VERSION }}`. The 3rd step is named `Verify .NET Core`. This step runs a script: `dotnet --info`. The 4th step is named `Restore packages in preparation for ASFEnhance publishing`. This step runs a script: `dotnet restore ASFEnhance -p:ContinuousIntegrationBuild=true --nologo`. The 5th step is named `Publish ASFEnhance on Windows`. This step uses PowerShell Core to run a script: `$script = \"./build.ps1\";\nSet-Location ${{ github.workspace }};\npowershell $script;\n`. The 6th step is named `Upload ASFEnhance-zh-Hans`. This step runs action `actions/upload-artifact` tagged as v3.0.0. The step defines 2 input parameters for the action: `name` is set to `ASFEnhance-zh-Hans` and `path` is set to `dist/ASFEnhance-zh-Hans.zip`. When this step fails, the job will move on to the next step. The 7th step is named `Upload ASFEnhance-en-US`. This step runs action `actions/upload-artifact` tagged as v3.0.0. The step defines 2 input parameters for the action: `name` is set to `ASFEnhance-en-US` and `path` is set to `dist/ASFEnhance-en-US.zip`. When this step fails, the job will move on to the next step. "}
{"id": "63c494b78052faa2781acd9d", "level": "level5", "llm_response": "```yaml\nname: Merge me!\n\non:\n  workflow_run:\n    workflows: [Continuous Integration]\n    types: [completed]\n\njobs:\n  merge-me:\n    id: merge-me\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    timeout-minutes: 5\n    steps:\n      - name: Merge me!\n        uses: ridedott/merge-me-action@master\n        with:\n          GITHUB_TOKEN: ${{ secrets.DOTTBOTT_TOKEN }}\n```", "answer": "```yaml name: Merge me!\n\non:\n  workflow_run:\n    types:\n      - completed\n    workflows:\n      - 'Continuous Integration'\n\njobs:\n  merge-me:\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    name: Merge me!\n    runs-on: ubuntu-latest\n    steps:\n      - name: Merge me!\n        uses: ridedott/merge-me-action@master\n        with:\n          GITHUB_TOKEN: ${{ secrets.DOTTBOTT_TOKEN }}\n    timeout-minutes: 5\n```", "prompt": "Generate a GitHub Workflow named `Merge me!` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: the workflow named Continuous Integration is completed. The workflow has one job. The 1st job is named `Merge me!` and its job id is `merge-me`. This job will run only if the condition(${{ github.event.workflow_run.conclusion == 'success' }}) is met. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 5. The job `merge-me` has one step. The 1st step is named `Merge me!`. This step runs action `ridedott/merge-me-action` from the master branch. The step defines an input parameter for the action: `GITHUB_TOKEN` is set to `${{ secrets.DOTTBOTT_TOKEN }}`. "}
{"id": "63c494a37843b61269a027ed", "level": "level5", "llm_response": "```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  test:\n    runs-on: ${{ matrix.platform }}\n    strategy:\n      matrix:\n        go-version: [1.17.x]\n        platform: [ubuntu-latest, macos-latest, windows-latest]\n\n    steps:\n    - name: Install Go\n      uses: actions/setup-go@v3.3.0\n      with:\n        go-version: ${{ matrix.go-version }}\n\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n\n    - name: Build\n      run: go build ./...\n\n    - name: Test\n      run: go test ./...\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\n\nname: CI\n\njobs:\n  test:\n    ## We want to define a strategy for our job\n    strategy:\n      ## this will contain a matrix of all the combinations\n      ## we wish to test again:\n      matrix:\n        go-version: [1.17.x]\n        platform: [ubuntu-latest, macos-latest, windows-latest]\n\n    ## Defines the platform for each test run\n    runs-on: ${{ matrix.platform }}\n\n    ## the steps that will be run through for each version and platform\n    ## combination\n    steps:\n    ## sets up go based on the version\n    - name: Install Go\n      uses: actions/setup-go@v3.3.0\n      with:\n        go-version: ${{ matrix.go-version }}\n\n    ## checks out our code locally, so we can work with the files\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n\n    ## runs go test ./...\n    - name: Build\n      run: go build ./...\n\n    ## runs go test ./...\n    - name: Test\n      run: go test ./...\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `test`. This job will run on ${{ matrix.platform }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `go-version` has one value: 1.17.x. The variable `platform` has 3 values: ubuntu-latest, macos-latest and windows-latest. The job `test` has 4 steps. The 1st step is named `Install Go`. This step runs action `actions/setup-go` tagged as v3.3.0. The step defines an input parameter for the action: `go-version` is set to `${{ matrix.go-version }}`. The 2nd step is named `Checkout code`. This step runs action `actions/checkout` tagged as v3.1.0. The 3rd step is named `Build`. This step runs a script: `go build ./...`. The 4th step is named `Test`. This step runs a script: `go test ./...`. "}
{"id": "63c493b87843b612699fd399", "level": "level5", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Release Please\n        uses: GoogleCloudPlatform/release-please-action@v2\n        with:\n          release-type: node\n          package-name: release-please-action\n```", "answer": "```yaml on:\n  push:\n    branches:\n      - master\nname: release-please\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: GoogleCloudPlatform/release-please-action@v2\n        with:\n          release-type: node\n          package-name: release-please-action\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. This job will run on ubuntu-latest runner. The job `release-please` has one step. The 1st step is named ``. This step runs action `GoogleCloudPlatform/release-please-action` tagged as v2. The step defines 2 input parameters for the action: `release-type` is set to `node` and `package-name` is set to `release-please-action`. "}
{"id": "63c4941e7843b612699ff1f7", "level": "level5", "llm_response": "```yaml\nname: Demo link\n\non:\n  pull_request:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    id: add_demo_link\n    runs-on: ubuntu-latest\n    permissions:\n      pull-requests: write\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - name: Update PR description\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const pullRequestId = context.payload.pull_request.number\n            const pullRequestBranch = context.payload.pull_request.head.ref\n\n            github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: pullRequestId,\n              body: `\ud83d\udc40 [Visit Preview](https://${pullRequestBranch}--welcome-ui.netlify.app)`\n            });\n```", "answer": "```yaml name: Demo link\n\non:\n  pull_request_target:\n    types: [opened]\n\njobs:\n  add_demo_link:\n    name: Add demo link to PR description\n    runs-on: ubuntu-latest\n    env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    permissions:\n      pull-requests: write\n    steps:\n      - name: Update PR description\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const pullRequestId = context.payload.pull_request.number\n            const pullRequestBranch = context.payload.pull_request.head.ref\n\n            github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: pullRequestId,\n              body: `\ud83d\udc40 [Visit Preview](https://${pullRequestBranch}--welcome-ui.netlify.app)`\n            });\n```", "prompt": "Generate a GitHub Workflow named `Demo link` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a pull request is created. The workflow has one job. The 1st job is named `Add demo link to PR description` and its job id is `add_demo_link`. This job will run on ubuntu-latest runner. The job `add_demo_link` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `add_demo_link`. The job sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. The job `add_demo_link` has one step. The 1st step is named `Update PR description`. This step runs action `actions/github-script` tagged as v6. The step defines an input parameter for the action: `script` is set to `const pullRequestId = context.payload.pull_request.number\nconst pullRequestBranch = context.payload.pull_request.head.ref\n\ngithub.rest.issues.createComment({\n  owner: context.repo.owner,\n  repo: context.repo.repo,\n  issue_number: pullRequestId,\n  body: `\ud83d\udc40 [Visit Preview](https://${pullRequestBranch}--welcome-ui.netlify.app)`\n});\n`. "}
{"id": "63c494608052faa2781aabf4", "level": "level5", "llm_response": "```yaml\nname: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Set up Go\n        uses: actions/setup-go@c4a742cab115ed795e34d4513e2cf7d472deb55f\n        with:\n          go-version: '1.17'\n\n      - name: Check go.mod files\n        run: |\n          cd gomod-sync\n          go run main.go check\n```", "answer": "```yaml name: go.mod check\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  check:\n    name: go.mod check\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - uses: actions/setup-go@c4a742cab115ed795e34d4513e2cf7d472deb55f\n        with:\n          go-version: 1.17\n\n      - name: Check go.mod files\n        shell: bash\n        run: |\n          cd gomod-sync\n          go run main.go check\n```", "prompt": "Generate a GitHub Workflow named `go.mod check` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) there is activity relating to a pull request. The workflow has one job. The 1st job is named `go.mod check` and its job id is `check`. This job will run on ubuntu-latest runner. The job `check` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` whose commit is 93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8. The 2nd step is named ``. This step runs action `actions/setup-go` whose commit is c4a742cab115ed795e34d4513e2cf7d472deb55f. The step defines an input parameter for the action: `go-version` is set to `1.17`. The 3rd step is named `Check go.mod files`. This step uses bash to run a script: `cd gomod-sync\ngo run main.go check\n`. "}
{"id": "63c494be7843b61269a0325c", "level": "level5", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n    strategy:\n      matrix:\n        language: [javascript, typescript]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: ${{ matrix.language }}\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # For most projects, this workflow file will not need changing; you simply need\n# to commit it to your repository.\n#\n# You may wish to alter this file to override the set of languages analyzed,\n# or to provide custom queries or build logic.\n#\n# ******** NOTE ********\n# We have attempted to detect the languages in your repository. Please check\n# the `language` matrix defined below to confirm you have the correct set of\n# supported CodeQL languages.\n#\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"main\" ]\n  schedule:\n    - cron: '25 2 * * 4'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'javascript', 'typescript' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 02:25 am, only on thursday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has 2 values: javascript and typescript. The job `analyze` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `actions` scope, read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `security-events` scope. This permission setting only applies to the job `analyze`. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Initialize CodeQL`. This step runs action `github/codeql-action/init` tagged as v2. The step defines an input parameter for the action: `languages` is set to `${{ matrix.language }}`. The 3rd step is named `Autobuild`. This step runs action `github/codeql-action/autobuild` tagged as v2. The 4th step is named `Perform CodeQL Analysis`. This step runs action `github/codeql-action/analyze` tagged as v2. "}
{"id": "63c494228052faa2781a95a5", "level": "level5", "llm_response": "```yaml\nname: snyk-pr\n\non:\n  pull_request:\n    branches:\n      - master\n\njobs:\n  whitesource:\n    runs-on: ubuntu-latest\n    if: github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa'\n    steps:\n      - name: checkout\n        uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n          fetch-depth: 0\n\n      - name: checkout action\n        uses: actions/checkout@v3\n        with:\n          repository: snowflakedb/whitesource-actions\n          token: ${{ secrets.WHITESOURCE_ACTION_TOKEN }}\n          path: whitesource-actions\n\n      - name: PR\n        env:\n          PR_TITLE: ${{ github.event.pull_request.title }}\n        run: ./whitesource-actions/snyk-pr\n        with:\n          jira_token: ${{ secrets.JIRA_TOKEN_PUBLIC_REPO }}\n          gh_token: ${{ secrets.GITHUB_TOKEN }}\n          amend: False\n```", "answer": "```yaml name: snyk-pr\non:\n  pull_request:\n    branches:\n      - master\njobs:\n  whitesource:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa' }}\n    steps:\n    - name: checkout\n      uses: actions/checkout@v3\n      with:\n        ref: ${{ github.event.pull_request.head.ref }}\n        fetch-depth: 0\n\n    - name: checkout action\n      uses: actions/checkout@v3\n      with:\n        repository: snowflakedb/whitesource-actions\n        token: ${{ secrets.WHITESOURCE_ACTION_TOKEN }}\n        path: whitesource-actions\n\n    - name: PR\n      uses: ./whitesource-actions/snyk-pr\n      env:\n        PR_TITLE: ${{ github.event.pull_request.title }}\n      with:\n        jira_token: ${{ secrets.JIRA_TOKEN_PUBLIC_REPO }}\n        gh_token: ${{ secrets.GITHUB_TOKEN }}\n        amend: false # true if you want the commit to be amended with the JIRA number\n```", "prompt": "Generate a GitHub Workflow named `snyk-pr` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `whitesource`. This job will run only if the condition(${{ github.event.pull_request.user.login == 'sfc-gh-snyk-sca-sa' }}) is met. This job will run on ubuntu-latest runner. The job `whitesource` has 3 steps. The 1st step is named `checkout`. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `ref` is set to `${{ github.event.pull_request.head.ref }}` and `fetch-depth` is set to `0`. The 2nd step is named `checkout action`. This step runs action `actions/checkout` tagged as v3. The step defines 3 input parameters for the action: `repository` is set to `snowflakedb/whitesource-actions`, `token` is set to `${{ secrets.WHITESOURCE_ACTION_TOKEN }}` and `path` is set to `whitesource-actions`. The 3rd step is named `PR`. The step sets an environment variable to use: `PR_TITLE` is set to `${{ github.event.pull_request.title }}`. This step runs action `./whitesource-actions/snyk-pr`.The step defines 3 input parameters for the action: `jira_token` is set to `${{ secrets.JIRA_TOKEN_PUBLIC_REPO }}`, `gh_token` is set to `${{ secrets.GITHUB_TOKEN }}` and `amend` is set to `False`. "}
{"id": "63c493c37843b612699fd587", "level": "level5", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Draft Release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        uses: release-drafter/release-drafter@v5\n        with:\n          tag_name: vNext\n          release_name: vNext\n          draft: true\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    # branches to consider in the event; optional, defaults to all\n    branches:\n      - main\n  # pull_request event is required only for autolabeler\n  pull_request:\n    # Only following types are handled by the action, but one can default to all as well\n    types: [opened, reopened, synchronize]\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Draft Release\n        uses: release-drafter/release-drafter@v5\n        with:\n          tag_name: vNext\n          release_name: vNext\n          draft: true\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is TSQL. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created, a previously closed pull request is reopened or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `update_release_draft`. This job will run on ubuntu-latest runner. The job `update_release_draft` has one step. The 1st step is named `Draft Release`. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `release-drafter/release-drafter` tagged as v5. The step defines 3 input parameters for the action: `tag_name` is set to `vNext`, `release_name` is set to `vNext` and `draft` is set to `True`. "}
{"id": "63c495238052faa2781afbf5", "level": "level5", "llm_response": "```yaml\nname: Greetings\n\non:\n  pull_request:\n  issue:\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Greet\n      uses: actions/first-interaction@v1\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        issue-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to fix your issue ASAP. Make sure that you have read about issue format in the docs'\n        pr-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to review your PR ASAP. Make sure that you have read about requirements to pull requests in the docs'\n```", "answer": "```yaml name: Greetings\n\non: [pull_request, issues]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/first-interaction@v1\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        issue-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to fix your issue ASAP. Make sure that you have read about issue format in the docs'\n        pr-message: 'Welcome to BrainFlow project and thanks for your contribution! We will try to review your PR ASAP. Make sure that you have read about requirements to pull requests in the docs'\n```", "prompt": "Generate a GitHub Workflow named `Greetings` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) activity related to an issue occurs. The workflow has one job. The job id of the 1st job is `greeting`. This job will run on ubuntu-latest runner. The job `greeting` has one step. The 1st step is named ``. This step runs action `actions/first-interaction` tagged as v1. The step defines 3 input parameters for the action: `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`, `issue-message` is set to `Welcome to BrainFlow project and thanks for your contribution! We will try to fix your issue ASAP. Make sure that you have read about issue format in the docs` and `pr-message` is set to `Welcome to BrainFlow project and thanks for your contribution! We will try to review your PR ASAP. Make sure that you have read about requirements to pull requests in the docs`. "}
{"id": "63c496956fc19abdf9c9ce1c", "level": "level5", "llm_response": "```yaml\nname: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    id: test\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set Node.js 16.x\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16.x'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Install licensed\n        run: |\n          cd $RUNNER_TEMP\n          curl -Lfs -o licensed.tar.gz https://github.com/github/licensed/releases/download/3.4.4/licensed-3.4.4-linux-x64.tar.gz\n          sudo tar -xzf licensed.tar.gz\n          sudo mv licensed /usr/local/bin/licensed\n\n      - name: Check licenses\n        run: licensed status\n```", "answer": "```yaml name: Licensed\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    name: Check licenses\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set Node.js 16.x\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16.x\n          cache: npm\n      - run: npm ci\n      - name: Install licensed\n        run: |\n          cd $RUNNER_TEMP\n          curl -Lfs -o licensed.tar.gz https://github.com/github/licensed/releases/download/3.4.4/licensed-3.4.4-linux-x64.tar.gz\n          sudo tar -xzf licensed.tar.gz\n          sudo mv licensed /usr/local/bin/licensed\n      - run: licensed status\n```", "prompt": "Generate a GitHub Workflow named `Licensed` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Check licenses` and its job id is `test`. This job will run on ubuntu-latest runner. The job `test` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set Node.js 16.x`. This step runs action `actions/setup-node` tagged as v3. The step defines 2 input parameters for the action: `node-version` is set to `16.x` and `cache` is set to `npm`. The 3rd step is named ``. This step runs a script: `npm ci`. The 4th step is named `Install licensed`. This step runs a script: `cd $RUNNER_TEMP\ncurl -Lfs -o licensed.tar.gz https://github.com/github/licensed/releases/download/3.4.4/licensed-3.4.4-linux-x64.tar.gz\nsudo tar -xzf licensed.tar.gz\nsudo mv licensed /usr/local/bin/licensed\n`. The 5th step is named ``. This step runs a script: `licensed status`. "}
{"id": "63c494937843b61269a02136", "level": "level5", "llm_response": "```yaml\nname: e2e melange bootstrap + build\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository:\n    types: [created]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    container:\n      image: alpine:latest\n      options: --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n\n    steps:\n    - name: Fetch dependencies\n      run: |\n        cat >/etc/apk/repositories <<_EOF_\n        https://dl-cdn.alpinelinux.org/alpine/edge/main\n        https://dl-cdn.alpinelinux.org/alpine/edge/community\n        https://dl-cdn.alpinelinux.org/alpine/edge/testing\n        _EOF_\n        apk upgrade -Ua\n        apk add go cosign build-base git bubblewrap\n\n    - name: Checkout code\n      uses: actions/checkout@2541b1294d2704b0964813337f33b291d3f8596b\n\n    - name: Mark workspace as a safe repository\n      run: git config --global --add safe.directory ${GITHUB_WORKSPACE}\n\n    - name: Build bootstrap melange tool (stage1)\n      run: make melange\n\n    - name: Generate a package signing keypair\n      run: |\n        ./melange keygen\n        mv melange.rsa.pub /etc/apk/keys\n\n    - name: Prepare build workspace for stage2\n      run: git clone . workspace-stage2/x86_64\n\n    - name: Build stage2 melange package with bootstrap melange\n      run: ./melange build --pipeline-dir=pipelines/ --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage2/\n\n    - name: Install stage2 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n\n    - name: Move stage2 artifacts to stage2 directory\n      run: mv packages stage2\n\n    - name: Verify operation of stage2 melange\n      run: melange version\n\n    - name: Prepare build workspace for stage3\n      run: git clone . workspace-stage3/x86_64\n\n    - name: Build stage3 melange package with stage2 melange\n      run: melange build --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage3/\n\n    - name: Install stage3 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n\n    - name: Move stage3 artifacts to stage3 directory\n      run: mv packages stage3\n\n    - name: Ensure melange package is reproducible\n      run: |\n        sha256sum stage2/x86_64/*.apk | sed -e 's:stage2/:stage3/:g' | sha256sum -c\n\n    - name: Verify operation of stage3 melange\n      run: melange version\n```", "answer": "```yaml name: e2e melange bootstrap + build\n\non:\n  push:\n  pull_request:\n\njobs:\n  build:\n    name: bootstrap package\n    runs-on: ubuntu-latest\n    container:\n      image: alpine:latest\n      options: |\n        --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n\n    steps:\n    - name: Fetch dependencies\n      run: |\n        cat >/etc/apk/repositories <<_EOF_\n        https://dl-cdn.alpinelinux.org/alpine/edge/main\n        https://dl-cdn.alpinelinux.org/alpine/edge/community\n        https://dl-cdn.alpinelinux.org/alpine/edge/testing\n        _EOF_\n\n        apk upgrade -Ua\n        apk add go cosign build-base git bubblewrap\n    - uses: actions/checkout@2541b1294d2704b0964813337f33b291d3f8596b\n    - name: Mark workspace as a safe repository\n      run: git config --global --add safe.directory ${GITHUB_WORKSPACE}\n    - name: Build bootstrap melange tool (stage1)\n      run: make melange\n    - name: Generate a package signing keypair\n      run: |\n        ./melange keygen\n        mv melange.rsa.pub /etc/apk/keys\n    - name: Prepare build workspace for stage2\n      run: |\n        git clone . workspace-stage2/x86_64\n    - name: Build stage2 melange package with bootstrap melange\n      run: ./melange build --pipeline-dir=pipelines/ --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage2/\n    - name: Install stage2 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage2 artifacts to stage2 directory\n      run: |\n        mv packages stage2\n    - name: Verify operation of stage2 melange\n      run: melange version\n    - name: Prepare build workspace for stage3\n      run: |\n        git clone . workspace-stage3/x86_64\n    - name: Build stage3 melange package with stage2 melange\n      run: melange build --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage3/\n    - name: Install stage3 melange package\n      run: apk add ./packages/x86_64/melange-*.apk\n    - name: Move stage3 artifacts to stage3 directory\n      run: |\n        mv packages stage3\n    - name: Ensure melange package is reproducible\n      run: |\n        sha256sum stage2/x86_64/*.apk | sed -e 's:stage2/:stage3/:g' | sha256sum -c\n    - name: Verify operation of stage3 melange\n      run: melange version\n```", "prompt": "Generate a GitHub Workflow named `e2e melange bootstrap + build` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `bootstrap package` and its job id is `build`. This job will run on ubuntu-latest runner. The job creates a Docker container that uses `alpine:latest` image. It configures additional container resource options: --cap-add NET_ADMIN --cap-add SYS_ADMIN --security-opt seccomp=unconfined --security-opt apparmor:unconfined\n. The job `build` has 16 steps. The 1st step is named `Fetch dependencies`. This step runs a script: `cat >/etc/apk/repositories <<_EOF_\nhttps://dl-cdn.alpinelinux.org/alpine/edge/main\nhttps://dl-cdn.alpinelinux.org/alpine/edge/community\nhttps://dl-cdn.alpinelinux.org/alpine/edge/testing\n_EOF_\n\napk upgrade -Ua\napk add go cosign build-base git bubblewrap\n`. The 2nd step is named ``. This step runs action `actions/checkout` whose commit is 2541b1294d2704b0964813337f33b291d3f8596b. The 3rd step is named `Mark workspace as a safe repository`. This step runs a script: `git config --global --add safe.directory ${GITHUB_WORKSPACE}`. The 4th step is named `Build bootstrap melange tool (stage1)`. This step runs a script: `make melange`. The 5th step is named `Generate a package signing keypair`. This step runs a script: `./melange keygen\nmv melange.rsa.pub /etc/apk/keys\n`. The 6th step is named `Prepare build workspace for stage2`. This step runs a script: `git clone . workspace-stage2/x86_64\n`. The 7th step is named `Build stage2 melange package with bootstrap melange`. This step runs a script: `./melange build --pipeline-dir=pipelines/ --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage2/`. The 8th step is named `Install stage2 melange package`. This step runs a script: `apk add ./packages/x86_64/melange-*.apk`. The 9th step is named `Move stage2 artifacts to stage2 directory`. This step runs a script: `mv packages stage2\n`. The 10th step is named `Verify operation of stage2 melange`. This step runs a script: `melange version`. The 11th step is named `Prepare build workspace for stage3`. This step runs a script: `git clone . workspace-stage3/x86_64\n`. The 12th step is named `Build stage3 melange package with stage2 melange`. This step runs a script: `melange build --signing-key=melange.rsa --arch x86_64 --workspace-dir workspace-stage3/`. The 13th step is named `Install stage3 melange package`. This step runs a script: `apk add ./packages/x86_64/melange-*.apk`. The 14th step is named `Move stage3 artifacts to stage3 directory`. This step runs a script: `mv packages stage3\n`. The 15th step is named `Ensure melange package is reproducible`. This step runs a script: `sha256sum stage2/x86_64/*.apk | sed -e 's:stage2/:stage3/:g' | sha256sum -c\n`. The 16th step is named `Verify operation of stage3 melange`. This step runs a script: `melange version`. "}
{"id": "63c495e58052faa2781b4f4c", "level": "level5", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 */6 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - name: Mark stale issues and pull requests\n      uses: actions/stale@v6\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        days-before-pr-stale: 14\n        days-before-pr-close: 14\n        stale-pr-label: inactive\n        close-pr-label: auto-close\n        exempt-pr-labels: keep-open\n        stale-pr-message: 'This pull request has been inactive for 14 days. If you are finished with your changes, don''t forget to sign off. See the [contributor guide](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-write-pull-request-automation?branch=main) for instructions. If this PR is inactive for 14 more days, it will be closed automatically. Thank you! VS Content Team [Contact Us](mailto:vs-content@microsoft.com)  [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)'\n        close-pr-message: 'This pull request has been inactive for 28 days. At this time, we are closing the PR. If you decide to continue working on your change, you can reopen the PR and continue working. Thank you! VS Content Team [Contact Us](mailto:vs-content@microsoft.com)  [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)'\n```", "answer": "```yaml name: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '0 */6 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v6\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        days-before-pr-stale: 14\n        days-before-pr-close: 14\n        stale-pr-label: 'inactive'\n        close-pr-label: 'auto-close'\n        exempt-pr-labels: 'keep-open'\n        stale-pr-message: >\n          This pull request has been inactive for 14 days. \n          If you are finished with your changes, don't forget to sign off. See the [contributor guide](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-write-pull-request-automation?branch=main) for instructions. \n          If this PR is inactive for 14 more days, it will be closed automatically. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n        close-pr-message: >\n          This pull request has been inactive for 28 days. At this time, we are closing the PR.  \n          If you decide to continue working on your change, you can reopen the PR and continue working. Thank you! \n          \n          VS Content Team\n          \n          [Contact Us](mailto:vs-content@microsoft.com) \n          [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n          \n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: every 6 hours. The workflow has one job. The job id of the 1st job is `stale`. This job will run on ubuntu-latest runner. The job `stale` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `stale`. The job `stale` has one step. The 1st step is named ``. This step runs action `actions/stale` tagged as v6. The step defines 8 input parameters for the action: `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`, `days-before-pr-stale` is set to `14`, `days-before-pr-close` is set to `14`, `stale-pr-label` is set to `inactive`, `close-pr-label` is set to `auto-close`, `exempt-pr-labels` is set to `keep-open`, `stale-pr-message` is set to `This pull request has been inactive for 14 days.  If you are finished with your changes, don't forget to sign off. See the [contributor guide](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-write-pull-request-automation?branch=main) for instructions.  If this PR is inactive for 14 more days, it will be closed automatically. Thank you! \nVS Content Team\n[Contact Us](mailto:vs-content@microsoft.com)  [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n` and `close-pr-message` is set to `This pull request has been inactive for 28 days. At this time, we are closing the PR.   If you decide to continue working on your change, you can reopen the PR and continue working. Thank you! \nVS Content Team\n[Contact Us](mailto:vs-content@microsoft.com)  [Contributor Guide](https://review.docs.microsoft.com/en-us/help/contribute/visualstudio-docs-contribute?branch=main)\n`. "}
{"id": "63c4951f7843b61269a0593c", "level": "level5", "llm_response": "```yaml\nname: docker-push\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.1.0\n\n      - name: Docker meta\n        id: meta\n        uses: docker/metadata-action@v4.1.0\n        with:\n          images: fsouza/fake-gcs-server\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n\n      - name: Setup QEMU\n        uses: docker/setup-qemu-action@v2.1.0\n\n      - name: Setup Buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2.1.0\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2.1.0\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v3.2.0\n        with:\n          context: .\n          push: True\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          platforms: linux/amd64,linux/arm64\n```", "answer": "```yaml name: docker-push\non:\n  push:\n    tags:\n      - \"v*\"\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n\n      - name: docker meta\n        id: meta\n        uses: docker/metadata-action@v4.1.0\n        with:\n          images: fsouza/fake-gcs-server\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n\n      - name: setup qemu\n        uses: docker/setup-qemu-action@v2.1.0\n\n      - name: setup buildx\n        id: buildx\n        uses: docker/setup-buildx-action@v2.1.0\n\n      - name: login to docker hub\n        uses: docker/login-action@v2.1.0\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: build and push\n        uses: docker/build-push-action@v3.2.0\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          platforms: linux/amd64,linux/arm64\n```", "prompt": "Generate a GitHub Workflow named `docker-push` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The job id of the 1st job is `build-and-push`. This job will run on ubuntu-latest runner. The job `build-and-push` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3.1.0. The 2nd step is named `docker meta` and its id is `meta`. This step runs action `docker/metadata-action` tagged as v4.1.0. The step defines 2 input parameters for the action: `images` is set to `fsouza/fake-gcs-server` and `tags` is set to `type=ref,event=branch\ntype=ref,event=pr\ntype=semver,pattern={{version}}\ntype=semver,pattern={{major}}.{{minor}}\ntype=semver,pattern={{major}}\n`. The 3rd step is named `setup qemu`. This step runs action `docker/setup-qemu-action` tagged as v2.1.0. The 4th step is named `setup buildx` and its id is `buildx`. This step runs action `docker/setup-buildx-action` tagged as v2.1.0. The 5th step is named `login to docker hub`. This step runs action `docker/login-action` tagged as v2.1.0. The step defines 2 input parameters for the action: `username` is set to `${{ secrets.DOCKER_USERNAME }}` and `password` is set to `${{ secrets.DOCKER_PASSWORD }}`. The 6th step is named `build and push`. This step runs action `docker/build-push-action` tagged as v3.2.0. The step defines 5 input parameters for the action: `context` is set to `.`, `push` is set to `True`, `tags` is set to `${{ steps.meta.outputs.tags }}`, `labels` is set to `${{ steps.meta.outputs.labels }}` and `platforms` is set to `linux/amd64,linux/arm64`. "}
{"id": "63c495407843b61269a06679", "level": "level5", "llm_response": "```yaml\nname: Tests\n\non:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  tests:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: [3.6, 3.7, 3.8, 3.9, 3.10, 3.11-dev]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Install Linux packages for Qt 5 support\n      if: matrix.os == 'ubuntu-latest'\n      run: |\n        sudo apt-get update\n        sudo apt-get install qt5-default\n        sudo apt-get install libxkbcommon-x11-0\n        sudo apt-get install libxcb-icccm4\n        sudo apt-get install libxcb-image0\n        sudo apt-get install libxcb-keysyms1\n        sudo apt-get install libxcb-randr0\n        sudo apt-get install libxcb-render-util0\n        sudo apt-get install libxcb-xinerama0\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies and local packages\n      run: python -m pip install .[test]\n\n    - name: Create clean test directory\n      run: mkdir testdir\n\n    - name: Test Traits package\n      uses: GabrielBB/xvfb-action@v1\n      with:\n        working-directory: testdir\n        run: python -m unittest discover -v traits\n```", "answer": "```yaml name: Tests\n\non:\n- pull_request\n- workflow_dispatch\n\njobs:\n  tests:\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: ['3.6', '3.7', '3.8', '3.9', '3.10', '3.11-dev']\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install Linux packages for Qt 5 support\n      run: |\n        sudo apt-get update\n        sudo apt-get install qt5-default\n        sudo apt-get install libxkbcommon-x11-0\n        sudo apt-get install libxcb-icccm4\n        sudo apt-get install libxcb-image0\n        sudo apt-get install libxcb-keysyms1\n        sudo apt-get install libxcb-randr0\n        sudo apt-get install libxcb-render-util0\n        sudo apt-get install libxcb-xinerama0\n      if: matrix.os == 'ubuntu-latest'\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies and local packages\n      run: |\n        python -m pip install .[test]\n    - name: Create clean test directory\n      run: |\n        mkdir testdir\n    - name: Test Traits package\n      uses: GabrielBB/xvfb-action@v1\n      with:\n        working-directory: testdir\n        run: python -m unittest discover -v traits\n```", "prompt": "Generate a GitHub Workflow named `Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `tests`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `os` has 3 values: ubuntu-latest, windows-latest and macos-latest. The variable `python-version` has 6 values: 3.6, 3.7, 3.8, 3.9, 3.10 and 3.11-dev. The job `tests` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Install Linux packages for Qt 5 support`. This step will run only if the condition(matrix.os == 'ubuntu-latest') is met. This step runs a script: `sudo apt-get update\nsudo apt-get install qt5-default\nsudo apt-get install libxkbcommon-x11-0\nsudo apt-get install libxcb-icccm4\nsudo apt-get install libxcb-image0\nsudo apt-get install libxcb-keysyms1\nsudo apt-get install libxcb-randr0\nsudo apt-get install libxcb-render-util0\nsudo apt-get install libxcb-xinerama0\n`. The 3rd step is named `Set up Python ${{ matrix.python-version }}`. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `${{ matrix.python-version }}`. The 4th step is named `Install dependencies and local packages`. This step runs a script: `python -m pip install .[test]\n`. The 5th step is named `Create clean test directory`. This step runs a script: `mkdir testdir\n`. The 6th step is named `Test Traits package`. This step runs action `GabrielBB/xvfb-action` tagged as v1. The step defines 2 input parameters for the action: `working-directory` is set to `testdir` and `run` is set to `python -m unittest discover -v traits`. "}
{"id": "63c495448052faa2781b0abc", "level": "level5", "llm_response": "```yaml\nname: Node Blog CI\n\non:\n  push:\n    branches:\n      - '*'\n    except:\n      - release\n  pull_request:\n    branches:\n      - '*'\n    except:\n      - release\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@master\n\n    - name: Launch MongoDB\n      uses: wbari/start-mongoDB@master\n      with:\n        mongoDBVersion: 5\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@master\n      with:\n        node-version: ${{ matrix.node-version }}\n\n    - name: yarn install, build, and test\n      run: |\n        yarn install\n        yarn run build\n        yarn run test:cov\n\n    - name: Upload coverage to Codecov\n      env:\n        CI: True\n      uses: codecov/codecov-action@master\n      with:\n        token: ${{secrets.CODECOV_TOKEN}}\n```", "answer": "```yaml name: Node Blog CI\n\non:\n  push:\n    branches-ignore:\n    - release\n  pull_request:\n    branches-ignore:\n    - release\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node-version: [16.x]\n    steps:\n    - uses: actions/checkout@master\n    - name: Launch MongoDB\n      uses: wbari/start-mongoDB@master\n      with:\n        mongoDBVersion: 5\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@master\n      with:\n        node-version: ${{ matrix.node-version }}\n    - name: yarn install, build, and test\n      run: |\n        yarn install\n        yarn run build\n        yarn run test:cov\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@master\n      with:\n        token: ${{secrets.CODECOV_TOKEN}}\n      env:\n        CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node Blog CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event unless the push event is to: a branch named release. 2) The workflow would run whenever there is a pull_request event unless the pull request is targeting: a branch named release. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `node-version` has one value: 16.x. The job `build` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` from the master branch. The 2nd step is named `Launch MongoDB`. This step runs action `wbari/start-mongoDB` from the master branch. The step defines an input parameter for the action: `mongoDBVersion` is set to `5`. The 3rd step is named `Use Node.js ${{ matrix.node-version }}`. This step runs action `actions/setup-node` from the master branch. The step defines an input parameter for the action: `node-version` is set to `${{ matrix.node-version }}`. The 4th step is named `yarn install, build, and test`. This step runs a script: `yarn install\nyarn run build\nyarn run test:cov\n`. The 5th step is named `Upload coverage to Codecov`. The step sets an environment variable to use: `CI` is set to `True`. This step runs action `codecov/codecov-action` from the master branch. The step defines an input parameter for the action: `token` is set to `${{secrets.CODECOV_TOKEN}}`. "}
{"id": "63c496561899db58864d23cc", "level": "level5", "llm_response": "```yaml\nname: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  mysql:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug-the == true }}\n      scenario: mysql\n      versions: \"[5.6, 5.7, \\\"8.0\\\", \\\"galera.3.mysql_wsrep.5.6\\\", \\\"galera.4.10.mysql_wsrep.8.0.26\\\", \\\"mariadb.10.3\\\", \\\"mariadb.10.4\\\", \\\"mariadb.10.5\\\", \\\"mariadb.10.6\\\"]\"\n```", "answer": "```yaml name: Molecule - MySQL\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.mysql.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/mysql.*/**\n      - roles/mysql/**\n      # Plugins\n      - plugins/filter/mysql_config.py\n      - plugins/filter/staten.py\n      - plugins/lookup/templates_exclusive.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  mysql:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: mysql\n      versions: '[5.6, 5.7, \"8.0\", \"galera.3.mysql_wsrep.5.6\", \"galera.4.10.mysql_wsrep.8.0.26\", \"mariadb.10.3\", \"mariadb.10.4\", \"mariadb.10.5\", \"mariadb.10.6\"]'\n```", "prompt": "Generate a GitHub Workflow named `Molecule - MySQL` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.mysql.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/mysql.*/**, roles/mysql/**, plugins/filter/mysql_config.py, plugins/filter/staten.py or plugins/lookup/templates_exclusive.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `mysql`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 3 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}`, the input `scenario` is `mysql` and the input `versions` is `[5.6, 5.7, \"8.0\", \"galera.3.mysql_wsrep.5.6\", \"galera.4.10.mysql_wsrep.8.0.26\", \"mariadb.10.3\", \"mariadb.10.4\", \"mariadb.10.5\", \"mariadb.10.6\"]`. "}
{"id": "63c495a88052faa2781b34fc", "level": "level5", "llm_response": "```yaml\nname: Build iso from elemental-iso-build as external user\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Install Docker\n        uses: docker-practice/actions-setup-docker@v1\n\n      - name: Install deps\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y mkisofs\n\n      - name: Build iso from script\n        run: |\n          echo \"TEST\" > config.yaml\n          curl -fsSL https://raw.githubusercontent.com/rancher/elemental/main/.github/elemental-iso-build -o elemental-iso-build\n          chmod +x ./elemental-iso-build\n          ./elemental-iso-build config.yaml\n\n      - name: Check config was inserted\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          isoinfo -x /livecd-cloud-config.yaml -R -i $ISO > livecd-cloud-config.yaml\n          cmp config.yaml livecd-cloud-config.yaml\n\n      - name: Basic sanity checks for ISO\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          isoinfo -d -i $ISO|grep -q Eltorito\n          isoinfo -d -i $ISO|grep -q bootable\n```", "answer": "```yaml name: Build iso from elemental-iso-build as external user\n# Test building the iso from an external point of view\n# This tests doesn't clone the repo, just interacts with the script as an external user would do\n# Gets the script only and runs it to see if the building is done properly\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Install Docker\n        uses: docker-practice/actions-setup-docker@v1\n      - name: Install deps\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y mkisofs\n      - name: Build iso from script\n        run: |\n          # Just a simple run to test the build script, no need to upload the generated iso!\n          echo \"TEST\" > config.yaml\n          curl -fsSL https://raw.githubusercontent.com/rancher/elemental/main/.github/elemental-iso-build -o elemental-iso-build\n          chmod +x ./elemental-iso-build\n          ./elemental-iso-build config.yaml\n      - name: Check config was inserted\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Extract config and check against our config\n          isoinfo -x /livecd-cloud-config.yaml -R -i $ISO > livecd-cloud-config.yaml\n          # This checks that the files are the same content\n          cmp config.yaml livecd-cloud-config.yaml\n      - name: Basic sanity checks for ISO\n        run: |\n          ISO=$(find . -name \"elemental-*.iso\" -print)\n          # Check it has eltorito\n          isoinfo -d -i $ISO|grep -q Eltorito\n          # check bootable flag\n          isoinfo -d -i $ISO|grep -q bootable        \n```", "prompt": "Generate a GitHub Workflow named `Build iso from elemental-iso-build as external user` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `deploy`. This job will run on ubuntu-latest runner. The job `deploy` has 5 steps. The 1st step is named `Install Docker`. This step runs action `docker-practice/actions-setup-docker` tagged as v1. The 2nd step is named `Install deps`. This step runs a script: `sudo apt-get update\nsudo apt-get install -y mkisofs\n`. The 3rd step is named `Build iso from script`. This step runs a script: `# Just a simple run to test the build script, no need to upload the generated iso!\necho \"TEST\" > config.yaml\ncurl -fsSL https://raw.githubusercontent.com/rancher/elemental/main/.github/elemental-iso-build -o elemental-iso-build\nchmod +x ./elemental-iso-build\n./elemental-iso-build config.yaml\n`. The 4th step is named `Check config was inserted`. This step runs a script: `ISO=$(find . -name \"elemental-*.iso\" -print)\n# Extract config and check against our config\nisoinfo -x /livecd-cloud-config.yaml -R -i $ISO > livecd-cloud-config.yaml\n# This checks that the files are the same content\ncmp config.yaml livecd-cloud-config.yaml\n`. The 5th step is named `Basic sanity checks for ISO`. This step runs a script: `ISO=$(find . -name \"elemental-*.iso\" -print)\n# Check it has eltorito\nisoinfo -d -i $ISO|grep -q Eltorito\n# check bootable flag\nisoinfo -d -i $ISO|grep -q bootable        \n`. "}
{"id": "63c495878052faa2781b26e9", "level": "level5", "llm_response": "```yaml\nname: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoclose issues\n        uses: arkon/issue-closer-action@v3.4\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          ignoreLabel: do-not-autoclose\n          rules: |\n            [\n              {\n                \"type\": \"title\",\n                \"regex\": \".*<(Source Name|short description)>*\",\n                \"message\": \"You did not fill out the description in the title\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*DELETE THIS SECTION IF YOU HAVE READ AND ACKNOWLEDGED IT.*\",\n                \"message\": \"The acknowledgment section was not removed\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*\\\\* (Aniyomi version|Android version|Device|Name|Link|Extension version): \\\\?.*\",\n                \"message\": \"The requested information was not filled out\"\n              }\n            ]\n```", "answer": "```yaml name: Issue closer\n\non:\n  issues:\n    types: [opened, edited, reopened]\n\njobs:\n  autoclose:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoclose issues\n        uses: arkon/issue-closer-action@v3.4\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          ignoreLabel: do-not-autoclose\n          rules: |\n            [\n              {\n                \"type\": \"title\",\n                \"regex\": \".*<(Source Name|short description)>*\",\n                \"message\": \"You did not fill out the description in the title\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*DELETE THIS SECTION IF YOU HAVE READ AND ACKNOWLEDGED IT.*\",\n                \"message\": \"The acknowledgment section was not removed\"\n              },\n              {\n                \"type\": \"body\",\n                \"regex\": \".*\\\\* (Aniyomi version|Android version|Device|Name|Link|Extension version): \\\\?.*\",\n                \"message\": \"The requested information was not filled out\"\n              }\n            ]\n```", "prompt": "Generate a GitHub Workflow named `Issue closer` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: an issue is opened, the title or body on an issue is edited or a closed issue is reopened. The workflow has one job. The job id of the 1st job is `autoclose`. This job will run on ubuntu-latest runner. The job `autoclose` has one step. The 1st step is named `Autoclose issues`. This step runs action `arkon/issue-closer-action` tagged as v3.4. The step defines 3 input parameters for the action: `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`, `ignoreLabel` is set to `do-not-autoclose` and `rules` is set to `[\n  {\n    \"type\": \"title\",\n    \"regex\": \".*<(Source Name|short description)>*\",\n    \"message\": \"You did not fill out the description in the title\"\n  },\n  {\n    \"type\": \"body\",\n    \"regex\": \".*DELETE THIS SECTION IF YOU HAVE READ AND ACKNOWLEDGED IT.*\",\n    \"message\": \"The acknowledgment section was not removed\"\n  },\n  {\n    \"type\": \"body\",\n    \"regex\": \".*\\\\* (Aniyomi version|Android version|Device|Name|Link|Extension version): \\\\?.*\",\n    \"message\": \"The requested information was not filled out\"\n  }\n]\n`. "}
{"id": "63c495257843b61269a05b78", "level": "level5", "llm_response": "```yaml\nname: Flatpak dependency updates\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-20.04\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3.1.0\n        with:\n          fetch-depth: 0\n          persist-credentials: false\n\n      - name: Update Flatpak dependencies\n        env:\n          GIT_AUTHOR_NAME: EasyEffects Bot\n          GIT_COMMITTER_NAME: EasyEffects Bot\n          GIT_AUTHOR_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GIT_COMMITTER_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GITHUB_TOKEN: ${{ secrets.EASYEFFECTS_BOT }}\n        run: docker run --rm -v $(pwd):/app ghcr.io/flathub/flatpak-external-data-checker:latest --update --always-fork util/flatpak/com.github.wwmm.easyeffects.Devel.json\n```", "answer": "```yaml name: Flatpak dependency updates\non:\n  schedule: # for scheduling to work this file must be in the default branch\n  - cron: \"0 0 * * *\" # run every day\n  workflow_dispatch: # can be manually dispatched under GitHub's \"Actions\" tab \n\njobs:\n  flatpak-external-data-checker:\n    runs-on: ubuntu-20.04\n\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          # we can't push changes to a fork via a shallow update, we need to clone the full repo\n          fetch-depth: 0\n          # by default when persisting credentials the local git config will use the workflow provided GITHUB_TOKEN, not our own GITHUB_TOKEN env var for the container\n          # we must not use the provided GITHUB_TOKEN, as it will fail to push to the fork since the provided GITHUB_TOKEN is only for the repository where the workflow is running \n          persist-credentials: false\n\n      - uses: docker://ghcr.io/flathub/flatpak-external-data-checker:latest\n        env:\n          GIT_AUTHOR_NAME: EasyEffects Bot\n          GIT_COMMITTER_NAME: EasyEffects Bot\n          # email sets \"EasyEffects Bot\" user as commit author\n          GIT_AUTHOR_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GIT_COMMITTER_EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          EMAIL: 110548574+easyeffects-bot@users.noreply.github.com\n          GITHUB_TOKEN: ${{ secrets.EASYEFFECTS_BOT }}\n        with:\n          args: --update --always-fork util/flatpak/com.github.wwmm.easyeffects.Devel.json\n```", "prompt": "Generate a GitHub Workflow named `Flatpak dependency updates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 am. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `flatpak-external-data-checker`. This job will run on ubuntu-20.04 runner. The job `flatpak-external-data-checker` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3.1.0. The step defines 2 input parameters for the action: `fetch-depth` is set to `0` and `persist-credentials` is set to `False`. The 2nd step is named ``. The step sets 6 environment variables to use: `GIT_AUTHOR_NAME` is set to `EasyEffects Bot`, `GIT_COMMITTER_NAME` is set to `EasyEffects Bot`, `GIT_AUTHOR_EMAIL` is set to `110548574+easyeffects-bot@users.noreply.github.com`, `GIT_COMMITTER_EMAIL` is set to `110548574+easyeffects-bot@users.noreply.github.com`, `EMAIL` is set to `110548574+easyeffects-bot@users.noreply.github.com` and `GITHUB_TOKEN` is set to `${{ secrets.EASYEFFECTS_BOT }}`. This step runs action `docker://ghcr.io/flathub/flatpak-external-data-checker:latest`.The step defines an input parameter for the action: `args` is set to `--update --always-fork util/flatpak/com.github.wwmm.easyeffects.Devel.json`. "}
{"id": "63c494a27843b61269a02770", "level": "level5", "llm_response": "```yaml\nname: Doc Site\n\non:\n  push:\n    branches:\n      - master\n  workflow_dispatch:\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-and-deploy-site:\n    runs-on: ubuntu-latest\n    id: build-and-deploy-site\n\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n\n      - name: Install and Build \ud83d\udd27\n        run: |\n          npm install --legacy-peer-deps\n          npm run docs:build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4.2.5\n        with:\n          branch: gh-pages\n          folder: dist/site\n```", "answer": "```yaml # This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Doc Site\n\non:\n  push:\n    branches: [master]\n  workflow_dispatch:\n\njobs:\n  build-and-deploy-site:\n    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v3\n\n      - name: Install and Build \ud83d\udd27 # This example project is built using npm and outputs the result to the 'build' folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.\n        run: |\n          npm install --legacy-peer-deps\n          npm run docs:build\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@v4.2.5\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: dist/site # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `Doc Site` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build-and-deploy-site`. This job will run on ubuntu-latest runner. Only a single job using the ci-${{ github.ref }} concurrency group will run at a time. The job `build-and-deploy-site` has 3 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Install and Build \ud83d\udd27`. This step runs a script: `npm install --legacy-peer-deps\nnpm run docs:build\n`. The 3rd step is named `Deploy \ud83d\ude80`. This step runs action `JamesIves/github-pages-deploy-action` tagged as v4.2.5. The step defines 2 input parameters for the action: `branch` is set to `gh-pages` and `folder` is set to `dist/site`. "}
{"id": "63c495bf8052faa2781b3ef6", "level": "level5", "llm_response": "```yaml\nname: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - master\n    paths:\n      - .github/workflows/mol_tree2_lib.yml\n      - tree2/**\n  pull_request:\n  schedule:\n    - cron: '0 7 * * *'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Run mam_build action\n        uses: hyoo-ru/mam_build@master2\n        with:\n          package: mol\n          modules: tree2/lib\n\n      - name: Publish to npm\n        if: github.ref == 'refs/heads/master'\n        uses: JS-DevTools/npm-publish@v1\n        with:\n          token: ${{ secrets.NPM_AUTH_TOKEN }}\n          package: ./mol/tree2/lib/-/package.json\n```", "answer": "```yaml name: mol_tree2_lib\n\non:\n  workflow_dispatch:\n  push:\n    branches: \n      - master\n    paths:\n      - '.github/workflows/mol_tree2_lib.yml'\n      - 'tree2/**'\n  pull_request:\n  schedule:\n    - cron: \"0 7 * * *\"\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    \n    steps:\n    \n    - uses: hyoo-ru/mam_build@master2\n      with:\n        package: mol\n        modules: tree2/lib\n    \n    - uses: JS-DevTools/npm-publish@v1\n      if: ${{ github.ref == 'refs/heads/master' }}\n      with:\n        token: ${{ secrets.NPM_AUTH_TOKEN }}\n        package: ./mol/tree2/lib/-/package.json\n```", "prompt": "Generate a GitHub Workflow named `mol_tree2_lib` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. Only if at least one path of push event matches a pattern in the paths filter(.github/workflows/mol_tree2_lib.yml or tree2/**), the workflow runs. 3) there is activity relating to a pull request. 4) the scheduled time has come: at 07:00 am. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 2 steps. The 1st step is named ``. This step runs action `hyoo-ru/mam_build` from the master2 branch. The step defines 2 input parameters for the action: `package` is set to `mol` and `modules` is set to `tree2/lib`. The 2nd step is named ``. This step will run only if the condition(${{ github.ref == 'refs/heads/master' }}) is met. This step runs action `JS-DevTools/npm-publish` tagged as v1. The step defines 2 input parameters for the action: `token` is set to `${{ secrets.NPM_AUTH_TOKEN }}` and `package` is set to `./mol/tree2/lib/-/package.json`. "}
{"id": "63c496361e33648075779191", "level": "level5", "llm_response": "```yaml\nname: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set up Release Drafter\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        uses: release-drafter/release-drafter@v5\n```", "answer": "```yaml name: Release Drafter\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release Drafter` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. This job will run on ubuntu-latest runner. The job `update_release_draft` has one step. The 1st step is named ``. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `release-drafter/release-drafter` tagged as v5. "}
{"id": "63c496561899db58864d23d2", "level": "level5", "llm_response": "```yaml\nname: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  ntp:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug-the == true }}\n      scenario: ntp\n```", "answer": "```yaml name: Molecule - Ntp\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.ntp.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/ntp/**\n      - roles/ntp/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  ntp:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: ntp\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Ntp` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.ntp.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/ntp/** or roles/ntp/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `ntp`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 2 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}` and the input `scenario` is `ntp`. "}
{"id": "63c494847843b61269a01ad6", "level": "level5", "llm_response": "```yaml\nname: Release v1 NPM Package\n\non:\n  workflow_dispatch:\n    inputs:\n      tag-this:\n        description: 'Enter the version for the release tag (must be larger than last tag, use patch for bug fixes, use minor for new actions)'\n        required: true\n        type: string\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  merge-to-v1-branch:\n    id: merge-to-v1-branch\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n          registry-url: 'https://registry.npmjs.org'\n\n      - name: Install dependencies\n        run: yarn install\n\n      - name: Set git name, mail and origin\n        run: |\n          git config --global user.name \"Josef Fr\u00f6hle\"\n          git config --global user.email \"github@josef-froehle.de\"\n          git remote set-url origin https://${{ secrets.BOT_PIPELINE_TOKEN }}@github.com/${{ github.repository }}\n\n      - name: Checkout v1 branch and merge\n        run: |\n          git checkout v1\n          git merge --ff-only master\n\n      - name: Generate new tag, push tag and branch\n        run: |\n          yarn run build\n          yarn version --non-interactive --no-git-tag-version --new-version ${{ github.event.inputs.tag }}\n          yarn run changelog\n          yarn run documentation\n          git add -A\n          yarn version --non-interactive --no-git-tag-version --new-version 0.0.0\n          yarn version --non-interactive --new-version ${{ github.event.inputs.tag }}\n          git push\n          git push --tags\n          git checkout master\n          git merge --ff-only v1\n          git push\n          git subtree split --prefix docs -b gh-pages\n          git push -f origin gh-pages:gh-pages\n\n      - name: Publish package\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n        run: yarn publish\n```", "answer": "```yaml name: \"Release v1 NPM Package\"\non:\n  workflow_dispatch:\n    inputs:\n      tag:\n        description: |\n          Enter the version for the release tag.\n          Must be larger than last tag.\n          Use patch (0.0.x) for bug fixes.\n          Use minor (0.x.0) for new actions.\n        type: string\n        required: true\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: false\njobs:\n  merge-to-v1-branch:\n    name: Create release by rebasing master to v1 and create a new tag\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n          cache: 'yarn'\n          registry-url: 'https://registry.npmjs.org'\n      - run: yarn install\n      - name: Set git name, mail and origin\n        run: |\n          git config --global user.name \"Josef Fr\u00f6hle\"\n          git config --global user.email \"github@josef-froehle.de\"\n          git remote set-url origin https://${{ secrets.BOT_PIPELINE_TOKEN }}@github.com/${{ github.repository }}\n      - name: Checkout v1 branch and merge\n        run: |\n          git checkout v1\n          git merge --ff-only master\n      - name: Generate new tag, push tag and branch\n        run: |\n          yarn run build\n          yarn version --non-interactive --no-git-tag-version --new-version ${{ github.event.inputs.tag }}\n          yarn run changelog\n          yarn run documentation\n          git add -A\n          yarn version --non-interactive --no-git-tag-version --new-version 0.0.0\n          yarn version --non-interactive --new-version ${{ github.event.inputs.tag }}\n          git push\n          git push --tags\n          git checkout master\n          git merge --ff-only v1\n          git push\n          git subtree split --prefix docs -b gh-pages\n          git push -f origin gh-pages:gh-pages\n      - run: yarn publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Release v1 NPM Package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: tag-this input represents enter the version for the release tag.\nmust be larger than last tag.\nuse patch (0.0.x) for bug fixes.\nuse minor (0.x.0) for new actions.\n, the data type is string and it must be supplied. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Create release by rebasing master to v1 and create a new tag` and its job id is `merge-to-v1-branch`. This job will run on ubuntu-latest runner. The job `merge-to-v1-branch` has 7 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines 3 input parameters for the action: `node-version` is set to `14`, `cache` is set to `yarn` and `registry-url` is set to `https://registry.npmjs.org`. The 3rd step is named ``. This step runs a script: `yarn install`. The 4th step is named `Set git name, mail and origin`. This step runs a script: `git config --global user.name \"Josef Fr\u00f6hle\"\ngit config --global user.email \"github@josef-froehle.de\"\ngit remote set-url origin https://${{ secrets.BOT_PIPELINE_TOKEN }}@github.com/${{ github.repository }}\n`. The 5th step is named `Checkout v1 branch and merge`. This step runs a script: `git checkout v1\ngit merge --ff-only master\n`. The 6th step is named `Generate new tag, push tag and branch`. This step runs a script: `yarn run build\nyarn version --non-interactive --no-git-tag-version --new-version ${{ github.event.inputs.tag }}\nyarn run changelog\nyarn run documentation\ngit add -A\nyarn version --non-interactive --no-git-tag-version --new-version 0.0.0\nyarn version --non-interactive --new-version ${{ github.event.inputs.tag }}\ngit push\ngit push --tags\ngit checkout master\ngit merge --ff-only v1\ngit push\ngit subtree split --prefix docs -b gh-pages\ngit push -f origin gh-pages:gh-pages\n`. The 7th step is named ``. The step sets an environment variable to use: `NODE_AUTH_TOKEN` is set to `${{ secrets.NPM_TOKEN }}`. This step runs a script: `yarn publish`. "}
{"id": "63c4963f1e3364807577960f", "level": "level5", "llm_response": "```yaml\nname: Validate Gradle Wrapper\n\non:\n  pull_request:\n\njobs:\n  validation:\n    id: validation\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Validate Gradle wrapper\n      uses: gradle/wrapper-validation-action@v1\n```", "answer": "```yaml name: \"Validate Gradle Wrapper\"\n\non: [ pull_request ]\n\njobs:\n  validation:\n    name: \"Validation\"\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: gradle/wrapper-validation-action@v1\n```", "prompt": "Generate a GitHub Workflow named `Validate Gradle Wrapper` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Validation` and its job id is `validation`. This job will run on ubuntu-latest runner. The job `validation` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `gradle/wrapper-validation-action` tagged as v1. "}
{"id": "63c4969cb008460c1df157a0", "level": "level5", "llm_response": "```yaml\nname: Post-release\n\non:\n  release:\n    types: [published, prereleased, edited]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Comment on release\n        uses: apexskier/github-release-commenter@v1\n        with:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          comment-template: 'This is addressed by {release_link}.'\n          label-template: 'released'\n```", "answer": "```yaml name: Post-release\non:\n  release:\n    types:\n      - published\n      - edited\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: apexskier/github-release-commenter@v1\n        with:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          comment-template: This is addressed by {release_link}.\n          label-template: released\n```", "prompt": "Generate a GitHub Workflow named `Post-release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published or the details of a release, pre-release, or draft release are edited. The workflow has one job. The job id of the 1st job is `release`. This job will run on ubuntu-latest runner. The job `release` has one step. The 1st step is named ``. This step runs action `apexskier/github-release-commenter` tagged as v1. The step defines 3 input parameters for the action: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`, `comment-template` is set to `This is addressed by {release_link}.` and `label-template` is set to `released`. "}
{"id": "63c4946e8052faa2781ab27f", "level": "level5", "llm_response": "```yaml\nname: test\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\npermissions:\n  contents: read\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macOS-latest]\n    max-parallel: 2\n    timeout-minutes: 10\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version-file: .go-version\n          cache: true\n      - name: Test\n        run: make test\n\n  testacc:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        terraform: [1.0.0, 0.15.5, 0.14.11, 0.13.7, 0.12.31]\n    max-parallel: 2\n    timeout-minutes: 10\n    env:\n      TERRAFORM_VERSION: ${{ matrix.terraform }}\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Docker build\n        run: docker-compose build\n      - name: Terraform --version\n        run: docker-compose run --rm tfschema terraform --version\n      - name: Testacc\n        run: docker-compose run --rm tfschema make testacc\n```", "answer": "```yaml name: test\npermissions:\n  contents: read\n\non:\n  push:\n    branches:\n    - master\n  pull_request:\n    branches:\n    - master\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        os:\n        - ubuntu-latest\n        - macOS-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-go@v3\n      with:\n        go-version-file: '.go-version'\n        cache: true\n    - name: test\n      run: make test\n  testacc:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    strategy:\n      matrix:\n        terraform:\n        - 1.0.0\n        - 0.15.5\n        - 0.14.11\n        - 0.13.7\n        - 0.12.31\n    env:\n      TERRAFORM_VERSION: ${{ matrix.terraform }}\n    steps:\n    - uses: actions/checkout@v3\n    - name: docker build\n      run: docker-compose build\n    - name: terraform --version\n      run: docker-compose run --rm tfschema terraform --version\n    - name: testacc\n      run: docker-compose run --rm tfschema make testacc\n```", "prompt": "Generate a GitHub Workflow named `test` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The job id of the 1st job is `test`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `os` has 2 values: ubuntu-latest and macOS-latest. The maximum number of minutes to run the job is 10. The job `test` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-go` tagged as v3. The step defines 2 input parameters for the action: `go-version-file` is set to `.go-version` and `cache` is set to `True`. The 3rd step is named `test`. This step runs a script: `make test`. The job id of the 2nd job is `testacc`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `terraform` has 5 values: 1.0.0, 0.15.5, 0.14.11, 0.13.7 and 0.12.31. The job sets an environment variable to use: `TERRAFORM_VERSION` is set to `${{ matrix.terraform }}`. The maximum number of minutes to run the job is 10. The job `testacc` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `docker build`. This step runs a script: `docker-compose build`. The 3rd step is named `terraform --version`. This step runs a script: `docker-compose run --rm tfschema terraform --version`. The 4th step is named `testacc`. This step runs a script: `docker-compose run --rm tfschema make testacc`. "}
{"id": "63c495297843b61269a05d16", "level": "level5", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n\njobs:\n  golangci:\n    id: golangci\n    runs-on: ubuntu-latest\n    timeout-minutes: 8\n\n    steps:\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: 1.18\n\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Get diff\n        uses: technote-space/get-diff-action@v6.1.0\n        with:\n          PATTERNS: \"**/**.go go.mod go.sum\"\n\n      - name: Run golangci-lint\n        if: env.GIT_DIFF\n        uses: golangci/golangci-lint-action@v3.2.0\n        with:\n          version: v1.47.2\n          args: --timeout 10m\n          github-token: ${{ secrets.github_token }}\n```", "answer": "```yaml name: Lint\n# Lint runs golangci-lint over the entire cosmos-sdk repository\n# This workflow is run on every pull request and push to main\n# The `golangci` will pass without running if no *.{go, mod, sum} files have been changed.\non:\n  pull_request:\n  push:\n    branches:\n      - main\njobs:\n  golangci:\n    name: golangci-lint\n    runs-on: ubuntu-latest\n    timeout-minutes: 8\n    steps:\n      - uses: actions/setup-go@v3\n        with:\n          go-version: 1.18\n      - uses: actions/checkout@v3\n      - uses: technote-space/get-diff-action@v6.1.0\n        with:\n          PATTERNS: |\n            **/**.go\n            go.mod\n            go.sum\n      - uses: golangci/golangci-lint-action@v3.2.0\n        with:\n          version: v1.47.2\n          args: --timeout 10m\n          github-token: ${{ secrets.github_token }}\n        if: env.GIT_DIFF\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The 1st job is named `golangci-lint` and its job id is `golangci`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 8. The job `golangci` has 4 steps. The 1st step is named ``. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `1.18`. The 2nd step is named ``. This step runs action `actions/checkout` tagged as v3. The 3rd step is named ``. This step runs action `technote-space/get-diff-action` tagged as v6.1.0. The step defines an input parameter for the action: `PATTERNS` is set to `**/**.go\ngo.mod\ngo.sum\n`. The 4th step is named ``. This step will run only if the condition(env.GIT_DIFF) is met. This step runs action `golangci/golangci-lint-action` tagged as v3.2.0. The step defines 3 input parameters for the action: `version` is set to `v1.47.2`, `args` is set to `--timeout 10m` and `github-token` is set to `${{ secrets.github_token }}`. "}
{"id": "63c4951f7843b61269a0593e", "level": "level5", "llm_response": "```yaml\nname: goreleaser\n\non:\n  push:\n    tags:\n      - '*'\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3.1.0\n        with:\n          fetch-depth: 0\n\n      - name: Fetch tags\n        run: git fetch --tags --force\n\n      - name: Setup Go\n        uses: actions/setup-go@v3.3.0\n        with:\n          go-version: 1.19\n\n      - name: Release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        uses: goreleaser/goreleaser-action@v3.1.0\n        with:\n          distribution: goreleaser\n          version: latest\n          args: release -f ci/.goreleaser.yml\n```", "answer": "```yaml name: goreleaser\non:\n  push:\n    tags:\n      - \"*\"\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          fetch-depth: 0\n\n      - name: fetch tags\n        run: git fetch --tags --force\n\n      - uses: actions/setup-go@v3.3.0\n        with:\n          go-version: 1.19\n\n      - uses: goreleaser/goreleaser-action@v3.1.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          distribution: goreleaser\n          version: latest\n          args: release -f ci/.goreleaser.yml\n```", "prompt": "Generate a GitHub Workflow named `goreleaser` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches *. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `release`. This job will run on ubuntu-latest runner. The job `release` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3.1.0. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `fetch tags`. This step runs a script: `git fetch --tags --force`. The 3rd step is named ``. This step runs action `actions/setup-go` tagged as v3.3.0. The step defines an input parameter for the action: `go-version` is set to `1.19`. The 4th step is named ``. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `goreleaser/goreleaser-action` tagged as v3.1.0. The step defines 3 input parameters for the action: `distribution` is set to `goreleaser`, `version` is set to `latest` and `args` is set to `release -f ci/.goreleaser.yml`. "}
{"id": "63c4967e33b087f6bde2c5c1", "level": "level5", "llm_response": "```yaml\nname: Dependabot auto-merge\n\non:\n  pull_request:\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n    if: github.actor == 'dependabot[bot]'\n\n    steps:\n    - name: Dependabot metadata\n      id: metadata\n      uses: dependabot/fetch-metadata@v1.3.4\n      with:\n        github-token: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Enable auto-merge for Dependabot PRs\n      if: steps.metadata.outputs.update-type == 'version-update:semver-patch' || steps.metadata.outputs.update-type == 'version-update:semver-minor'\n      env:\n        PR_URL: ${{github.event.pull_request.html_url}}\n        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n      run: gh pr merge --auto --merge \"$PR_URL\"\n```", "answer": "```yaml ---\nname: Dependabot auto-merge\n\"on\": pull_request\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n    if: ${{ github.actor == 'dependabot[bot]' }}\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        uses: dependabot/fetch-metadata@v1.3.4\n        with:\n          github-token: \"${{ secrets.GITHUB_TOKEN }}\"\n      - name: Enable auto-merge for Dependabot PRs\n        if: >-\n          ${{\n          steps.metadata.outputs.update-type == 'version-update:semver-patch' ||\n          steps.metadata.outputs.update-type == 'version-update:semver-minor'\n          }}\n        run: gh pr merge --auto --merge \"$PR_URL\"\n        env:\n          PR_URL: ${{github.event.pull_request.html_url}}\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n```", "prompt": "Generate a GitHub Workflow named `Dependabot auto-merge` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `pull-requests` scope and write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `dependabot`. This job will run only if the condition(${{ github.actor == 'dependabot[bot]' }}) is met. This job will run on ubuntu-latest runner. The job `dependabot` has 2 steps. The 1st step is named `Dependabot metadata` and its id is `metadata`. This step runs action `dependabot/fetch-metadata` tagged as v1.3.4. The step defines an input parameter for the action: `github-token` is set to `${{ secrets.GITHUB_TOKEN }}`. The 2nd step is named `Enable auto-merge for Dependabot PRs`. This step will run only if the condition(${{ steps.metadata.outputs.update-type == 'version-update:semver-patch' || steps.metadata.outputs.update-type == 'version-update:semver-minor' }}) is met. The step sets 2 environment variables to use: `PR_URL` is set to `${{github.event.pull_request.html_url}}` and `GITHUB_TOKEN` is set to `${{secrets.GITHUB_TOKEN}}`. This step runs a script: `gh pr merge --auto --merge \"$PR_URL\"`. "}
{"id": "63c496326fc19abdf9c9a7c5", "level": "level5", "llm_response": "```yaml\nname: Test CI\n\non:\n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    id: test\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Install requirements\n        run: |\n          apk update && apk upgrade\n          apk add make bash coreutils neovim lua5.4\n          ln -sv /usr/bin/lua5.4 /usr/bin/lua\n          ln -sv /usr/lib/lua5.4/liblua.so /usr/lib/liblua5.4.so\n\n      - name: Install Tangerine\n        run: make install\n\n      - name: Build Runner\n        run: make runner\n\n      - name: Run Tests\n        run: yes | make test\n```", "answer": "```yaml name: Test CI\n\non: \n  pull_request:\n  push:\n    paths:\n      - lua/**\n      - test/**\n      - .github/**\n\njobs:\n  test:\n    runs-on:   ubuntu-latest\n    container: alpine\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Install requirements\n      run: |\n        apk update && apk upgrade \n        apk add make bash coreutils neovim lua5.4\n        # links lua5.4 -> lua\n        ln -sv /usr/bin/lua5.4           /usr/bin/lua\n        ln -sv /usr/lib/lua5.4/liblua.so /usr/lib/liblua5.4.so\n\n    - name: Install Tangerine\n      run:  make install\n\n    - name: Build Runner\n      run:  make runner\n\n    - name: Run Tests\n      run:  yes | make test\n```", "prompt": "Generate a GitHub Workflow named `Test CI` for a GitHub repository whose primary programming language is Fennel. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) Only if at least one path of push event matches a pattern in the paths filter(lua/**, test/** or .github/**), the workflow runs. The workflow has one job. The job id of the 1st job is `test`. This job will run on ubuntu-latest runner. The job creates a Docker container that uses `alpine` image. The job `test` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Install requirements`. This step runs a script: `apk update && apk upgrade \napk add make bash coreutils neovim lua5.4\n# links lua5.4 -> lua\nln -sv /usr/bin/lua5.4           /usr/bin/lua\nln -sv /usr/lib/lua5.4/liblua.so /usr/lib/liblua5.4.so\n`. The 3rd step is named `Install Tangerine`. This step runs a script: `make install`. The 4th step is named `Build Runner`. This step runs a script: `make runner`. The 5th step is named `Run Tests`. This step runs a script: `yes | make test`. "}
{"id": "63c495207843b61269a059a2", "level": "level5", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  label:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Label PR\n        uses: actions/labeler@v4\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler/blob/master/README.md\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/labeler@v4\n      with:\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. This job will run on ubuntu-latest runner. The job `label` has one step. The 1st step is named ``. This step runs action `actions/labeler` tagged as v4. The step defines an input parameter for the action: `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`. "}
{"id": "63c494378052faa2781a9e70", "level": "level5", "llm_response": "```yaml\nname: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches:\n      - main\n      - devnet\n    types:\n      - opened\n      - synchronize\n      - reopened\n      - ready_for_review\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Protobuf format\n        uses: jidicula/clang-format-action@v4.9.0\n        with:\n          clang-format-version: 14\n\n      - name: Lint shell, Docker and protobuf\n        env:\n          VALIDATE_ALL_CODEBASE: \"False\"\n          DEFAULT_BRANCH: \"main\"\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          VALIDATE_SHELL_SHFMT: \"True\"\n        uses: github/super-linter/slim@v4\n```", "answer": "```yaml name: Miscellaneous Lint\n\non:\n  push:\n    branches:\n      - main\n      - devnet\n  pull_request:\n    branches: [ main ]\n    types: [opened, synchronize, reopened, ready_for_review]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Code\n        uses: actions/checkout@v3\n        with:\n          # Full git history isn't needed to get a proper list of changed files within `super-linter`\n          fetch-depth: 0\n\n      - name: Protobuf format\n        uses: jidicula/clang-format-action@v4.9.0\n        with:\n          clang-format-version: '14'\n  \n      - name: Lint shell, Docker and protobuf\n        uses: github/super-linter/slim@v4\n        env:\n          VALIDATE_ALL_CODEBASE: false\n          DEFAULT_BRANCH: main\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # Select file types to lint. Python and Rust linters are configured separately.\n          VALIDATE_SHELL_SHFMT: true\n          #\n          # disable hadolint \n          # https://github.com/hadolint/hadolint/issues/821\n          # VALIDATE_DOCKERFILE_HADOLINT: true\n          # DOCKERFILE_HADOLINT_FILE_NAME: .github/config/.hadolint.yaml\n          #\n          # Enable after fixing proto lint issues.\n          # VALIDATE_PROTOBUF: true\n```", "prompt": "Generate a GitHub Workflow named `Miscellaneous Lint` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch named devnet. 2) a pull request is created, a pull request's head branch is updated, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `lint`. This job will run on ubuntu-latest runner. The job `lint` has 3 steps. The 1st step is named `Checkout Code`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Protobuf format`. This step runs action `jidicula/clang-format-action` tagged as v4.9.0. The step defines an input parameter for the action: `clang-format-version` is set to `14`. The 3rd step is named `Lint shell, Docker and protobuf`. The step sets 4 environment variables to use: `VALIDATE_ALL_CODEBASE` is set to `False`, `DEFAULT_BRANCH` is set to `main`, `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}` and `VALIDATE_SHELL_SHFMT` is set to `True`. This step runs action `github/super-linter/slim` tagged as v4. "}
{"id": "63c496561899db58864d23b6", "level": "level5", "llm_response": "```yaml\nname: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Run with tmate debugging'\n        required: false\n        default: false\n        type: boolean\n\njobs:\n  docker:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: docker\n```", "answer": "```yaml name: Molecule - Docker\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.docker.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/docker/**\n      - roles/docker/**\n      # Plugins\n      - plugins/filter/json.py\n      - plugins/filter/staten.py\n      - plugins/lookup/docker_applications.py\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  docker:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: docker\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Docker` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.docker.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/docker/**, roles/docker/**, plugins/filter/json.py, plugins/filter/staten.py or plugins/lookup/docker_applications.py), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `docker`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 2 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}` and the input `scenario` is `docker`. "}
{"id": "63c496851899db58864d36f3", "level": "level5", "llm_response": "```yaml\nname: Test with Pre-commit\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [3.10]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pre-commit\n          pre-commit install-hooks\n\n      - name: Lint with pre-commit\n        run: pre-commit run --all-files\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Test with Pre-commit\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.10\"]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pre-commit\n          pre-commit install-hooks\n      - name: Lint with pre-commit\n        run: pre-commit run --all-files\n```", "prompt": "Generate a GitHub Workflow named `Test with Pre-commit` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `python-version` has one value: 3.10. The job `build` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Python ${{ matrix.python-version }}`. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `${{ matrix.python-version }}`. The 3rd step is named `Install dependencies`. This step runs a script: `python -m pip install --upgrade pip\npip install pre-commit\npre-commit install-hooks\n`. The 4th step is named `Lint with pre-commit`. This step runs a script: `pre-commit run --all-files`. "}
{"id": "63c495e58052faa2781b4fae", "level": "level5", "llm_response": "```yaml\nname: Self-assign\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  one:\n    runs-on: ubuntu-latest\n    if: github.event.comment.body == '#take' || github.event.comment.body == '#self-assign' && !github.event.issue.pull_request\n    steps:\n      - name: Assign issue\n        run: |\n          echo \"Assigning issue ${{ github.event.issue.number }} to ${{ github.event.comment.user.login }}\"\n          curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -d '{\"assignees\": [\"${{ github.event.comment.user.login }}\"]}' https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/assignees\n```", "answer": "```yaml # Allow users to automatically tag themselves to issues\n\nname: Self-assign\non:\n  issue_comment:\n    types: created\njobs:\n  one:\n    runs-on: ubuntu-latest\n    if: >-\n      (github.event.comment.body == '#take' ||\n       github.event.comment.body == '#self-assign') &&\n       (!github.event.issue.pull_request)\n    steps:\n      - run: |\n          echo \"Assigning issue ${{ github.event.issue.number }} to ${{ github.event.comment.user.login }}\"\n          curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -d '{\"assignees\": [\"${{ github.event.comment.user.login }}\"]}' https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/assignees\n```", "prompt": "Generate a GitHub Workflow named `Self-assign` for a GitHub repository whose primary programming language is Jupyter Notebook. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `one`. This job will run only if the condition((github.event.comment.body == '#take' ||\n github.event.comment.body == '#self-assign') &&\n (!github.event.issue.pull_request)) is met. This job will run on ubuntu-latest runner. The job `one` has one step. The 1st step is named ``. This step runs a script: `echo \"Assigning issue ${{ github.event.issue.number }} to ${{ github.event.comment.user.login }}\"\ncurl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -d '{\"assignees\": [\"${{ github.event.comment.user.login }}\"]}' https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/assignees\n`. "}
{"id": "63c496561899db58864d23c2", "level": "level5", "llm_response": "```yaml\nname: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug-the:\n        description: 'Run with tmate debugging'\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  java:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug-the == true }}\n      scenario: java\n```", "answer": "```yaml name: Molecule - Java\n\non:\n  pull_request:\n    paths:\n      - .github/workflows/molecule.java.yml\n      - .config/molecule/config.yml\n      - molecule/Dockerfile.*\n      - molecule/java/**\n      - roles/java/**\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        description: Run with tmate debugging\n        required: false\n        default: false\n\njobs:\n  java:\n    uses: ./.github/workflows/molecule.yaml\n    with:\n      debug: ${{ inputs.debug == true }}\n      scenario: java\n```", "prompt": "Generate a GitHub Workflow named `Molecule - Java` for a GitHub repository whose primary programming language is Jinja. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(.github/workflows/molecule.java.yml, .config/molecule/config.yml, molecule/Dockerfile.*, molecule/java/** or roles/java/**), the workflow runs. 2) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, this input represents run with tmate debugging, it is optional and its default value is False. The workflow has one job. The job id of the 1st job is `java`. This job will call a reusable workflow located at `./.github/workflows/molecule.yaml`. The job will pass 2 inputs to the called workflow: the input `debug` is `${{ inputs.debug == true }}` and the input `scenario` is `java`. "}
{"id": "63c4957c8052faa2781b2239", "level": "level5", "llm_response": "```yaml\nname: Add Issues/PRs to TF Provider DevEx team board\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request_target:\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    id: add-content-to-project\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Set Issue to 'Priority = Triage Next'\n        if: github.event_name == 'issues'\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: hashicorp\n          project_id: 99\n          resource_node_id: ${{ github.event.issue.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\"name\":\"Priority\",\"type\":\"single_select\",\"value\":\"Triage Next\"}]'\n\n      - name: Set Pull Request to 'Priority = Triage Next'\n        if: github.event_name == 'pull_request_target'\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: hashicorp\n          project_id: 99\n          resource_node_id: ${{ github.event.pull_request.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\"name\":\"Priority\",\"type\":\"single_select\",\"value\":\"Triage Next\"}]'\n```", "answer": "```yaml # Based on https://github.com/leonsteinhaeuser/project-beta-automations\n\nname: \"Add Issues/PRs to TF Provider DevEx team board\"\n\non:\n  issues:\n    types: [opened, reopened]\n  pull_request_target:\n    # NOTE: The way content is added to project board is equivalent to an \"upsert\".\n    # Calling it multiple times will be idempotent.\n    #\n    # See https://securitylab.github.com/research/github-actions-preventing-pwn-requests/\n    #\u00a0to see the reasoning behind using `pull_request_target` instead of `pull_request`\n    types: [opened, reopened, ready_for_review]\n\njobs:\n  add-content-to-project:\n    name: \"Add Content to project\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Set Issue to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'issues'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.issue.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n      - name: \"Set Pull Request to 'Priority = Triage Next'\"\n        uses: leonsteinhaeuser/project-beta-automations@v2.0.1\n        if: github.event_name == 'pull_request_target'\n        with:\n          gh_token: ${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}\n          organization: \"hashicorp\"\n          project_id: 99      #< https://github.com/orgs/hashicorp/projects/99\n          resource_node_id: ${{ github.event.pull_request.node_id }}\n          operation_mode: custom_field\n          custom_field_values: '[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]'\n```", "prompt": "Generate a GitHub Workflow named `Add Issues/PRs to TF Provider DevEx team board` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) an issue is opened or a closed issue is reopened. 2) a pull request is created, a previously closed pull request is reopened or a draft pull request is marked as ready for review. The workflow has one job. The 1st job is named `Add Content to project` and its job id is `add-content-to-project`. This job will run on ubuntu-latest runner. The job `add-content-to-project` has 2 steps. The 1st step is named `Set Issue to 'Priority = Triage Next'`. This step will run only if the condition(github.event_name == 'issues') is met. This step runs action `leonsteinhaeuser/project-beta-automations` tagged as v2.0.1. The step defines 6 input parameters for the action: `gh_token` is set to `${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}`, `organization` is set to `hashicorp`, `project_id` is set to `99`, `resource_node_id` is set to `${{ github.event.issue.node_id }}`, `operation_mode` is set to `custom_field` and `custom_field_values` is set to `[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]`. The 2nd step is named `Set Pull Request to 'Priority = Triage Next'`. This step will run only if the condition(github.event_name == 'pull_request_target') is met. This step runs action `leonsteinhaeuser/project-beta-automations` tagged as v2.0.1. The step defines 6 input parameters for the action: `gh_token` is set to `${{ secrets.TF_DEVEX_PROJECT_GITHUB_TOKEN }}`, `organization` is set to `hashicorp`, `project_id` is set to `99`, `resource_node_id` is set to `${{ github.event.pull_request.node_id }}`, `operation_mode` is set to `custom_field` and `custom_field_values` is set to `[{\\\"name\\\":\\\"Priority\\\",\\\"type\\\":\\\"single_select\\\",\\\"value\\\":\\\"Triage Next\\\"}]`. "}
{"id": "63c49697b008460c1df15590", "level": "level5", "llm_response": "```yaml\nname: Release\n\non:\n  release:\n    types: [published, prereleased, draft]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v1\n\n      - name: Build the file\n        run: |\n          cd /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card\n          npm install\n          npm run build\n\n      - name: Upload zip to release\n        uses: svenstaro/upload-release-action@v1-release\n        with:\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          file: /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card/dist/thermostat-dark-card.js\n          asset_name: thermostat-dark-card.js\n          tag: ${{ github.ref }}\n          overwrite: True\n\n      - name: HACS Action\n        uses: hacs/action@main\n        with:\n          category: plugin\n```", "answer": "```yaml name: Release\n\non:\n  release:\n    types: [published]\n\njobs:\n  release:\n    name: Prepare release\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n\n      # Build\n      - name: Build the file\n        run: |\n          cd /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card\n          npm install\n          npm run build\n\n      # Upload build file to the releas as an asset.\n      - name: Upload zip to release\n        uses: svenstaro/upload-release-action@v1-release\n\n        with:\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          file: /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card/dist/thermostat-dark-card.js\n          asset_name: thermostat-dark-card.js\n          tag: ${{ github.ref }}\n          overwrite: true\n      - name: HACS Action\n        uses: \"hacs/action@main\"\n        with:\n          category: \"plugin\"\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow has one job. The 1st job is named `Prepare release` and its job id is `release`. This job will run on ubuntu-latest runner. The job `release` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v1. The 2nd step is named `Build the file`. This step runs a script: `cd /home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card\nnpm install\nnpm run build\n`. The 3rd step is named `Upload zip to release`. This step runs action `svenstaro/upload-release-action` from the v1-release branch. The step defines 5 input parameters for the action: `repo_token` is set to `${{ secrets.GITHUB_TOKEN }}`, `file` is set to `/home/runner/work/lovelace-thermostat-dark-card/lovelace-thermostat-dark-card/dist/thermostat-dark-card.js`, `asset_name` is set to `thermostat-dark-card.js`, `tag` is set to `${{ github.ref }}` and `overwrite` is set to `True`. The 4th step is named `HACS Action`. This step runs action `hacs/action` from the main branch. The step defines an input parameter for the action: `category` is set to `plugin`. "}
{"id": "63c4955b8052faa2781b1498", "level": "level5", "llm_response": "```yaml\nname: CI v2\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go: [1.16]\n\n    steps:\n    - name: Setup\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Prerequisites\n      run: |\n        sudo apt-get update\n        sudo apt-get -y install libvlc-dev vlc-plugin-base vlc-plugin-video-output vlc-plugin-access-extra\n\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Dependencies\n      run: |\n        go version\n        go get -v -t -d ./...\n        go install golang.org/x/lint/golint@latest\n\n    - name: Lint\n      run: |\n        golint -set_exit_status=1 ./...\n\n    - name: Vet\n      run: |\n        go vet -unsafeptr=false ./...\n\n    - name: Test\n      run: |\n        go test -v -coverprofile=coverage.txt -covermode=atomic ./...\n\n    - name: Coverage\n      uses: codecov/codecov-action@v3\n```", "answer": "```yaml name: CI v2\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go: ['1.16']\n    steps:\n    - name: Setup\n      uses: actions/setup-go@v3\n      with:\n        go-version: ${{ matrix.go }}\n\n    - name: Prerequisites\n      run: |\n        sudo apt-get update\n        sudo apt-get -y install libvlc-dev vlc-plugin-base vlc-plugin-video-output vlc-plugin-access-extra\n\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Dependencies\n      working-directory: ./v2\n      run: |\n        go version\n        go get -v -t -d ./...\n        go install golang.org/x/lint/golint@latest\n\n    - name: Lint\n      working-directory: ./v2\n      run: golint -set_exit_status=1 ./...\n\n    - name: Vet\n      working-directory: ./v2\n      run: go vet -unsafeptr=false ./...\n\n    - name: Test\n      working-directory: ./v2\n      run: go test -v -coverprofile=coverage.txt -covermode=atomic ./...\n\n    - name: Coverage\n      uses: codecov/codecov-action@v3\n```", "prompt": "Generate a GitHub Workflow named `CI v2` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `go` has one value: 1.16. The job `build` has 8 steps. The 1st step is named `Setup`. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `${{ matrix.go }}`. The 2nd step is named `Prerequisites`. This step runs a script: `sudo apt-get update\nsudo apt-get -y install libvlc-dev vlc-plugin-base vlc-plugin-video-output vlc-plugin-access-extra\n`. The 3rd step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The 4th step is named `Dependencies`. This step runs a script: `go version\ngo get -v -t -d ./...\ngo install golang.org/x/lint/golint@latest\n`. The 5th step is named `Lint`. This step runs a script: `golint -set_exit_status=1 ./...`. The 6th step is named `Vet`. This step runs a script: `go vet -unsafeptr=false ./...`. The 7th step is named `Test`. This step runs a script: `go test -v -coverprofile=coverage.txt -covermode=atomic ./...`. The 8th step is named `Coverage`. This step runs action `codecov/codecov-action` tagged as v3. "}
{"id": "63c494b87843b61269a03054", "level": "level5", "llm_response": "```yaml\nname: autoupdate\n\non:\n  push:\n    branches-ignore:\n      - version-bump/**\n      - dependabot/**\n      - bot/**\n      - all-contributors/**\n\njobs:\n  autoupdate-for-bot:\n    runs-on: ubuntu-latest\n    if: startsWith(github.repository, 'asyncapi/')\n    id: autoupdate-for-bot\n    steps:\n      - name: Autoupdating\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN_BOT_EVE }}\n          PR_FILTER: labelled\n          PR_LABELS: autoupdate\n          PR_READY_STATE: ready_for_review\n          MERGE_CONFLICT_ACTION: ignore\n        uses: docker://chinthakagodawita/autoupdate-action:v1\n```", "answer": "```yaml # This action is centrally managed in https://github.com/asyncapi/.github/\r\n# Don't make changes to this file in this repo as they will be overwritten with changes made to the same file in above mentioned repo\r\n\r\n# This workflow is designed to work with:\r\n# - autoapprove and automerge workflows for dependabot and asyncapibot.\r\n# - special release branches that we from time to time create in upstream repos. If we open up PRs for them from the very beginning of the release, the release branch will constantly update with new things from the destination branch they are opened against\r\n\r\n# It uses GitHub Action that auto-updates pull requests branches, whenever changes are pushed to their destination branch.\r\n# Autoupdating to latest destination branch works only in the context of upstream repo and not forks\r\n\r\nname: autoupdate\r\n\r\non:\r\n  push:\r\n    branches-ignore:  \r\n      - 'version-bump/**'\r\n      - 'dependabot/**'\r\n      - 'bot/**'\r\n      - 'all-contributors/**'\r\n\r\njobs:\r\n  autoupdate-for-bot:\r\n    if: startsWith(github.repository, 'asyncapi/')\r\n    name: Autoupdate autoapproved PR created in the upstream\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - name: Autoupdating\r\n        uses: docker://chinthakagodawita/autoupdate-action:v1\r\n        env:\r\n          GITHUB_TOKEN: '${{ secrets.GH_TOKEN_BOT_EVE }}'\r\n          PR_FILTER: \"labelled\"\r\n          PR_LABELS: \"autoupdate\"\r\n          PR_READY_STATE: \"ready_for_review\"\r\n          MERGE_CONFLICT_ACTION: \"ignore\"\r\n```", "prompt": "Generate a GitHub Workflow named `autoupdate` for a GitHub repository whose primary programming language is null. This workflow will be triggered by an event: The workflow would run whenever there is a push event unless the push event is to: a branch whose name matches version-bump/**, a branch whose name matches dependabot/**, a branch whose name matches bot/** or a branch whose name matches all-contributors/**. The workflow has one job. The 1st job is named `Autoupdate autoapproved PR created in the upstream` and its job id is `autoupdate-for-bot`. This job will run only if the condition(startsWith(github.repository, 'asyncapi/')) is met. This job will run on ubuntu-latest runner. The job `autoupdate-for-bot` has one step. The 1st step is named `Autoupdating`. The step sets 5 environment variables to use: `GITHUB_TOKEN` is set to `${{ secrets.GH_TOKEN_BOT_EVE }}`, `PR_FILTER` is set to `labelled`, `PR_LABELS` is set to `autoupdate`, `PR_READY_STATE` is set to `ready_for_review` and `MERGE_CONFLICT_ACTION` is set to `ignore`. This step runs action `docker://chinthakagodawita/autoupdate-action:v1`."}
{"id": "63c494877843b61269a01c1e", "level": "level5", "llm_response": "```yaml\nname: Prepare Release\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version number'\n        required: true\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Push Tag\n      run: |\n        echo \"version is ${{ github.event.inputs.version }}\"\n        git config user.name \"GitHub Actions Bot\"\n        git config user.email \"\"\n        sed -i \"/is_master/d\" fxmanifest.lua\n        sed -i \"/^version/c\\version '${{ github.event.inputs.version }}'\" fxmanifest.lua\n        git add .\n        git commit -m \"${{ github.event.inputs.version }}\"\n        git tag -a ${{ github.event.inputs.version }} -m \"Version ${{ github.event.inputs.version }}\"\n        sed -i \"/^version/ais_master 'yes'\" fxmanifest.lua\n        git add .\n        git commit -m \"Update Version\"\n        git push --follow-tags\n```", "answer": "```yaml \nname: Prepare Release\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version Number'\n        required: true\n\njobs:\n  create:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Push Tag\n      run: | \n            echo \"version is ${{ github.event.inputs.version }}\"\n            git config user.name \"GitHub Actions Bot\"\n            git config user.email \"<>\"\n            sed -i \"/is_master/d\" fxmanifest.lua\n            sed -i \"/^version/c\\version '${{ github.event.inputs.version }}'\" fxmanifest.lua\n            git add .\n            git commit -m \"${{ github.event.inputs.version }}\"\n            git tag -a ${{ github.event.inputs.version }} -m \"Version ${{ github.event.inputs.version }}\"\n            sed -i \"/^version/ais_master 'yes'\" fxmanifest.lua\n            git add .\n            git commit -m \"Update Version\"\n            git push --follow-tags\n```", "prompt": "Generate a GitHub Workflow named `Prepare Release` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: version-this input represents version number and it must be supplied. The workflow has one job. The job id of the 1st job is `create`. This job will run on ubuntu-latest runner. The job `create` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` from the master branch. The 2nd step is named `Push Tag`. This step runs a script: `echo \"version is ${{ github.event.inputs.version }}\"\ngit config user.name \"GitHub Actions Bot\"\ngit config user.email \"<>\"\nsed -i \"/is_master/d\" fxmanifest.lua\nsed -i \"/^version/c\\version '${{ github.event.inputs.version }}'\" fxmanifest.lua\ngit add .\ngit commit -m \"${{ github.event.inputs.version }}\"\ngit tag -a ${{ github.event.inputs.version }} -m \"Version ${{ github.event.inputs.version }}\"\nsed -i \"/^version/ais_master 'yes'\" fxmanifest.lua\ngit add .\ngit commit -m \"Update Version\"\ngit push --follow-tags\n`. "}
{"id": "63c4966d33b087f6bde2bebf", "level": "level5", "llm_response": "```yaml\nname: CodeQL\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    id: analyse\n    runs-on: ubuntu-20.04\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 2\n\n      - name: Checkout base commit for PR\n        if: ${{ github.event_name == 'pull_request' }}\n        run: git checkout HEAD^2\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: go\n\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml name: \"CodeQL\"\n\non:\n  workflow_dispatch:\n  push:\n    branches: [main]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [main]\n  schedule:\n    - cron: '0 5 * * 0'\n\njobs:\n  analyse:\n    name: Analyse\n    runs-on: ubuntu-20.04\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n      with:\n        # We must fetch at least the immediate parents so that if this is\n        # a pull request then we can checkout the head.\n        fetch-depth: 2\n\n    # If this run was triggered by a pull request event, then checkout\n    # the head of the pull request instead of the merge commit.\n    - run: git checkout HEAD^2\n      if: ${{ github.event_name == 'pull_request' }}\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      # Override language selection by uncommenting this and choosing your languages\n      with:\n        languages: go\n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda https://git.io/JvXDl\n\n    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n    #    and modify them (or add more) to build your code if your project\n    #    uses a compiled language\n\n    #- run: |\n    #   make bootstrap\n    #   make release\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. 3) The workflow would run whenever there is a pull_request event targeting: a branch named main. 4) the scheduled time has come: at 05:00 am, only on sunday. The workflow has one job. The 1st job is named `Analyse` and its job id is `analyse`. This job will run on ubuntu-20.04 runner. The job `analyse` has 5 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `2`. The 2nd step is named ``. This step will run only if the condition(${{ github.event_name == 'pull_request' }}) is met. This step runs a script: `git checkout HEAD^2`. The 3rd step is named `Initialize CodeQL`. This step runs action `github/codeql-action/init` tagged as v2. The step defines an input parameter for the action: `languages` is set to `go`. The 4th step is named `Autobuild`. This step runs action `github/codeql-action/autobuild` tagged as v2. The 5th step is named `Perform CodeQL Analysis`. This step runs action `github/codeql-action/analyze` tagged as v2. "}
{"id": "63c496581e3364807577a144", "level": "level5", "llm_response": "```yaml\nname: Remove ALL artifacts\n\non:\n  workflow_dispatch:\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: Remove ALL artifacts\n        uses: c-hive/gha-remove-artifacts@v1\n        with:\n          age: '0 days'\n          skip-tags: 'true'\n          skip-recent: '0'\n```", "answer": "```yaml name: Remove ALL artifacts\n\non:\n  workflow_dispatch: # only manually\n\njobs:\n  remove-all-artifacts:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - name: Remove ALL artifacts\n        uses: c-hive/gha-remove-artifacts@v1\n        with:\n          age: '0 days'\n          skip-tags: true\n          skip-recent: 0\n```", "prompt": "Generate a GitHub Workflow named `Remove ALL artifacts` for a GitHub repository whose primary programming language is C. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `remove-all-artifacts`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 10. The job `remove-all-artifacts` has one step. The 1st step is named `Remove ALL artifacts`. This step runs action `c-hive/gha-remove-artifacts` tagged as v1. The step defines 3 input parameters for the action: `age` is set to `0 days`, `skip-tags` is set to `True` and `skip-recent` is set to `0`. "}
{"id": "63c494e18052faa2781adf45", "level": "level5", "llm_response": "```yaml\nname: Deploy to GH Pages\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - docs/**\n      - !.github/workflows/deploy-storybook.yml\n      - .storybook/**\n      - .wordpress-org/**\n      - __mocks__/**\n      - __static__/**\n      - bin/**\n      - tests/**\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    id: build-storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Setup Node\n        uses: actions/setup-node@8c91899e586c5b171469028077307d293428b516\n        with:\n          node-version-file: .nvmrc\n          cache: npm\n\n      - name: Install dependencies\n        env:\n          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: True\n        run: npm ci\n\n      - name: Build storybook\n        run: npm run storybook:build\n\n      - name: Upload storybook\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: storybook-files\n          path: build/storybook\n\n  deploy-gh-pages:\n    id: deploy-gh-pages\n    needs: build-storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    permissions:\n      contents: write\n    steps:\n      - name: Harden Runner\n        uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n        with:\n          egress-policy: audit\n\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n        with:\n          ref: gh-pages\n          token: ${{ secrets.GOOGLEFORCREATORS_BOT_TOKEN }}\n\n      - name: Download storybook files\n        uses: actions/download-artifact@fb598a63ae348fa914e94cd0ff38f362e927b741\n        with:\n          name: storybook-files\n          path: storybook-files\n\n      - name: Move storybook assets\n        run: |\n          mkdir -p storybook\n          rm -rf storybook/*\n          mv storybook-files/* storybook/\n\n      - name: Commit updates\n        env:\n          GIT_AUTHOR_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_AUTHOR_NAME: googleforcreators-bot\n          GIT_COMMITTER_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_COMMITTER_NAME: googleforcreators-bot\n        run: |\n          git add .\n          git status\n          git diff --staged --quiet && echo 'No changes to commit; exiting!' && exit 0\n          git commit -m \"Deploy storybook for ${{ github.sha }}\"\n          git pull --rebase --no-edit --quiet\n          git push origin gh-pages\n```", "answer": "```yaml name: Deploy to GH Pages\n\non:\n  push:\n    # Don't run for irrelevant changes.\n    paths-ignore:\n      - 'docs/**'\n      - '!.github/workflows/deploy-storybook.yml'\n      - '.storybook/**'\n      - '.wordpress-org/**'\n      - '__mocks__/**'\n      - '__static__/**'\n      - 'bin/**'\n      - 'tests/**'\n    branches:\n      - main\n\npermissions:\n  contents: read\n\n# Cancels all previous workflow runs for pull requests that have not completed.\nconcurrency:\n  # The concurrency group contains the workflow name and the (target) branch name.\n  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build-storybook:\n    name: Build storybook\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n      - name: Setup Node\n        uses: actions/setup-node@8c91899e586c5b171469028077307d293428b516\n        with:\n          node-version-file: '.nvmrc'\n          cache: npm\n\n      - name: Install dependencies\n        run: npm ci\n        env:\n          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: true\n\n      - name: Build storyook\n        run: npm run storybook:build\n\n      - name: Upload storybook\n        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8\n        with:\n          name: storybook-files\n          path: build/storybook\n\n  deploy-gh-pages:\n    name: Deploy storybook\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write # for Git to git push\n    timeout-minutes: 10\n    needs: [build-storybook]\n    steps:\n      - name: Harden Runner\n        uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n        with:\n          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs\n\n      - name: Checkout\n        uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n        with:\n          ref: gh-pages\n          token: ${{ secrets.GOOGLEFORCREATORS_BOT_TOKEN }}\n\n      - name: Download storybook files\n        uses: actions/download-artifact@fb598a63ae348fa914e94cd0ff38f362e927b741\n        with:\n          name: storybook-files\n          path: storybook-files\n\n      - name: Move storybook assets\n        run: |\n          mkdir -p storybook\n          rm -rf storybook/*\n          mv storybook-files/* storybook/\n\n      - name: Commit updates\n        run: |\n          git add .\n          git status\n          git diff --staged --quiet && echo 'No changes to commit; exiting!' && exit 0\n          git commit -m \"Deploy storybook for ${{ github.sha }}\"\n          git pull --rebase --no-edit --quiet\n          git push origin gh-pages\n        env:\n          GIT_AUTHOR_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_AUTHOR_NAME: googleforcreators-bot\n          GIT_COMMITTER_EMAIL: 94923726+googleforcreators-bot@users.noreply.github.com\n          GIT_COMMITTER_NAME: googleforcreators-bot\n```", "prompt": "Generate a GitHub Workflow named `Deploy to GH Pages` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**, !.github/workflows/deploy-storybook.yml, .storybook/**, .wordpress-org/**, __mocks__/**, __static__/**, bin/** or tests/**), the workflow will not run. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.head_ref || github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `Build storybook` and its job id is `build-storybook`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 10. The job `build-storybook` has 5 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` whose commit is 93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8. The 2nd step is named `Setup Node`. This step runs action `actions/setup-node` whose commit is 8c91899e586c5b171469028077307d293428b516. The step defines 2 input parameters for the action: `node-version-file` is set to `.nvmrc` and `cache` is set to `npm`. The 3rd step is named `Install dependencies`. The step sets an environment variable to use: `PUPPETEER_SKIP_CHROMIUM_DOWNLOAD` is set to `True`. This step runs a script: `npm ci`. The 4th step is named `Build storyook`. This step runs a script: `npm run storybook:build`. The 5th step is named `Upload storybook`. This step runs action `actions/upload-artifact` whose commit is 3cea5372237819ed00197afe530f5a7ea3e805c8. The step defines 2 input parameters for the action: `name` is set to `storybook-files` and `path` is set to `build/storybook`. The 2nd job is named `Deploy storybook` and its job id is `deploy-gh-pages`. Before this job runs, `build-storybook` must complete successfully. This job will run on ubuntu-latest runner. The job `deploy-gh-pages` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `deploy-gh-pages`. The maximum number of minutes to run the job is 10. The job `deploy-gh-pages` has 5 steps. The 1st step is named `Harden Runner`. This step runs action `step-security/harden-runner` whose commit is 2e205a28d0e1da00c5f53b161f4067b052c61f34. The step defines an input parameter for the action: `egress-policy` is set to `audit`. The 2nd step is named `Checkout`. This step runs action `actions/checkout` whose commit is 93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8. The step defines 2 input parameters for the action: `ref` is set to `gh-pages` and `token` is set to `${{ secrets.GOOGLEFORCREATORS_BOT_TOKEN }}`. The 3rd step is named `Download storybook files`. This step runs action `actions/download-artifact` whose commit is fb598a63ae348fa914e94cd0ff38f362e927b741. The step defines 2 input parameters for the action: `name` is set to `storybook-files` and `path` is set to `storybook-files`. The 4th step is named `Move storybook assets`. This step runs a script: `mkdir -p storybook\nrm -rf storybook/*\nmv storybook-files/* storybook/\n`. The 5th step is named `Commit updates`. The step sets 4 environment variables to use: `GIT_AUTHOR_EMAIL` is set to `94923726+googleforcreators-bot@users.noreply.github.com`, `GIT_AUTHOR_NAME` is set to `googleforcreators-bot`, `GIT_COMMITTER_EMAIL` is set to `94923726+googleforcreators-bot@users.noreply.github.com` and `GIT_COMMITTER_NAME` is set to `googleforcreators-bot`. This step runs a script: `git add .\ngit status\ngit diff --staged --quiet && echo 'No changes to commit; exiting!' && exit 0\ngit commit -m \"Deploy storybook for ${{ github.sha }}\"\ngit pull --rebase --no-edit --quiet\ngit push origin gh-pages\n`. "}
{"id": "63c496571899db58864d2453", "level": "level5", "llm_response": "```yaml\nname: Lint Checks\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, synchronize]\n\npermissions:\n  contents: read\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n  lint-python:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          persist-credentials: false\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: 3.10\n\n      - name: Install flake8\n        run: pip install flake8\n\n      - name: Run flake8 linting\n        run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude src/external\n\n  lint-rust:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Rustfmt check\n        run: (cd src && cargo fmt -- --check)\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Cargo update check\n        run: |\n          # This will return an error if any versions of local crates in the Cargo.lock\n          # are out of date compared to the crate versions in Cargo.toml. This can fail\n          # if the Shadow version is bumped without using Cargo to update the lock file.\n          (cd src && cargo update --locked --workspace)\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Cargo doc check\n        run: |\n          cmake -S . -B build\n          (cd src && RUSTDOCFLAGS='-D warnings' cargo doc)\n```", "answer": "```yaml # Syntax reference:\n# https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions\n\nname: Lint Checks\npermissions: read-all\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    types: [opened, synchronize]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n\n  lint-python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          persist-credentials: false\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n      - run: pip install flake8\n      - run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude src/external\n\n  lint-rust:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Rustfmt check\n        run: (cd src && cargo fmt -- --check)\n\n  lint-cargo-lock:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Cargo update check\n        run: |\n          # This will return an error if any versions of local crates in the Cargo.lock\n          # are out of date compared to the crate versions in Cargo.toml. This can fail\n          # if the Shadow version is bumped without using Cargo to update the lock file.\n          (cd src && cargo update --locked --workspace)\n\n  lint-cargo-doc:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Run on PR head instead of merge result. Running on the merge\n          # result can give confusing results, and we require PR to be up to\n          # date with target branch before merging, anyway.\n          # See https://github.com/shadow/shadow/issues/2166\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Cargo doc check\n        run: |\n          cmake -S . -B build\n          (cd src && RUSTDOCFLAGS='-D warnings' cargo doc)\n```", "prompt": "Generate a GitHub Workflow named `Lint Checks` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) a pull request is created or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `CARGO_TERM_COLOR` is set to `always`. The workflow has 4 jobs. The job id of the 1st job is `lint-python`. This job will run on ubuntu-latest runner. The job `lint-python` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `persist-credentials` is set to `False` and `ref` is set to `${{ github.event.pull_request.head.sha }}`. The 2nd step is named ``. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `3.10`. The 3rd step is named ``. This step runs a script: `pip install flake8`. The 4th step is named ``. This step runs a script: `flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude src/external`. The job id of the 2nd job is `lint-rust`. This job will run on ubuntu-latest runner. The job `lint-rust` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `ref` is set to `${{ github.event.pull_request.head.sha }}`. The 2nd step is named `Rustfmt check`. This step runs a script: `(cd src && cargo fmt -- --check)`. The job id of the 3rd job is `lint-cargo-lock`. This job will run on ubuntu-latest runner. The job `lint-cargo-lock` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Cargo update check`. This step runs a script: `# This will return an error if any versions of local crates in the Cargo.lock\n# are out of date compared to the crate versions in Cargo.toml. This can fail\n# if the Shadow version is bumped without using Cargo to update the lock file.\n(cd src && cargo update --locked --workspace)\n`. The job id of the 4th job is `lint-cargo-doc`. This job will run on ubuntu-latest runner. The job `lint-cargo-doc` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `ref` is set to `${{ github.event.pull_request.head.sha }}`. The 2nd step is named `Cargo doc check`. This step runs a script: `cmake -S . -B build\n(cd src && RUSTDOCFLAGS='-D warnings' cargo doc)\n`. "}
{"id": "63c4956e7843b61269a0794c", "level": "level5", "llm_response": "```yaml\nname: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\njobs:\n  black:\n    id: black\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n      - name: Black\n        uses: psf/black@22.3.0\n\n  flake8:\n    id: flake8\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade wheel pip\n          pip install .[lint]\n      - name: Lint examples\n        run: flake8 examples --show-source\n      - name: Lint scripts\n        run: flake8 setup.py docs/conf.py scripts --show-source\n      - name: Lint tests\n        run: flake8 tests --show-source\n      - name: Lint moviepy\n        run: flake8 moviepy --show-source\n\n  isort:\n    id: isort\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Check imports\n        run: isort --check-only moviepy tests examples docs/conf.py scripts\n```", "answer": "```yaml name: Code Format Check\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n\n\njobs:\n  black:\n    runs-on: ubuntu-latest\n    name: Black\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n      - name: Black\n        uses: psf/black@22.3.0  # already includes args \"--check --diff\"\n  flake8:\n    runs-on: ubuntu-latest\n    name: Flake8\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade wheel pip\n          pip install .[lint]\n      - name: Lint examples\n        run: flake8 examples --show-source\n      - name: Lint scripts\n        run: flake8 setup.py docs/conf.py scripts --show-source\n      - name: Lint tests\n        run: flake8 tests --show-source\n      - name: Lint moviepy\n        run: flake8 moviepy --show-source\n  isort:\n    runs-on: ubuntu-latest\n    name: isort\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install isort\n      - name: Check imports\n        run: isort --check-only moviepy tests examples docs/conf.py scripts\n```", "prompt": "Generate a GitHub Workflow named `Code Format Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. The workflow has 3 jobs. The 1st job is named `Black` and its job id is `black`. This job will run on ubuntu-latest runner. The job `black` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Python`. This step runs action `actions/setup-python` tagged as v3. The 3rd step is named `Black`. This step runs action `psf/black` tagged as 22.3.0. The 2nd job is named `Flake8` and its job id is `flake8`. This job will run on ubuntu-latest runner. The job `flake8` has 7 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Python`. This step runs action `actions/setup-python` tagged as v3. The step defines an input parameter for the action: `python-version` is set to `3.9`. The 3rd step is named `Install dependencies`. This step runs a script: `python -m pip install --upgrade wheel pip\npip install .[lint]\n`. The 4th step is named `Lint examples`. This step runs a script: `flake8 examples --show-source`. The 5th step is named `Lint scripts`. This step runs a script: `flake8 setup.py docs/conf.py scripts --show-source`. The 6th step is named `Lint tests`. This step runs a script: `flake8 tests --show-source`. The 7th step is named `Lint moviepy`. This step runs a script: `flake8 moviepy --show-source`. The 3rd job is named `isort` and its job id is `isort`. This job will run on ubuntu-latest runner. The job `isort` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Python`. This step runs action `actions/setup-python` tagged as v3. The step defines an input parameter for the action: `python-version` is set to `3.9`. The 3rd step is named `Install dependencies`. This step runs a script: `python -m pip install --upgrade pip\npip install isort\n`. The 4th step is named `Check imports`. This step runs a script: `isort --check-only moviepy tests examples docs/conf.py scripts`. "}
{"id": "63c493ea8052faa2781a7e17", "level": "level5", "llm_response": "```yaml\nname: master\n\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  test:\n    id: test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust: [1.31.0, stable]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set Rust toolchain\n        uses: dtolnay/rust-toolchain@master\n        with:\n          toolchain: ${{ matrix.rust }}\n      - name: Build project\n        run: cargo build\n      - name: Run tests\n        run: ./ci/test_full.sh\n```", "answer": "```yaml name: master\non:\n  push:\n    branches:\n      - master\n  schedule:\n    - cron: '0 0 * * 0' # 00:00 Sunday\n\njobs:\n\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust: [1.31.0, stable]\n    steps:\n      - uses: actions/checkout@v3\n      - uses: dtolnay/rust-toolchain@master\n        with:\n          toolchain: ${{ matrix.rust }}\n      - run: cargo build\n      - run: ./ci/test_full.sh\n```", "prompt": "Generate a GitHub Workflow named `master` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The 1st job is named `Test` and its job id is `test`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `rust` has 2 values: 1.31.0 and stable. The job `test` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `dtolnay/rust-toolchain` from the master branch. The step defines an input parameter for the action: `toolchain` is set to `${{ matrix.rust }}`. The 3rd step is named ``. This step runs a script: `cargo build`. The 4th step is named ``. This step runs a script: `./ci/test_full.sh`. "}
{"id": "63c495668052faa2781b18dd", "level": "level5", "llm_response": "```yaml\nname: release management\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Set up Release Drafter\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        uses: toolmantim/release-drafter@v5\n```", "answer": "```yaml name: release management\non:\n  push:\n    branches: [master]\n\njobs:\n  update-draft-release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: toolmantim/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `release management` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `update-draft-release`. This job will run on ubuntu-latest runner. The job `update-draft-release` has one step. The 1st step is named ``. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `toolmantim/release-drafter` tagged as v5. "}
{"id": "63c494608052faa2781aac1c", "level": "level5", "llm_response": "```yaml\nname: ASF-ci\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n  repository_dispatch:\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: True\n  DOTNET_NOLOGO: True\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        configuration: [Debug, Release]\n        os: [macos-latest, ubuntu-latest, windows-latest]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n      with:\n        submodules: recursive\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v3.0.2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --info\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test ArchiSteamFarm.Tests -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Upload latest strings for translation on Crowdin\n      if: github.event_name == 'push' && github.ref == 'refs/heads/main' && matrix.configuration == 'Release' && startsWith(matrix.os, 'ubuntu-')\n      uses: crowdin/github-action@1.4.16\n      with:\n        crowdin_branch_name: main\n        config: .github/crowdin.yml\n        project_id: ${{ secrets.ASF_CROWDIN_PROJECT_ID }}\n        token: ${{ secrets.ASF_CROWDIN_API_TOKEN }}\n```", "answer": "```yaml name: ASF-ci\n\non: [push, pull_request]\n\nenv:\n  DOTNET_CLI_TELEMETRY_OPTOUT: true\n  DOTNET_NOLOGO: true\n  DOTNET_SDK_VERSION: 6.0.x\n\njobs:\n  main:\n    strategy:\n      fail-fast: false\n      matrix:\n        configuration: [Debug, Release]\n        os: [macos-latest, ubuntu-latest, windows-latest]\n\n    runs-on: ${{ matrix.os }}\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n      with:\n        submodules: recursive\n\n    - name: Setup .NET Core\n      uses: actions/setup-dotnet@v3.0.2\n      with:\n        dotnet-version: ${{ env.DOTNET_SDK_VERSION }}\n\n    - name: Verify .NET Core\n      run: dotnet --info\n\n    - name: Build ${{ matrix.configuration }} ArchiSteamFarm and other projects\n      run: dotnet build -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Run ${{ matrix.configuration }} ArchiSteamFarm.Tests\n      run: dotnet test ArchiSteamFarm.Tests -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo\n\n    - name: Upload latest strings for translation on Crowdin\n      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && matrix.configuration == 'Release' && startsWith(matrix.os, 'ubuntu-') }}\n      uses: crowdin/github-action@1.4.16\n      with:\n        crowdin_branch_name: main\n        config: '.github/crowdin.yml'\n        project_id: ${{ secrets.ASF_CROWDIN_PROJECT_ID }}\n        token: ${{ secrets.ASF_CROWDIN_API_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `ASF-ci` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow sets 3 environment variables to use: `DOTNET_CLI_TELEMETRY_OPTOUT` is set to `True`, `DOTNET_NOLOGO` is set to `True` and `DOTNET_SDK_VERSION` is set to `6.0.x`. The workflow has one job. The job id of the 1st job is `main`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `configuration` has 2 values: Debug and Release. The variable `os` has 3 values: macos-latest, ubuntu-latest and windows-latest. The job `main` has 6 steps. The 1st step is named `Checkout code`. This step runs action `actions/checkout` tagged as v3.1.0. The step defines an input parameter for the action: `submodules` is set to `recursive`. The 2nd step is named `Setup .NET Core`. This step runs action `actions/setup-dotnet` tagged as v3.0.2. The step defines an input parameter for the action: `dotnet-version` is set to `${{ env.DOTNET_SDK_VERSION }}`. The 3rd step is named `Verify .NET Core`. This step runs a script: `dotnet --info`. The 4th step is named `Build ${{ matrix.configuration }} ArchiSteamFarm and other projects`. This step runs a script: `dotnet build -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo`. The 5th step is named `Run ${{ matrix.configuration }} ArchiSteamFarm.Tests`. This step runs a script: `dotnet test ArchiSteamFarm.Tests -c \"${{ matrix.configuration }}\" -p:ContinuousIntegrationBuild=true -p:UseAppHost=false --nologo`. The 6th step is named `Upload latest strings for translation on Crowdin`. This step will run only if the condition(${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && matrix.configuration == 'Release' && startsWith(matrix.os, 'ubuntu-') }}) is met. This step runs action `crowdin/github-action` tagged as 1.4.16. The step defines 4 input parameters for the action: `crowdin_branch_name` is set to `main`, `config` is set to `.github/crowdin.yml`, `project_id` is set to `${{ secrets.ASF_CROWDIN_PROJECT_ID }}` and `token` is set to `${{ secrets.ASF_CROWDIN_API_TOKEN }}`. "}
{"id": "63c495da7843b61269a0a66e", "level": "level5", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        go: [1.19]\n        os: [ubuntu-20.04, ubuntu-22.04, macos-11, macos-12, windows-2019, windows-2022]\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: ${{ matrix.go }}\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  main:\n    strategy:\n      matrix:\n        go:\n          - 1.19\n        os:\n          - ubuntu-20.04\n          - ubuntu-22.04\n          - macos-11\n          - macos-12\n          - windows-2019\n          - windows-2022\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Go\n        uses: actions/setup-go@v3\n        with:\n          go-version: ${{ matrix.go }}\n\n      - name: Build\n        run: go build -v ./...\n\n      - name: Test\n        run: go test -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `main`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `go` has one value: 1.19. The variable `os` has 6 values: ubuntu-20.04, ubuntu-22.04, macos-11, macos-12, windows-2019 and windows-2022. The job `main` has 4 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Go`. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `${{ matrix.go }}`. The 3rd step is named `Build`. This step runs a script: `go build -v ./...`. The 4th step is named `Test`. This step runs a script: `go test -v ./...`. "}
{"id": "63c494247843b612699ff48a", "level": "level5", "llm_response": "```yaml\nname: Rust\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n  repository_dispatch:\n    types: [ clone ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@master\n\n    - name: Set up Rust\n      uses: hecrj/setup-rust-action@master\n      with:\n        rust-version: stable\n\n    - name: Check Cargo availability\n      run: cargo --version\n\n    - name: Check Rustup default toolchain\n      run: rustup default | grep stable\n\n    - name: Build without default features\n      run: env RUSTFLAGS=\"-C link-arg=-s\" cargo check --no-default-features\n\n    - name: Build with default features\n      run: env RUSTFLAGS=\"-C link-arg=-s\" cargo check\n```", "answer": "```yaml name: Rust\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@master\n      - uses: hecrj/setup-rust-action@master\n        with:\n          rust-version: stable\n      - name: Check Cargo availability\n        run: cargo --version\n      - name: Check Rustup default toolchain\n        run: rustup default | grep stable\n      - name: Build without default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check --no-default-features\n      - name: Build with default features\n        run: |\n          env RUSTFLAGS=\"-C link-arg=-s\" cargo check\n```", "prompt": "Generate a GitHub Workflow named `Rust` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` from the master branch. The 2nd step is named ``. This step runs action `hecrj/setup-rust-action` from the master branch. The step defines an input parameter for the action: `rust-version` is set to `stable`. The 3rd step is named `Check Cargo availability`. This step runs a script: `cargo --version`. The 4th step is named `Check Rustup default toolchain`. This step runs a script: `rustup default | grep stable`. The 5th step is named `Build without default features`. This step runs a script: `env RUSTFLAGS=\"-C link-arg=-s\" cargo check --no-default-features\n`. The 6th step is named `Build with default features`. This step runs a script: `env RUSTFLAGS=\"-C link-arg=-s\" cargo check\n`. "}
{"id": "63c494fd7843b61269a04a9b", "level": "level5", "llm_response": "```yaml\nname: Automatic Releases\n\non:\n  milestone:\n    closed:\n      types: [closed]\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Call reusable release workflow\n        uses: doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0\n        with:\n          GIT_AUTHOR_EMAIL: ${{ secrets.GIT_AUTHOR_EMAIL }}\n          GIT_AUTHOR_NAME: ${{ secrets.GIT_AUTHOR_NAME }}\n          ORGANIZATION_ADMIN_TOKEN: ${{ secrets.ORGANIZATION_ADMIN_TOKEN }}\n          SIGNING_SECRET_KEY: ${{ secrets.SIGNING_SECRET_KEY }}\n```", "answer": "```yaml name: \"Automatic Releases\"\n\non:\n  milestone:\n    types:\n      - \"closed\"\n\njobs:\n  release:\n    name: \"Git tag, release & create merge-up PR\"\n    uses: \"doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0\"\n    secrets:\n      GIT_AUTHOR_EMAIL: ${{ secrets.GIT_AUTHOR_EMAIL }}\n      GIT_AUTHOR_NAME: ${{ secrets.GIT_AUTHOR_NAME }}\n      ORGANIZATION_ADMIN_TOKEN: ${{ secrets.ORGANIZATION_ADMIN_TOKEN }}\n      SIGNING_SECRET_KEY: ${{ secrets.SIGNING_SECRET_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Automatic Releases` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: a milestone is closed. The workflow has one job. The 1st job is named `Git tag, release & create merge-up PR` and its job id is `release`. This job will call a reusable workflow located at `doctrine/.github/.github/workflows/release-on-milestone-closed.yml@1.5.0`. The job will pass 4 secrets to the called workflow: the secret `GIT_AUTHOR_EMAIL` is `${{ secrets.GIT_AUTHOR_EMAIL }}`, the secret `GIT_AUTHOR_NAME` is `${{ secrets.GIT_AUTHOR_NAME }}`, the secret `ORGANIZATION_ADMIN_TOKEN` is `${{ secrets.ORGANIZATION_ADMIN_TOKEN }}` and the secret `SIGNING_SECRET_KEY` is `${{ secrets.SIGNING_SECRET_KEY }}`. "}
{"id": "63c4957d8052faa2781b22ad", "level": "level5", "llm_response": "```yaml\nname: nix-build\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n      - release-v**\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install Nix\n        uses: cachix/install-nix-action@v17\n        with:\n          install_url: https://releases.nixos.org/nix/nix-2.10.3/install\n\n      - name: Authenticate with Cachix\n        uses: cachix/cachix-action@v10\n        with:\n          name: centrifuge-chain\n          authToken: ${{ secrets.CACHIX_AUTH_TOKEN }}\n\n      - name: Build centrifuge-chain\n        run: nix build --no-allow-dirty -L\n```", "answer": "```yaml name: nix-build\non:\n  pull_request:\n  push:\n    branches: [main, 'release-v**']\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          # Nix Flakes doesn't work on shallow clones\n          fetch-depth: 0\n      - uses: cachix/install-nix-action@v17\n        with:\n          install_url: https://releases.nixos.org/nix/nix-2.10.3/install\n      - uses: cachix/cachix-action@v10\n        with:\n          name: centrifuge-chain\n          authToken: \"${{ secrets.CACHIX_AUTH_TOKEN }}\"\n      - name: Build centrifuge-chain\n        run: nix build --no-allow-dirty -L```", "prompt": "Generate a GitHub Workflow named `nix-build` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches release-v**. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named ``. This step runs action `cachix/install-nix-action` tagged as v17. The step defines an input parameter for the action: `install_url` is set to `https://releases.nixos.org/nix/nix-2.10.3/install`. The 3rd step is named ``. This step runs action `cachix/cachix-action` tagged as v10. The step defines 2 input parameters for the action: `name` is set to `centrifuge-chain` and `authToken` is set to `${{ secrets.CACHIX_AUTH_TOKEN }}`. The 4th step is named `Build centrifuge-chain`. This step runs a script: `nix build --no-allow-dirty -L`. "}
{"id": "63c4968a6fc19abdf9c9ca16", "level": "level5", "llm_response": "```yaml\nname: conda builds\n\non:\n  pull_request:\n    paths:\n      - conda-environment.yml\n      - .github/workflows/test_conda-build.yml\n  schedule:\n    - cron: '17 22 * * 6'\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: checkout cylc-flow\n        uses: actions/checkout@v3\n      - name: build conda env\n        run: |\n          env_file='conda-environment.yml'\n          echo \"  - pip\"  >> \"$env_file\"\n          echo \"  - pip:\" >> \"$env_file\"\n          echo \"    - .\"  >> \"$env_file\"\n          cat \"$env_file\"\n          conda env create \\\n            -f \"$env_file\" \\\n            --prefix cylc-dev\n          . /usr/share/miniconda/etc/profile.d/conda.sh\n          conda run --prefix cylc-dev cylc version --long\n      - name: check for activate scripts\n        run: |\n          find ./cylc-dev/ -name \"activate.d\" | tee > activates.txt\n          sed -i '/cylc-dev\\/etc\\/conda\\/activate.d/d' activates.txt\n          if [[ $(cat activates.txt | wc -l) -ne 0 ]]; then\n              echo '::error::Found activate scripts in installation.'\n              cat activates.txt >&2\n              exit 1\n          fi\n```", "answer": "```yaml name: conda builds\n\non:\n  pull_request:\n    paths:\n      - 'conda-environment.yml'\n      - '.github/workflows/test_conda-build.yml'\n  schedule:\n    - cron: '17 22 * * 6'  # Every Saturday at 22:17\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  test_conda_install:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    steps:\n      - name: checkout cylc-flow\n        uses: actions/checkout@v3\n\n      - name: build conda env\n        run: |\n          # write environment file\n          env_file='conda-environment.yml'\n          echo \"  - pip\"  >> \"$env_file\"  # list pip as a dependency\n          echo \"  - pip:\" >> \"$env_file\"  # add a pip section\n          echo \"    - .\"  >> \"$env_file\"  # install cylc-flow (pip install .)\n          cat \"$env_file\"\n          # install environment\n          conda env create \\\n            -f \"$env_file\" \\\n            --prefix cylc-dev\n          . /usr/share/miniconda/etc/profile.d/conda.sh\n          # check cylc-flow was installed correctly\n          conda run --prefix cylc-dev cylc version --long\n\n      - name: check for activate scripts\n        run: |\n          # https://github.com/cylc/cylc-flow/issues/3704#issuecomment-897442365\n          # locate all activate scripts\n          find ./cylc-dev/ -name \"activate.d\" | tee > activates.txt\n          # ignore the conda activate script itself\n          sed -i '/cylc-dev\\/etc\\/conda\\/activate.d/d' activates.txt\n          # check to make sure no packages have contributed new activate scripts\n          # (we rely on having a conda activate-less environment)\n          if [[ $(cat activates.txt | wc -l) -ne 0 ]]; then\n              echo '::error::Found activate scripts in installation.'\n              cat activates.txt >&2\n              exit 1\n          fi\n```", "prompt": "Generate a GitHub Workflow named `conda builds` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) Only if at least one path of pull_request event matches a pattern in the paths filter(conda-environment.yml or .github/workflows/test_conda-build.yml), the workflow runs. 2) the scheduled time has come: at 10:17 pm, only on saturday. 3) someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `test_conda_install`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 10. The job `test_conda_install` has 3 steps. The 1st step is named `checkout cylc-flow`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `build conda env`. This step runs a script: `# write environment file\nenv_file='conda-environment.yml'\necho \"  - pip\"  >> \"$env_file\"  # list pip as a dependency\necho \"  - pip:\" >> \"$env_file\"  # add a pip section\necho \"    - .\"  >> \"$env_file\"  # install cylc-flow (pip install .)\ncat \"$env_file\"\n# install environment\nconda env create \\\n  -f \"$env_file\" \\\n  --prefix cylc-dev\n. /usr/share/miniconda/etc/profile.d/conda.sh\n# check cylc-flow was installed correctly\nconda run --prefix cylc-dev cylc version --long\n`. The 3rd step is named `check for activate scripts`. This step runs a script: `# https://github.com/cylc/cylc-flow/issues/3704#issuecomment-897442365\n# locate all activate scripts\nfind ./cylc-dev/ -name \"activate.d\" | tee > activates.txt\n# ignore the conda activate script itself\nsed -i '/cylc-dev\\/etc\\/conda\\/activate.d/d' activates.txt\n# check to make sure no packages have contributed new activate scripts\n# (we rely on having a conda activate-less environment)\nif [[ $(cat activates.txt | wc -l) -ne 0 ]]; then\n    echo '::error::Found activate scripts in installation.'\n    cat activates.txt >&2\n    exit 1\nfi\n`. "}
{"id": "63c496411e3364807577968e", "level": "level5", "llm_response": "```yaml\nname: Add to project\n\non:\n  issues:\n    types: [opened, transferred]\n\njobs:\n  add-to-project:\n    id: add-to-project\n    runs-on: ubuntu-latest\n\n    steps:\n    - id: add_project\n      uses: actions/add-to-project@main\n      with:\n        project-url: ${{ secrets.PROJECT_PLANNING }}\n        github-token: ${{ secrets.BOT_TOKEN_PROJECT }}\n\n    - name: Set Team\n      env:\n        GITHUB_TOKEN: ${{ secrets.BOT_TOKEN_PROJECT }}\n      run: |\n        gh api graphql -f query='\n        mutation(\n            $project: ID!\n            $item: ID!\n            $status_field: ID!\n            $status_value: String!\n          )  {\n          updateProjectV2ItemFieldValue(\n            input: {\n             projectId: $project\n              itemId: $item\n              fieldId: $status_field\n              value: { \n                singleSelectOptionId: $status_value\n                }\n            }\n          ) {\n            projectV2Item {\n              id\n            }\n          }\n        }' -f project=${{ secrets.PROJECT_PLANNING_ID }} -f item=${{ steps.add_project.outputs.itemId }} -f status_field=${{ secrets.PLANNING_TEAM_FIELD_ID }} -f status_value=ed46988b --silent\n```", "answer": "```yaml name: Add to project\n\non:\n  issues:\n    types: [opened,transferred]\n\njobs:\n  add-to-project:\n    name: Add issue to project\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/add-to-project@main\n        id: add_project\n        with:\n          project-url: ${{ secrets.PROJECT_PLANNING }}\n          github-token: ${{ secrets.BOT_TOKEN_PROJECT }}\n      - name: Set Team\n        env:\n          GITHUB_TOKEN: ${{ secrets.BOT_TOKEN_PROJECT }}\n        run: |\n          gh api graphql -f query='\n          mutation(\n              $project: ID!\n              $item: ID!\n              $status_field: ID!\n              $status_value: String!\n            )  {\n            updateProjectV2ItemFieldValue(\n              input: {\n               projectId: $project\n                itemId: $item\n                fieldId: $status_field\n                value: { \n                  singleSelectOptionId: $status_value\n                  }\n              }\n            ) {\n              projectV2Item {\n                id\n              }\n            }\n          }' -f project=${{ secrets.PROJECT_PLANNING_ID }} -f item=${{ steps.add_project.outputs.itemId }} -f status_field=${{ secrets.PLANNING_TEAM_FIELD_ID }} -f status_value=ed46988b --silent```", "prompt": "Generate a GitHub Workflow named `Add to project` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: an issue is opened or an issue is transferred to another repository. The workflow has one job. The 1st job is named `Add issue to project` and its job id is `add-to-project`. This job will run on ubuntu-latest runner. The job `add-to-project` has 2 steps. The 1st step is named `` and its id is `add_project`. This step runs action `actions/add-to-project` from the main branch. The step defines 2 input parameters for the action: `project-url` is set to `${{ secrets.PROJECT_PLANNING }}` and `github-token` is set to `${{ secrets.BOT_TOKEN_PROJECT }}`. The 2nd step is named `Set Team`. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.BOT_TOKEN_PROJECT }}`. This step runs a script: `gh api graphql -f query='\nmutation(\n    $project: ID!\n    $item: ID!\n    $status_field: ID!\n    $status_value: String!\n  )  {\n  updateProjectV2ItemFieldValue(\n    input: {\n     projectId: $project\n      itemId: $item\n      fieldId: $status_field\n      value: { \n        singleSelectOptionId: $status_value\n        }\n    }\n  ) {\n    projectV2Item {\n      id\n    }\n  }\n}' -f project=${{ secrets.PROJECT_PLANNING_ID }} -f item=${{ steps.add_project.outputs.itemId }} -f status_field=${{ secrets.PLANNING_TEAM_FIELD_ID }} -f status_value=ed46988b --silent`. "}
{"id": "63c494c17843b61269a0331c", "level": "level5", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - dev\n  pull_request:\n    branches:\n      - dev\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n    strategy:\n      matrix:\n        language: [java]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@v2\n        with:\n          languages: ${{ matrix.language }}\n      - name: Autobuild\n        uses: github/codeql-action/autobuild@v2\n      - name: Run Maven build\n        run: |\n          ./mvnw -q -Dmaven.test.skip=true -Dscala.version=2.12.8 -Dscala.binary.version=2.12 clean install || ./mvnw -q -Dmaven.test.skip=true clean install\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n```", "answer": "```yaml # Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ \"dev\" ]\n  pull_request:\n    # The branches below must be a subset of the branches above\n    branches: [ \"dev\" ]\n  schedule:\n    - cron: '20 16 * * 5'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'java' ]\n        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]\n        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    # Initializes the CodeQL tools for scanning.\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v2\n      with:\n        languages: ${{ matrix.language }}\n        # If you wish to specify custom queries, you can do so here or in a config file.\n        # By default, queries listed here will override any specified in a config file.\n        # Prefix the list here with \"+\" to use these queries and those in the config file.\n        \n        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs\n        # queries: security-extended,security-and-quality\n\n        \n    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n    # If this step fails, then you should remove it and run the build manually (see below)\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v2\n\n    # \u2139\ufe0f Command-line programs to run using the OS shell.\n    # \ud83d\udcda See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun\n\n    #   If the Autobuild fails above, remove it and uncomment the following three lines. \n    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.\n\n    # - run: |\n    #   echo \"Run, Build Application using script\"\n    #   ./location_of_script_within_repo/buildscript.sh\n    - run: ./mvnw -q -Dmaven.test.skip=true -Dscala.version=2.12.8 -Dscala.binary.version=2.12 clean install || ./mvnw -q -Dmaven.test.skip=true clean install\n  \n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Vue. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named dev. 2) The workflow would run whenever there is a pull_request event targeting: a branch named dev. 3) the scheduled time has come: at 04:20 pm, only on friday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has one value: java. The job `analyze` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `actions` scope, read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `security-events` scope. This permission setting only applies to the job `analyze`. The job `analyze` has 5 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Initialize CodeQL`. This step runs action `github/codeql-action/init` tagged as v2. The step defines an input parameter for the action: `languages` is set to `${{ matrix.language }}`. The 3rd step is named `Autobuild`. This step runs action `github/codeql-action/autobuild` tagged as v2. The 4th step is named ``. This step runs a script: `./mvnw -q -Dmaven.test.skip=true -Dscala.version=2.12.8 -Dscala.binary.version=2.12 clean install || ./mvnw -q -Dmaven.test.skip=true clean install`. The 5th step is named `Perform CodeQL Analysis`. This step runs action `github/codeql-action/analyze` tagged as v2. "}
{"id": "63c496861e3364807577b319", "level": "level5", "llm_response": "```yaml\nname: documentation\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  skip_duplicate_jobs:\n    runs-on: ubuntu-latest\n    outputs:\n      should_skip: ${{ steps.skip_check.outputs.should_skip }}\n    steps:\n      - name: skip_check\n        id: skip_check\n        uses: fkirc/skip-duplicate-actions@master\n        with:\n          concurrent_skipping: same_content\n          skip_after_successful_duplicate: true\n          paths: \"doc/**\"\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: skip_duplicate_jobs\n    if: ${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2.3.1\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Create output directories\n        run: mkdir -p output/reference\n\n      - name: Copy index.html\n        run: cp website/index.html output/index.html\n\n      - name: Generate reference\n        id: adocbuild\n        uses: tonynv/asciidoctor-action@master\n        with:\n          program: asciidoctor doc/index.adoc -o output/reference/index.html\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.1.7\n        with:\n          branch: gh-pages\n          folder: output\n```", "answer": "```yaml # adapted from:\n#\n# * base code: https://peterevans.dev/posts/github-actions-how-to-automate-code-formatting-in-pull-requests/\n# * fix push auth: https://github.com/ad-m/github-push-action\n# * checkout PR head commit https://github.com/actions/checkout#checkout-pull-request-head-commit-instead-of-merge-commit\nname: documentation\non:\n  push:\n    branches:\n      - master\njobs:\n  skip_duplicate_jobs:\n    runs-on: ubuntu-latest\n    outputs:\n      should_skip: ${{ steps.skip_check.outputs.should_skip }}\n    steps:\n      - id: skip_check\n        uses: fkirc/skip-duplicate-actions@master\n        with:\n          concurrent_skipping: 'same_content'\n          skip_after_successful_duplicate: 'true'\n          paths: '[\"doc/**\"]'\n  deploy:\n    needs: skip_duplicate_jobs\n    if: ${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2.3.1\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      - name: Create output directories\n        run: mkdir -p output/reference\n\n      - name: Copy index.html\n        run: cp website/index.html output/index.html\n\n      - name: Generate reference\n        id: adocbuild\n        uses: tonynv/asciidoctor-action@master\n        with:\n            program: asciidoctor doc/index.adoc -o output/reference/index.html\n\n\n      - name: Deploy \ud83d\ude80\n        uses: JamesIves/github-pages-deploy-action@4.1.7\n        with:\n          branch: gh-pages # The branch the action should deploy to.\n          folder: output # The folder the action should deploy.\n```", "prompt": "Generate a GitHub Workflow named `documentation` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has 2 jobs. The job id of the 1st job is `skip_duplicate_jobs`. This job will run on ubuntu-latest runner. The job `skip_duplicate_jobs` has one step. The 1st step is named `` and its id is `skip_check`. This step runs action `fkirc/skip-duplicate-actions` from the master branch. The step defines 3 input parameters for the action: `concurrent_skipping` is set to `same_content`, `skip_after_successful_duplicate` is set to `true` and `paths` is set to `[\"doc/**\"]`. This job has an output: `should_skip` is defined as ${{ steps.skip_check.outputs.should_skip }}. The job id of the 2nd job is `deploy`. Before this job runs, `skip_duplicate_jobs` must complete successfully. This job will run only if the condition(${{ needs.skip_duplicate_jobs.outputs.should_skip != 'true' }}) is met. This job will run on ubuntu-latest runner. The job `deploy` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v2.3.1. The step defines an input parameter for the action: `ref` is set to `${{ github.event.pull_request.head.sha }}`. The 2nd step is named `Create output directories`. This step runs a script: `mkdir -p output/reference`. The 3rd step is named `Copy index.html`. This step runs a script: `cp website/index.html output/index.html`. The 4th step is named `Generate reference` and its id is `adocbuild`. This step runs action `tonynv/asciidoctor-action` from the master branch. The step defines an input parameter for the action: `program` is set to `asciidoctor doc/index.adoc -o output/reference/index.html`. The 5th step is named `Deploy \ud83d\ude80`. This step runs action `JamesIves/github-pages-deploy-action` tagged as 4.1.7. The step defines 2 input parameters for the action: `branch` is set to `gh-pages` and `folder` is set to `output`. "}
{"id": "63c496496fc19abdf9c9b198", "level": "level5", "llm_response": "```yaml\nname: Run checks\n\non:\n  pull_request:\n    branches:\n      - master\n\njobs:\n  go-checks:\n    id: go-checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Test Go Modules Vendor\n        env:\n          IMPORT: cedrickring/golang-action\n          PROJECT_PATH: ./tests/projects/go_modules_vendored\n        run: ./\n\n      - name: Test Go Modules\n        env:\n          IMPORT: cedrickring/golang-action\n          PROJECT_PATH: ./tests/projects/go_modules\n        run: ./\n\n      - name: Test Go Standard\n        env:\n          IMPORT: cedrickring/golang-action\n          PROJECT_PATH: ./tests/projects/go_standard\n        run: ./\n\n  action-checks:\n    id: action-checks\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Install dockerfile_lint\n        run: sudo npm i -g dockerfile_lint\n\n      - name: Lint\n        run: make lint\n\n      - name: Test\n        run: make test\n\n      - name: Docker Build\n        run: make build\n\n      - name: Check all versions\n        run: make docker-check\n```", "answer": "```yaml on: pull_request\nname: Run checks\njobs:\n  go-checks:\n    name: Run go checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Test Go Modules Vendor\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules_vendored\n    - name: Test Go Modules\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_modules\n    - name: Test Go Standard\n      uses: ./\n      env:\n        IMPORT: cedrickring/golang-action\n        PROJECT_PATH: ./tests/projects/go_standard\n  action-checks:\n    permissions:\n      contents: read\n    name: Run action checks\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - name: Install dockerfile_lint\n      run: sudo npm i -g dockerfile_lint\n    - name: Lint\n      run: make lint\n    - name: Test\n      run: make test\n    - name: Docker Build\n      run: make build\n    - name: Check all versions\n      run: make docker-check\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Run go checks` and its job id is `go-checks`. This job will run on ubuntu-latest runner. The job `go-checks` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` from the master branch. The 2nd step is named `Test Go Modules Vendor`. The step sets 2 environment variables to use: `IMPORT` is set to `cedrickring/golang-action` and `PROJECT_PATH` is set to `./tests/projects/go_modules_vendored`. This step runs action `./`.The 3rd step is named `Test Go Modules`. The step sets 2 environment variables to use: `IMPORT` is set to `cedrickring/golang-action` and `PROJECT_PATH` is set to `./tests/projects/go_modules`. This step runs action `./`.The 4th step is named `Test Go Standard`. The step sets 2 environment variables to use: `IMPORT` is set to `cedrickring/golang-action` and `PROJECT_PATH` is set to `./tests/projects/go_standard`. This step runs action `./`.The 2nd job is named `Run action checks` and its job id is `action-checks`. This job will run on ubuntu-latest runner. The job `action-checks` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `action-checks`. The job `action-checks` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` from the master branch. The 2nd step is named `Install dockerfile_lint`. This step runs a script: `sudo npm i -g dockerfile_lint`. The 3rd step is named `Lint`. This step runs a script: `make lint`. The 4th step is named `Test`. This step runs a script: `make test`. The 5th step is named `Docker Build`. This step runs a script: `make build`. The 6th step is named `Check all versions`. This step runs a script: `make docker-check`. "}
{"id": "63c4964f6fc19abdf9c9b3d1", "level": "level5", "llm_response": "```yaml\nname: Package\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    env:\n      PIPENV_VENV_IN_PROJECT: 1\n      PIPENV_IGNORE_VIRTUALENVS: 1\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Setup Python Environment\n      run: |\n        pip3 install pipenv\n        pipenv install pyqt5 lxml\n        pipenv run pip install pyqt5==5.15.6 lxml\n    - name: Build LabelImg\n      run: |\n        pipenv run make qt5py3\n        rm -rf build dist\n    - name: Package LabelImg\n      run: |\n        pipenv run python setup.py py2app\n        open dist/labelImg.app\n    - name: Archive macOS app\n      run: |\n        cd dist/\n        tar czf labelImg.tgz labelImg.app\n    - name: Upload macOS artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: macOS artifact\n        path: dist/labelImg.tgz\n\n  package-windows:\n    runs-on: windows-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Setup Python Environment\n      run: |\n        pip3 install pyinstaller pyqt5==5.15.6 lxml\n    - name: Build LabelImg\n      run: pyrcc5 -o libs/resources.py resources.qrc\n    - name: Package LabelImg\n      run: |\n        pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n    - name: Upload Windows artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: Windows artifact\n        path: dist/labelImg.exe\n\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Setup Python Environment\n      run: |\n        pip3 install pyinstaller pyqt5==5.15.6 lxml\n    - name: Build LabelImg\n      run: pyrcc5 -o libs/resources.py resources.qrc\n    - name: Package LabelImg\n      run: |\n        pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n    - name: Upload Linux artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: Linux artifact\n        path: dist/labelImg\n```", "answer": "```yaml name: Package\non: [push, pull_request]\n\njobs:\n  package-macos:\n    runs-on: macos-latest\n    env:\n      PIPENV_VENV_IN_PROJECT: 1\n      PIPENV_IGNORE_VIRTUALENVS: 1\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pipenv\n          pipenv install pyqt5 lxml\n          pipenv run pip install pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pipenv run make qt5py3\n          rm -rf build dist\n      - name: Package LabelImg\n        run: |\n          pipenv run python setup.py py2app\n          open dist/labelImg.app\n      - name: Archive macOS app\n        run: |\n          cd dist/\n          tar czf labelImg.tgz labelImg.app\n      - uses: actions/upload-artifact@v3\n        with:\n          name: macOS artifact\n          path: dist/labelImg.tgz\n  package-windows:\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Windows artifact\n          path: dist/labelImg.exe\n  package-linux:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Setup Python Environment\n        run: |\n          pip3 install pyinstaller pyqt5==5.15.6 lxml\n      - name: Build LabelImg\n        run: |\n          pyrcc5 -o libs/resources.py resources.qrc\n      - name: Package LabelImg\n        run: |\n          pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n      - uses: actions/upload-artifact@v3\n        with:\n          name: Linux artifact\n          path: dist/labelImg\n```", "prompt": "Generate a GitHub Workflow named `Package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has 3 jobs. The job id of the 1st job is `package-macos`. This job will run on macos-latest runner. The job sets 2 environment variables to use: `PIPENV_VENV_IN_PROJECT` is set to `1` and `PIPENV_IGNORE_VIRTUALENVS` is set to `1`. The job `package-macos` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Setup Python Environment`. This step runs a script: `pip3 install pipenv\npipenv install pyqt5 lxml\npipenv run pip install pyqt5==5.15.6 lxml\n`. The 3rd step is named `Build LabelImg`. This step runs a script: `pipenv run make qt5py3\nrm -rf build dist\n`. The 4th step is named `Package LabelImg`. This step runs a script: `pipenv run python setup.py py2app\nopen dist/labelImg.app\n`. The 5th step is named `Archive macOS app`. This step runs a script: `cd dist/\ntar czf labelImg.tgz labelImg.app\n`. The 6th step is named ``. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `macOS artifact` and `path` is set to `dist/labelImg.tgz`. The job id of the 2nd job is `package-windows`. This job will run on windows-latest runner. The job `package-windows` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Setup Python Environment`. This step runs a script: `pip3 install pyinstaller pyqt5==5.15.6 lxml\n`. The 3rd step is named `Build LabelImg`. This step runs a script: `pyrcc5 -o libs/resources.py resources.qrc\n`. The 4th step is named `Package LabelImg`. This step runs a script: `pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n`. The 5th step is named ``. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `Windows artifact` and `path` is set to `dist/labelImg.exe`. The job id of the 3rd job is `package-linux`. This job will run on ubuntu-latest runner. The job `package-linux` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Setup Python Environment`. This step runs a script: `pip3 install pyinstaller pyqt5==5.15.6 lxml\n`. The 3rd step is named `Build LabelImg`. This step runs a script: `pyrcc5 -o libs/resources.py resources.qrc\n`. The 4th step is named `Package LabelImg`. This step runs a script: `pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n`. The 5th step is named ``. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `Linux artifact` and `path` is set to `dist/labelImg`. "}
{"id": "63c495c68052faa2781b4230", "level": "level5", "llm_response": "```yaml\nname: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n  label:\n    types: [edited]\n\njobs:\n  issueHandler:\n    id: issueHandler\n    runs-on: windows-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n    - name: Issue Handler\n      if: github.event.action == 'opened' || (github.event.action == 'labeled' && contains(github.event.issue.labels.*.name, 'verify'))\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      uses: Ash258/Scoop-GithubActions@stable-win\n```", "answer": "```yaml name: Issues\n\non:\n  issues:\n    types: [opened, labeled]\n\njobs:\n  issueHandler:\n    runs-on: windows-latest\n    name: Issue Handler\n    steps:\n      - uses: actions/checkout@v3\n      - name: Issue Handler\n        uses: Ash258/Scoop-GithubActions@stable-win\n        if: github.event.action == 'opened' || (github.event.action == 'labeled' && contains(github.event.issue.labels.*.name, 'verify'))\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Issues` for a GitHub repository whose primary programming language is PowerShell. This workflow will be triggered by an event: an issue is opened or a label is added to an issue. The workflow has one job. The 1st job is named `Issue Handler` and its job id is `issueHandler`. This job will run on windows-latest runner. The job `issueHandler` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Issue Handler`. This step will run only if the condition(github.event.action == 'opened' || (github.event.action == 'labeled' && contains(github.event.issue.labels.*.name, 'verify'))) is met. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `Ash258/Scoop-GithubActions` from the stable-win branch. "}
{"id": "63c494c78052faa2781ad471", "level": "level5", "llm_response": "```yaml\nname: cla\n\non:\n  issue_comment:\n    types: [created]\n  pull_request:\n    types: [opened, closed, synchronize]\n  pull_request_target:\n    types: [opened, closed, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Get Team Members\n      id: team\n      uses: actions/github-script@7a5c598405937d486b0331594b5da2b14db670da\n      with:\n        github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        result-encoding: string\n        script: |\n          const members = await github.paginate(\n            github.rest.orgs.listMembers,\n            { org: \"skalenetwork\" },\n          );\n          return members.map(m => m.login).join(\",\");\n\n    - name: CLA Assistant\n      if: github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA' || github.event_name == 'pull_request_target'\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n      uses: cla-assistant/github-action@ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba\n      with:\n        path-to-signatures: signatures/version1/cla.json\n        path-to-document: https://skale.network/cla.txt\n        remote-organization-name: skalenetwork\n        remote-repository-name: cla-sigs\n        allowlist: ${{ steps.team.outputs.result }},*[bot]\n```", "answer": "```yaml name: \"cla\"\non:\n  issue_comment:\n    types: [created]\n  pull_request_target:\n    types: [opened, closed, synchronize]\n\njobs:\n  cla:\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Get Team Members\"\n        id: team\n        # github-script, v6.1.0\n        uses: actions/github-script@7a5c598405937d486b0331594b5da2b14db670da\n        with:\n          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n          result-encoding: string\n          script: |\n            const members = await github.paginate(\n              github.rest.orgs.listMembers,\n              { org: \"skalenetwork\" },\n            );\n            return members.map(m => m.login).join(\",\");\n      - name: \"CLA Assistant\"\n        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'\n        # Beta Release, v2.1.3-beta\n        uses: cla-assistant/github-action@ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          PERSONAL_ACCESS_TOKEN : ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        with:\n          path-to-signatures: 'signatures/version1/cla.json'\n          path-to-document: 'https://skale.network/cla.txt'\n          remote-organization-name: 'skalenetwork'\n          remote-repository-name: cla-sigs\n          allowlist: '${{ steps.team.outputs.result }},*[bot]'\n```", "prompt": "Generate a GitHub Workflow named `cla` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) a pull request is created, a pull request is closed or a pull request's head branch is updated. The workflow has one job. The job id of the 1st job is `cla`. This job will run on ubuntu-latest runner. The job `cla` has 2 steps. The 1st step is named `Get Team Members` and its id is `team`. This step runs action `actions/github-script` whose commit is 7a5c598405937d486b0331594b5da2b14db670da. The step defines 3 input parameters for the action: `github-token` is set to `${{ secrets.PERSONAL_ACCESS_TOKEN }}`, `result-encoding` is set to `string` and `script` is set to `const members = await github.paginate(\n  github.rest.orgs.listMembers,\n  { org: \"skalenetwork\" },\n);\nreturn members.map(m => m.login).join(\",\");\n`. The 2nd step is named `CLA Assistant`. This step will run only if the condition((github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target') is met. The step sets 2 environment variables to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}` and `PERSONAL_ACCESS_TOKEN` is set to `${{ secrets.PERSONAL_ACCESS_TOKEN }}`. This step runs action `cla-assistant/github-action` whose commit is ba066dbae3769e2ce93ec8cfc4fdc51b9db628ba. The step defines 5 input parameters for the action: `path-to-signatures` is set to `signatures/version1/cla.json`, `path-to-document` is set to `https://skale.network/cla.txt`, `remote-organization-name` is set to `skalenetwork`, `remote-repository-name` is set to `cla-sigs` and `allowlist` is set to `${{ steps.team.outputs.result }},*[bot]`. "}
{"id": "63c495f07843b61269a0af74", "level": "level5", "llm_response": "```yaml\nname: Acquire activation file\n\non:\n  workflow_dispatch:\n\njobs:\n  activation:\n    runs-on: ubuntu-latest\n    id: activation\n    steps:\n      - name: Request manual activation file\n        id: getManualLicenseFile\n        uses: game-ci/unity-request-activation-file@v2\n      - name: Expose as artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: ${{ steps.getManualLicenseFile.outputs.filePath }}\n          path: ${{ steps.getManualLicenseFile.outputs.filePath }}\n```", "answer": "```yaml \ufeffname: Acquire activation file\non:\n  workflow_dispatch: {}\njobs:\n  activation:\n    name: Request manual activation file\n    runs-on: ubuntu-latest\n    steps:\n      - name: Request manual activation file\n        id: getManualLicenseFile\n        uses: game-ci/unity-request-activation-file@v2\n      - name: Expose as artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: ${{ steps.getManualLicenseFile.outputs.filePath }}\n          path: ${{ steps.getManualLicenseFile.outputs.filePath }}\n```", "prompt": "Generate a GitHub Workflow named `Acquire activation file` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Request manual activation file` and its job id is `activation`. This job will run on ubuntu-latest runner. The job `activation` has 2 steps. The 1st step is named `Request manual activation file` and its id is `getManualLicenseFile`. This step runs action `game-ci/unity-request-activation-file` tagged as v2. The 2nd step is named `Expose as artifact`. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `${{ steps.getManualLicenseFile.outputs.filePath }}` and `path` is set to `${{ steps.getManualLicenseFile.outputs.filePath }}`. "}
{"id": "63c4967d33b087f6bde2c593", "level": "level5", "llm_response": "```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n    paths-ignore:\n      - assets/**\n      - .vscode/**\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        run: ./.github/actions/install\n\n      - name: Check\n        run: yarn check\n\n      - name: Lint\n        run: yarn lint\n\n      - name: Test\n        run: yarn test\n\n  deploy-site:\n    id: deploy-site\n    runs-on: ubuntu-latest\n    environment: github-pages\n\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        run: ./.github/actions/install\n\n      - name: Build Site\n        run: bash -c 'yarn --cwd apps/site ci:build'\n\n      - name: Deploy Website\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./apps/site/out\n          cname: tamagui.dev\n```", "answer": "```yaml name: Release\n\non:\n  push:\n    paths-ignore:\n      - 'assets/**'\n      - '.vscode/**'\n    branches:\n      - master\n\njobs:\n  check:\n    name: Run checks\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Check\n        run: yarn check\n\n      - name: Lint\n        run: yarn lint\n\n      - name: Test\n        run: yarn test\n\n  deploy-site:\n    name: Deploy site\n    runs-on: ubuntu-latest\n    environment: github-pages\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Install\n        uses: ./.github/actions/install\n\n      - name: Build Site\n        shell: bash\n        run: |\n          yarn --cwd apps/site ci:build\n\n      - name: Deploy Website\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./apps/site/out\n          cname: tamagui.dev\n```", "prompt": "Generate a GitHub Workflow named `Release` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. When all the path names of push event match patterns in the paths-ignore filter(assets/** or .vscode/**), the workflow will not run. The workflow has 2 jobs. The 1st job is named `Run checks` and its job id is `check`. This job will run on ubuntu-latest runner. The job `check` has 5 steps. The 1st step is named `Checkout Repo`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Install`. This step runs action `./.github/actions/install`.The 3rd step is named `Check`. This step runs a script: `yarn check`. The 4th step is named `Lint`. This step runs a script: `yarn lint`. The 5th step is named `Test`. This step runs a script: `yarn test`. The 2nd job is named `Deploy site` and its job id is `deploy-site`. This job will run on ubuntu-latest runner. This job references github-pages environment. The job `deploy-site` has 4 steps. The 1st step is named `Checkout Repo`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Install`. This step runs action `./.github/actions/install`.The 3rd step is named `Build Site`. This step uses bash to run a script: `yarn --cwd apps/site ci:build\n`. The 4th step is named `Deploy Website`. This step runs action `peaceiris/actions-gh-pages` tagged as v3. The step defines 3 input parameters for the action: `deploy_key` is set to `${{ secrets.ACTIONS_DEPLOY_KEY }}`, `publish_dir` is set to `./apps/site/out` and `cname` is set to `tamagui.dev`. "}
{"id": "63c495418052faa2781b099b", "level": "level5", "llm_response": "```yaml\nname: 60 Days Stale Check\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Stale Action\n        uses: actions/stale@v3.0.14\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          stale-issue-message: 'This issue is stale because it has been open 60 days with no activity.'\n          stale-pr-message: 'This PR is stale because it has been open 60 days with no activity.'\n          days-before-stale: '-1'\n          days-before-close: '-1'\n          stale-issue-label: 'stale'\n          stale-pr-label: 'stale'\n          exempt-pr-labels: 'never-stale'\n          exempt-issue-labels: 'never-stale'\n```", "answer": "```yaml name: 60 Days Stale Check\non:\n  schedule:\n    - cron: '00 00 * * *' # Run each day at 00:00 UTC\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/stale@v3.0.14\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          stale-issue-message: 'This issue is stale because it has been open 60 days with no activity.'\n          stale-pr-message: 'This PR is stale because it has been open 60 days with no activity.'\n          days-before-stale: -1 # 60 days before marking anything stale - Turned off\n          days-before-close: -1 # Do not close anything automatically\n          stale-issue-label: 'stale'\n          stale-pr-label: 'stale'\n          exempt-pr-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n          exempt-issue-labels: 'never-stale' # Exempt 'never-stale' labels from being marked stale\n```", "prompt": "Generate a GitHub Workflow named `60 Days Stale Check` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `stale`. This job will run on ubuntu-latest runner. The job `stale` has one step. The 1st step is named ``. This step runs action `actions/stale` tagged as v3.0.14. The step defines 9 input parameters for the action: `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`, `stale-issue-message` is set to `This issue is stale because it has been open 60 days with no activity.`, `stale-pr-message` is set to `This PR is stale because it has been open 60 days with no activity.`, `days-before-stale` is set to `-1`, `days-before-close` is set to `-1`, `stale-issue-label` is set to `stale`, `stale-pr-label` is set to `stale`, `exempt-pr-labels` is set to `never-stale` and `exempt-issue-labels` is set to `never-stale`. "}
{"id": "63c496731e3364807577abab", "level": "level5", "llm_response": "```yaml\nname: Automatically crawl CVEs\n\non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n  schedule:\n    - cron: '15 * * * *'\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repo\n        uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.8'\n      - name: Configure pip caching\n        uses: actions/cache@v2\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: ${{ runner.os }}-pip-\n      - name: Install Python dependencies\n        run: python -m pip install -r requirements.txt\n      - name: Crawl CVEs\n        run: python main.py -g \"${{ secrets.CRAWL_PWD }}\" --gtk ${{ secrets.GRAPAQL_TOKEN }}\n      - name: Commit and push Github page (if changed)\n        if: github.event_name != 'pull_request'\n        run: |\n          git diff\n          git config --global user.email \"github-bot@example.com\"\n          git config --global user.name \"Github-Bot\"\n          git add -A\n          git commit -m \"Updated by Github Bot\" || exit 0\n          git push origin master\n```", "answer": "```yaml name: Automatically crawl CVEs \non:\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n    branches:\n      - master\n  schedule:\n    - cron: '15 * * * *'\n\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Check out repo\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.8\n      - uses: actions/cache@v2\n        name: Configure pip caching\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install Python dependencies\n        run: |\n          python -m pip install -r requirements.txt\n\n      - name: Crawl CVEs\n        run: |-\n          python main.py -g \"${{ secrets.CRAWL_PWD }}\" --gtk ${{ secrets.GRAPAQL_TOKEN }}\n\n      # \u82e5\u8be5\u65f6\u95f4\u6bb5\u6ca1\u6709 CVE\uff0c \u5219 file://cache/mail.dat \u6587\u4ef6\u4e0d\u4f1a\u751f\u6210\uff0c\u6b64\u65f6\u4e0d\u4f1a\u53d1\u9001\u90ae\u4ef6\n      # - name: Send mail\n      #   if: ${{ secrets.CRAWL_PWD != '' && github.event_name != 'pull_request' }}\n      #   uses: lyy289065406/action-send-mail@master\n      #   with:\n      #     server_address: ${{ secrets.MAIL_SMTP }}\n      #     server_port: 465\n      #     username: ${{ secrets.MAIL_USER }}\n      #     password: ${{ secrets.MAIL_PASS }}\n      #     from: ${{ secrets.MAIL_USER }}\n      #     to: file://cache/mail_recvs.dat\n      #     body: file://cache/mail_content.dat\n      #     content_type: text/html\n      #     subject: \u5a01\u80c1\u60c5\u62a5\u64ad\u62a5\n\n      # \u5982\u679c\u4e0d\u5e0c\u671b\u6c61\u67d3 commit \u8bb0\u5f55\uff0cuser.email \u548c user.name \u968f\u4fbf\u586b\u5373\u53ef\n      # Github Runner \u662f\u6709\u6743\u9650\u63d0\u4ea4\u5230\u4ed3\u5e93\u7684\uff0c\u53ea\u8981 user \u4e0d\u662f owner \uff0c\u5f53\u6b21 commit \u4e0d\u4f1a\u88ab\u8bb0\u5f55\n      - name: Commit and push Github page (if changed)\n        if: ${{ github.event_name != 'pull_request' }}\n        run: |-\n          git diff\n          git config --global user.email \"github-bot@example.com\"\n          git config --global user.name \"Github-Bot\"\n          git add -A\n          git commit -m \"Updated by Github Bot\" || exit 0\n          git push origin master\n\n```", "prompt": "Generate a GitHub Workflow named `Automatically crawl CVEs` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch named master. 2) someone manually triggers the workflow. 3) the scheduled time has come: at 15 minutes past the hour. The workflow has one job. The job id of the 1st job is `build-and-deploy`. This job will run on ubuntu-latest runner. The job `build-and-deploy` has 6 steps. The 1st step is named `Check out repo`. This step runs action `actions/checkout` tagged as v2. The 2nd step is named `Set up Python`. This step runs action `actions/setup-python` tagged as v2. The step defines an input parameter for the action: `python-version` is set to `3.8`. The 3rd step is named `Configure pip caching`. This step runs action `actions/cache` tagged as v2. The step defines 3 input parameters for the action: `path` is set to `~/.cache/pip`, `key` is set to `${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}` and `restore-keys` is set to `${{ runner.os }}-pip-\n`. The 4th step is named `Install Python dependencies`. This step runs a script: `python -m pip install -r requirements.txt\n`. The 5th step is named `Crawl CVEs`. This step runs a script: `python main.py -g \"${{ secrets.CRAWL_PWD }}\" --gtk ${{ secrets.GRAPAQL_TOKEN }}`. The 6th step is named `Commit and push Github page (if changed)`. This step will run only if the condition(${{ github.event_name != 'pull_request' }}) is met. This step runs a script: `git diff\ngit config --global user.email \"github-bot@example.com\"\ngit config --global user.name \"Github-Bot\"\ngit add -A\ngit commit -m \"Updated by Github Bot\" || exit 0\ngit push origin master`. "}
{"id": "63c496891e3364807577b43b", "level": "level5", "llm_response": "```yaml\nname: Build Docker\n\non:\n  push:\n    branches:\n      - trunk\n    paths:\n      - tools/docker/Dockerfile\n      - tools/docker/bin/run.sh\n      - tools/docker/config/**\n      - .github/versions.sh\n      - .github/workflows/build-docker.yml\n  pull_request:\n    branches:\n      - trunk\n    paths:\n      - tools/docker/Dockerfile\n      - tools/docker/bin/run.sh\n      - tools/docker/config/**\n      - .github/versions.sh\n      - .github/workflows/build-docker.yml\n\nconcurrency:\n  group: build-docker-${{ github.event_name }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    timeout-minutes: 60\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up qemu\n        uses: docker/setup-qemu-action@v2\n        with:\n          platforms: arm64\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: matticbot\n          password: ${{ secrets.DOCKER_HUB_MATTICBOT_TOKEN }}\n\n      - name: Log in to GitHub Packages\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Fetch build args\n        id: buildargs\n        run: |\n          source .github/versions.sh\n          source .github/files/gh-funcs.sh\n\n          gh_set_output php-version \"$PHP_VERSION\"\n          gh_set_output composer-version \"$COMPOSER_VERSION\"\n          gh_set_output node-version \"$NODE_VERSION\"\n          gh_set_output pnpm-version \"$PNPM_VERSION\"\n\n          # We're not git-tagging for the env. Just tag all trunk builds as latest.\n          if [[ \"$GITHUB_EVENT_NAME\" == \"push\" ]]; then\n            gh_set_output tags \"type=raw,latest\"\n            gh_set_output images $'automattic/jetpack-wordpress-dev\\nghcr.io/automattic/jetpack-wordpress-dev'\n          elif [[ \"$GITHUB_EVENT_NAME\" == \"pull_request\" ]]; then\n            gh_set_output tags \"type=ref,event=pr\"\n            gh_set_output images \"ghcr.io/automattic/jetpack-wordpress-dev\"\n          else\n            echo \"Unknown GITHUB_EVENT_NAME $GITHUB_EVENT_NAME\"\n            exit 1\n          fi\n\n      - name: Extract Docker metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          flavor: latest=false\n          tags: ${{ steps.buildargs.outputs.tags }}\n          images: ${{ steps.buildargs.outputs.images }}\n          labels: |\n            org.opencontainers.image.title=Jetpack Development Environment\n            org.opencontainers.image.description=Unified environment for developing in the Jetpack Monorepo using Docker containers.\n            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/trunk/tools/docker/README.md\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v3\n        with:\n          context: tools/docker\n          platforms: linux/amd64,linux/arm64\n          push: True\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          build-args: |\n            PHP_VERSION=${{ steps.buildargs.outputs.php-version }}\n            COMPOSER_VERSION=${{ steps.buildargs.outputs.composer-version }}\n            NODE_VERSION=${{ steps.buildargs.outputs.node-version }}\n            PNPM_VERSION=${{ steps.buildargs.outputs.pnpm-version }}\n```", "answer": "```yaml name: Build Docker\non:\n  push:\n    branches: [ 'trunk' ]\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\n  pull_request:\n    paths:\n      - 'tools/docker/Dockerfile'\n      - 'tools/docker/bin/run.sh'\n      - 'tools/docker/config/*'\n      - '.github/versions.sh'\n      - '.github/workflows/build-docker.yml'\nconcurrency:\n  group: build-docker-${{ github.event_name }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    name: Build and publish Jetpack Dev Environment\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    timeout-minutes: 60  # 2021-10-26: Build for arm64 is S-L-O-W. Sigh.\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up qemu\n        uses: docker/setup-qemu-action@v2\n        with:\n          platforms: arm64\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: matticbot\n          password: ${{ secrets.DOCKER_HUB_MATTICBOT_TOKEN }}\n\n      - name: Log in to GitHub Packages\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Fetch build args\n        id: buildargs\n        run: |\n          source .github/versions.sh\n          source .github/files/gh-funcs.sh\n\n          gh_set_output php-version \"$PHP_VERSION\"\n          gh_set_output composer-version \"$COMPOSER_VERSION\"\n          gh_set_output node-version \"$NODE_VERSION\"\n          gh_set_output pnpm-version \"$PNPM_VERSION\"\n\n          # We're not git-tagging for the env. Just tag all trunk builds as latest.\n          if [[ \"$GITHUB_EVENT_NAME\" == \"push\" ]]; then\n            gh_set_output tags \"type=raw,latest\"\n            gh_set_output images $'automattic/jetpack-wordpress-dev\\nghcr.io/automattic/jetpack-wordpress-dev'\n          elif [[ \"$GITHUB_EVENT_NAME\" == \"pull_request\" ]]; then\n            gh_set_output tags \"type=ref,event=pr\"\n            gh_set_output images \"ghcr.io/automattic/jetpack-wordpress-dev\"\n          else\n            echo \"Unknown GITHUB_EVENT_NAME $GITHUB_EVENT_NAME\"\n            exit 1\n          fi\n\n      - name: Extract Docker metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          flavor: latest=false\n          tags: ${{ steps.buildargs.outputs.tags }}\n          images: ${{ steps.buildargs.outputs.images }}\n          labels: |\n            org.opencontainers.image.title=Jetpack Development Environment\n            org.opencontainers.image.description=Unified environment for developing in the Jetpack Monorepo using Docker containers.\n            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/trunk/tools/docker/README.md\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v3\n        with:\n          context: tools/docker\n          platforms: linux/amd64,linux/arm64\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          build-args: |\n            PHP_VERSION=${{ steps.buildargs.outputs.php-version }}\n            COMPOSER_VERSION=${{ steps.buildargs.outputs.composer-version }}\n            NODE_VERSION=${{ steps.buildargs.outputs.node-version }}\n            PNPM_VERSION=${{ steps.buildargs.outputs.pnpm-version }}\n```", "prompt": "Generate a GitHub Workflow named `Build Docker` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named trunk. Only if at least one path of push event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. 2) Only if at least one path of pull_request event matches a pattern in the paths filter(tools/docker/Dockerfile, tools/docker/bin/run.sh, tools/docker/config/*, .github/versions.sh or .github/workflows/build-docker.yml), the workflow runs. Only a single workflow using the build-docker-${{ github.event_name }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Build and publish Jetpack Dev Environment` and its job id is `build`. This job will run on ubuntu-latest runner. The job `build` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `packages` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `build`. The maximum number of minutes to run the job is 60. The job `build` has 8 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up qemu`. This step runs action `docker/setup-qemu-action` tagged as v2. The step defines an input parameter for the action: `platforms` is set to `arm64`. The 3rd step is named `Set up Docker Buildx`. This step runs action `docker/setup-buildx-action` tagged as v2. The 4th step is named `Log in to Docker Hub`. This step runs action `docker/login-action` tagged as v2. The step defines 2 input parameters for the action: `username` is set to `matticbot` and `password` is set to `${{ secrets.DOCKER_HUB_MATTICBOT_TOKEN }}`. The 5th step is named `Log in to GitHub Packages`. This step runs action `docker/login-action` tagged as v2. The step defines 3 input parameters for the action: `registry` is set to `ghcr.io`, `username` is set to `${{ github.actor }}` and `password` is set to `${{ secrets.GITHUB_TOKEN }}`. The 6th step is named `Fetch build args` and its id is `buildargs`. This step runs a script: `source .github/versions.sh\nsource .github/files/gh-funcs.sh\n\ngh_set_output php-version \"$PHP_VERSION\"\ngh_set_output composer-version \"$COMPOSER_VERSION\"\ngh_set_output node-version \"$NODE_VERSION\"\ngh_set_output pnpm-version \"$PNPM_VERSION\"\n\n# We're not git-tagging for the env. Just tag all trunk builds as latest.\nif [[ \"$GITHUB_EVENT_NAME\" == \"push\" ]]; then\n  gh_set_output tags \"type=raw,latest\"\n  gh_set_output images $'automattic/jetpack-wordpress-dev\\nghcr.io/automattic/jetpack-wordpress-dev'\nelif [[ \"$GITHUB_EVENT_NAME\" == \"pull_request\" ]]; then\n  gh_set_output tags \"type=ref,event=pr\"\n  gh_set_output images \"ghcr.io/automattic/jetpack-wordpress-dev\"\nelse\n  echo \"Unknown GITHUB_EVENT_NAME $GITHUB_EVENT_NAME\"\n  exit 1\nfi\n`. The 7th step is named `Extract Docker metadata` and its id is `meta`. This step runs action `docker/metadata-action` tagged as v4. The step defines 4 input parameters for the action: `flavor` is set to `latest=false`, `tags` is set to `${{ steps.buildargs.outputs.tags }}`, `images` is set to `${{ steps.buildargs.outputs.images }}` and `labels` is set to `org.opencontainers.image.title=Jetpack Development Environment\norg.opencontainers.image.description=Unified environment for developing in the Jetpack Monorepo using Docker containers.\norg.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/trunk/tools/docker/README.md\n`. The 8th step is named `Build and push Docker image`. This step runs action `docker/build-push-action` tagged as v3. The step defines 6 input parameters for the action: `context` is set to `tools/docker`, `platforms` is set to `linux/amd64,linux/arm64`, `push` is set to `True`, `tags` is set to `${{ steps.meta.outputs.tags }}`, `labels` is set to `${{ steps.meta.outputs.labels }}` and `build-args` is set to `PHP_VERSION=${{ steps.buildargs.outputs.php-version }}\nCOMPOSER_VERSION=${{ steps.buildargs.outputs.composer-version }}\nNODE_VERSION=${{ steps.buildargs.outputs.node-version }}\nPNPM_VERSION=${{ steps.buildargs.outputs.pnpm-version }}\n`. "}
{"id": "63c494318052faa2781a9bf5", "level": "level5", "llm_response": "```yaml\nname: Test a branch on canary\n\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n\npermissions:\n  contents: read\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\n\ndefaults:\n  run:\n    shell: pwsh\n\njobs:\n  update_tag:\n    id: update_tag\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n    - name: Harden runner\n      uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34\n      with:\n        allowed-endpoints: api.github.com:443 github.com:443\n\n    - name: Checkout code\n      uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8\n\n    - name: Update the rc tag\n      uses: step-security/publish-action@b438f840875fdcb7d1de4fc3d1d30e86cf6acb5d\n      with:\n        rc-sha: ${{ env.COMMIT_SHA }}\n        rc: True\n\n    - name: Canary test\n      env:\n        PAT: ${{ secrets.PAT }}\n        canary: True\n      run: docker://ghcr.io/step-security/integration-test/int:latest\n```", "answer": "```yaml name: Test a branch on canary\non:\n  workflow_dispatch:\n    inputs:\n      COMMIT_SHA:\n        description: 'Commit SHA to be tested'\n        required: true\n\nenv:\n  COMMIT_SHA: ${{ github.event.inputs.COMMIT_SHA }}\ndefaults:\n  run:\n    shell: pwsh\n\npermissions:  # added using https://github.com/step-security/secure-workflows\n  contents: read\n\njobs:\n  update_tag:\n    name: Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n    - uses: step-security/harden-runner@2e205a28d0e1da00c5f53b161f4067b052c61f34 # v1\n      with:\n        allowed-endpoints: \n          api.github.com:443\n          github.com:443\n\n    - uses: actions/checkout@93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8 # v2\n    - name: Update the rc tag\n      uses: step-security/publish-action@b438f840875fdcb7d1de4fc3d1d30e86cf6acb5d\n      with:\n        rc-sha: ${{ env.COMMIT_SHA }}\n        rc: true\n\n    - name: Canary test\n      uses: docker://ghcr.io/step-security/integration-test/int:latest\n      env:\n        PAT: ${{ secrets.PAT }}\n        canary: true\n```", "prompt": "Generate a GitHub Workflow named `Test a branch on canary` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: COMMIT_SHA-this input represents commit sha to be tested and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `COMMIT_SHA` is set to `${{ github.event.inputs.COMMIT_SHA }}`. For all run steps in the workflow, default shell is set to pwsh. The workflow has one job. The 1st job is named `Update the rc tag to ${{ github.event.inputs.COMMIT_SHA }} commit` and its job id is `update_tag`. This job will run on ubuntu-latest runner. The job `update_tag` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `update_tag`. The job `update_tag` has 4 steps. The 1st step is named ``. This step runs action `step-security/harden-runner` whose commit is 2e205a28d0e1da00c5f53b161f4067b052c61f34. The step defines an input parameter for the action: `allowed-endpoints` is set to `api.github.com:443 github.com:443`. The 2nd step is named ``. This step runs action `actions/checkout` whose commit is 93ea575cb5d8a053eaa0ac8fa3b40d7e05a33cc8. The 3rd step is named `Update the rc tag`. This step runs action `step-security/publish-action` whose commit is b438f840875fdcb7d1de4fc3d1d30e86cf6acb5d. The step defines 2 input parameters for the action: `rc-sha` is set to `${{ env.COMMIT_SHA }}` and `rc` is set to `True`. The 4th step is named `Canary test`. The step sets 2 environment variables to use: `PAT` is set to `${{ secrets.PAT }}` and `canary` is set to `True`. This step runs action `docker://ghcr.io/step-security/integration-test/int:latest`."}
{"id": "63c4964733b087f6bde2ad41", "level": "level5", "llm_response": "```yaml\nname: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - 'py-*'\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [macos-latest, windows-latest]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.7'\n\n    - name: Fix README symlink\n      run: |\n        rm py-polars/README.md\n        cp README.md py-polars/README.md\n\n    - name: Publish wheel\n      env:\n        MATURIN_PASSWORD: ${{ secrets.PYPI_PASS }}\n        RUSTFLAGS: -C target-feature=+fxsr,+sse,+sse2,+sse3,+sse4.1,+sse4.2\n      uses: messense/maturin-action@v1\n      with:\n        rust-toolchain: 'nightly-2022-10-06'\n        maturin-version: '0.13.5'\n        command: 'publish'\n        args: '-m py-polars/Cargo.toml --no-sdist --skip-existing -o wheels -i python -u ritchie46'\n```", "answer": "```yaml name: Create Python release windows macos\n\non:\n  push:\n    tags:\n      - py-*\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  win-macos:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, windows-latest]\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.7'\n\n      - name: Fix README symlink\n        run: |\n          rm py-polars/README.md\n          cp README.md py-polars/README.md\n\n      - name: Publish wheel\n        uses: messense/maturin-action@v1\n        env:\n          MATURIN_PASSWORD: ${{ secrets.PYPI_PASS }}\n          RUSTFLAGS: -C target-feature=+fxsr,+sse,+sse2,+sse3,+sse4.1,+sse4.2\n        with:\n          rust-toolchain: nightly-2022-10-06\n          maturin-version: '0.13.5'\n          command: publish\n          args: -m py-polars/Cargo.toml --no-sdist --skip-existing -o wheels -i python -u ritchie46\n```", "prompt": "Generate a GitHub Workflow named `Create Python release windows macos` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches py-*. For all run steps in the workflow, default shell is set to bash. The workflow has one job. The job id of the 1st job is `win-macos`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `os` has 2 values: macos-latest and windows-latest. The job `win-macos` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `3.7`. The 3rd step is named `Fix README symlink`. This step runs a script: `rm py-polars/README.md\ncp README.md py-polars/README.md\n`. The 4th step is named `Publish wheel`. The step sets 2 environment variables to use: `MATURIN_PASSWORD` is set to `${{ secrets.PYPI_PASS }}` and `RUSTFLAGS` is set to `-C target-feature=+fxsr,+sse,+sse2,+sse3,+sse4.1,+sse4.2`. This step runs action `messense/maturin-action` tagged as v1. The step defines 4 input parameters for the action: `rust-toolchain` is set to `nightly-2022-10-06`, `maturin-version` is set to `0.13.5`, `command` is set to `publish` and `args` is set to `-m py-polars/Cargo.toml --no-sdist --skip-existing -o wheels -i python -u ritchie46`. "}
{"id": "63c496566fc19abdf9c9b6ef", "level": "level5", "llm_response": "```yaml\nname: automerge\n\non:\n  pull_request:\n    types: [labeled]\n\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: enable automerge\n      if: contains(github.event.pull_request.labels.*.name, 'automerge')\n      uses: peter-evans/enable-pull-request-automerge@v2\n      with:\n        token: ${{ secrets.PAT }}\n        pull-request-number: ${{ github.event.pull_request.number }}\n        merge-method: rebase\n```", "answer": "```yaml name: automerge\non:\n  pull_request_target:\n    types:\n      - labeled\njobs:\n  automerge:\n    runs-on: ubuntu-latest\n    steps:\n      - name: enable automerge\n        if: contains( github.event.pull_request.labels.*.name, 'automerge')\n        uses: peter-evans/enable-pull-request-automerge@v2\n        with:\n          token: ${{ secrets.PAT }}\n          pull-request-number: ${{ github.event.pull_request.number }}\n          merge-method: rebase\n```", "prompt": "Generate a GitHub Workflow named `automerge` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: a label is added to a pull request. The workflow has one job. The job id of the 1st job is `automerge`. This job will run on ubuntu-latest runner. The job `automerge` has one step. The 1st step is named `enable automerge`. This step will run only if the condition(contains( github.event.pull_request.labels.*.name, 'automerge')) is met. This step runs action `peter-evans/enable-pull-request-automerge` tagged as v2. The step defines 3 input parameters for the action: `token` is set to `${{ secrets.PAT }}`, `pull-request-number` is set to `${{ github.event.pull_request.number }}` and `merge-method` is set to `rebase`. "}
{"id": "63c4941d8052faa2781a937b", "level": "level5", "llm_response": "```yaml\nname: update-flake-lock\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 0 * * 0'\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Install Nix\n        uses: cachix/install-nix-action@v18\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n      - name: Update flake.lock\n        uses: DeterminateSystems/update-flake-lock@v14\n        with:\n          inputs: nixpkgs\n```", "answer": "```yaml name: update-flake-lock\non:\n  workflow_dispatch: # allows manual triggering\n  schedule:\n    - cron: '0 0 * * 0' # runs weekly on Sunday at 00:00\n\njobs:\n  lockfile:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Install Nix\n        uses: cachix/install-nix-action@v18\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n      - name: Update flake.lock\n        uses: DeterminateSystems/update-flake-lock@v14\n        with:\n          # we update nixos-common-styles manual\n          # and the rest of the inputs are content inputs\n          inputs: nixpkgs\n```", "prompt": "Generate a GitHub Workflow named `update-flake-lock` for a GitHub repository whose primary programming language is Less. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 12:00 am, only on sunday. The workflow has one job. The job id of the 1st job is `lockfile`. This job will run on ubuntu-latest runner. The job `lockfile` has 3 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Install Nix`. This step runs action `cachix/install-nix-action` tagged as v18. The step defines an input parameter for the action: `extra_nix_config` is set to `access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n`. The 3rd step is named `Update flake.lock`. This step runs action `DeterminateSystems/update-flake-lock` tagged as v14. The step defines an input parameter for the action: `inputs` is set to `nixpkgs`. "}
{"id": "63c4965533b087f6bde2b378", "level": "level5", "llm_response": "```yaml\nname: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    id: packagist\n    runs-on: ubuntu-latest\n    steps:\n      - name: Update Packagist\n        env:\n          PACKAGIST_API_KEY: ${{ secrets.PACKAGIST_API_KEY }}\n        run: |\n          curl -X POST \"https://packagist.org/api/update-package?username=svix&apiToken=$PACKAGIST_API_KEY\" \\\n            -H 'content-type: application/json' \\\n            -d '{\"repository\":{\"url\":\"https://packagist.org/packages/svix/svix\"}}'\n```", "answer": "```yaml name: PHP Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  packagist:\n    name: Update Packagist\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Update Packagist\n        run: |\n          curl -X POST \"https://packagist.org/api/update-package?username=svix&apiToken=$PACKAGIST_API_KEY\" \\\n            -H 'content-type: application/json' \\\n            -d '{\"repository\":{\"url\":\"https://packagist.org/packages/svix/svix\"}}'\n        env:\n          PACKAGIST_API_KEY: ${{ secrets.PACKAGIST_API_KEY }}```", "prompt": "Generate a GitHub Workflow named `PHP Release` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Update Packagist` and its job id is `packagist`. This job will run on ubuntu-latest runner. The job `packagist` has one step. The 1st step is named `Update Packagist`. The step sets an environment variable to use: `PACKAGIST_API_KEY` is set to `${{ secrets.PACKAGIST_API_KEY }}`. This step runs a script: `curl -X POST \"https://packagist.org/api/update-package?username=svix&apiToken=$PACKAGIST_API_KEY\" \\\n  -H 'content-type: application/json' \\\n  -d '{\"repository\":{\"url\":\"https://packagist.org/packages/svix/svix\"}}'\n`. "}
{"id": "63c4959c7843b61269a08c30", "level": "level5", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    permissions:\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n        with:\n          persist-credentials: false\n\n      - name: Run analysis\n        uses: ossf/scorecard-action@c8416b0b2bf627c349ca92fc8e3de51a64b005cf\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          publish_results: true\n\n      - name: Upload artifact\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5\n        with:\n          sarif_file: results.sarif\n```", "answer": "```yaml name: Scorecards supply-chain security\n# Run only manually, because the answers don't change often and the results have \n# many unhelpful positives.\n  \non:\n  workflow_dispatch: \n  # Only the default branch is supported.\n  # branch_protection_rule:\n  # schedule:\n  #   - cron: '38 17 * * 6'\n  # push:\n  #  branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c8416b0b2bf627c349ca92fc8e3de51a64b005cf # v1.0.2\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. This job will run on ubuntu-latest runner. The job `analysis` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `security-events` scope, read access is granted to the GITHUB_TOKEN in the `actions` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. This step runs action `actions/checkout` whose commit is ec3a7ce113134d7a93b817d10a8272cb61118579. The step defines an input parameter for the action: `persist-credentials` is set to `False`. The 2nd step is named `Run analysis`. This step runs action `ossf/scorecard-action` whose commit is c8416b0b2bf627c349ca92fc8e3de51a64b005cf. The step defines 4 input parameters for the action: `results_file` is set to `results.sarif`, `results_format` is set to `sarif`, `repo_token` is set to `${{ secrets.SCORECARD_READ_TOKEN }}` and `publish_results` is set to `True`. The 3rd step is named `Upload artifact`. This step runs action `actions/upload-artifact` whose commit is 82c141cc518b40d92cc801eee768e7aafc9c2fa2. The step defines 3 input parameters for the action: `name` is set to `SARIF file`, `path` is set to `results.sarif` and `retention-days` is set to `5`. The 4th step is named `Upload to code-scanning`. This step runs action `github/codeql-action/upload-sarif` whose commit is 5f532563584d71fdef14ee64d17bafb34f751ce5. The step defines an input parameter for the action: `sarif_file` is set to `results.sarif`. "}
{"id": "63c495547843b61269a06e6c", "level": "level5", "llm_response": "```yaml\nname: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 1 * * *'\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\njobs:\n  recreate:\n    runs-on: ubuntu-22.04\n    if: github.repository == 'Homebrew/homebrew-core'\n    strategy:\n      matrix:\n        runner_name: [linux-self-hosted-1]\n    env:\n      RUNNER_LABEL: TODO\n\n    steps:\n    - name: Set up Cloud SDK\n      uses: google-github-actions/setup-gcloud@v0.2.1\n      with:\n        project_id: ${{ secrets.GCP_PROJECT_ID }}\n        service_account_key: ${{ secrets.GCP_SA_KEY }}\n        export_default_credentials: True\n\n    - name: Wait for idle runner\n      id: killable\n      uses: Homebrew/actions/wait-for-idle-runner@master\n      with:\n        runner_name: ${{ matrix.runner_name }}\n        github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n    - name: Kill runner and create a new one\n      if: steps.killable.outputs.runner-found == 'true' && steps.killable.outputs.runner-idle == 'true'\n      uses: Homebrew/actions/create-gcloud-instance@master\n      with:\n        runner_name: ${{ matrix.runner_name }}\n        gcp_project_id: ${{ secrets.GCP_PROJECT_ID }}\n        gcp_service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n        gcp_sa_key: ${{ secrets.GCP_SA_KEY }}\n        github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "answer": "```yaml name: Recreate Linux self-hosted runners on schedule\n\non:\n  workflow_dispatch:\n  schedule:\n    # Once each 24 hours, at 1 during the night\n    - cron: \"0 1 * * *\"\n\nconcurrency:\n  group: recreate-linux-runners\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  recreate:\n    if: github.repository == 'Homebrew/homebrew-core'\n    runs-on: ubuntu-22.04\n    env:\n      # TODO agree on one label for all runners\n      RUNNER_LABEL: TODO\n    strategy:\n      matrix:\n        runner_name:\n          - linux-self-hosted-1\n    steps:\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.2.1\n        with:\n          project_id: ${{ secrets.GCP_PROJECT_ID }}\n          service_account_key: ${{ secrets.GCP_SA_KEY }}\n          export_default_credentials: true\n\n      - name: Wait for idle runner\n        id: killable\n        uses: Homebrew/actions/wait-for-idle-runner@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n      - name: Kill runner and create a new one\n        if: ${{ steps.killable.outputs.runner-found == 'true' && steps.killable.outputs.runner-idle == 'true' }}\n        uses: Homebrew/actions/create-gcloud-instance@master\n        with:\n          runner_name: ${{ matrix.runner_name }}\n          gcp_project_id: ${{ secrets.GCP_PROJECT_ID }}\n          gcp_service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n          gcp_sa_key: ${{ secrets.GCP_SA_KEY }}\n          github_token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Recreate Linux self-hosted runners on schedule` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 01:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the recreate-linux-runners concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `recreate`. This job will run only if the condition(github.repository == 'Homebrew/homebrew-core') is met. This job will run on ubuntu-22.04 runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `runner_name` has one value: linux-self-hosted-1. The job sets an environment variable to use: `RUNNER_LABEL` is set to `TODO`. The job `recreate` has 3 steps. The 1st step is named `Set up Cloud SDK`. This step runs action `google-github-actions/setup-gcloud` tagged as v0.2.1. The step defines 3 input parameters for the action: `project_id` is set to `${{ secrets.GCP_PROJECT_ID }}`, `service_account_key` is set to `${{ secrets.GCP_SA_KEY }}` and `export_default_credentials` is set to `True`. The 2nd step is named `Wait for idle runner` and its id is `killable`. This step runs action `Homebrew/actions/wait-for-idle-runner` from the master branch. The step defines 2 input parameters for the action: `runner_name` is set to `${{ matrix.runner_name }}` and `github_token` is set to `${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}`. The 3rd step is named `Kill runner and create a new one`. This step will run only if the condition(${{ steps.killable.outputs.runner-found == 'true' && steps.killable.outputs.runner-idle == 'true' }}) is met. This step runs action `Homebrew/actions/create-gcloud-instance` from the master branch. The step defines 5 input parameters for the action: `runner_name` is set to `${{ matrix.runner_name }}`, `gcp_project_id` is set to `${{ secrets.GCP_PROJECT_ID }}`, `gcp_service_account` is set to `${{ secrets.GCP_SERVICE_ACCOUNT }}`, `gcp_sa_key` is set to `${{ secrets.GCP_SA_KEY }}` and `github_token` is set to `${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}`. "}
{"id": "63c4942a8052faa2781a9911", "level": "level5", "llm_response": "```yaml\nname: Integration tests\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n      - dev\n\njobs:\n  integration_tests:\n    id: integration_tests\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f\n\n      - name: Set up Go\n        uses: actions/setup-go@37335c7bb261b353407cff977110895fa0b4f7d8\n        with:\n          go-version: '1.18'\n\n      - name: Check Go version\n        run: go version\n\n      - name: Run integration tests\n        env:\n          LINODE_TOKEN: ${{ secrets.DX_LINODE_TOKEN }}\n        run: make testacc\n```", "answer": "```yaml name: Integration tests\non:\n  workflow_dispatch: null\n  push:\n    branches:\n      - main\n      - dev\njobs:\n  integration_tests:\n    name: Run integration tests\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clone Repository\n        uses: actions/checkout@5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f # pin@v2\n      - uses: actions/setup-go@37335c7bb261b353407cff977110895fa0b4f7d8 # pin@v2\n        with:\n          go-version: '1.18'\n      - run: go version\n      - run: make testacc\n        env:\n          LINODE_TOKEN: ${{ secrets.DX_LINODE_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `Integration tests` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main or a branch named dev. The workflow has one job. The 1st job is named `Run integration tests` and its job id is `integration_tests`. This job will run on ubuntu-latest runner. The job `integration_tests` has 4 steps. The 1st step is named `Clone Repository`. This step runs action `actions/checkout` whose commit is 5a4ac9002d0be2fb38bd78e4b4dbde5606d7042f. The 2nd step is named ``. This step runs action `actions/setup-go` whose commit is 37335c7bb261b353407cff977110895fa0b4f7d8. The step defines an input parameter for the action: `go-version` is set to `1.18`. The 3rd step is named ``. This step runs a script: `go version`. The 4th step is named ``. The step sets an environment variable to use: `LINODE_TOKEN` is set to `${{ secrets.DX_LINODE_TOKEN }}`. This step runs a script: `make testacc`. "}
{"id": "63c4942a8052faa2781a9910", "level": "level5", "llm_response": "```yaml\nname: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n    if: github.event.issue.pull_request\n\n    steps:\n      - name: Generate App Installation Token\n        id: generate_token\n        uses: tibdex/github-app-token@v1\n        with:\n          app_id: ${{ secrets.DX_ACCTEST_APP_ID }}\n          private_key: ${{ secrets.DX_ACCTEST_PRIV_KEY }}\n\n      - name: Slash Command Dispatch\n        env:\n          TOKEN: ${{ steps.generate_token.outputs.token }}\n        uses: peter-evans/slash-command-dispatch@v1\n        with:\n          token: ${{ env.TOKEN }}\n          reaction-token: ${{ secrets.GITHUB_TOKEN }}\n          issue-type: pull-request\n          commands: acctest\n          named-args: 'true'\n          permission: write\n```", "answer": "```yaml name: AccTest Command\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  acctest-command:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.issue.pull_request }}\n    steps:\n      - name: Generate App Installation Token\n        id: generate_token\n        uses: tibdex/github-app-token@v1\n        with:\n          app_id: ${{ secrets.DX_ACCTEST_APP_ID }}\n          private_key: ${{ secrets.DX_ACCTEST_PRIV_KEY }}\n\n      - name: Slash Command Dispatch\n        uses: peter-evans/slash-command-dispatch@v1\n        env:\n          TOKEN: ${{ steps.generate_token.outputs.token }}\n        with:\n          token: ${{ env.TOKEN }}\n          reaction-token: ${{ secrets.GITHUB_TOKEN }}\n          issue-type: pull-request\n          commands: acctest\n          named-args: true\n          permission: write\n```", "prompt": "Generate a GitHub Workflow named `AccTest Command` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a comment on an issue or pull request is created. The workflow has one job. The job id of the 1st job is `acctest-command`. This job will run only if the condition(${{ github.event.issue.pull_request }}) is met. This job will run on ubuntu-latest runner. The job `acctest-command` has 2 steps. The 1st step is named `Generate App Installation Token` and its id is `generate_token`. This step runs action `tibdex/github-app-token` tagged as v1. The step defines 2 input parameters for the action: `app_id` is set to `${{ secrets.DX_ACCTEST_APP_ID }}` and `private_key` is set to `${{ secrets.DX_ACCTEST_PRIV_KEY }}`. The 2nd step is named `Slash Command Dispatch`. The step sets an environment variable to use: `TOKEN` is set to `${{ steps.generate_token.outputs.token }}`. This step runs action `peter-evans/slash-command-dispatch` tagged as v1. The step defines 6 input parameters for the action: `token` is set to `${{ env.TOKEN }}`, `reaction-token` is set to `${{ secrets.GITHUB_TOKEN }}`, `issue-type` is set to `pull-request`, `commands` is set to `acctest`, `named-args` is set to `True` and `permission` is set to `write`. "}
{"id": "63c4940f7843b612699feb8d", "level": "level5", "llm_response": "```yaml\nname: Go Coverage\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Run tests with coverage\n        run: make test-cover\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v2\n        with:\n          file: ./coverage.out\n          fail_ci_if_error: true\n```", "answer": "```yaml # add public code coverage reports\non:\n  push:\n    branches:\n    - main\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@master\n    - run: \"make test-cover\"\n    - uses: codecov/codecov-action@v2\n    with:\n      file: ./coverage.out\n      fail_ci_if_error: true\n```", "prompt": "Generate a GitHub Workflow named `` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `coverage`. This job will run on ubuntu-latest runner. The job `coverage` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` from the master branch. The 2nd step is named ``. This step runs a script: `make test-cover`. The 3rd step is named ``. This step runs action `codecov/codecov-action` tagged as v2. The job will pass 2 inputs to the called workflow: the input `file` is `./coverage.out` and the input `fail_ci_if_error` is `True`. "}
{"id": "63c496a06fc19abdf9c9d2e3", "level": "level5", "llm_response": "```yaml\nname: Scorecards supply-chain security\n\non:\n  branch_protection_rule:\n  schedule:\n    - cron: '18 9 * * 4'\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: read\n\njobs:\n  analysis:\n    id: analysis\n    runs-on: ubuntu-latest\n\n    permissions:\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579\n        with:\n          persist-credentials: false\n\n      - name: Run analysis\n        uses: ossf/scorecard-action@c1aec4ac820532bab364f02a81873c555a0ba3a1\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          publish_results: true\n\n      - name: Upload artifact\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      - name: Upload to code-scanning\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5\n        with:\n          sarif_file: results.sarif\n```", "answer": "```yaml # This file is part of ICU4X. For terms of use, please see the file\n# called LICENSE at the top level of the ICU4X source tree\n# (online at: https://github.com/unicode-org/icu4x/blob/main/LICENSE ).\n\nname: Scorecards supply-chain security\non:\n  # Only the default branch is supported.\n  branch_protection_rule:\n  schedule:\n    - cron: '18 9 * * 4'\n  push:\n    branches: [ main ]\n\n# Declare default permissions as read only.\npermissions: read-all\n\njobs:\n  analysis:\n    name: Scorecards analysis\n    runs-on: ubuntu-latest\n    permissions:\n      # Needed to upload the results to code-scanning dashboard.\n      security-events: write\n      actions: read\n      contents: read\n\n    steps:\n      - name: \"Checkout code\"\n        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # v2.4.0\n        with:\n          persist-credentials: false\n\n      - name: \"Run analysis\"\n        uses: ossf/scorecard-action@c1aec4ac820532bab364f02a81873c555a0ba3a1 # v1.0.4\n        with:\n          results_file: results.sarif\n          results_format: sarif\n          # Read-only PAT token. To create it,\n          # follow the steps in https://github.com/ossf/scorecard-action#pat-token-creation.\n          repo_token: ${{ secrets.SCORECARD_READ_TOKEN }}\n          # Publish the results to enable scorecard badges. For more details, see\n          # https://github.com/ossf/scorecard-action#publishing-results.\n          # For private repositories, `publish_results` will automatically be set to `false`,\n          # regardless of the value entered here.\n          publish_results: true\n\n      # Upload the results as artifacts (optional).\n      - name: \"Upload artifact\"\n        uses: actions/upload-artifact@82c141cc518b40d92cc801eee768e7aafc9c2fa2 # v2.3.1\n        with:\n          name: SARIF file\n          path: results.sarif\n          retention-days: 5\n\n      # Upload the results to GitHub's code scanning dashboard.\n      - name: \"Upload to code-scanning\"\n        uses: github/codeql-action/upload-sarif@5f532563584d71fdef14ee64d17bafb34f751ce5 # v1.0.26\n        with:\n          sarif_file: results.sarif\n```", "prompt": "Generate a GitHub Workflow named `Scorecards supply-chain security` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by multiple events: 1) activity related to a branch protection rule occurs. 2) the scheduled time has come: at 09:18 am, only on thursday. 3) The workflow would run whenever there is a push event to: a branch named main. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Scorecards analysis` and its job id is `analysis`. This job will run on ubuntu-latest runner. The job `analysis` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `security-events` scope, read access is granted to the GITHUB_TOKEN in the `actions` scope and read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `analysis`. The job `analysis` has 4 steps. The 1st step is named `Checkout code`. This step runs action `actions/checkout` whose commit is ec3a7ce113134d7a93b817d10a8272cb61118579. The step defines an input parameter for the action: `persist-credentials` is set to `False`. The 2nd step is named `Run analysis`. This step runs action `ossf/scorecard-action` whose commit is c1aec4ac820532bab364f02a81873c555a0ba3a1. The step defines 4 input parameters for the action: `results_file` is set to `results.sarif`, `results_format` is set to `sarif`, `repo_token` is set to `${{ secrets.SCORECARD_READ_TOKEN }}` and `publish_results` is set to `True`. The 3rd step is named `Upload artifact`. This step runs action `actions/upload-artifact` whose commit is 82c141cc518b40d92cc801eee768e7aafc9c2fa2. The step defines 3 input parameters for the action: `name` is set to `SARIF file`, `path` is set to `results.sarif` and `retention-days` is set to `5`. The 4th step is named `Upload to code-scanning`. This step runs action `github/codeql-action/upload-sarif` whose commit is 5f532563584d71fdef14ee64d17bafb34f751ce5. The step defines an input parameter for the action: `sarif_file` is set to `results.sarif`. "}
{"id": "63c495257843b61269a05b79", "level": "level5", "llm_response": "```yaml\nname: Update translation templates\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  update-templates:\n    id: update-templates\n    runs-on: ubuntu-20.04\n    container:\n      image: archlinux\n\n    steps:\n      - name: Install git\n        run: pacman -Syu --noconfirm git\n\n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n\n      - name: Install deps\n        run: |\n          # install general build deps\n          pacman -Syu --noconfirm ninja gcc pkgconf python3 python-pip which\n          # install easyeffects deps\n          source ./PKGBUILD && pacman -Syu --noconfirm --needed --asdeps \"${makedepends[@]}\" \"${depends[@]}\"\n\n      - name: Change git permissions\n        run: git config --global --add safe.directory \"$GITHUB_WORKSPACE\"\n\n      - name: Run meson targets\n        run: |\n          meson build\n          cd build\n          ../util/update_translation_templates.sh\n          cd ..\n\n      - name: Check for non-timestamp diff\n        run: |\n          # see https://stackoverflow.com/a/26622262\n          DIFF_LINES=$(git diff --unified=0 | grep '^[+-]' | grep -Ev '^(--- a/|\\+\\+\\+ b/)')\n\n          if [[ $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\") != \"$DIFF_LINES\" ]]; then\n            echo \"The calculated diff includes modifications besides just timestamp changes (POT-Creation-Date).\"\n            echo \"Letting the PR continue as this is a valid reason to open a PR.\"\n          else\n            echo \"The calculated diff just has timestamp changes (POT-Creation-Date).\"\n            echo \"Restoring original files since this is not a valid reason to open a PR.\"\n            git restore .\n          fi\n\n          echo \"All diff lines count: $(echo \"$DIFF_LINES\" | wc -l)\"\n          echo \"Diff lines count where POT-Creation-Date was changed: $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\" | wc -l)\"\n\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4.1.3\n        with:\n          title: Update translation templates\n          body: Ensure to merge all other Pull Requests before merging this. Conflicts here will automatically be resolved in case of changes in master.\n          commit-message: Update translation templates\n          committer: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          author: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          branch: automatically-update-translation-templates\n          push-to-fork: easyeffects-bot/easyeffects\n          token: ${{ secrets.EASYEFFECTS_BOT }}\n```", "answer": "```yaml on:\n  push:\n    branches: [ master ]\n\nname: Update translation templates\njobs:\n  update-templates:\n    name: Update translation templates\n    runs-on: ubuntu-20.04\n    container:\n      image: archlinux\n    steps:\n      # install git first otherwise checkout will not give us an actual git repo\n      - name: Install git\n        run: pacman -Syu --noconfirm git\n    \n      - name: Checkout\n        uses: actions/checkout@v3.1.0\n\n      - name: Install deps\n        run: |\n          # install general build deps\n          pacman -Syu --noconfirm ninja gcc pkgconf python3 python-pip which\n          # install easyeffects deps\n          source ./PKGBUILD && pacman -Syu --noconfirm --needed --asdeps \"${makedepends[@]}\" \"${depends[@]}\"\n          \n      # workaround upstream permissions issue github.com/peter-evans/create-pull-request/issues/1170\n      - name: Change git permissions\n        run: git config --global --add safe.directory \"$GITHUB_WORKSPACE\"\n\n      - name: Run meson targets\n        run: |\n          meson build\n          cd build\n          ../util/update_translation_templates.sh\n          cd ..\n\n      - name: Check for non-timestamp diff\n        run: |\n          # see https://stackoverflow.com/a/26622262\n          DIFF_LINES=$(git diff --unified=0 | grep '^[+-]' | grep -Ev '^(--- a/|\\+\\+\\+ b/)')\n\n          if [[ $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\") != \"$DIFF_LINES\" ]]; then\n            echo \"The calculated diff includes modifications besides just timestamp changes (POT-Creation-Date).\"\n            echo \"Letting the PR continue as this is a valid reason to open a PR.\"\n          else\n            echo \"The calculated diff just has timestamp changes (POT-Creation-Date).\"\n            echo \"Restoring original files since this is not a valid reason to open a PR.\"\n            git restore .\n          fi\n\n          echo \"All diff lines count: $(echo \"$DIFF_LINES\" | wc -l)\"\n          echo \"Diff lines count where POT-Creation-Date was changed: $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\" | wc -l)\"\n\n      # TODO it would be ideal to refresh metainfo fully by copying release notes from the upcoming release in NEWS.yaml to metainfo, and then running the above update template script,\n      # however this is not possible without putting a dummy release in the metainfo with said upcoming release notes which would later have to be adjusted to the real release.\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4.1.3\n        with:\n          title: Update translation templates\n          body: Ensure to merge all other Pull Requests before merging this. Conflicts here will automatically be resolved in case of changes in master.\n          commit-message: Update translation templates\n          # email sets \"EasyEffects Bot\" user as commit author\n          committer: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          author: EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>\n          branch: automatically-update-translation-templates\n          # the easyeffects_bot secret/token is only valid for a fork\n          # note the machine user (easyeffects-bot) must have already forked the repository  where the action is running for this to work\n          push-to-fork: easyeffects-bot/easyeffects\n          token: ${{ secrets.EASYEFFECTS_BOT }}\n```", "prompt": "Generate a GitHub Workflow named `Update translation templates` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The 1st job is named `Update translation templates` and its job id is `update-templates`. This job will run on ubuntu-20.04 runner. The job creates a Docker container that uses `archlinux` image. The job `update-templates` has 7 steps. The 1st step is named `Install git`. This step runs a script: `pacman -Syu --noconfirm git`. The 2nd step is named `Checkout`. This step runs action `actions/checkout` tagged as v3.1.0. The 3rd step is named `Install deps`. This step runs a script: `# install general build deps\npacman -Syu --noconfirm ninja gcc pkgconf python3 python-pip which\n# install easyeffects deps\nsource ./PKGBUILD && pacman -Syu --noconfirm --needed --asdeps \"${makedepends[@]}\" \"${depends[@]}\"\n`. The 4th step is named `Change git permissions`. This step runs a script: `git config --global --add safe.directory \"$GITHUB_WORKSPACE\"`. The 5th step is named `Run meson targets`. This step runs a script: `meson build\ncd build\n../util/update_translation_templates.sh\ncd ..\n`. The 6th step is named `Check for non-timestamp diff`. This step runs a script: `# see https://stackoverflow.com/a/26622262\nDIFF_LINES=$(git diff --unified=0 | grep '^[+-]' | grep -Ev '^(--- a/|\\+\\+\\+ b/)')\n\nif [[ $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\") != \"$DIFF_LINES\" ]]; then\n  echo \"The calculated diff includes modifications besides just timestamp changes (POT-Creation-Date).\"\n  echo \"Letting the PR continue as this is a valid reason to open a PR.\"\nelse\n  echo \"The calculated diff just has timestamp changes (POT-Creation-Date).\"\n  echo \"Restoring original files since this is not a valid reason to open a PR.\"\n  git restore .\nfi\n\necho \"All diff lines count: $(echo \"$DIFF_LINES\" | wc -l)\"\necho \"Diff lines count where POT-Creation-Date was changed: $(echo \"$DIFF_LINES\" | grep \"POT-Creation-Date:\" | wc -l)\"\n`. The 7th step is named `Create Pull Request`. This step runs action `peter-evans/create-pull-request` tagged as v4.1.3. The step defines 8 input parameters for the action: `title` is set to `Update translation templates`, `body` is set to `Ensure to merge all other Pull Requests before merging this. Conflicts here will automatically be resolved in case of changes in master.`, `commit-message` is set to `Update translation templates`, `committer` is set to `EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>`, `author` is set to `EasyEffects Bot <110548574+easyeffects-bot@users.noreply.github.com>`, `branch` is set to `automatically-update-translation-templates`, `push-to-fork` is set to `easyeffects-bot/easyeffects` and `token` is set to `${{ secrets.EASYEFFECTS_BOT }}`. "}
{"id": "63c4967d1899db58864d33af", "level": "level5", "llm_response": "```yaml\nname: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      name:\n        description: 'Package name'\n        required: true\n        default: 'generateblocks'\n\njobs:\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '14'\n        cache: 'npm'\n\n    - name: NPM install\n      run: npm install\n\n    - name: NPM build\n      run: npm run build\n\n    - name: Grunt action-package\n      run: npm run action-package\n\n    - name: Build zip file\n      uses: actions/upload-artifact@v3.1.0\n      with:\n        name: ${{ github.event.inputs.name }}\n        path: package/\n        retention-days: 1\n```", "answer": "```yaml name: Build package\n\non:\n  workflow_dispatch:\n    inputs:\n      name:\n        description: 'Package name'\n        default: 'generateblocks'\n        required: true\n\njobs:\n\n  build-package:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n          cache: 'npm'\n\n      - name: NPM install\n        run: npm install\n\n      - name: NPM build\n        run: npm run build\n\n      - name: Grunt action-package\n        run: npm run action-package\n\n      - name: Build zip file\n        uses: actions/upload-artifact@v3.1.0\n        with:\n          name: ${{ github.event.inputs.name }}\n          path: |\n            package/\n          retention-days: 1\n```", "prompt": "Generate a GitHub Workflow named `Build package` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives an input: name-this input represents package name, its default value is generateblocks and it must be supplied. The workflow has one job. The job id of the 1st job is `build-package`. This job will run on ubuntu-latest runner. The job `build-package` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines 2 input parameters for the action: `node-version` is set to `14` and `cache` is set to `npm`. The 3rd step is named `NPM install`. This step runs a script: `npm install`. The 4th step is named `NPM build`. This step runs a script: `npm run build`. The 5th step is named `Grunt action-package`. This step runs a script: `npm run action-package`. The 6th step is named `Build zip file`. This step runs action `actions/upload-artifact` tagged as v3.1.0. The step defines 3 input parameters for the action: `name` is set to `${{ github.event.inputs.name }}`, `path` is set to `package/\n` and `retention-days` is set to `1`. "}
{"id": "63c494637843b61269a00d3a", "level": "level5", "llm_response": "```yaml\nname: olm\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\n\nenv:\n  GO_VERSION: 1.19\n  KIND_IMG_TAG: v1.25.0\n\njobs:\n  tests:\n    id: main\n    runs-on: ubuntu-22.04\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Download binaries\n      run: |\n        mkdir -p ${GITHUB_WORKSPACE}/build\n        echo \"${GITHUB_WORKSPACE}/build\" >> ${GITHUB_PATH}\n        make operator-sdk\n        make opm\n\n    - name: Set up Go\n      uses: actions/setup-go@268d8c0ca0432bb2cf416faae41297df9d262d7f\n      with:\n        go-version: ${{ env.GO_VERSION }}\n\n    - name: Install dependencies\n      run: |\n        sudo apt update\n        sudo apt install -y libseccomp-dev libelf-dev libapparmor-dev\n        sudo hack/install-libbpf.sh\n\n    - name: Create and verify bundle\n      run: make verify-bundle\n\n    - name: Create and set up K8s KinD Cluster\n      run: ./hack/kind-with-registry.sh\n\n    - name: Run the tests\n      run: ./hack/ci/e2e-olm.sh\n```", "answer": "```yaml name: olm\non:\n  push:\n    branches:\n      - main\n  pull_request:\nenv:\n  GO_VERSION: '1.19'\n  KIND_IMG_TAG: v1.25.0\npermissions:\n  actions: none\n  checks: none\n  contents: none\n  deployments: none\n  id-token: none\n  issues: none\n  discussions: none\n  packages: none\n  pull-requests: none\n  repository-projects: none\n  security-events: none\n  statuses: none\njobs:\n  main:\n    name: tests\n    runs-on: ubuntu-22.04\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Download binaries\n      run: |\n        mkdir -p ${GITHUB_WORKSPACE}/build\n        echo \"${GITHUB_WORKSPACE}/build\" >> ${GITHUB_PATH}\n        make operator-sdk\n        make opm\n\n    - uses: actions/setup-go@268d8c0ca0432bb2cf416faae41297df9d262d7f\n      with:\n        go-version: ${{ env.GO_VERSION }}\n    - name: Install dependencies\n      run: |\n        sudo apt update\n        sudo apt install -y libseccomp-dev libelf-dev libapparmor-dev\n        sudo hack/install-libbpf.sh\n\n    - name: Create and verify bundle\n      run: |\n        make verify-bundle\n\n    - name: Create and set up K8s KinD Cluster\n      run: |\n        ./hack/kind-with-registry.sh\n\n    - name: Run the tests\n      run: ./hack/ci/e2e-olm.sh\n```", "prompt": "Generate a GitHub Workflow named `olm` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: none access is granted to the GITHUB_TOKEN in the `actions` scope, none access is granted to the GITHUB_TOKEN in the `checks` scope, none access is granted to the GITHUB_TOKEN in the `contents` scope, none access is granted to the GITHUB_TOKEN in the `deployments` scope, none access is granted to the GITHUB_TOKEN in the `id-token` scope, none access is granted to the GITHUB_TOKEN in the `issues` scope, none access is granted to the GITHUB_TOKEN in the `discussions` scope, none access is granted to the GITHUB_TOKEN in the `packages` scope, none access is granted to the GITHUB_TOKEN in the `pull-requests` scope, none access is granted to the GITHUB_TOKEN in the `repository-projects` scope, none access is granted to the GITHUB_TOKEN in the `security-events` scope and none access is granted to the GITHUB_TOKEN in the `statuses` scope. This permission setting applies to all jobs in the workflow. The workflow sets 2 environment variables to use: `GO_VERSION` is set to `1.19` and `KIND_IMG_TAG` is set to `v1.25.0`. The workflow has one job. The 1st job is named `tests` and its job id is `main`. This job will run on ubuntu-22.04 runner. The job `main` has 7 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Download binaries`. This step runs a script: `mkdir -p ${GITHUB_WORKSPACE}/build\necho \"${GITHUB_WORKSPACE}/build\" >> ${GITHUB_PATH}\nmake operator-sdk\nmake opm\n`. The 3rd step is named ``. This step runs action `actions/setup-go` whose commit is 268d8c0ca0432bb2cf416faae41297df9d262d7f. The step defines an input parameter for the action: `go-version` is set to `${{ env.GO_VERSION }}`. The 4th step is named `Install dependencies`. This step runs a script: `sudo apt update\nsudo apt install -y libseccomp-dev libelf-dev libapparmor-dev\nsudo hack/install-libbpf.sh\n`. The 5th step is named `Create and verify bundle`. This step runs a script: `make verify-bundle\n`. The 6th step is named `Create and set up K8s KinD Cluster`. This step runs a script: `./hack/kind-with-registry.sh\n`. The 7th step is named `Run the tests`. This step runs a script: `./hack/ci/e2e-olm.sh`. "}
{"id": "63c494c78052faa2781ad49a", "level": "level5", "llm_response": "```yaml\nname: Pull Request Labeler\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n    - name: Label PR\n      uses: actions/labeler@v4\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml name: \"Pull Request Labeler\"\non:\n  - pull_request_target\n\njobs:\n  triage:\n    permissions:\n      contents: read\n      pull-requests: write\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/labeler@v4\n        with:\n          repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Pull Request Labeler` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `triage`. This job will run on ubuntu-latest runner. The job `triage` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `triage`. The job `triage` has one step. The 1st step is named ``. This step runs action `actions/labeler` tagged as v4. The step defines an input parameter for the action: `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`. "}
{"id": "63c495928052faa2781b2bc0", "level": "level5", "llm_response": "```yaml\nname: Labeler\n\non:\n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n  label:\n    id: label\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n    steps:\n      - name: Generate changelog from release\n        uses: rhysd/changelog-from-release/action@v2\n        with:\n          file: CHANGELOG.md\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n```", "answer": "```yaml # This workflow will triage pull requests and apply a label based on the\n# paths that are modified in the pull request.\n#\n# To use this workflow, you will need to set up a .github/labeler.yml\n# file with configuration.  For more information, see:\n# https://github.com/actions/labeler\n\nname: Labeler\non: [pull_request]\n\njobs:\n  label:\n\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n    - uses: rhysd/changelog-from-release/action@v2\n      with:\n        file: CHANGELOG.md\n        repo-token: \"${{ secrets.GITHUB_TOKEN }}\"\n```", "prompt": "Generate a GitHub Workflow named `Labeler` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `label`. This job will run on ubuntu-latest runner. The job `label` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `label`. The job `label` has one step. The 1st step is named ``. This step runs action `rhysd/changelog-from-release/action` tagged as v2. The step defines 2 input parameters for the action: `file` is set to `CHANGELOG.md` and `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`. "}
{"id": "63c494608052faa2781aabf2", "level": "level5", "llm_response": "```yaml\nname: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    id: configlet\n    uses: exercism/github-actions/.github/workflows/configlet.yml@main\n```", "answer": "```yaml name: Configlet\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\npermissions:\n  contents: read\n\njobs:\n  configlet:\n    uses: exercism/github-actions/.github/workflows/configlet.yml@main\n```", "prompt": "Generate a GitHub Workflow named `Configlet` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) there is activity relating to a pull request. 2) The workflow would run whenever there is a push event to: a branch named main. 3) someone manually triggers the workflow. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `configlet`. This job will call a reusable workflow located at `exercism/github-actions/.github/workflows/configlet.yml@main`. "}
{"id": "63c4949e7843b61269a025e6", "level": "level5", "llm_response": "```yaml\nname: TagBot\n\non:\n  issue_comment:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  TagBot:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    steps:\n    - uses: JuliaRegistries/TagBot@v1\n      with:\n        token: ${{ secrets.GITHUB_TOKEN }}\n        ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "answer": "```yaml name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `TagBot` for a GitHub repository whose primary programming language is Julia. This workflow will be triggered by multiple events: 1) a comment on an issue or pull request is created. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `TagBot`. This job will run only if the condition(github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot') is met. This job will run on ubuntu-latest runner. The job `TagBot` has one step. The 1st step is named ``. This step runs action `JuliaRegistries/TagBot` tagged as v1. The step defines 2 input parameters for the action: `token` is set to `${{ secrets.GITHUB_TOKEN }}` and `ssh` is set to `${{ secrets.DOCUMENTER_KEY }}`. "}
{"id": "63c495d98052faa2781b4aa8", "level": "level5", "llm_response": "```yaml\nname: NMake\n\non:\n  push:\n    branches: [ main ]\n  tag:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  nmake:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        name: [ 'Windows NMake x86', 'Windows NMake x64 compat', 'Windows NMake x64 Symbol Prefix', 'Windows NMake x64 Symbol Prefix Compat', 'Windows NMake x64', 'Windows NMake ARM No Test', 'Windows NMake ARM64 No Test' ]\n        os: [ 'windows-2022' ]\n        makefile: [ 'win32/Makefile.msc', 'win32/Makefile.arm', 'win32/Makefile.a64' ]\n        arch: [ 'x86', 'x86_amd64', 'x86_arm', 'x86_arm64' ]\n        additional-args: [ '', 'ZLIB_COMPAT=yes', 'SYMBOL_PREFIX=zTest_', 'ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_' ]\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Setup development environment\n      uses: ilammy/msvc-dev-cmd@v1.10.0\n      with:\n        arch: ${{ matrix.arch }}\n\n    - name: Compile source code\n      run: nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}\n\n    - name: Run test cases\n      if: contains(matrix.arch, 'arm') == false\n      run: |\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} test\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} testdll\n```", "answer": "```yaml name: NMake\non: [push, pull_request]\njobs:\n  nmake:\n    name: ${{ matrix.name }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - name: Windows NMake x86\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86\n\n          - name: Windows NMake x64 compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes\n\n          - name: Windows NMake x64 Symbol Prefix\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64 Symbol Prefix Compat\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n            additional-args: ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_\n\n          - name: Windows NMake x64\n            os: windows-2022\n            makefile: win32/Makefile.msc\n            arch: x86_amd64\n\n          - name: Windows NMake ARM No Test\n            os: windows-2022\n            makefile: win32/Makefile.arm\n            arch: x86_arm\n\n          - name: Windows NMake ARM64 No Test\n            os: windows-2022\n            makefile: win32/Makefile.a64\n            arch: x86_arm64\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v3\n\n    - name: Setup development environment\n      uses: ilammy/msvc-dev-cmd@v1.10.0\n      with:\n        arch: ${{ matrix.arch }}\n\n    - name: Compile source code\n      shell: cmd\n      run: nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}\n\n    - name: Run test cases\n      shell: cmd\n      # Don't run tests on Windows ARM\n      if: contains(matrix.arch, 'arm') == false\n      run: |\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} test\n        nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} testdll\n```", "prompt": "Generate a GitHub Workflow named `NMake` for a GitHub repository whose primary programming language is C. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow has one job. The 1st job is named `${{ matrix.name }}` and its job id is `nmake`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. For each object in the [{'name': 'Windows NMake x86', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86'}, {'name': 'Windows NMake x64 compat', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86_amd64', 'additional-args': 'ZLIB_COMPAT=yes'}, {'name': 'Windows NMake x64 Symbol Prefix', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86_amd64', 'additional-args': 'SYMBOL_PREFIX=zTest_'}, {'name': 'Windows NMake x64 Symbol Prefix Compat', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86_amd64', 'additional-args': 'ZLIB_COMPAT=yes SYMBOL_PREFIX=zTest_'}, {'name': 'Windows NMake x64', 'os': 'windows-2022', 'makefile': 'win32/Makefile.msc', 'arch': 'x86_amd64'}, {'name': 'Windows NMake ARM No Test', 'os': 'windows-2022', 'makefile': 'win32/Makefile.arm', 'arch': 'x86_arm'}, {'name': 'Windows NMake ARM64 No Test', 'os': 'windows-2022', 'makefile': 'win32/Makefile.a64', 'arch': 'x86_arm64'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job `nmake` has 4 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Setup development environment`. This step runs action `ilammy/msvc-dev-cmd` tagged as v1.10.0. The step defines an input parameter for the action: `arch` is set to `${{ matrix.arch }}`. The 3rd step is named `Compile source code`. This step uses Windows cmd to run a script: `nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }}`. The 4th step is named `Run test cases`. This step will run only if the condition(contains(matrix.arch, 'arm') == false) is met. This step uses Windows cmd to run a script: `nmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} test\nnmake -f ${{ matrix.makefile }} ${{ matrix.additional-args }} testdll\n`. "}
{"id": "63c493b77843b612699fd377", "level": "level5", "llm_response": "```yaml\nname: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - 'public/**'\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install Nix\n        uses: cachix/install-nix-action@v15\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build\n        run: nix build .#website\n\n      - name: Deploy \ud83d\ude80\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./result\n          cname: mdzk.app\n```", "answer": "```yaml name: Publish website\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - \"public/**\"\n\njobs:\n  deploy-website:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout \ud83d\udece\ufe0f\n        uses: actions/checkout@v2.3.1\n\n      - name: Install Nix\n        uses: cachix/install-nix-action@v15\n        with:\n          extra_nix_config: |\n            access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build\n        run: nix build .#website\n\n      - name: Deploy \ud83d\ude80\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./result\n          cname: mdzk.app\n```", "prompt": "Generate a GitHub Workflow named `Publish website` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(public/**), the workflow runs. The workflow has one job. The job id of the 1st job is `deploy-website`. This job will run on ubuntu-latest runner. The job `deploy-website` has 4 steps. The 1st step is named `Checkout \ud83d\udece\ufe0f`. This step runs action `actions/checkout` tagged as v2.3.1. The 2nd step is named `Install Nix`. This step runs action `cachix/install-nix-action` tagged as v15. The step defines an input parameter for the action: `extra_nix_config` is set to `access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}\n`. The 3rd step is named `Build`. This step runs a script: `nix build .#website`. The 4th step is named `Deploy \ud83d\ude80`. This step runs action `peaceiris/actions-gh-pages` tagged as v3. The step defines 3 input parameters for the action: `github_token` is set to `${{ secrets.GITHUB_TOKEN }}`, `publish_dir` is set to `./result` and `cname` is set to `mdzk.app`. "}
{"id": "63c4946f7843b61269a011d1", "level": "level5", "llm_response": "```yaml\nname: I2::Dev::Nightly::Publish\n\non:\n  workflow_dispatch:\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n      - name: Build and push iroha2:dev-nightly image\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          tags: hyperledger/iroha2:dev-nightly-${{ github.sha }}\n          labels: commit=${{ github.sha }}\n          build-args: TAG=dev\n```", "answer": "```yaml name: I2::Dev::Nightly::Publish\n\non: workflow_dispatch\n\njobs:\n  dockerhub:\n    runs-on: ubuntu-latest\n    container:\n      image: 7272721/i2-ci:nightly\n    steps:\n      - uses: actions/checkout@v3\n      - uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n      - name: Build and push iroha2:dev-nightly image\n        uses: docker/build-push-action@v3\n        with:\n          push: true\n          tags: hyperledger/iroha2:dev-nightly-${{ github.sha }}\n          labels: commit=${{ github.sha }}\n          build-args: TAG=dev\n```", "prompt": "Generate a GitHub Workflow named `I2::Dev::Nightly::Publish` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `dockerhub`. This job will run on ubuntu-latest runner. The job creates a Docker container that uses `7272721/i2-ci:nightly` image. The job `dockerhub` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `docker/login-action` tagged as v2. The step defines 2 input parameters for the action: `username` is set to `${{ secrets.DOCKERHUB_USERNAME }}` and `password` is set to `${{ secrets.DOCKERHUB_TOKEN }}`. The 3rd step is named `Build and push iroha2:dev-nightly image`. This step runs action `docker/build-push-action` tagged as v3. The step defines 4 input parameters for the action: `push` is set to `True`, `tags` is set to `hyperledger/iroha2:dev-nightly-${{ github.sha }}`, `labels` is set to `commit=${{ github.sha }}` and `build-args` is set to `TAG=dev`. "}
{"id": "63c4941b7843b612699ff0aa", "level": "level5", "llm_response": "```yaml\nname: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - zap/zap.gradle.kts\n\njobs:\n  release:\n    id: release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n          persist-credentials: false\n\n      - name: Setup Java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'temurin'\n          java-version: '11'\n\n      - name: Build and Release\n        env:\n          INSTALL4J_LICENSE: ${{ secrets.INSTALL4J_LICENSE }}\n          ZAPBOT_TOKEN: ${{ secrets.ZAPBOT_TOKEN }}\n          ZAP_RELEASE: 1\n          ZAP_JAVA_VERSION: 11\n        run: ./gradlew \"-Dorg.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m\" :zap:createMainRelease\n```", "answer": "```yaml name: Release Main Version\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n    paths:\n      - 'zap/zap.gradle.kts'\n\njobs:\n  release:\n    name: Build and Release\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n        persist-credentials: false\n    - name: Setup Java\n      uses: actions/setup-java@v3\n      with:\n        distribution: 'temurin'\n        java-version: 11\n    - name: Build and Release\n      env:\n        INSTALL4J_LICENSE: ${{ secrets.INSTALL4J_LICENSE }}\n        ZAPBOT_TOKEN: ${{ secrets.ZAPBOT_TOKEN }}\n        ZAP_RELEASE: 1\n        ZAP_JAVA_VERSION: 11\n      run: ./gradlew \"-Dorg.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m\" :zap:createMainRelease\n```", "prompt": "Generate a GitHub Workflow named `Release Main Version` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(zap/zap.gradle.kts), the workflow runs. The workflow has one job. The 1st job is named `Build and Release` and its job id is `release`. This job will run on ubuntu-latest runner. The job `release` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `fetch-depth` is set to `0` and `persist-credentials` is set to `False`. The 2nd step is named `Setup Java`. This step runs action `actions/setup-java` tagged as v3. The step defines 2 input parameters for the action: `distribution` is set to `temurin` and `java-version` is set to `11`. The 3rd step is named `Build and Release`. The step sets 4 environment variables to use: `INSTALL4J_LICENSE` is set to `${{ secrets.INSTALL4J_LICENSE }}`, `ZAPBOT_TOKEN` is set to `${{ secrets.ZAPBOT_TOKEN }}`, `ZAP_RELEASE` is set to `1` and `ZAP_JAVA_VERSION` is set to `11`. This step runs a script: `./gradlew \"-Dorg.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m\" :zap:createMainRelease`. "}
{"id": "63c494a97843b61269a02a52", "level": "level5", "llm_response": "```yaml\nname: pytorch1_8_1-cuda11_1\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    id: build\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu111\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.8.1-cu111\n      develop_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "answer": "```yaml name: pytorch1_8_1-cuda11_1\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '0 17 * * *' # 1:00 am UTC+8:00\n  workflow_dispatch:\n\njobs:\n  build:\n    uses: ./.github/workflows/resuable_gpu_build.yml\n    with:\n      cuda_version: cu111\n      remote_runtime_docker: bladedisc:latest-runtime-torch1.8.1-cu111\n      develop_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      runtime_base_image: nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04\n      extra_envs: -e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON\n          -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111\n      exec_command: bash ./scripts/ci/test_pytorch_blade.sh\n      deploy_command: TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh\n    secrets:\n      ALIYUN_DOCKER_USERNAME: ${{ secrets.ALIYUN_DOCKER_USERNAME }}\n      ALIYUN_DOCKER_PASSWORD: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}\n      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n```", "prompt": "Generate a GitHub Workflow named `pytorch1_8_1-cuda11_1` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 05:00 pm. 4) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will call a reusable workflow located at `./.github/workflows/resuable_gpu_build.yml`. The job will pass 7 inputs to the called workflow: the input `cuda_version` is `cu111`, the input `remote_runtime_docker` is `bladedisc:latest-runtime-torch1.8.1-cu111`, the input `develop_base_image` is `nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04`, the input `runtime_base_image` is `nvidia/cuda:11.1.1-cudnn8-devel-ubuntu18.04`, the input `extra_envs` is `-e TORCH_BLADE_BUILD_TENSORRT_STATIC=ON -e TORCH_BLADE_CI_BUILD_TORCH_VERSION=1.8.1+cu111`, the input `exec_command` is `bash ./scripts/ci/test_pytorch_blade.sh` and the input `deploy_command` is `TORCH_VERSION=1.8.1+cu111 bash ./scripts/ci/deploy_pytorch_blade.sh`. The job will pass 4 secrets to the called workflow: the secret `ALIYUN_DOCKER_USERNAME` is `${{ secrets.ALIYUN_DOCKER_USERNAME }}`, the secret `ALIYUN_DOCKER_PASSWORD` is `${{ secrets.ALIYUN_DOCKER_PASSWORD }}`, the secret `DOCKER_USERNAME` is `${{ secrets.DOCKER_USERNAME }}` and the secret `DOCKER_PASSWORD` is `${{ secrets.DOCKER_PASSWORD }}`. "}
{"id": "63c493ff8052faa2781a8681", "level": "level5", "llm_response": "```yaml\nname: Check License Lines\n\non:\n  push:\n    branches: [ '*' ]\n\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Check License Lines\n      uses: kt3k/license_checker@v1.0.6\n```", "answer": "```yaml name: Check License Lines\non:\n  push:\n    branches: '**'\n#  pull_request:\n#    branches:\n#      - main\njobs:\n  check-license-lines:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Check License Lines\n        uses: kt3k/license_checker@v1.0.6```", "prompt": "Generate a GitHub Workflow named `Check License Lines` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch whose name matches * or a branch whose name matches *. The workflow has one job. The job id of the 1st job is `check-license-lines`. This job will run on ubuntu-latest runner. The job `check-license-lines` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Check License Lines`. This step runs action `kt3k/license_checker` tagged as v1.0.6. "}
{"id": "63c494888052faa2781abb68", "level": "level5", "llm_response": "```yaml\nname: MERGE_MASTER_TO_DEVELOP\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n      - name: Checkout develop\n        uses: actions/checkout@v3\n        with:\n          ref: develop\n          fetch-depth: 0\n\n      - name: Merge master to develop and push\n        run: |\n          git config user.name '${{ secrets.BPMN_IO_USERNAME }}'\n          git config user.email '${{ secrets.BPMN_IO_EMAIL }}'\n          git merge -m 'Merge master to develop' --no-edit origin/master\n          git push\n\n      - name: Notify failure on Slack\n        if: failure()\n        env:\n          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}\n        uses: slackapi/slack-github-action@v1.15.0\n        with:\n          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}\n          slack-message: 'Automatic merge of <https://github.com/${{ github.repository }}/tree/${{ github.ref }}|${{ github.ref }}> to <https://github.com/${{ github.repository }}/tree/develop|${{ github.repository }}#develop> failed.'\n```", "answer": "```yaml name: MERGE_MASTER_TO_DEVELOP\non:\n  push:\n    branches:\n    - \"master\"\n\njobs:\n  Merge_master_to_develop:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n    steps:\n    - name: Checkout develop\n      uses: actions/checkout@v3\n      with:\n        ref: develop\n        fetch-depth: 0\n    - name: Merge master to develop and push\n      run: |\n        git config user.name '${{ secrets.BPMN_IO_USERNAME }}'\n        git config user.email '${{ secrets.BPMN_IO_EMAIL }}'\n        git merge -m 'Merge master to develop' --no-edit origin/master\n        git push\n\n    - name: Notify failure on Slack\n      if: failure()\n      uses: slackapi/slack-github-action@v1.15.0\n      with:\n        channel-id: ${{ secrets.SLACK_CHANNEL_ID }}\n        slack-message: \"Automatic merge of <https://github.com/${{ github.repository }}/tree/${{ github.ref }}|${{ github.ref }}> to <https://github.com/${{ github.repository }}/tree/develop|${{ github.repository }}#develop> failed.\"\n      env:\n        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `MERGE_MASTER_TO_DEVELOP` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `Merge_master_to_develop`. This job will run on ubuntu-latest runner. The job `Merge_master_to_develop` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting only applies to the job `Merge_master_to_develop`. The job `Merge_master_to_develop` has 3 steps. The 1st step is named `Checkout develop`. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `ref` is set to `develop` and `fetch-depth` is set to `0`. The 2nd step is named `Merge master to develop and push`. This step runs a script: `git config user.name '${{ secrets.BPMN_IO_USERNAME }}'\ngit config user.email '${{ secrets.BPMN_IO_EMAIL }}'\ngit merge -m 'Merge master to develop' --no-edit origin/master\ngit push\n`. The 3rd step is named `Notify failure on Slack`. This step will run only if the condition(failure()) is met. The step sets an environment variable to use: `SLACK_BOT_TOKEN` is set to `${{ secrets.SLACK_BOT_TOKEN }}`. This step runs action `slackapi/slack-github-action` tagged as v1.15.0. The step defines 2 input parameters for the action: `channel-id` is set to `${{ secrets.SLACK_CHANNEL_ID }}` and `slack-message` is set to `Automatic merge of <https://github.com/${{ github.repository }}/tree/${{ github.ref }}|${{ github.ref }}> to <https://github.com/${{ github.repository }}/tree/develop|${{ github.repository }}#develop> failed.`. "}
{"id": "63c494298052faa2781a987a", "level": "level5", "llm_response": "```yaml\nname: Hypothesis Tests\n\non:\n  workflow_dispatch:\n  schedule:\n    - cron: '0 6 * * *'\n\npermissions:\n  issues: write\n\nenv:\n  python_version: 3.10\n\njobs:\n  hypothesis:\n    runs-on: ubuntu-22.04\n    timeout-minutes: 90\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3.1.0\n      with:\n        ref: ${{ github.event.pull_request.head.sha }}\n\n    - name: Install Linux Dependencies\n      run: ./.github/actions/linux_dependencies\n\n    - name: Set up Python\n      uses: actions/setup-python@v4.3.0\n      with:\n        python-version: ${{ env.python_version }}\n\n    - name: Use Python Dependency Cache\n      uses: actions/cache@v3.0.11\n      with:\n        path: ~/.cache/pip\n        key: ${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}-20.04\n\n    - name: Use Hypothesis Cache\n      uses: pat-s/always-upload-cache@v3.0.1\n      with:\n        path: .hypothesis\n        key: ${{ runner.os }}-hypothesis\n\n    - name: Install Dependencies and Test\n      run: ./.github/actions/setup_and_test\n\n    - name: Test with Hypothesis\n      run: xvfb-run poetry run pytest -m hypothesis --hypothesis-profile=ci\n\n    - name: Create Issue on Failure\n      if: failure()\n      uses: nashmaniac/create-issue-action@v1.1\n      with:\n        title: Hypothesis tests failed\n        token: ${{secrets.GITHUB_TOKEN}}\n        labels: bug,hypothesis\n        body: Test run failed for commit ${{github.sha}}.\n        See https://github.com/gaphor/gaphor/actions/workflows/hypothesis-test.yml.\n```", "answer": "```yaml name: Hypothesis Tests\non:\n  workflow_dispatch:\n  schedule:\n    # min hour dom month dow\n    - cron:  '0 6 * * *'\nenv:\n  python_version: '3.10'\n\npermissions:\n  issues: write\n\njobs:\n\n  hypothesis:\n    runs-on: ubuntu-22.04\n    timeout-minutes: 90\n    steps:\n      - uses: actions/checkout@v3.1.0\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n      - name: Install Linux Dependencies\n        uses: ./.github/actions/linux_dependencies\n      - name: Set up Python\n        uses: actions/setup-python@v4.3.0\n        with:\n          python-version: ${{ env.python_version }}\n      - name: Use Python Dependency Cache\n        uses: actions/cache@v3.0.11\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}-20.04\n      - name: Use Hypothesis Cache\n        uses: pat-s/always-upload-cache@v3.0.1\n        with:\n          path: .hypothesis\n          key: ${{ runner.os }}-hypothesis\n      - name: Install Dependencies and Test\n        uses: ./.github/actions/setup_and_test\n      - name: Test with Hypothesis\n        run: xvfb-run poetry run pytest -m hypothesis --hypothesis-profile=ci\n        shell: bash\n      - uses: nashmaniac/create-issue-action@v1.1\n        if: failure()\n        name: Create Issue on Failure\n        with:\n          title: Hypothesis tests failed\n          token: ${{secrets.GITHUB_TOKEN}}\n          labels: bug,hypothesis\n          body: |\n            Test run failed for commit ${{github.sha}}.\n            See https://github.com/gaphor/gaphor/actions/workflows/hypothesis-test.yml.\n```", "prompt": "Generate a GitHub Workflow named `Hypothesis Tests` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) the scheduled time has come: at 06:00 am. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope. This permission setting applies to all jobs in the workflow. The workflow sets an environment variable to use: `python_version` is set to `3.10`. The workflow has one job. The job id of the 1st job is `hypothesis`. This job will run on ubuntu-22.04 runner. The maximum number of minutes to run the job is 90. The job `hypothesis` has 8 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3.1.0. The step defines an input parameter for the action: `ref` is set to `${{ github.event.pull_request.head.sha }}`. The 2nd step is named `Install Linux Dependencies`. This step runs action `./.github/actions/linux_dependencies`.The 3rd step is named `Set up Python`. This step runs action `actions/setup-python` tagged as v4.3.0. The step defines an input parameter for the action: `python-version` is set to `${{ env.python_version }}`. The 4th step is named `Use Python Dependency Cache`. This step runs action `actions/cache` tagged as v3.0.11. The step defines 2 input parameters for the action: `path` is set to `~/.cache/pip` and `key` is set to `${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}-20.04`. The 5th step is named `Use Hypothesis Cache`. This step runs action `pat-s/always-upload-cache` tagged as v3.0.1. The step defines 2 input parameters for the action: `path` is set to `.hypothesis` and `key` is set to `${{ runner.os }}-hypothesis`. The 6th step is named `Install Dependencies and Test`. This step runs action `./.github/actions/setup_and_test`.The 7th step is named `Test with Hypothesis`. This step uses bash to run a script: `xvfb-run poetry run pytest -m hypothesis --hypothesis-profile=ci`. The 8th step is named `Create Issue on Failure`. This step will run only if the condition(failure()) is met. This step runs action `nashmaniac/create-issue-action` tagged as v1.1. The step defines 4 input parameters for the action: `title` is set to `Hypothesis tests failed`, `token` is set to `${{secrets.GITHUB_TOKEN}}`, `labels` is set to `bug,hypothesis` and `body` is set to `Test run failed for commit ${{github.sha}}.\nSee https://github.com/gaphor/gaphor/actions/workflows/hypothesis-test.yml.\n`. "}
{"id": "63c495038052faa2781aede8", "level": "level5", "llm_response": "```yaml\nname: Python package\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  windows:\n    id: windows\n    runs-on: windows-latest\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10]\n      fail-fast: true\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Allow unsecure commands\n        run: |\n          echo \"::set-env name=ACTIONS_ALLOW_UNSECURE_COMMANDS::true\"\n\n      - name: Set up Miniconda\n        uses: conda-incubator/setup-miniconda@v2\n        with:\n          auto-update-conda: true\n          python-version: ${{ matrix.python-version }}\n          channels: conda-forge\n\n      - name: Create Conda environment with the right deps\n        run: bash -l -c 'conda create -n zarr-env python==${{matrix.python-version}} numcodecs pip nodejs'\n\n      - name: Install dependencies\n        run: bash -l -c 'conda activate zarr-env\n        python -m pip install --upgrade pip\n        python -m pip install -U pip setuptools wheel\n        python -m pip install -r requirements_dev_numpy.txt -r requirements_dev_minimal.txt -r requirements_dev_optional.txt\n        python -m pip install .\n        python -m pip freeze\n        npm install -g azurite'\n\n      - name: Run Tests\n        env:\n          ZARR_TEST_ABS: 1\n          ZARR_V3_EXPERIMENTAL_API: 1\n        run: bash -l -c 'conda activate zarr-env\n        mkdir ~/blob_emulator\n        azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n        pytest -sv --timeout=300'\n\n      - name: Conda info\n        run: bash -l -c 'conda info'\n\n      - name: Conda list\n        run: |\n          conda list\n```", "answer": "```yaml # This workflow will install Python dependencies, run tests and lint with a variety of Python versions\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\nname: Python package\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  windows:\n    name: Windows Tests\n    runs-on: \"windows-latest\"\n    strategy:\n      fail-fast: True\n      matrix:\n        python-version: ['3.8', '3.9', '3.10']\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: conda-incubator/setup-miniconda@v2\n        with:\n          auto-update-conda: true\n          python-version: ${{ matrix.python-version }}\n          channels: conda-forge\n        env:\n          ACTIONS_ALLOW_UNSECURE_COMMANDS: true\n      - name: Create Conda environment with the rights deps\n        shell: bash -l {0}\n        run: |\n          conda create -n zarr-env python==${{matrix.python-version}} numcodecs pip nodejs\n      - name: Install dependencies\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          python -m pip install --upgrade pip\n          python -m pip install -U pip setuptools wheel\n          python -m pip install -r requirements_dev_numpy.txt -r requirements_dev_minimal.txt -r requirements_dev_optional.txt\n          python -m pip install .\n          python -m pip freeze\n          npm install -g azurite\n      - name: Run Tests\n        shell: bash -l {0}\n        run: |\n          conda activate zarr-env\n          mkdir ~/blob_emulator\n          azurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\n          pytest -sv --timeout=300\n        env:\n          ZARR_TEST_ABS: 1\n          ZARR_V3_EXPERIMENTAL_API: 1\n      - name: Conda info\n        shell: bash -l {0}\n        run: conda info\n      - name: Conda list\n        shell: pwsh\n        run: conda list\n```", "prompt": "Generate a GitHub Workflow named `Python package` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The 1st job is named `Windows Tests` and its job id is `windows`. This job will run on windows-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `python-version` has 3 values: 3.8, 3.9 and 3.10. If any job run in the matrix fails, all in-progress and queued jobs in the matrix will be canceled. The job `windows` has 7 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named ``. The step sets an environment variable to use: `ACTIONS_ALLOW_UNSECURE_COMMANDS` is set to `True`. This step runs action `conda-incubator/setup-miniconda` tagged as v2. The step defines 3 input parameters for the action: `auto-update-conda` is set to `True`, `python-version` is set to `${{ matrix.python-version }}` and `channels` is set to `conda-forge`. The 3rd step is named `Create Conda environment with the rights deps`. This step uses a custom shell bash -l {0} to run a script: `conda create -n zarr-env python==${{matrix.python-version}} numcodecs pip nodejs\n`. The 4th step is named `Install dependencies`. This step uses a custom shell bash -l {0} to run a script: `conda activate zarr-env\npython -m pip install --upgrade pip\npython -m pip install -U pip setuptools wheel\npython -m pip install -r requirements_dev_numpy.txt -r requirements_dev_minimal.txt -r requirements_dev_optional.txt\npython -m pip install .\npython -m pip freeze\nnpm install -g azurite\n`. The 5th step is named `Run Tests`. The step sets 2 environment variables to use: `ZARR_TEST_ABS` is set to `1` and `ZARR_V3_EXPERIMENTAL_API` is set to `1`. This step uses a custom shell bash -l {0} to run a script: `conda activate zarr-env\nmkdir ~/blob_emulator\nazurite -l ~/blob_emulator --debug debug.log 2>&1 > stdouterr.log &\npytest -sv --timeout=300\n`. The 6th step is named `Conda info`. This step uses a custom shell bash -l {0} to run a script: `conda info`. The 7th step is named `Conda list`. This step uses PowerShell Core to run a script: `conda list`. "}
{"id": "63c494347843b612699ffaac", "level": "level5", "llm_response": "```yaml\nname: Monitor CI Scaler\n\non:\n  schedule:\n    - cron: '0 5 * * *'\n    - cron: '0 17 * * *'\n\njobs:\n  MonitorCI:\n    id: MonitorCI\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: checkout\n        uses: actions/checkout@v1\n        with:\n          submodules: recursive\n\n      - name: setup environment\n        run: bash ./scripts/dev_setup.sh  -b -t -y\n\n      - name: check scaler\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        run: python3 ./scripts/monitor_autoscaler_recreate.py\n```", "answer": "```yaml name: Monitor CI Scaler\n\non:\n  # workflow_dispatch:\n  schedule:\n    - cron: '0 5,17 * * *'\n\njobs:\n  MonitorCI:\n    name: monitor ci scaler\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout\n        uses: actions/checkout@v1\n        with:\n          submodules: recursive\n      - name: setup environment\n        run: bash ./scripts/dev_setup.sh  -b -t -y\n      - name: check scaler\n        run: python3 ./scripts/monitor_autoscaler_recreate.py\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n```", "prompt": "Generate a GitHub Workflow named `Monitor CI Scaler` for a GitHub repository whose primary programming language is Rust. This workflow will be triggered by an event: the scheduled time has come: at 05:00 am and 05:00 pm. The workflow has one job. The 1st job is named `monitor ci scaler` and its job id is `MonitorCI`. This job will run on ubuntu-latest runner. The job `MonitorCI` has 3 steps. The 1st step is named `checkout`. This step runs action `actions/checkout` tagged as v1. The step defines an input parameter for the action: `submodules` is set to `recursive`. The 2nd step is named `setup environment`. This step runs a script: `bash ./scripts/dev_setup.sh  -b -t -y`. The 3rd step is named `check scaler`. The step sets 2 environment variables to use: `AWS_ACCESS_KEY_ID` is set to `${{ secrets.AWS_ACCESS_KEY_ID }}` and `AWS_SECRET_ACCESS_KEY` is set to `${{ secrets.AWS_SECRET_ACCESS_KEY }}`. This step runs a script: `python3 ./scripts/monitor_autoscaler_recreate.py`. "}
{"id": "63c494cf8052faa2781ad80f", "level": "level5", "llm_response": "```yaml\nname: Release Documentation\n\non:\n  release:\n    types: [published, prereleased, drafted]\n\nenv:\n  GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  java-build:\n    id: java-build\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        java: [8]\n        os: [ubuntu-22.04]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Cache Gradle dependencies\n      uses: actions/cache@v3\n      with:\n        path: ~/.gradle/caches\n        key: ${{ runner.os }}-gradle-caches-${{ hashFiles('**/*.gradle') }}\n        restore-keys: |\n          ${{ runner.os }}-gradle-caches-\n\n    - name: Cache Gradle wrappers\n      uses: actions/cache@v3\n      with:\n        path: ~/.gradle/wrapper\n        key: ${{ runner.os }}-gradle-wrapper\n\n    - name: Setup java\n      uses: actions/setup-java@v3\n      with:\n        distribution: zulu\n        java-version: ${{ matrix.java }}\n\n    - name: Build with Gradle\n      run: ./gradlew tutorialPublish -Paeron.ci.apiKey=${{ secrets.WIKI_PAGE_TOKEN }} --stacktrace\n```", "answer": "```yaml name: Release Documentation\non:\n  release:\n    types: [published]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\nenv:\n  GRADLE_OPTS: '-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail'\n\njobs:\n  java-build:\n    name: Publish Release Documentation\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        java: [ '8' ]\n        os: ['ubuntu-22.04' ]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Cache Gradle dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/caches\n          key: ${{ runner.os }}-gradle-caches-${{ hashFiles('**/*.gradle') }}\n          restore-keys: |\n            ${{ runner.os }}-gradle-caches-\n      - name: Cache Gradle wrappers\n        uses: actions/cache@v3\n        with:\n          path: ~/.gradle/wrapper\n          key: ${{ runner.os }}-gradle-wrapper\n      - name: Setup java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: ${{ matrix.java }}\n      - name: Build with Gradle\n        run: ./gradlew tutorialPublish -Paeron.ci.apiKey=${{ secrets.WIKI_PAGE_TOKEN }} --stacktrace\n```", "prompt": "Generate a GitHub Workflow named `Release Documentation` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: a release, pre-release, or draft of a release is published. The workflow sets an environment variable to use: `GRADLE_OPTS` is set to `-Dorg.gradle.daemon=false -Dorg.gradle.java.installations.auto-detect=false -Dorg.gradle.warning.mode=fail`. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The 1st job is named `Publish Release Documentation` and its job id is `java-build`. This job will run on ${{ matrix.os }} runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `java` has one value: 8. The variable `os` has one value: ubuntu-22.04. The job `java-build` has 5 steps. The 1st step is named `Checkout code`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Cache Gradle dependencies`. This step runs action `actions/cache` tagged as v3. The step defines 3 input parameters for the action: `path` is set to `~/.gradle/caches`, `key` is set to `${{ runner.os }}-gradle-caches-${{ hashFiles('**/*.gradle') }}` and `restore-keys` is set to `${{ runner.os }}-gradle-caches-\n`. The 3rd step is named `Cache Gradle wrappers`. This step runs action `actions/cache` tagged as v3. The step defines 2 input parameters for the action: `path` is set to `~/.gradle/wrapper` and `key` is set to `${{ runner.os }}-gradle-wrapper`. The 4th step is named `Setup java`. This step runs action `actions/setup-java` tagged as v3. The step defines 2 input parameters for the action: `distribution` is set to `zulu` and `java-version` is set to `${{ matrix.java }}`. The 5th step is named `Build with Gradle`. This step runs a script: `./gradlew tutorialPublish -Paeron.ci.apiKey=${{ secrets.WIKI_PAGE_TOKEN }} --stacktrace`. "}
{"id": "63c4967d6fc19abdf9c9c492", "level": "level5", "llm_response": "```yaml\nname: gradio-ui\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\nenv:\n  CI: \"True\"\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: \"1\"\n  NODE_OPTIONS: \"--max-old-space-size=4096\"\n\nconcurrency:\n  group: \"deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}\"\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    id: static-checks\n    runs-on: ubuntu-22.04\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up pnpm\n        uses: pnpm/action-setup@v2.2.1\n        with:\n          version: \"7\"\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"16\"\n          cache: \"pnpm\"\n          cache-dependency-path: \"ui/pnpm-lock.yaml\"\n      - name: Install dependencies\n        run: pnpm i --frozen-lockfile\n      - name: Formatting check\n        run: pnpm format:check\n      - name: Typecheck\n        run: pnpm ts:check\n      - name: Unit tests\n        run: pnpm test:run\n\n  functional-test:\n    id: functional-test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up pnpm\n        uses: pnpm/action-setup@v2.2.1\n        with:\n          version: \"7\"\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"16\"\n          cache: \"pnpm\"\n          cache-dependency-path: \"ui/pnpm-lock.yaml\"\n      - name: Install Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: \"3.x\"\n      - name: Install Gradio\n        run: cd .. && bash scripts/install_gradio.sh\n      - name: Install demo requirements\n        run: pip install -r ../demo/outbreak_forecast/requirements.txt\n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n      - name: Install Playwright\n        run: pnpm exec playwright install chromium\n      - name: Run functional tests\n        run: pnpm test:browser:full\n      - name: Upload failed tests screenshots\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          retention-days: 3\n          name: test-failure-${{ github.run_id }}\n          path: ui/packages/app/test-results\n```", "answer": "```yaml name: gradio-ui\n\non:\n  push:\n    branches:\n      - \"main\"\n  pull_request:\n\ndefaults:\n  run:\n    working-directory: ui\n\nenv:\n  CI: true\n  PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: \"1\"\n  NODE_OPTIONS: \"--max-old-space-size=4096\"\n\nconcurrency:\n  group: deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }}\n  cancel-in-progress: true\n\njobs:\n  quick-checks:\n    name: static checks\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: install dependencies\n        run: pnpm i --frozen-lockfile\n      - name: formatting check\n        run: pnpm format:check\n      - name: typecheck\n        run: pnpm ts:check\n      - name: unit tests\n        run: pnpm test:run\n  functional-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2.2.1\n        with:\n          version: 7\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n          cache: pnpm\n          cache-dependency-path: ui/pnpm-lock.yaml\n      - name: Install Python\n        uses: actions/setup-python@v3\n        with:\n          python-version: '3.x'\n      - run: cd .. && bash scripts/install_gradio.sh\n      - run: pip install -r ../demo/outbreak_forecast/requirements.txt\n      - run: pnpm install --frozen-lockfile\n      - run: pnpm exec playwright install chromium\n      - run: pnpm test:browser:full\n      - name: Upload failed tests screenshots\n        if: failure()\n        uses: actions/upload-artifact@v3\n        with:\n          retention-days: 3\n          name: test-failure-${{ github.run_id }}\n          path: ui/packages/app/test-results\n```", "prompt": "Generate a GitHub Workflow named `gradio-ui` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) there is activity relating to a pull request. The workflow sets 3 environment variables to use: `CI` is set to `True`, `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` is set to `1` and `NODE_OPTIONS` is set to `--max-old-space-size=4096`. For all run steps in the workflow, default working directory is set to ui. Only a single workflow using the deploy-${{ github.ref }}-${{ github.event_name == 'push' || github.event.inputs.fire != null }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 2 jobs. The 1st job is named `static checks` and its job id is `quick-checks`. This job will run on ubuntu-22.04 runner. The job `quick-checks` has 7 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `pnpm/action-setup` tagged as v2.2.1. The step defines an input parameter for the action: `version` is set to `7`. The 3rd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines 3 input parameters for the action: `node-version` is set to `16`, `cache` is set to `pnpm` and `cache-dependency-path` is set to `ui/pnpm-lock.yaml`. The 4th step is named `install dependencies`. This step runs a script: `pnpm i --frozen-lockfile`. The 5th step is named `formatting check`. This step runs a script: `pnpm format:check`. The 6th step is named `typecheck`. This step runs a script: `pnpm ts:check`. The 7th step is named `unit tests`. This step runs a script: `pnpm test:run`. The job id of the 2nd job is `functional-test`. This job will run on ubuntu-latest runner. The job `functional-test` has 10 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `pnpm/action-setup` tagged as v2.2.1. The step defines an input parameter for the action: `version` is set to `7`. The 3rd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines 3 input parameters for the action: `node-version` is set to `16`, `cache` is set to `pnpm` and `cache-dependency-path` is set to `ui/pnpm-lock.yaml`. The 4th step is named `Install Python`. This step runs action `actions/setup-python` tagged as v3. The step defines an input parameter for the action: `python-version` is set to `3.x`. The 5th step is named ``. This step runs a script: `cd .. && bash scripts/install_gradio.sh`. The 6th step is named ``. This step runs a script: `pip install -r ../demo/outbreak_forecast/requirements.txt`. The 7th step is named ``. This step runs a script: `pnpm install --frozen-lockfile`. The 8th step is named ``. This step runs a script: `pnpm exec playwright install chromium`. The 9th step is named ``. This step runs a script: `pnpm test:browser:full`. The 10th step is named `Upload failed tests screenshots`. This step will run only if the condition(failure()) is met. This step runs action `actions/upload-artifact` tagged as v3. The step defines 3 input parameters for the action: `retention-days` is set to `3`, `name` is set to `test-failure-${{ github.run_id }}` and `path` is set to `ui/packages/app/test-results`. "}
{"id": "63c496851899db58864d368d", "level": "level5", "llm_response": "```yaml\nname: Bump repositories\n\non:\n  schedule:\n    - cron: '0 20 * * *'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Bump cos \ud83d\udd27\n        run: |\n          docker run --name=yq -v \"${PWD}\":/workdir mikefarah/yq\n          docker cp yq:/usr/bin/yq ./\n          export YQ=$PWD/yq\n          sudo -E bash ./.github/bump_repositories.sh\n          rm -rf yq\n      - name: Create Pull Request\n        uses: peter-evans/create-pull-request@v4\n        with:\n          token: ${{ secrets.PAT_TOKEN }}\n          push-to-fork: ci-robbot/c3os\n          commit-message: ':arrow_up: Update repositories'\n          title: 'Repositories bump'\n          body: 'Bump of luet repositories'\n```", "answer": "```yaml name: Bump repositories\non: \n schedule:\n   - cron: 0 20 * * *\n workflow_dispatch:\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Bump cos \ud83d\udd27\n      run: |\n           docker run --name=yq -v \"${PWD}\":/workdir mikefarah/yq\n           docker cp yq:/usr/bin/yq ./\n           export YQ=$PWD/yq\n           sudo -E bash ./.github/bump_repositories.sh\n           rm -rf yq\n    - name: Create Pull Request\n      uses: peter-evans/create-pull-request@v4\n      with:\n        token: ${{ secrets.PAT_TOKEN }}\n        push-to-fork: ci-robbot/c3os\n        commit-message: \":arrow_up: Update repositories\"\n        title: \"Repositories bump\"\n        body: \"Bump of luet repositories\"\n```", "prompt": "Generate a GitHub Workflow named `Bump repositories` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 08:00 pm. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Bump cos \ud83d\udd27`. This step runs a script: `docker run --name=yq -v \"${PWD}\":/workdir mikefarah/yq\ndocker cp yq:/usr/bin/yq ./\nexport YQ=$PWD/yq\nsudo -E bash ./.github/bump_repositories.sh\nrm -rf yq\n`. The 3rd step is named `Create Pull Request`. This step runs action `peter-evans/create-pull-request` tagged as v4. The step defines 5 input parameters for the action: `token` is set to `${{ secrets.PAT_TOKEN }}`, `push-to-fork` is set to `ci-robbot/c3os`, `commit-message` is set to `:arrow_up: Update repositories`, `title` is set to `Repositories bump` and `body` is set to `Bump of luet repositories`. "}
{"id": "63c4945a7843b61269a00a52", "level": "level5", "llm_response": "```yaml\nname: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Set up QEMU\n      uses: docker/setup-qemu-action@v2\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v2\n\n    - name: Build and export to Docker\n      uses: docker/build-push-action@v3\n      with:\n        context: .\n        load: true\n        push: false\n        tags: ${{ env.TEST_TAG }}\n\n    - name: Run\n      run: docker run --rm ${{ env.TEST_TAG }} ci\n```", "answer": "```yaml name: ci\n\non:\n  pull_request:\n\nenv:\n  TEST_TAG: protoc-gen-validate:${{ github.sha }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      - name: Build and export to Docker\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          load: true\n          push: false\n          tags: ${{ env.TEST_TAG }}\n      - name: Run\n        run: |\n          docker run --rm ${{ env.TEST_TAG }} ci\n```", "prompt": "Generate a GitHub Workflow named `ci` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow sets an environment variable to use: `TEST_TAG` is set to `protoc-gen-validate:${{ github.sha }}`. The workflow has one job. The job id of the 1st job is `docker`. This job will run on ubuntu-latest runner. The job `docker` has 5 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up QEMU`. This step runs action `docker/setup-qemu-action` tagged as v2. The 3rd step is named `Set up Docker Buildx`. This step runs action `docker/setup-buildx-action` tagged as v2. The 4th step is named `Build and export to Docker`. This step runs action `docker/build-push-action` tagged as v3. The step defines 4 input parameters for the action: `context` is set to `.`, `load` is set to `True`, `push` is set to `False` and `tags` is set to `${{ env.TEST_TAG }}`. The 5th step is named `Run`. This step runs a script: `docker run --rm ${{ env.TEST_TAG }} ci\n`. "}
{"id": "63c49698b008460c1df15629", "level": "level5", "llm_response": "```yaml\nname: Auto Assign PR to Author\n\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - name: Auto Assign PR to Author\n        uses: kentaro-m/auto-assign-action@v1.2.1\n```", "answer": "```yaml name: 'Auto Assign PR to Author'\non:\n  pull_request:\n    types: [opened]\n\npermissions:\n  contents: read\n\njobs:\n  add-reviews:\n    permissions:\n      contents: read  # for kentaro-m/auto-assign-action to fetch config file\n      pull-requests: write  # for kentaro-m/auto-assign-action to assign PR reviewers\n    runs-on: ubuntu-latest\n    steps:\n      - uses: kentaro-m/auto-assign-action@v1.2.1\n```", "prompt": "Generate a GitHub Workflow named `Auto Assign PR to Author` for a GitHub repository whose primary programming language is Groovy. This workflow will be triggered by an event: a pull request is created. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has one job. The job id of the 1st job is `add-reviews`. This job will run on ubuntu-latest runner. The job `add-reviews` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `add-reviews`. The job `add-reviews` has one step. The 1st step is named ``. This step runs action `kentaro-m/auto-assign-action` tagged as v1.2.1. "}
{"id": "63c494a87843b61269a02a08", "level": "level5", "llm_response": "```yaml\nname: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: pip install -r requirements/build-docs.txt\n\n      - name: Run linkcheckMarkdown\n        run: linkcheckMarkdown docs/ -v -r\n\n      - name: Build MkDocs site\n        run: mkdocs build --verbose\n```", "answer": "```yaml name: Test\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-python@v4\n        with:\n          python-version: 3.x\n      - run: pip install -r requirements/build-docs.txt\n      - run: linkcheckMarkdown docs/ -v -r\n      - run: mkdocs build --verbose\n```", "prompt": "Generate a GitHub Workflow named `Test` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. 3) the scheduled time has come: at 12:00 am. The workflow has one job. The job id of the 1st job is `docs`. This job will run on ubuntu-latest runner. The job `docs` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named ``. This step runs action `actions/setup-python` tagged as v4. The step defines an input parameter for the action: `python-version` is set to `3.x`. The 3rd step is named ``. This step runs a script: `pip install -r requirements/build-docs.txt`. The 4th step is named ``. This step runs a script: `linkcheckMarkdown docs/ -v -r`. The 5th step is named ``. This step runs a script: `mkdocs build --verbose`. "}
{"id": "63c4956d7843b61269a07890", "level": "level5", "llm_response": "```yaml\nname: Issue Comments for merge\n\non:\n  issues:\n    types: [commented]\n  pull_request:\n    types: [commented]\n\njobs:\n  check_comments_merge:\n    id: check_comments_merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        uses: xt0rted/slash-command-action@v1.1.0\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          command: merge\n          reaction: true\n          reaction-type: eyes\n          allow-edits: false\n          permission-level: admin\n\n  merge:\n    id: merge\n    needs: check_comments_merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Merge Pull Request\n        uses: juliangruber/merge-pull-request-action@v1.1.0\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          number: ${{ github.event.issue.number }}\n          method: merge\n\n  commentFeedback:\n    id: commentFeedback\n    needs: merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Add reaction on success\n        uses: peter-evans/create-or-update-comment@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}\n          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}\n          reaction-type: hooray\n```", "answer": "```yaml on: issue_comment\nname: Issue Comments for merge\njobs:\n  check_comments_merge:\n    name: Check comments for /merge\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for Command\n        uses: xt0rted/slash-command-action@v1.1.0\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          command: merge\n          reaction: \"true\"\n          reaction-type: \"eyes\"\n          allow-edits: \"false\"\n          permission-level: admin\n  merge:\n    runs-on: ubuntu-latest\n    needs: [check_comments_merge]\n    steps:\n      - name: Merge Pull Request\n        uses: juliangruber/merge-pull-request-action@v1.1.0\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          number: ${{ github.event.issue.number }}\n          method: merge\n  commentFeedback:\n    runs-on: ubuntu-latest\n    needs: [merge]\n    steps:\n      - name: Add reaction on success\n        uses: peter-evans/create-or-update-comment@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}\n          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}\n          reaction-type: hooray\n```", "prompt": "Generate a GitHub Workflow named `Issue Comments for merge` for a GitHub repository whose primary programming language is HCL. This workflow will be triggered by an event: activity related to an issue or pull request comment occurs. The workflow has 3 jobs. The 1st job is named `Check comments for /merge` and its job id is `check_comments_merge`. This job will run on ubuntu-latest runner. The job `check_comments_merge` has one step. The 1st step is named `Check for Command`. This step runs action `xt0rted/slash-command-action` tagged as v1.1.0. The step defines 6 input parameters for the action: `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`, `command` is set to `merge`, `reaction` is set to `true`, `reaction-type` is set to `eyes`, `allow-edits` is set to `false` and `permission-level` is set to `admin`. The job id of the 2nd job is `merge`. Before this job runs, `check_comments_merge` must complete successfully. This job will run on ubuntu-latest runner. The job `merge` has one step. The 1st step is named `Merge Pull Request`. This step runs action `juliangruber/merge-pull-request-action` tagged as v1.1.0. The step defines 3 input parameters for the action: `github-token` is set to `${{ secrets.GITHUB_TOKEN }}`, `number` is set to `${{ github.event.issue.number }}` and `method` is set to `merge`. The job id of the 3rd job is `commentFeedback`. Before this job runs, `merge` must complete successfully. This job will run on ubuntu-latest runner. The job `commentFeedback` has one step. The 1st step is named `Add reaction on success`. This step runs action `peter-evans/create-or-update-comment` tagged as v2. The step defines 4 input parameters for the action: `token` is set to `${{ secrets.GITHUB_TOKEN }}`, `repository` is set to `${{ github.event.client_payload.github.payload.repository.full_name }}`, `comment-id` is set to `${{ github.event.client_payload.github.payload.comment.id }}` and `reaction-type` is set to `hooray`. "}
{"id": "63c495888052faa2781b2739", "level": "level5", "llm_response": "```yaml\nname: \u2744\ufe0f Lint\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  repository_dispatch:\n    types: [ clone ]\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    id: misc\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v3.1.0\n      - name: spell check\n        run: |\n          pip install codespell==2.1.0\n          git grep --cached -l '' | xargs codespell --ignore-words=.ignore_words\n      - name: Merge conflict\n        run: bash ./utils/check-merge-conflict.sh\n      - name: Plugin Code\n        run: bash ./utils/check-plugins-code.sh\n\n  ci-eclint:\n    id: ci-eclint\n    runs-on: ubuntu-latest\n    timeout-minutes: 5\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v3.1.0\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v3.5.1\n        with:\n          node-version: '12'\n      - name: Install eclint\n        run: sudo npm install -g eclint\n      - name: Run eclint\n        run: eclint check\n```", "answer": "```yaml name: \u2744\ufe0f Lint\n\non: [push, pull_request]\n\npermissions:\n  contents: read\n\njobs:\n  misc:\n    name: misc checker\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code.\n        uses: actions/checkout@v3.1.0\n      - name: spell check\n        run: |\n          pip install codespell==2.1.0\n          git grep --cached -l '' | xargs codespell --ignore-words=.ignore_words\n      - name: Merge conflict\n        run: |\n          bash ./utils/check-merge-conflict.sh\n      - name: Plugin Code\n        run: |\n          bash ./utils/check-plugins-code.sh\n\n  ci-eclint:\n    runs-on: ubuntu-latest\n    timeout-minutes: 5\n\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v3.1.0\n\n      - name: Setup Nodejs env\n        uses: actions/setup-node@v3.5.1\n        with:\n          node-version: '12'\n\n      - name: Install eclint\n        run: |\n          sudo npm install -g eclint\n\n      - name: Run eclint\n        run: |\n          eclint check\n```", "prompt": "Generate a GitHub Workflow named `\u2744\ufe0f Lint` for a GitHub repository whose primary programming language is Lua. This workflow will be triggered by multiple events: 1) a commit or tag is pushed, or a repository is cloned. 2) there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `misc checker` and its job id is `misc`. This job will run on ubuntu-latest runner. The job `misc` has 4 steps. The 1st step is named `Check out code.`. This step runs action `actions/checkout` tagged as v3.1.0. The 2nd step is named `spell check`. This step runs a script: `pip install codespell==2.1.0\ngit grep --cached -l '' | xargs codespell --ignore-words=.ignore_words\n`. The 3rd step is named `Merge conflict`. This step runs a script: `bash ./utils/check-merge-conflict.sh\n`. The 4th step is named `Plugin Code`. This step runs a script: `bash ./utils/check-plugins-code.sh\n`. The job id of the 2nd job is `ci-eclint`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 5. The job `ci-eclint` has 4 steps. The 1st step is named `Check out code`. This step runs action `actions/checkout` tagged as v3.1.0. The 2nd step is named `Setup Nodejs env`. This step runs action `actions/setup-node` tagged as v3.5.1. The step defines an input parameter for the action: `node-version` is set to `12`. The 3rd step is named `Install eclint`. This step runs a script: `sudo npm install -g eclint\n`. The 4th step is named `Run eclint`. This step runs a script: `eclint check\n`. "}
{"id": "63c4951b8052faa2781af857", "level": "level5", "llm_response": "```yaml\nname: Docs Build\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - master\n\njobs:\n  docs-build:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Set node version to 16\n      uses: actions/setup-node@v3\n      with:\n        node-version: 16\n\n    - name: Install deps\n      run: |\n        npm install vuepress -D\n        npm install macaca-ecosystem -D\n\n    - name: Build docs\n      run: npm run docs:build\n\n    - name: Deploy to GitHub Pages\n      if: success()\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: ./docs_dist\n```", "answer": "```yaml name: Docs Build\n\non:\n  # allows to manually run the job at any time\n  workflow_dispatch:\n  \n  # run on every push on the master branch\n  push:\n    branches:\n      - master\n\njobs:\n  docs-build:\n    timeout-minutes: 10\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set node version to 16\n        uses: actions/setup-node@v3\n        with:\n          node-version: '16'\n\n      - name: Install deps\n        run: |\n          npm install vuepress -D\n          npm install macaca-ecosystem -D\n\n      - name: Build docs\n        run: npm run docs:build\n\n      - name: Deploy to GitHub Pages\n        if: success()\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs_dist\n```", "prompt": "Generate a GitHub Workflow named `Docs Build` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. 2) The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `docs-build`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 10. The job `docs-build` has 5 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Set node version to 16`. This step runs action `actions/setup-node` tagged as v3. The step defines an input parameter for the action: `node-version` is set to `16`. The 3rd step is named `Install deps`. This step runs a script: `npm install vuepress -D\nnpm install macaca-ecosystem -D\n`. The 4th step is named `Build docs`. This step runs a script: `npm run docs:build`. The 5th step is named `Deploy to GitHub Pages`. This step will run only if the condition(success()) is met. This step runs action `peaceiris/actions-gh-pages` tagged as v3. The step defines 2 input parameters for the action: `github_token` is set to `${{ secrets.GITHUB_TOKEN }}` and `publish_dir` is set to `./docs_dist`. "}
{"id": "63c494027843b612699fe5e4", "level": "level5", "llm_response": "```yaml\nname: CLA\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v1\n    - name: Check CLA\n      run: ./ci/check-cla.sh \"${{ github.event.pull_request.user.login }}\"\n```", "answer": "```yaml name: CLA\non: [pull_request]\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v1\n    - run: ./ci/check-cla.sh \"${{ github.event.pull_request.user.login }}\"\n```", "prompt": "Generate a GitHub Workflow named `CLA` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The job id of the 1st job is `check`. This job will run on ubuntu-latest runner. The job `check` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v1. The 2nd step is named ``. This step runs a script: `./ci/check-cla.sh \"${{ github.event.pull_request.user.login }}\"`. "}
{"id": "63c496831e3364807577b1f9", "level": "level5", "llm_response": "```yaml\nname: Fastlane Metadata\n\non:\n  push:\n    branches:\n      - main\n      - '[0-9]+\\.[0-9]+\\.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n  pull_request:\n    branches:\n      - main\n      - '[0-9]+\\.[0-9]+\\.x'\n    paths:\n      - fastlane/**\n      - .github/workflows/fastlane-metadata.yaml\n\njobs:\n  validate:\n    id: validate\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Validate Fastlane Metadata\n        uses: ashutoshgngwr/validate-fastlane-supply-metadata@v2\n        with:\n          usePlayStoreLocales: True\n\n  play-store-upload:\n    id: play-store-upload\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    needs: validate\n    if: github.event_name == 'push'\n    steps:\n      - name: Setup Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '2.7'\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Install dependencies\n        run: bundle install\n      - name: Set up service account key\n        run: echo \"$SERVICE_ACCOUNT_KEY\" > service-account-key.json\n        env:\n          SERVICE_ACCOUNT_KEY: ${{ secrets.SERVICE_ACCOUNT_KEY }}\n      - name: Upload metadata\n        run: bundle exec fastlane upload_metadata\n      - name: Clean up service account key\n        run: rm -f service-account-key.json\n        if: always()\n```", "answer": "```yaml name: Fastlane Metadata\non:\n  push:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n  pull_request:\n    branches:\n      - main\n      - \"[0-9]+.[0-9]+.x\"\n    paths:\n      - \"fastlane/**\"\n      - \".github/workflows/fastlane-metadata.yaml\"\n\njobs:\n  validate:\n    name: Validate\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    steps:\n      - uses: actions/checkout@v3\n      - uses: ashutoshgngwr/validate-fastlane-supply-metadata@v2\n        with:\n          usePlayStoreLocales: true\n\n  play-store-upload:\n    name: Play Store Upload\n    needs: validate\n    if: github.event_name == 'push'\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    steps:\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n      - uses: actions/checkout@v3\n      - run: bundle install\n      - run: echo \"$SERVICE_ACCOUNT_KEY\" > service-account-key.json\n        env:\n          SERVICE_ACCOUNT_KEY: ${{ secrets.SERVICE_ACCOUNT_KEY }}\n      - run: bundle exec fastlane upload_metadata\n      - if: ${{ always() }}\n        run: rm -f service-account-key.json\n```", "prompt": "Generate a GitHub Workflow named `Fastlane Metadata` for a GitHub repository whose primary programming language is Kotlin. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of push event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main or a branch whose name matches [0-9]+.[0-9]+.x. Only if at least one path of pull_request event matches a pattern in the paths filter(fastlane/** or .github/workflows/fastlane-metadata.yaml), the workflow runs. The workflow has 2 jobs. The 1st job is named `Validate` and its job id is `validate`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 15. The job `validate` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `ashutoshgngwr/validate-fastlane-supply-metadata` tagged as v2. The step defines an input parameter for the action: `usePlayStoreLocales` is set to `True`. The 2nd job is named `Play Store Upload` and its job id is `play-store-upload`. Before this job runs, `validate` must complete successfully. This job will run only if the condition(github.event_name == 'push') is met. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 30. The job `play-store-upload` has 6 steps. The 1st step is named ``. This step runs action `ruby/setup-ruby` tagged as v1. The step defines an input parameter for the action: `ruby-version` is set to `2.7`. The 2nd step is named ``. This step runs action `actions/checkout` tagged as v3. The 3rd step is named ``. This step runs a script: `bundle install`. The 4th step is named ``. The step sets an environment variable to use: `SERVICE_ACCOUNT_KEY` is set to `${{ secrets.SERVICE_ACCOUNT_KEY }}`. This step runs a script: `echo \"$SERVICE_ACCOUNT_KEY\" > service-account-key.json`. The 5th step is named ``. This step runs a script: `bundle exec fastlane upload_metadata`. The 6th step is named ``. This step will run only if the condition(${{ always() }}) is met. This step runs a script: `rm -f service-account-key.json`. "}
{"id": "63c496701e3364807577aa6c", "level": "level5", "llm_response": "```yaml\nname: dds-rtps\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  Linux:\n    runs-on: ubuntu-20.04\n    steps:\n    - name: checkout OpenDDS\n      uses: actions/checkout@v3\n      with:\n        path: OpenDDS\n        submodules: true\n\n    - name: checkout dds-rtps\n      uses: actions/checkout@v3\n      with:\n        repository: omg-dds/dds-rtps\n        path: dds-rtps\n\n    - name: checkout ACE_TAO\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/ACE_TAO\n        ref: Latest_Micro\n        path: OpenDDS/ACE_TAO\n\n    - name: get ACE_TAO commit\n      run: |\n        cd OpenDDS/ACE_TAO\n        export ACE_COMMIT=$(git rev-parse HEAD)\n        echo \"ACE_COMMIT=$ACE_COMMIT\" >> $GITHUB_ENV\n\n    - name: get compiler version\n      run: |\n        export COMPILER_VERSION=$(g++ --version 2>&1 | head -n 1)\n        echo \"COMPILER_VERSION=$COMPILER_VERSION\" >> $GITHUB_ENV\n\n    - name: checkout MPC\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/MPC\n        path: OpenDDS/ACE_TAO/ACE/MPC\n\n    - name: configure OpenDDS\n      run: |\n        cd OpenDDS\n        ./configure --optimize --no-debug --static --no-inline\n        tools/scripts/show_build_config.pl\n\n    - name: match gcc problems\n      uses: ammaraskar/gcc-problem-matcher@0.1.0\n\n    - name: build OpenDDS\n      run: |\n        cd OpenDDS\n        make -j4 OpenDDS_Rtps_Udp\n\n    - name: build shape_main\n      run: |\n        cd dds-rtps/srcCxx\n        . ../../OpenDDS/setenv.sh\n        mwc.pl -type gnuace\n        make -sj4\n\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: ${{ github.job }}_artifact\n        path: dds-rtps/srcCxx/shape_main\n```", "answer": "```yaml name: \"omg-dds/dds-rtps\"\n\non:\n  workflow_dispatch:\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n\n  Linux:\n    runs-on: ubuntu-20.04\n    steps:\n    - name: checkout OpenDDS\n      uses: actions/checkout@v3\n      with:\n        path: OpenDDS\n        submodules: true\n    - name: checkout dds-rtps\n      uses: actions/checkout@v3\n      with:\n        repository: omg-dds/dds-rtps\n        path: dds-rtps\n    - name: checkout ACE_TAO\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/ACE_TAO\n        ref: Latest_Micro\n        path: OpenDDS/ACE_TAO\n    - name: get ACE_TAO commit\n      shell: bash\n      run: |\n        cd OpenDDS/ACE_TAO\n        export ACE_COMMIT=$(git rev-parse HEAD)\n        echo \"ACE_COMMIT=$ACE_COMMIT\" >> $GITHUB_ENV\n    - name: get compiler version\n      shell: bash\n      run: |\n        export COMPILER_VERSION=$(g++ --version 2>&1 | head -n 1)\n        echo \"COMPILER_VERSION=$COMPILER_VERSION\" >> $GITHUB_ENV\n    - name: checkout MPC\n      uses: actions/checkout@v3\n      with:\n        repository: DOCGroup/MPC\n        path: OpenDDS/ACE_TAO/ACE/MPC\n    - name: configure OpenDDS\n      run: |\n        cd OpenDDS\n        ./configure --optimize --no-debug --static --no-inline\n        tools/scripts/show_build_config.pl\n    - uses: ammaraskar/gcc-problem-matcher@0.1\n    - name: build OpenDDS\n      shell: bash\n      run: |\n        cd OpenDDS\n        make -j4 OpenDDS_Rtps_Udp\n    - name: build shape_main\n      shell: bash\n      run: |\n        cd dds-rtps/srcCxx\n        . ../../OpenDDS/setenv.sh\n        mwc.pl -type gnuace\n        make -sj4\n    - name: upload shape_main artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: ${{ github.job }}_artifact\n        path: dds-rtps/srcCxx/shape_main\n```", "prompt": "Generate a GitHub Workflow named `omg-dds/dds-rtps` for a GitHub repository whose primary programming language is C++. This workflow will be triggered by an event: someone manually triggers the workflow. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `Linux`. This job will run on ubuntu-20.04 runner. The job `Linux` has 11 steps. The 1st step is named `checkout OpenDDS`. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `path` is set to `OpenDDS` and `submodules` is set to `True`. The 2nd step is named `checkout dds-rtps`. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `repository` is set to `omg-dds/dds-rtps` and `path` is set to `dds-rtps`. The 3rd step is named `checkout ACE_TAO`. This step runs action `actions/checkout` tagged as v3. The step defines 3 input parameters for the action: `repository` is set to `DOCGroup/ACE_TAO`, `ref` is set to `Latest_Micro` and `path` is set to `OpenDDS/ACE_TAO`. The 4th step is named `get ACE_TAO commit`. This step uses bash to run a script: `cd OpenDDS/ACE_TAO\nexport ACE_COMMIT=$(git rev-parse HEAD)\necho \"ACE_COMMIT=$ACE_COMMIT\" >> $GITHUB_ENV\n`. The 5th step is named `get compiler version`. This step uses bash to run a script: `export COMPILER_VERSION=$(g++ --version 2>&1 | head -n 1)\necho \"COMPILER_VERSION=$COMPILER_VERSION\" >> $GITHUB_ENV\n`. The 6th step is named `checkout MPC`. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `repository` is set to `DOCGroup/MPC` and `path` is set to `OpenDDS/ACE_TAO/ACE/MPC`. The 7th step is named `configure OpenDDS`. This step runs a script: `cd OpenDDS\n./configure --optimize --no-debug --static --no-inline\ntools/scripts/show_build_config.pl\n`. The 8th step is named ``. This step runs action `ammaraskar/gcc-problem-matcher` tagged as 0.1. The 9th step is named `build OpenDDS`. This step uses bash to run a script: `cd OpenDDS\nmake -j4 OpenDDS_Rtps_Udp\n`. The 10th step is named `build shape_main`. This step uses bash to run a script: `cd dds-rtps/srcCxx\n. ../../OpenDDS/setenv.sh\nmwc.pl -type gnuace\nmake -sj4\n`. The 11th step is named `upload shape_main artifact`. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `${{ github.job }}_artifact` and `path` is set to `dds-rtps/srcCxx/shape_main`. "}
{"id": "63c495277843b61269a05c66", "level": "level5", "llm_response": "```yaml\nname: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    - cron: '0 10 * * *'\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        package:\n          - packages/freezed\n          - packages/freezed_annotation\n        channel:\n          - master\n          - stable\n        dependencies:\n          - get\n          - downgrade\n      exclude:\n        - package: packages/freezed_annotation\n          channel: master\n          dependencies: downgrade\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          channel: ${{ matrix.channel }}\n          cache: ${{ matrix.channel == 'stable' }}\n\n      - name: Removing example folder\n        run: rm -rf example\n\n      - name: Install dependencies\n        run: flutter pub ${{ matrix.dependencies }}\n\n      - name: Check format\n        if: matrix.channel == 'master'\n        run: flutter format --set-exit-if-changed .\n\n      - name: Generate\n        run: |\n          if grep -q build_runner \"pubspec.yaml\"; then\n            flutter pub run build_runner build --delete-conflicting-outputs\n          fi\n\n      - name: Analyze\n        run: flutter analyze\n\n      - name: Run tests\n        run: |\n          if grep -q \"name: example\" \"pubspec.yaml\"; then\n            flutter test\n          else\n            dart test\n          fi\n```", "answer": "```yaml name: Build\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    # runs the CI everyday at 10AM\n    - cron: \"0 10 * * *\"\n\njobs:\n  freezed:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        package:\n          - packages/freezed\n          - packages/freezed_annotation\n        channel:\n          - master\n          - stable\n        dependencies:\n          - get\n          - downgrade\n        exclude:\n          - channel: master\n            dependencies: downgrade\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: subosito/flutter-action@v2\n        with:\n          channel: ${{ matrix.channel }}\n          cache: ${{ matrix.channel == 'stable' }}\n\n      # It is executed separately\n      - name: Removing example folder\n        run: rm -rf example\n        working-directory: ${{ matrix.package }}\n\n      - name: Install dependencies\n        run: |\n          flutter pub ${{ matrix.dependencies }}\n        working-directory: ${{ matrix.package }}\n\n      - name: Check format\n        # Check format only on master\n        if: matrix.channel == 'master'\n        run: flutter format --set-exit-if-changed .\n        working-directory: ${{ matrix.package }}\n\n      - name: Generate\n        run: |\n          if grep -q build_runner \"pubspec.yaml\"; then\n            flutter pub run build_runner build --delete-conflicting-outputs\n          fi\n        working-directory: ${{ matrix.package }}\n\n      - name: Analyze\n        run: flutter analyze\n        working-directory: ${{ matrix.package }}\n\n      - name: Run tests\n        run: |\n          if grep -q \"name: example\" \"pubspec.yaml\"; then\n            flutter test\n          else\n            dart test\n          fi\n        working-directory: ${{ matrix.package }}\n```", "prompt": "Generate a GitHub Workflow named `Build` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 10:00 am. The workflow has one job. The job id of the 1st job is `freezed`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `package` has 2 values: packages/freezed and packages/freezed_annotation. The variable `channel` has 2 values: master and stable. The variable `dependencies` has 2 values: get and downgrade. If combinations of variables partially match one of the objects [{'channel': 'master', 'dependencies': 'downgrade'}], combinations should be excluded from the matrix. The job `freezed` has 8 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `subosito/flutter-action` tagged as v2. The step defines 2 input parameters for the action: `channel` is set to `${{ matrix.channel }}` and `cache` is set to `${{ matrix.channel == 'stable' }}`. The 3rd step is named `Removing example folder`. This step runs a script: `rm -rf example`. The 4th step is named `Install dependencies`. This step runs a script: `flutter pub ${{ matrix.dependencies }}\n`. The 5th step is named `Check format`. This step will run only if the condition(matrix.channel == 'master') is met. This step runs a script: `flutter format --set-exit-if-changed .`. The 6th step is named `Generate`. This step runs a script: `if grep -q build_runner \"pubspec.yaml\"; then\n  flutter pub run build_runner build --delete-conflicting-outputs\nfi\n`. The 7th step is named `Analyze`. This step runs a script: `flutter analyze`. The 8th step is named `Run tests`. This step runs a script: `if grep -q \"name: example\" \"pubspec.yaml\"; then\n  flutter test\nelse\n  dart test\nfi\n`. "}
{"id": "63c4968933b087f6bde2ca37", "level": "level5", "llm_response": "```yaml\nname: e2e-kind-upgrades\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: ~/.cache/bazel\n          key: bazel\n\n      - name: End-to-end (k3d)\n        run: make test/e2e/k3d-upgrades\n```", "answer": "```yaml # Copyright 2022 The Cockroach Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nname: e2e-kind-upgrades\n\non:\n  # Triggers the workflow on push or pull request events but only for the master branch\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\njobs:\n  e2e-kind-upgrades:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n      - name: Mount bazel cache\n        uses: actions/cache@v3\n        with:\n          path: \"~/.cache/bazel\"\n          key: bazel\n\n      - name: End-to-end (k3d)\n        run: make test/e2e/k3d-upgrades\n```", "prompt": "Generate a GitHub Workflow named `e2e-kind-upgrades` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. 3) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `e2e-kind-upgrades`. This job will run on ubuntu-latest runner. The job `e2e-kind-upgrades` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Mount bazel cache`. This step runs action `actions/cache` tagged as v3. The step defines 2 input parameters for the action: `path` is set to `~/.cache/bazel` and `key` is set to `bazel`. The 3rd step is named `End-to-end (k3d)`. This step runs a script: `make test/e2e/k3d-upgrades`. "}
{"id": "63c494147843b612699fedb4", "level": "level5", "llm_response": "```yaml\nname: test-chart-testing-action\n\non:\n  pull_request:\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n    id: test_ct_action\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Install chart-testing\n        run: ./\n      - name: Check install!\n        run: |\n          ct version\n          CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n          ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n          if [[ $ACTUAL_VERSION != 'v3.7.1' ]]; then\n            echo 'should be v3.7.1'\n            exit 1\n          else\n            exit 0\n          fi\n      - name: Check root directory\n        run: |\n          if [[ $(git diff --stat) != '' ]]; then\n            echo 'should be clean'\n            exit 1\n          else\n            exit 0\n          fi\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n    id: test_ct_action_custom\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Install chart-testing\n        run: ./\n        with:\n          version: v3.5.1\n          yamllint_version: 1.27.1\n          yamale_version: 3.0.4\n      - name: Check install!\n        run: |\n          ct version\n          CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n          ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n          if [[ $ACTUAL_VERSION != 'v3.5.1' ]]; then\n            echo 'should be v3.5.1'\n            exit 1\n          else\n            exit 0\n          fi\n      - name: Check root directory\n        run: |\n          if [[ $(git diff --stat) != '' ]]; then\n            echo 'should be clean'\n            exit 1\n          else\n            exit 0\n          fi\n```", "answer": "```yaml name: test-chart-testing-action\n\non: [pull_request]\n\njobs:\n  test_ct_action:\n    runs-on: ubuntu-latest\n\n    name: Install chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.7.1' ]]; then\n          echo 'should be v3.7.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n\n  test_ct_action_custom:\n    runs-on: ubuntu-latest\n\n    name: Install Custom chart-testing and test presence in path\n    steps:\n    - uses: actions/checkout@v3\n    - name: Install chart-testing\n      uses: ./\n      with:\n        version: 'v3.5.1'\n        yamllint_version: '1.27.1'\n        yamale_version: '3.0.4'\n    - name: Check install!\n      run: |\n        ct version\n        CT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\n        ACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\n        if [[ $ACTUAL_VERSION != 'v3.5.1' ]]; then\n          echo 'should be v3.5.1'\n          exit 1\n        else\n          exit 0\n        fi\n      shell: bash\n    - name: Check root directory\n      run: |\n        if [[ $(git diff --stat) != '' ]]; then\n          echo 'should be clean'\n          exit 1\n        else\n          exit 0\n        fi\n```", "prompt": "Generate a GitHub Workflow named `test-chart-testing-action` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has 2 jobs. The 1st job is named `Install chart-testing and test presence in path` and its job id is `test_ct_action`. This job will run on ubuntu-latest runner. The job `test_ct_action` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Install chart-testing`. This step runs action `./`.The 3rd step is named `Check install!`. This step uses bash to run a script: `ct version\nCT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\nACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\nif [[ $ACTUAL_VERSION != 'v3.7.1' ]]; then\n  echo 'should be v3.7.1'\n  exit 1\nelse\n  exit 0\nfi\n`. The 4th step is named `Check root directory`. This step runs a script: `if [[ $(git diff --stat) != '' ]]; then\n  echo 'should be clean'\n  exit 1\nelse\n  exit 0\nfi\n`. The 2nd job is named `Install Custom chart-testing and test presence in path` and its job id is `test_ct_action_custom`. This job will run on ubuntu-latest runner. The job `test_ct_action_custom` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Install chart-testing`. This step runs action `./`.The step defines 3 input parameters for the action: `version` is set to `v3.5.1`, `yamllint_version` is set to `1.27.1` and `yamale_version` is set to `3.0.4`. The 3rd step is named `Check install!`. This step uses bash to run a script: `ct version\nCT_VERSION_OUTPUT=$(ct version 2>&1 /dev/null)\nACTUAL_VERSION=$(echo \"$CT_VERSION_OUTPUT\" | grep Version | rev | cut -d ' ' -f1 | rev)\nif [[ $ACTUAL_VERSION != 'v3.5.1' ]]; then\n  echo 'should be v3.5.1'\n  exit 1\nelse\n  exit 0\nfi\n`. The 4th step is named `Check root directory`. This step runs a script: `if [[ $(git diff --stat) != '' ]]; then\n  echo 'should be clean'\n  exit 1\nelse\n  exit 0\nfi\n`. "}
{"id": "63c494fc8052faa2781aead3", "level": "level5", "llm_response": "```yaml\nname: Update Release List\n\non:\n  workflow_run:\n    workflows: [Build]\n    types: [completed]\n    branches: [master]\n    conditions:\n      - ${{ github.event.workflow_run.conclusion == 'success' }}\n\npermissions:\n  contents: write\n\nenv:\n  USER_NAME: ctags-win32 CI\n  USER_EMAIL: ctags-win32-ci@users.noreply.github.com\n  COL_RED: \u001b[31m\n  COL_GREEN: \u001b[32m\n  COL_YELLOW: \u001b[33m\n  COL_RESET: \u001b[m\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    steps:\n      - name: Checkout main branch\n        uses: actions/checkout@v3\n        with:\n          path: main\n\n      - name: Checkout wiki repository\n        uses: actions/checkout@v3\n        with:\n          repository: ${{ github.repository }}.wiki\n          path: wiki\n\n      - name: Update Release List\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: |\n          cd main\n          latest=$(cat ctagsver.txt)\n          cd ../wiki\n          ../main/scripts/update-release-list.py\n          git add Releases-in-*.md\n          if git diff HEAD --quiet; then\n            echo ${COL_YELLOW}No updates.${COL_RESET}\n          else\n            git config --local user.name ${USER_NAME}\n            git config --local user.email ${USER_EMAIL}\n            git commit -a -m \"Update Release List to ${latest}\"\n            git push origin HEAD\n          fi\n```", "answer": "```yaml name: Update Release List\n\non:\n  #release:\n  #  types: [published]\n  workflow_run:\n    workflows: [\"Build\"]\n    branches: [master]\n    types: [completed]\n\npermissions:\n  contents: write # to update wiki\n\nenv:\n  # Account for committing\n  USER_NAME: \"ctags-win32 CI\"\n  USER_EMAIL: \"ctags-win32-ci@users.noreply.github.com\"\n\n  # Escape sequences\n  COL_RED: \"\\x1b[31m\"\n  COL_GREEN: \"\\x1b[32m\"\n  COL_YELLOW: \"\\x1b[33m\"\n  COL_RESET: \"\\x1b[m\"\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        path: main\n\n    - uses: actions/checkout@v3\n      with:\n        repository: \"${{ github.repository }}.wiki\"\n        path: wiki\n\n    - name: Update Release List\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      run: |\n        cd main\n        latest=$(cat ctagsver.txt)\n        cd ../wiki\n        ../main/scripts/update-release-list.py\n        git add Releases-in-*.md\n        if git diff HEAD --quiet; then\n          echo ${COL_YELLOW}No updates.${COL_RESET}\n        else\n          git config --local user.name ${USER_NAME}\n          git config --local user.email ${USER_EMAIL}\n          git commit -a -m \"Update Release List to ${latest}\"\n          git push origin HEAD\n        fi\n```", "prompt": "Generate a GitHub Workflow named `Update Release List` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: the workflow named Build is completed on a branch whose name matches master. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow sets 6 environment variables to use: `USER_NAME` is set to `ctags-win32 CI`, `USER_EMAIL` is set to `ctags-win32-ci@users.noreply.github.com`, `COL_RED` is set to `\u001b[31m`, `COL_GREEN` is set to `\u001b[32m`, `COL_YELLOW` is set to `\u001b[33m` and `COL_RESET` is set to `\u001b[m`. The workflow has one job. The job id of the 1st job is `update`. This job will run only if the condition(${{ github.event.workflow_run.conclusion == 'success' }}) is met. This job will run on ubuntu-latest runner. The job `update` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `path` is set to `main`. The 2nd step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `repository` is set to `${{ github.repository }}.wiki` and `path` is set to `wiki`. The 3rd step is named `Update Release List`. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs a script: `cd main\nlatest=$(cat ctagsver.txt)\ncd ../wiki\n../main/scripts/update-release-list.py\ngit add Releases-in-*.md\nif git diff HEAD --quiet; then\n  echo ${COL_YELLOW}No updates.${COL_RESET}\nelse\n  git config --local user.name ${USER_NAME}\n  git config --local user.email ${USER_EMAIL}\n  git commit -a -m \"Update Release List to ${latest}\"\n  git push origin HEAD\nfi\n`. "}
{"id": "63c4969c1899db58864d4153", "level": "level5", "llm_response": "```yaml\nname: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    id: backend-tests\n    runs-on: ubuntu-latest\n    uses: ./.github/workflows/partial-backend.yml\n\n  frontend-tests:\n    id: frontend-tests\n    runs-on: ubuntu-latest\n    uses: ./.github/workflows/partial-frontend.yml\n\n  build-release:\n    id: build-release\n    needs: [backend-tests, frontend-tests]\n    runs-on: ubuntu-latest\n    uses: ./.github/workflows/partial-builder.yml\n    with:\n      tag: nightly\n    secrets:\n      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}\n      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}\n\n  notify-discord:\n    id: notify-discord\n    needs: build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        env:\n          DISCORD_WEBHOOK: ${{ secrets.DISCORD_NIGHTLY_WEBHOOK }}\n        uses: Ilshidur/action-discord@0.3.2\n        with:\n          args: \ud83d\ude80  A New build of mealie:api-nightly and mealie:frontend-nightly is available\n\n  deploy-demo:\n    id: deploy-demo\n    needs: build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clean and Deploy Demo\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.DEMO_SERVER_IP }}\n          username: ${{ secrets.DEMO_SERVER_USER }}\n          key: ${{ secrets.DEMO_SERVER_SSH_KEY }}\n          port: ${{ secrets.DEMO_SERVER_PORT }}\n          script_stop: True\n          script: |\n            cd ~/docker/mealie-next\n            docker-compose pull\n            docker-compose down -v\n            docker-compose up -d\n```", "answer": "```yaml name: Docker Nightly Production\n\non:\n  push:\n    branches:\n      - mealie-next\n\nconcurrency:\n  group: nightly-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  backend-tests:\n    name: \"Backend Server Tests\"\n    uses: ./.github/workflows/partial-backend.yml\n\n  frontend-tests:\n    name: \"Frontend and End-to-End Tests\"\n    uses: ./.github/workflows/partial-frontend.yml\n\n  build-release:\n    name: Build Tagged Release\n    uses: ./.github/workflows/partial-builder.yml\n    needs:\n      - frontend-tests\n      - backend-tests\n    with:\n      tag: nightly\n    secrets:\n      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}\n      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}\n\n  notify-discord:\n    name: Notify Discord\n    needs:\n      - build-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Discord notification\n        env:\n          DISCORD_WEBHOOK: ${{ secrets.DISCORD_NIGHTLY_WEBHOOK }}\n        uses: Ilshidur/action-discord@0.3.2\n        with:\n          args: \"\ud83d\ude80  A New build of mealie:api-nightly and mealie:frontend-nightly is available\"\n\n  deploy-demo:\n    runs-on: ubuntu-latest\n    name: Deploy Demo\n    needs:\n      - build-release\n    steps:\n      - name: Clean and Deploy Demo\n        uses: appleboy/ssh-action@master\n        with:\n          host: ${{ secrets.DEMO_SERVER_IP }}\n          username: ${{ secrets.DEMO_SERVER_USER }}\n          key: ${{ secrets.DEMO_SERVER_SSH_KEY }}\n          port: ${{ secrets.DEMO_SERVER_PORT }}\n          script_stop: true\n          script: |\n            cd ~/docker/mealie-next\n            docker-compose pull\n            docker-compose down -v\n            docker-compose up -d\n```", "prompt": "Generate a GitHub Workflow named `Docker Nightly Production` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named mealie-next. Only a single workflow using the nightly-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has 5 jobs. The 1st job is named `Backend Server Tests` and its job id is `backend-tests`. This job will call a reusable workflow located at `./.github/workflows/partial-backend.yml`. The 2nd job is named `Frontend and End-to-End Tests` and its job id is `frontend-tests`. This job will call a reusable workflow located at `./.github/workflows/partial-frontend.yml`. The 3rd job is named `Build Tagged Release` and its job id is `build-release`. Before this job runs, `frontend-tests` and `backend-tests` must complete successfully. This job will call a reusable workflow located at `./.github/workflows/partial-builder.yml`. The job will pass an input to the called workflow: the input `tag` is `nightly`. The job will pass 2 secrets to the called workflow: the secret `DOCKERHUB_USERNAME` is `${{ secrets.DOCKERHUB_USERNAME }}` and the secret `DOCKERHUB_TOKEN` is `${{ secrets.DOCKERHUB_TOKEN }}`. The 4th job is named `Notify Discord` and its job id is `notify-discord`. Before this job runs, `build-release` must complete successfully. This job will run on ubuntu-latest runner. The job `notify-discord` has one step. The 1st step is named `Discord notification`. The step sets an environment variable to use: `DISCORD_WEBHOOK` is set to `${{ secrets.DISCORD_NIGHTLY_WEBHOOK }}`. This step runs action `Ilshidur/action-discord` tagged as 0.3.2. The step defines an input parameter for the action: `args` is set to `\ud83d\ude80  A New build of mealie:api-nightly and mealie:frontend-nightly is available`. The 5th job is named `Deploy Demo` and its job id is `deploy-demo`. Before this job runs, `build-release` must complete successfully. This job will run on ubuntu-latest runner. The job `deploy-demo` has one step. The 1st step is named `Clean and Deploy Demo`. This step runs action `appleboy/ssh-action` from the master branch. The step defines 6 input parameters for the action: `host` is set to `${{ secrets.DEMO_SERVER_IP }}`, `username` is set to `${{ secrets.DEMO_SERVER_USER }}`, `key` is set to `${{ secrets.DEMO_SERVER_SSH_KEY }}`, `port` is set to `${{ secrets.DEMO_SERVER_PORT }}`, `script_stop` is set to `True` and `script` is set to `cd ~/docker/mealie-next\ndocker-compose pull\ndocker-compose down -v\ndocker-compose up -d\n`. "}
{"id": "63c494037843b612699fe649", "level": "level5", "llm_response": "```yaml\nname: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Version'\n        required: true\n      tag:\n        description: 'Tag'\n        required: true\n        default: 'latest'\n\npermissions:\n  contents: write\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    environment: release\n    permissions:\n      contents: none\n\n    steps:\n      - name: Setup Node\n        uses: actions/setup-node@v3\n\n      - name: Update tag\n        env:\n          npm_config_//registry.npmjs.org/:_authToken: ${{ secrets.NPM_TOKEN }}\n        run: |\n          npm dist-tag add pnpm@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n          npm dist-tag add @pnpm/exe@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n```", "answer": "```yaml name: Tag\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: Version\n        required: true\n      tag:\n        description: Tag\n        default: latest\n        required: true\n\npermissions: {}\njobs:\n  build:\n    name: Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}\n    environment: release\n    runs-on: ubuntu-latest\n    steps:\n    - name: Setup Node\n      uses: actions/setup-node@v3\n    - name: Update tag\n      env:\n        \"npm_config_//registry.npmjs.org/:_authToken\": ${{ secrets.NPM_TOKEN }}\n      run: |\n        npm dist-tag add pnpm@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n        npm dist-tag add @pnpm/exe@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n```", "prompt": "Generate a GitHub Workflow named `Tag` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. This workflow receives 2 inputs: version-this input represents version and it must be supplied; tag-this input represents tag, its default value is latest and it must be supplied. The workflow modifies the default permissions for the GITHUB_TOKEN: the workflow disables permissions for the GITHUB_TOKEN across all scopes. This permission setting applies to all jobs in the workflow. The workflow has one job. The 1st job is named `Tagging ${{ github.event.inputs.version }} as ${{ github.event.inputs.tag }}` and its job id is `build`. This job will run on ubuntu-latest runner. This job references release environment. The job `build` has 2 steps. The 1st step is named `Setup Node`. This step runs action `actions/setup-node` tagged as v3. The 2nd step is named `Update tag`. The step sets an environment variable to use: `npm_config_//registry.npmjs.org/:_authToken` is set to `${{ secrets.NPM_TOKEN }}`. This step runs a script: `npm dist-tag add pnpm@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\nnpm dist-tag add @pnpm/exe@${{ github.event.inputs.version }} ${{ github.event.inputs.tag }}\n`. "}
{"id": "63c4949a8052faa2781ac0b0", "level": "level5", "llm_response": "```yaml\nname: Node.js CI\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n\n    - name: Cache pnpm modules\n      env:\n        cache-name: cache-pnpm-modules\n      uses: actions/cache@v3\n      with:\n        path: ~/.pnpm-store\n        key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n        restore-keys: ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n\n    - name: Cache Next.js cache\n      uses: actions/cache@v3\n      with:\n        path: ${{ github.workspace }}/.next/cache\n        key: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}\n        restore-keys: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-\n\n    - name: Set up pnpm\n      uses: pnpm/action-setup@v2.2.4\n      with:\n        version: 7.x.x\n        run_install: True\n\n    - name: Build project\n      env:\n        CI: True\n      run: |\n        yarn build\n        yarn lint\n```", "answer": "```yaml # This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Node.js CI\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [16.x]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: Cache pnpm modules\n        uses: actions/cache@v3\n        env:\n          cache-name: cache-pnpm-modules\n        with:\n          path: ~/.pnpm-store\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n      - uses: actions/cache@v3\n        with:\n          path: |\n            ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}\n          restore-keys: |\n            ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-\n      - uses: pnpm/action-setup@v2.2.4\n        with:\n          version: 7.x.x\n          run_install: true\n      - name: Build project\n        run: |\n          yarn build\n          yarn lint\n        env:\n          CI: true\n```", "prompt": "Generate a GitHub Workflow named `Node.js CI` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `node-version` has one value: 16.x. The job `build` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Use Node.js ${{ matrix.node-version }}`. This step runs action `actions/setup-node` tagged as v3. The step defines an input parameter for the action: `node-version` is set to `${{ matrix.node-version }}`. The 3rd step is named `Cache pnpm modules`. The step sets an environment variable to use: `cache-name` is set to `cache-pnpm-modules`. This step runs action `actions/cache` tagged as v3. The step defines 3 input parameters for the action: `path` is set to `~/.pnpm-store`, `key` is set to `${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}` and `restore-keys` is set to `${{ runner.os }}-build-${{ env.cache-name }}-${{ matrix.node-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n`. The 4th step is named ``. This step runs action `actions/cache` tagged as v3. The step defines 3 input parameters for the action: `path` is set to `${{ github.workspace }}/.next/cache\n`, `key` is set to `${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}` and `restore-keys` is set to `${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-\n`. The 5th step is named ``. This step runs action `pnpm/action-setup` tagged as v2.2.4. The step defines 2 input parameters for the action: `version` is set to `7.x.x` and `run_install` is set to `True`. The 6th step is named `Build project`. The step sets an environment variable to use: `CI` is set to `True`. This step runs a script: `yarn build\nyarn lint\n`. "}
{"id": "63c4967e1899db58864d33dd", "level": "level5", "llm_response": "```yaml\nname: Lint\n\non:\n  pull_request:\n    types: [opened, edited, synchronize]\n  pull_request_target:\n    types: [opened, edited, synchronize]\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    id: lint-commit-message\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Commit Message\n        run: .github/lint-commit-message.sh\n      - name: File names\n        run: .github/lint-filename.sh\n      - name: Functions\n        run: .github/lint-disallowed-functions-in-library.sh\n      - name: Logging messages should not have trailing newlines\n        run: .github/lint-no-trailing-newline-in-log-messages.sh\n\n  lint-go:\n    id: lint-go\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: read\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: golangci-lint\n        uses: golangci/golangci-lint-action@v3\n        with:\n          version: v1.45.2\n          args: $GOLANGCI_LINT_EXRA_ARGS\n```", "answer": "```yaml #\n# DO NOT EDIT THIS FILE\n#\n# It is automatically copied from https://github.com/pion/.goassets repository.\n# If this repository should have package specific CI config,\n# remove the repository name from .goassets/.github/workflows/assets-sync.yml.\n#\n# If you want to update the shared CI config, send a PR to\n# https://github.com/pion/.goassets instead of this repository.\n#\n\nname: Lint\non:\n  pull_request:\n    types:\n      - opened\n      - edited\n      - synchronize\n\npermissions:\n  contents: read\n\njobs:\n  lint-commit-message:\n    name: Metadata\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n        - uses: actions/checkout@v3\n          with:\n            fetch-depth: 0\n\n        - name: Commit Message\n          run: .github/lint-commit-message.sh\n\n        - name: File names\n          run: .github/lint-filename.sh\n\n        - name: Functions\n          run: .github/lint-disallowed-functions-in-library.sh\n\n        - name: Logging messages should not have trailing newlines\n          run: .github/lint-no-trailing-newline-in-log-messages.sh\n\n  lint-go:\n    name: Go\n    permissions:\n      contents: read\n      pull-requests: read\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: golangci-lint\n        uses: golangci/golangci-lint-action@v3\n        with:\n          version: v1.45.2\n          args: $GOLANGCI_LINT_EXRA_ARGS\n```", "prompt": "Generate a GitHub Workflow named `Lint` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by an event: a pull request is created, the title or body of a pull request is edited or a pull request's head branch is updated. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. The workflow has 2 jobs. The 1st job is named `Metadata` and its job id is `lint-commit-message`. This job will run on ubuntu-latest runner. The job `lint-commit-message` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Commit Message`. This step runs a script: `.github/lint-commit-message.sh`. The 3rd step is named `File names`. This step runs a script: `.github/lint-filename.sh`. The 4th step is named `Functions`. This step runs a script: `.github/lint-disallowed-functions-in-library.sh`. The 5th step is named `Logging messages should not have trailing newlines`. This step runs a script: `.github/lint-no-trailing-newline-in-log-messages.sh`. The 2nd job is named `Go` and its job id is `lint-go`. This job will run on ubuntu-latest runner. The job `lint-go` modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope and read access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `lint-go`. The job `lint-go` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `golangci-lint`. This step runs action `golangci/golangci-lint-action` tagged as v3. The step defines 2 input parameters for the action: `version` is set to `v1.45.2` and `args` is set to `$GOLANGCI_LINT_EXRA_ARGS`. "}
{"id": "63c4947b8052faa2781ab631", "level": "level5", "llm_response": "```yaml\nname: Publish Test Results\n\non:\n  workflow_run:\n    workflows: [CI]\n    types: [completed]\n\njobs:\n  test-results:\n    id: test-results\n    runs-on: ubuntu-latest\n    if: github.event.workflow_run.conclusion != 'skipped'\n    steps:\n      - name: Download and Extract Artifacts\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: |\n          mkdir -p artifacts && cd artifacts\n          artifacts_url=${{ github.event.workflow_run.artifacts_url }}\n          gh api \"$artifacts_url\" -q '.artifacts[] | [.name, .archive_download_url] | @tsv' | while read artifact\n          do\n            IFS=$'\\t' read name url <<< \"$artifact\"\n            gh api $url > \"$name.zip\"\n            unzip -d \"$name\" \"$name.zip\"\n          done\n\n      - name: Publish Test Results\n        uses: EnricoMi/publish-unit-test-result-action@v2\n        with:\n          commit: ${{ github.event.workflow_run.head_sha }}\n          event_file: artifacts/Event File/event.json\n          event_name: ${{ github.event.workflow_run.event }}\n          junit_files: |\n            artifacts/**/surefire-reports/*.xml\n            artifacts/**/failsafe-reports/TEST-*.xml\n```", "answer": "```yaml # Publishing of unit test results has to be a separate workflow in order to support forked PRs\n# See https://github.com/EnricoMi/publish-unit-test-result-action#support-fork-repositories-and-dependabot-branches\nname: Publish Test Results\non:\n  workflow_run:\n    workflows: [CI]\n    types:\n      - completed\njobs:\n  test-results:\n    name: Test Results\n    runs-on: ubuntu-latest\n    if: github.event.workflow_run.conclusion != 'skipped'\n\n    steps:\n      - name: Download and Extract Artifacts\n        env:\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n        run: |\n          mkdir -p artifacts && cd artifacts\n\n          artifacts_url=${{ github.event.workflow_run.artifacts_url }}\n\n          gh api \"$artifacts_url\" -q '.artifacts[] | [.name, .archive_download_url] | @tsv' | while read artifact\n          do\n            IFS=$'\\t' read name url <<< \"$artifact\"\n            gh api $url > \"$name.zip\"\n            unzip -d \"$name\" \"$name.zip\"\n          done\n\n      - name: Publish Test Results\n        uses: EnricoMi/publish-unit-test-result-action@v2\n        with:\n          commit: ${{ github.event.workflow_run.head_sha }}\n          event_file: artifacts/Event File/event.json\n          event_name: ${{ github.event.workflow_run.event }}\n          junit_files: |\n            artifacts/**/surefire-reports/*.xml\n            artifacts/**/failsafe-reports/TEST-*.xml\n```", "prompt": "Generate a GitHub Workflow named `Publish Test Results` for a GitHub repository whose primary programming language is Java. This workflow will be triggered by an event: the workflow named CI is completed. The workflow has one job. The 1st job is named `Test Results` and its job id is `test-results`. This job will run only if the condition(github.event.workflow_run.conclusion != 'skipped') is met. This job will run on ubuntu-latest runner. The job `test-results` has 2 steps. The 1st step is named `Download and Extract Artifacts`. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{secrets.GITHUB_TOKEN}}`. This step runs a script: `mkdir -p artifacts && cd artifacts\n\nartifacts_url=${{ github.event.workflow_run.artifacts_url }}\n\ngh api \"$artifacts_url\" -q '.artifacts[] | [.name, .archive_download_url] | @tsv' | while read artifact\ndo\n  IFS=$'\\t' read name url <<< \"$artifact\"\n  gh api $url > \"$name.zip\"\n  unzip -d \"$name\" \"$name.zip\"\ndone\n`. The 2nd step is named `Publish Test Results`. This step runs action `EnricoMi/publish-unit-test-result-action` tagged as v2. The step defines 4 input parameters for the action: `commit` is set to `${{ github.event.workflow_run.head_sha }}`, `event_file` is set to `artifacts/Event File/event.json`, `event_name` is set to `${{ github.event.workflow_run.event }}` and `junit_files` is set to `artifacts/**/surefire-reports/*.xml\nartifacts/**/failsafe-reports/TEST-*.xml\n`. "}
{"id": "63c4964a1e33648075779a84", "level": "level5", "llm_response": "```yaml\nname: Publish Terminal.Gui\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  publish:\n    id: publish\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n\n    - name: Install and calculate the new version with GitVersion\n      uses: gittools/actions/gitversion/setup@v0.9.13\n      with:\n        versionSpec: '5.x'\n\n    - name: Determine Version\n      id: gitversion\n      uses: gittools/actions/gitversion/execute@v0.9.13\n\n    - name: Display GitVersion outputs\n      run: |\n        echo \"Version: ${{ steps.gitversion.outputs.SemVer }}\"\n        echo \"CommitsSinceVersionSource: ${{ steps.gitversion.outputs.CommitsSinceVersionSource }}\"\n\n    - name: Setup dotnet\n      uses: actions/setup-dotnet@v3.0.1\n      with:\n        dotnet-version: '6.0.100'\n\n    - name: Install dependencies\n      run: dotnet restore\n\n    - name: Build Release\n      run: |\n        dotnet-gitversion /updateprojectfiles\n        dotnet build --no-restore -c Release\n\n    - name: Pack\n      run: dotnet pack -c Release --include-symbols -p:Version='${{ steps.gitversion.outputs.SemVer }}'\n\n    - name: Test to generate Code Coverage Report\n      run: |\n        dotnet test --verbosity normal --collect:\"XPlat Code Coverage\" --settings UnitTests/coverlet.runsettings\n        mv -v UnitTests/TestResults/*/*.* UnitTests/TestResults/\n\n    - name: Create Test Coverage Badge\n      id: create_coverage_badge\n      uses: simon-k/dotnet-code-coverage-badge@v1.0.0\n      with:\n        label: 'Unit Test Coverage'\n        color: 'brightgreen'\n        path: 'UnitTests/TestResults/coverage.opencover.xml'\n        gist-filename: 'code-coverage.json'\n        gist-id: '90ef67a684cb71db1817921a970f8d27'\n        gist-auth-token: ${{ secrets.GIST_AUTH_TOKEN }}\n\n    - name: Print Code Coverage\n      run: |\n        echo \"Code coverage percentage: ${{steps.create_coverage_badge.outputs.percentage}}%\"\n        echo \"Badge data: ${{steps.create_coverage_badge.outputs.badge}}\"\n\n    - name: Publish to NuGet.org\n      run: dotnet nuget push Terminal.Gui/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json\n```", "answer": "```yaml name: Publish Terminal.Gui\non:\n  push:\n    tags:\n      - v*\n\njobs:\n\n  publish:\n    name: Build and Publish to Nuget.org\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 0 #fetch-depth is needed for GitVersion\n\n    - name: Install and calculate the new version with GitVersion \n      uses: gittools/actions/gitversion/setup@v0.9.13\n      with:\n        versionSpec: 5.x\n\n    - name: Determine Version\n      uses: gittools/actions/gitversion/execute@v0.9.13\n      id: gitversion # step id used as reference for output values\n\n    - name: Display GitVersion outputs\n      run: |\n        echo \"Version: ${{ steps.gitversion.outputs.SemVer }}\"\n        echo \"CommitsSinceVersionSource: ${{ steps.gitversion.outputs.CommitsSinceVersionSource }}\"\n\n    - name: Setup dotnet\n      uses: actions/setup-dotnet@v3.0.1\n      with:\n        dotnet-version: 6.0.100\n\n    - name: Install dependencies\n      run: dotnet restore\n\n    - name: Build Release\n      run: |\n        dotnet-gitversion /updateprojectfiles\n        dotnet build --no-restore -c Release\n\n    - name: Pack\n      run: dotnet pack -c Release --include-symbols -p:Version='${{ steps.gitversion.outputs.SemVer }}' \n\n    - name: Test to generate Code Coverage Report\n      run: |\n        dotnet test --verbosity normal --collect:\"XPlat Code Coverage\" --settings UnitTests/coverlet.runsettings\n        mv -v UnitTests/TestResults/*/*.* UnitTests/TestResults/\n\n    - name: Create Test Coverage Badge\n      uses: simon-k/dotnet-code-coverage-badge@v1.0.0\n      id: create_coverage_badge\n      with:\n        label: Unit Test Coverage\n        color: brightgreen\n        path: UnitTests/TestResults/coverage.opencover.xml\n        gist-filename: code-coverage.json\n        # https://gist.github.com/migueldeicaza/90ef67a684cb71db1817921a970f8d27\n        gist-id: 90ef67a684cb71db1817921a970f8d27\n        gist-auth-token: ${{ secrets.GIST_AUTH_TOKEN }}   \n\n    - name: Print Code Coverage\n      run: |\n        echo \"Code coverage percentage: ${{steps.create_coverage_badge.outputs.percentage}}%\"\n        echo \"Badge data: ${{steps.create_coverage_badge.outputs.badge}}\"\n        \n    #- name: Prep GitHub Packages\n    #  run: dotnet nuget add source --username tig --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/tig/index.json\"\n\n    #- name: Publish to GitHub packages \n    #  run: dotnet nuget push NStack/bin/Release/*.nupkg --api-key ${{ secrets.GITHUB_TOKEN }}  --source \"github\"\n\n    - name: Publish to NuGet.org\n      run: dotnet nuget push Terminal.Gui/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json\n```", "prompt": "Generate a GitHub Workflow named `Publish Terminal.Gui` for a GitHub repository whose primary programming language is C#. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Build and Publish to Nuget.org` and its job id is `publish`. This job will run on ubuntu-latest runner. The job `publish` has 12 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines an input parameter for the action: `fetch-depth` is set to `0`. The 2nd step is named `Install and calculate the new version with GitVersion`. This step runs action `gittools/actions/gitversion/setup` tagged as v0.9.13. The step defines an input parameter for the action: `versionSpec` is set to `5.x`. The 3rd step is named `Determine Version` and its id is `gitversion`. This step runs action `gittools/actions/gitversion/execute` tagged as v0.9.13. The 4th step is named `Display GitVersion outputs`. This step runs a script: `echo \"Version: ${{ steps.gitversion.outputs.SemVer }}\"\necho \"CommitsSinceVersionSource: ${{ steps.gitversion.outputs.CommitsSinceVersionSource }}\"\n`. The 5th step is named `Setup dotnet`. This step runs action `actions/setup-dotnet` tagged as v3.0.1. The step defines an input parameter for the action: `dotnet-version` is set to `6.0.100`. The 6th step is named `Install dependencies`. This step runs a script: `dotnet restore`. The 7th step is named `Build Release`. This step runs a script: `dotnet-gitversion /updateprojectfiles\ndotnet build --no-restore -c Release\n`. The 8th step is named `Pack`. This step runs a script: `dotnet pack -c Release --include-symbols -p:Version='${{ steps.gitversion.outputs.SemVer }}'`. The 9th step is named `Test to generate Code Coverage Report`. This step runs a script: `dotnet test --verbosity normal --collect:\"XPlat Code Coverage\" --settings UnitTests/coverlet.runsettings\nmv -v UnitTests/TestResults/*/*.* UnitTests/TestResults/\n`. The 10th step is named `Create Test Coverage Badge` and its id is `create_coverage_badge`. This step runs action `simon-k/dotnet-code-coverage-badge` tagged as v1.0.0. The step defines 6 input parameters for the action: `label` is set to `Unit Test Coverage`, `color` is set to `brightgreen`, `path` is set to `UnitTests/TestResults/coverage.opencover.xml`, `gist-filename` is set to `code-coverage.json`, `gist-id` is set to `90ef67a684cb71db1817921a970f8d27` and `gist-auth-token` is set to `${{ secrets.GIST_AUTH_TOKEN }}`. The 11th step is named `Print Code Coverage`. This step runs a script: `echo \"Code coverage percentage: ${{steps.create_coverage_badge.outputs.percentage}}%\"\necho \"Badge data: ${{steps.create_coverage_badge.outputs.badge}}\"\n`. The 12th step is named `Publish to NuGet.org`. This step runs a script: `dotnet nuget push Terminal.Gui/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json`. "}
{"id": "63c4950a7843b61269a0501c", "level": "level5", "llm_response": "```yaml\nname: Integration test on schedule (minimal)\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  start-integration-test-minimal:\n    id: start-integration-test-minimal\n    uses: ./.github/workflows/integration.yml\n    with:\n      install_profile: minimal\n      cluster_region: ams3\n      kubernetes_versions: ['1.22', '1.23']\n    secrets:\n      special_case_secrets: inherit\n```", "answer": "```yaml name: Integration test on schedule (minimal)\nconcurrency: ${{ github.workflow }}-${{ github.ref }}\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  start-integration-test-minimal:\n    name: Start integration test (minimal)\n    uses: ./.github/workflows/integration.yml\n    secrets: inherit\n    with:\n      install_profile: minimal\n      cluster_region: ams3\n      kubernetes_versions: \"['1.22', '1.23']\"\n```", "prompt": "Generate a GitHub Workflow named `Integration test on schedule (minimal)` for a GitHub repository whose primary programming language is Mustache. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. Only a single workflow using the ${{ github.workflow }}-${{ github.ref }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Start integration test (minimal)` and its job id is `start-integration-test-minimal`. This job will call a reusable workflow located at `./.github/workflows/integration.yml`. The job will pass 3 inputs to the called workflow: the input `install_profile` is `minimal`, the input `cluster_region` is `ams3` and the input `kubernetes_versions` is `['1.22', '1.23']`. The job will pass a secret to the called workflow: the secret `special_case_secrets` is `inherit`. "}
{"id": "63c494b08052faa2781aca76", "level": "level5", "llm_response": "```yaml\nname: CodeQL\n\non:\n  push:\n    branches:\n      - master\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    id: analyze\n    runs-on: macos-11\n    strategy:\n      matrix:\n        language: [cpp]\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@cc7986c02bac29104a72998e67239bb5ee2ee110\n        with:\n          languages: ${{ matrix.language }}\n      - name: Build\n        run: env NSUnbufferedIO=YES xcodebuild -workspace Sentry.xcworkspace -scheme Sentry -configuration Release -destination platform=\"iOS Simulator,OS=latest,name=iPhone 11 Pro\"\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@cc7986c02bac29104a72998e67239bb5ee2ee110\n```", "answer": "```yaml name: 'CodeQL'\n\non:\n  push:\n    branches: [master]\n  pull_request:\n  schedule:\n    - cron: '40 4 * * 6'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: macos-11\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: ['cpp']\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Initialize CodeQL\n        uses: github/codeql-action/init@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n        with:\n          languages: ${{ matrix.language }}\n\n      - run: >-\n          env NSUnbufferedIO=YES\n          xcodebuild\n          -workspace Sentry.xcworkspace\n          -scheme Sentry\n          -configuration Release\n          -destination platform=\"iOS Simulator,OS=latest,name=iPhone 11 Pro\"\n\n      - name: Perform CodeQL Analysis\n        uses: github/codeql-action/analyze@cc7986c02bac29104a72998e67239bb5ee2ee110 # pin@v2\n```", "prompt": "Generate a GitHub Workflow named `CodeQL` for a GitHub repository whose primary programming language is Objective-C. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master. 2) there is activity relating to a pull request. 3) the scheduled time has come: at 04:40 am, only on saturday. The workflow has one job. The 1st job is named `Analyze` and its job id is `analyze`. This job will run on macos-11 runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `language` has one value: cpp. The job `analyze` has 4 steps. The 1st step is named `Checkout repository`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Initialize CodeQL`. This step runs action `github/codeql-action/init` whose commit is cc7986c02bac29104a72998e67239bb5ee2ee110. The step defines an input parameter for the action: `languages` is set to `${{ matrix.language }}`. The 3rd step is named ``. This step runs a script: `env NSUnbufferedIO=YES xcodebuild -workspace Sentry.xcworkspace -scheme Sentry -configuration Release -destination platform=\"iOS Simulator,OS=latest,name=iPhone 11 Pro\"`. The 4th step is named `Perform CodeQL Analysis`. This step runs action `github/codeql-action/analyze` whose commit is cc7986c02bac29104a72998e67239bb5ee2ee110. "}
{"id": "63c496891e3364807577b43d", "level": "level5", "llm_response": "```yaml\nname: Check Actions rate limit\n\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    id: check\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check rate limit\n        env:\n          TOKEN: ${{ github.token }}\n        run: |\n          curl -v --no-progress-meter --header \"Authorization: Bearer $TOKEN\" https://api.github.com/rate_limit\n```", "answer": "```yaml name: Check Actions rate limit\non:\n  workflow_dispatch:\n\njobs:\n  check:\n    name: Check Actions rate limit\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check rate limit\n        env:\n          TOKEN: ${{ github.token }}\n        run: |\n          curl -v --no-progress-meter --header \"Authorization: Bearer $TOKEN\" https://api.github.com/rate_limit\n```", "prompt": "Generate a GitHub Workflow named `Check Actions rate limit` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Check Actions rate limit` and its job id is `check`. This job will run on ubuntu-latest runner. The job `check` has one step. The 1st step is named `Check rate limit`. The step sets an environment variable to use: `TOKEN` is set to `${{ github.token }}`. This step runs a script: `curl -v --no-progress-meter --header \"Authorization: Bearer $TOKEN\" https://api.github.com/rate_limit\n`. "}
{"id": "63c4969e1899db58864d41ee", "level": "level5", "llm_response": "```yaml\nname: Auto message on Creating Issue.\n\non:\n  issues:\n    types: [opened]\n\njobs:\n  greeting:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Create comment for issue\n        if: github.event_name == 'issues'\n        uses: peter-evans/create-or-update-comment@v1\n        with:\n          issue-number: ${{tojson(github.event.issue.number)}}\n          body: |\n            Hi \ud83d\ude04, @${{ github.actor }} Thanks for creating an issue at FunwithPhysics. We request you to follow the contributing guidelines.\n```", "answer": "```yaml name: Auto message on Creating Issue.\n\non:\n\n  issues:\n\n    types: [opened]\n\njobs:\n\n  greeting:\n\n    runs-on: ubuntu-latest\n\n    steps:\n\n    - name: Create comment for issue\n\n      if: github.event_name =='issues' \n\n      uses: peter-evans/create-or-update-comment@v1\n\n      with:\n\n        issue-number: ${{tojson(github.event.issue.number)}}\n\n        body: |\n\n            Hi \ud83d\ude04, @${{ github.actor }} Thanks for creating an issue at FunwithPhysics. We request you to follow the contributing guidelines. \n```", "prompt": "Generate a GitHub Workflow named `Auto message on Creating Issue.` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: an issue is opened. The workflow has one job. The job id of the 1st job is `greeting`. This job will run on ubuntu-latest runner. The job `greeting` has one step. The 1st step is named `Create comment for issue`. This step will run only if the condition(github.event_name =='issues') is met. This step runs action `peter-evans/create-or-update-comment` tagged as v1. The step defines 2 input parameters for the action: `issue-number` is set to `${{tojson(github.event.issue.number)}}` and `body` is set to `\nHi \ud83d\ude04, @${{ github.actor }} Thanks for creating an issue at FunwithPhysics. We request you to follow the contributing guidelines. \n`. "}
{"id": "63c496941899db58864d3d85", "level": "level5", "llm_response": "```yaml\nname: release-please\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release-please:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: GoogleCloudPlatform/release-please-action@v2\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          release-type: simple\n          version-file: ./version.txt\n          package-name: release-please-action\n          default-branch: master\n```", "answer": "```yaml name: release-please\non:\n   push:\n      branches:\n         - master\njobs:\n   release-please:\n      runs-on: ubuntu-latest\n      steps:\n         - uses: GoogleCloudPlatform/release-please-action@v2\n           with:\n            token: ${{ secrets.GITHUB_TOKEN }}\n            release-type: simple\n            version-file: \"./version.txt\"\n            package-name: release-please-action\n            default-branch: master\n```", "prompt": "Generate a GitHub Workflow named `release-please` for a GitHub repository whose primary programming language is Swift. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named master. The workflow has one job. The job id of the 1st job is `release-please`. This job will run on ubuntu-latest runner. The job `release-please` has one step. The 1st step is named ``. This step runs action `GoogleCloudPlatform/release-please-action` tagged as v2. The step defines 5 input parameters for the action: `token` is set to `${{ secrets.GITHUB_TOKEN }}`, `release-type` is set to `simple`, `version-file` is set to `./version.txt`, `package-name` is set to `release-please-action` and `default-branch` is set to `master`. "}
{"id": "63c496486fc19abdf9c9b0d5", "level": "level5", "llm_response": "```yaml\nname: Dependencies\n\non:\n  schedule:\n    - cron: '0 12 * * 1'\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    id: upgrade\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up pnpm\n        uses: pnpm/action-setup@v2\n        with:\n          version: latest\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          cache: pnpm\n          node-version-file: .nvmrc\n          registry-url: https://npm.pkg.github.com\n\n      - name: Clean up\n        run: rm -rf pnpm-lock.yaml **/node_modules/\n\n      - name: Set environment variable\n        run: echo \"NODE_AUTH_TOKEN=${{ secrets.NPM_GITHUB_TOKEN }}\" >> $GITHUB_ENV\n\n      - name: Install dependencies\n        run: pnpm install\n\n      - name: Add and commit changes\n        uses: EndBug/add-and-commit@v9\n        with:\n          message: chore(deps): upgrade versions\n```", "answer": "```yaml name: Dependencies\n\non:\n  schedule:\n    - cron: \"0 12 * * 1\"\n  workflow_dispatch:\n\njobs:\n  upgrade:\n    name: Upgrade dependencies\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: pnpm/action-setup@v2\n        with:\n          version: latest\n      - uses: actions/setup-node@v3\n        with:\n          cache: \"pnpm\"\n          node-version-file: \".nvmrc\"\n          registry-url: \"https://npm.pkg.github.com\"\n      - run: rm -rf pnpm-lock.yaml **/node_modules/\n      - run: pnpm install\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_GITHUB_TOKEN }}\n      - uses: EndBug/add-and-commit@v9\n        with:\n          message: \"chore(deps): upgrade versions\"\n```", "prompt": "Generate a GitHub Workflow named `Dependencies` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) the scheduled time has come: at 12:00 pm, only on monday. 2) someone manually triggers the workflow. The workflow has one job. The 1st job is named `Upgrade dependencies` and its job id is `upgrade`. This job will run on ubuntu-latest runner. The job `upgrade` has 6 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `pnpm/action-setup` tagged as v2. The step defines an input parameter for the action: `version` is set to `latest`. The 3rd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines 3 input parameters for the action: `cache` is set to `pnpm`, `node-version-file` is set to `.nvmrc` and `registry-url` is set to `https://npm.pkg.github.com`. The 4th step is named ``. This step runs a script: `rm -rf pnpm-lock.yaml **/node_modules/`. The 5th step is named ``. The step sets an environment variable to use: `NODE_AUTH_TOKEN` is set to `${{ secrets.NPM_GITHUB_TOKEN }}`. This step runs a script: `pnpm install`. The 6th step is named ``. This step runs action `EndBug/add-and-commit` tagged as v9. The step defines an input parameter for the action: `message` is set to `chore(deps): upgrade versions`. "}
{"id": "63c4954d8052faa2781b0e83", "level": "level5", "llm_response": "```yaml\nname: xgo\n\non:\n  push:\n    branches:\n      - master\n    tags:\n      - v*\n    paths-ignore:\n      - '**.md'\n  pull_request:\n    branches:\n      - master\n    paths-ignore:\n      - '**.md'\n\nconcurrency:\n  group: xgo-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Build artifacts\n        uses: docker/bake-action@v2\n        with:\n          targets: artifact-all\n\n      - name: Move artifacts\n        run: mv ./dist/**/* ./dist/\n\n      - name: Upload artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: xgo\n          path: ./dist/*\n          if-no-files-found: error\n\n      - name: GitHub Release\n        if: startsWith(github.ref, 'refs/tags/v')\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        uses: softprops/action-gh-release@v1\n        with:\n          draft: true\n          files: dist/*.tar.gz dist/*.zip\n```", "answer": "```yaml name: xgo\n\nconcurrency:\n  group: xgo-${{ github.ref }}\n  cancel-in-progress: true\n\non:\n  push:\n    branches:\n      - 'master'\n    tags:\n      - 'v*'\n    paths-ignore:\n      - '**.md'\n  pull_request:\n    branches:\n      - 'master'\n    paths-ignore:\n      - '**.md'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n      -\n        name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      -\n        name: Build artifacts\n        uses: docker/bake-action@v2\n        with:\n          targets: artifact-all\n      -\n        name: Move artifacts\n        run: |\n          mv ./dist/**/* ./dist/\n      -\n        name: Upload artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: xgo\n          path: ./dist/*\n          if-no-files-found: error\n      -\n        name: GitHub Release\n        uses: softprops/action-gh-release@v1\n        if: startsWith(github.ref, 'refs/tags/v')\n        with:\n          draft: true\n          files: |\n            dist/*.tar.gz\n            dist/*.zip\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```", "prompt": "Generate a GitHub Workflow named `xgo` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named master or a tag whose name matches v*. When all the path names of push event match patterns in the paths-ignore filter(**.md), the workflow will not run. 2) The workflow would run whenever there is a pull_request event targeting: a branch named master. When all the path names of pull_request event match patterns in the paths-ignore filter(**.md), the workflow will not run. Only a single workflow using the xgo-${{ github.ref }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 6 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Docker Buildx`. This step runs action `docker/setup-buildx-action` tagged as v2. The 3rd step is named `Build artifacts`. This step runs action `docker/bake-action` tagged as v2. The step defines an input parameter for the action: `targets` is set to `artifact-all`. The 4th step is named `Move artifacts`. This step runs a script: `mv ./dist/**/* ./dist/\n`. The 5th step is named `Upload artifacts`. This step runs action `actions/upload-artifact` tagged as v3. The step defines 3 input parameters for the action: `name` is set to `xgo`, `path` is set to `./dist/*` and `if-no-files-found` is set to `error`. The 6th step is named `GitHub Release`. This step will run only if the condition(startsWith(github.ref, 'refs/tags/v')) is met. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GITHUB_TOKEN }}`. This step runs action `softprops/action-gh-release` tagged as v1. The step defines 2 input parameters for the action: `draft` is set to `True` and `files` is set to `dist/*.tar.gz\ndist/*.zip\n`. "}
{"id": "63c494a48052faa2781ac54e", "level": "level5", "llm_response": "```yaml\nname: lint\n\non:\n  pull_request:\n    paths-ignore:\n      - docs/**\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - docs/**\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Run cspell\n        run: npx cspell \"**\" --dot --no-progress\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Install dependencies\n        run: yarn\n      - name: Run lint\n        run: yarn lint\n```", "answer": "```yaml name: lint\non: # rebuild any PRs and main branch changes\n  pull_request:\n    paths-ignore:\n      - \"docs/**\"\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - \"docs/**\"\n\njobs:\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npx cspell \"**\" --dot --no-progress\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: yarn\n      - run: yarn lint\n```", "prompt": "Generate a GitHub Workflow named `lint` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by multiple events: 1) When all the path names of pull_request event match patterns in the paths-ignore filter(docs/**), the workflow will not run. 2) The workflow would run whenever there is a push event to: a branch named main. When all the path names of push event match patterns in the paths-ignore filter(docs/**), the workflow will not run. The workflow has 2 jobs. The job id of the 1st job is `cspell`. This job will run on ubuntu-latest runner. The job `cspell` has 2 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs a script: `npx cspell \"**\" --dot --no-progress`. The job id of the 2nd job is `lint`. This job will run on ubuntu-latest runner. The job `lint` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs a script: `yarn`. The 3rd step is named ``. This step runs a script: `yarn lint`. "}
{"id": "63c4957d8052faa2781b229c", "level": "level5", "llm_response": "```yaml\nname: Build site nightly\n\non:\n  schedule:\n    - cron: '0 0 * * *'\n\njobs:\n  dot-release:\n    id: dot-release\n    runs-on: ubuntu-latest\n    steps:\n      - name: curl\n        uses: wei/curl@v1\n        env:\n          NETLIFY_BUILD_HOOK: ${{ secrets.NETLIFY_BUILD_HOOK }}\n        with:\n          args: -X POST -d '{}' \"$NETLIFY_BUILD_HOOK\"\n```", "answer": "```yaml # Copyright 2022 The Knative Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nname: Build site nightly\n\non:\n  schedule:\n    - cron: \"0 0 * * *\"\n\njobs:\n  dot-release:\n    name: dot-release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: curl\n        env:\n          NETLIFY_BUILD_HOOK: ${{ secrets.NETLIFY_BUILD_HOOK }}\n        uses: wei/curl@v1\n        with:\n          args: -X POST -d '{}' \"$NETLIFY_BUILD_HOOK\"\n```", "prompt": "Generate a GitHub Workflow named `Build site nightly` for a GitHub repository whose primary programming language is HTML. This workflow will be triggered by an event: the scheduled time has come: at 12:00 am. The workflow has one job. The 1st job is named `dot-release` and its job id is `dot-release`. This job will run on ubuntu-latest runner. The job `dot-release` has one step. The 1st step is named `curl`. The step sets an environment variable to use: `NETLIFY_BUILD_HOOK` is set to `${{ secrets.NETLIFY_BUILD_HOOK }}`. This step runs action `wei/curl` tagged as v1. The step defines an input parameter for the action: `args` is set to `-X POST -d '{}' \"$NETLIFY_BUILD_HOOK\"`. "}
{"id": "63c496891e3364807577b43a", "level": "level5", "llm_response": "```yaml\nname: Jetpack block performance\n\non:\n  schedule:\n    - cron: '0 */12 * * *'\n\njobs:\n  block-performance:\n    id: block-performance\n    runs-on: ubuntu-latest\n    timeout-minutes: 50\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '14'\n      - name: Checkout Gutenberg\n        uses: actions/checkout@v3\n        with:\n          repository: 'WordPress/gutenberg'\n          path: 'gutenberg'\n      - name: Build Gutenberg\n        run: |\n          npm ci\n          npm run build\n      - name: Cache npm\n        uses: actions/cache@v3\n        with:\n          path: '~/.npm'\n          key: ${{ runner.os }}-node-${{ hashFiles('gutenberg/**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n      - name: Setup tools for J\n        run: ./.github/actions/tool-setup\n      - name: Build Production Jetpack\n        run: |\n          pnpm install\n          pnpm jetpack build plugins/jetpack -v --production\n      - name: Environment set-up\n        env:\n          CONFIG_KEY: ${{ secrets.E2E_CONFIG_KEY }}\n        run: |\n          echo \"e2e:\" >> ../docker/jetpack-docker-config.yml\n          echo \"  volumeMappings:\" >> ../docker/jetpack-docker-config.yml\n          echo \"    gutenberg/packages/e2e-tests/plugins/disable-animations.php: /var/www/html/wp-content/plugins/disable-animations.php\" >> ../docker/jetpack-docker-config.yml\n          mkdir results\n          pnpm config:decrypt\n          pnpm env:start\n      - name: Run performance tests\n        run: node ./bin/performance.js\n      - name: Environment tear-down\n        if: always()\n        run: |\n          pnpm run tunnel:off\n          # Update permissions to workaround https://github.com/actions/cache/issues/753\n          sudo chown -R runner:docker \"$GITHUB_WORKSPACE/tools/docker\"\n      - name: Upload test artifacts\n        if: always()\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-output-block-perf\n          path: tools/e2e-commons/results\n\n  test-reports:\n    id: test-reports\n    runs-on: ubuntu-latest\n    needs: block-performance\n    if: !cancelled()\n    steps:\n      - name: Repository Dispatch\n        uses: peter-evans/repository-dispatch@v2\n        with:\n          token: ${{ secrets.E2E_TEST_REPORTS_TOKEN }}\n          repository: 'automattic/jetpack-e2e-reports'\n          event-type: 'block-perf'\n          client-payload: '{\"run_id\": \"${{github.run_id}}\", \"repository\": \"${{github.repository}}\" }'\n\n  slack-notification:\n    id: slack-notification\n    runs-on: ubuntu-latest\n    needs: block-performance\n    if: !cancelled()\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n      - name: Set up tools\n        run: ./.github/actions/tool-setup\n      - name: Build action\n        env:\n          COMPOSER_ROOT_VERSION: 'dev-trunk'\n        run: |\n          pnpm install\n          composer install\n          composer build-development\n      - name: Send notification\n        uses: ./projects/github-actions/test-results-to-slack\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          slack_token: ${{ secrets.SLACK_TOKEN }}\n          slack_channel: ${{ secrets.SLACK_E2E_CHANNEL }}\n          slack_icon_emoji: ':jetpack:'\n          suite_name: 'blocks performance'\n```", "answer": "```yaml name: Jetpack block performance\n\non:\n  schedule:\n    - cron:  '0 */12 * * *'\n\njobs:\n  block-performance:\n    name: \"Performance tests\"\n    runs-on: ubuntu-latest\n    timeout-minutes: 50  # 2021-12-13: Successful runs seem to take 40 minutes\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 14\n\n      - uses: actions/checkout@v3\n        with:\n          repository: 'WordPress/gutenberg'\n          path: 'gutenberg'\n\n      - name: Build Gutenberg\n        working-directory: gutenberg\n        run: |\n          npm ci\n          npm run build\n\n      - uses: actions/cache@v3\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('gutenberg/**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - name: Setup tools for J\n        uses: ./.github/actions/tool-setup\n\n      - name: Build Production Jetpack\n        run: |\n          pnpm install\n          pnpm jetpack build plugins/jetpack -v --production\n\n      - name: Environment set-up\n        working-directory: tools/e2e-commons\n        env:\n          CONFIG_KEY: ${{ secrets.E2E_CONFIG_KEY }}\n        run: |\n          # Gutenberg Performance tests require disable-animations.php test plugin to be available on a site. Below we inject the mapping for that plugin into a Docker config file\n\n          echo \"e2e:\" >> ../docker/jetpack-docker-config.yml\n          echo \"  volumeMappings:\" >> ../docker/jetpack-docker-config.yml\n          echo \"    gutenberg/packages/e2e-tests/plugins/disable-animations.php: /var/www/html/wp-content/plugins/disable-animations.php\" >> ../docker/jetpack-docker-config.yml\n\n          mkdir results\n          pnpm config:decrypt\n          pnpm env:start\n\n      - name: Run performance tests\n        working-directory: tools/e2e-commons\n        run: |\n          node ./bin/performance.js\n\n      - name: Environment tear-down\n        if: ${{ always() }}\n        working-directory: tools/e2e-commons\n        continue-on-error: true\n        run: |\n          pnpm run tunnel:off\n          # Update permissions to workaround https://github.com/actions/cache/issues/753\n          sudo chown -R runner:docker \"$GITHUB_WORKSPACE/tools/docker\"\n\n      - name: Upload test artifacts\n        if: ${{ always() }}\n        continue-on-error: true\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-output-block-perf\n          path: tools/e2e-commons/results\n\n  test-reports:\n    name: \"Trigger test report workflow\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: block-performance\n\n    steps:\n      - name: Repository Dispatch\n        uses: peter-evans/repository-dispatch@v2\n        with:\n          token: ${{ secrets.E2E_TEST_REPORTS_TOKEN }}\n          repository: automattic/jetpack-e2e-reports\n          event-type: block-perf\n          client-payload: '{\"run_id\": \"${{github.run_id}}\", \"repository\": \"${{github.repository}}\"}'\n\n  slack-notification:\n    name: \"Slack notification\"\n    runs-on: ubuntu-latest\n    if: ${{ ! cancelled() }}\n    needs: [block-performance]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up tools\n        uses: ./.github/actions/tool-setup\n\n      - name: Build action\n        env:\n          COMPOSER_ROOT_VERSION: dev-trunk\n        run: |\n          pnpm install\n          composer install\n          composer build-development\n        working-directory: ./projects/github-actions/test-results-to-slack\n\n      - name: \"Send notification\"\n        uses: ./projects/github-actions/test-results-to-slack\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          slack_token: ${{ secrets.SLACK_TOKEN }}\n          slack_channel: ${{ secrets.SLACK_E2E_CHANNEL }}\n          slack_icon_emoji: \":jetpack:\"\n          suite_name: \"blocks performance\"\n```", "prompt": "Generate a GitHub Workflow named `Jetpack block performance` for a GitHub repository whose primary programming language is PHP. This workflow will be triggered by an event: the scheduled time has come: every 12 hours. The workflow has 3 jobs. The 1st job is named `Performance tests` and its job id is `block-performance`. This job will run on ubuntu-latest runner. The maximum number of minutes to run the job is 50. The job `block-performance` has 11 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named ``. This step runs action `actions/setup-node` tagged as v3. The step defines an input parameter for the action: `node-version` is set to `14`. The 3rd step is named ``. This step runs action `actions/checkout` tagged as v3. The step defines 2 input parameters for the action: `repository` is set to `WordPress/gutenberg` and `path` is set to `gutenberg`. The 4th step is named `Build Gutenberg`. This step runs a script: `npm ci\nnpm run build\n`. The 5th step is named ``. This step runs action `actions/cache` tagged as v3. The step defines 3 input parameters for the action: `path` is set to `~/.npm`, `key` is set to `${{ runner.os }}-node-${{ hashFiles('gutenberg/**/package-lock.json') }}` and `restore-keys` is set to `${{ runner.os }}-node-\n`. The 6th step is named `Setup tools for J`. This step runs action `./.github/actions/tool-setup`.The 7th step is named `Build Production Jetpack`. This step runs a script: `pnpm install\npnpm jetpack build plugins/jetpack -v --production\n`. The 8th step is named `Environment set-up`. The step sets an environment variable to use: `CONFIG_KEY` is set to `${{ secrets.E2E_CONFIG_KEY }}`. This step runs a script: `# Gutenberg Performance tests require disable-animations.php test plugin to be available on a site. Below we inject the mapping for that plugin into a Docker config file\n\necho \"e2e:\" >> ../docker/jetpack-docker-config.yml\necho \"  volumeMappings:\" >> ../docker/jetpack-docker-config.yml\necho \"    gutenberg/packages/e2e-tests/plugins/disable-animations.php: /var/www/html/wp-content/plugins/disable-animations.php\" >> ../docker/jetpack-docker-config.yml\n\nmkdir results\npnpm config:decrypt\npnpm env:start\n`. The 9th step is named `Run performance tests`. This step runs a script: `node ./bin/performance.js\n`. The 10th step is named `Environment tear-down`. This step will run only if the condition(${{ always() }}) is met. This step runs a script: `pnpm run tunnel:off\n# Update permissions to workaround https://github.com/actions/cache/issues/753\nsudo chown -R runner:docker \"$GITHUB_WORKSPACE/tools/docker\"\n`. When this step fails, the job will move on to the next step. The 11th step is named `Upload test artifacts`. This step will run only if the condition(${{ always() }}) is met. This step runs action `actions/upload-artifact` tagged as v3. The step defines 2 input parameters for the action: `name` is set to `test-output-block-perf` and `path` is set to `tools/e2e-commons/results`. When this step fails, the job will move on to the next step. The 2nd job is named `Trigger test report workflow` and its job id is `test-reports`. Before this job runs, `block-performance` must complete successfully. This job will run only if the condition(${{ ! cancelled() }}) is met. This job will run on ubuntu-latest runner. The job `test-reports` has one step. The 1st step is named `Repository Dispatch`. This step runs action `peter-evans/repository-dispatch` tagged as v2. The step defines 4 input parameters for the action: `token` is set to `${{ secrets.E2E_TEST_REPORTS_TOKEN }}`, `repository` is set to `automattic/jetpack-e2e-reports`, `event-type` is set to `block-perf` and `client-payload` is set to `{\"run_id\": \"${{github.run_id}}\", \"repository\": \"${{github.repository}}\"}`. The 3rd job is named `Slack notification` and its job id is `slack-notification`. Before this job runs, `block-performance` must complete successfully. This job will run only if the condition(${{ ! cancelled() }}) is met. This job will run on ubuntu-latest runner. The job `slack-notification` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up tools`. This step runs action `./.github/actions/tool-setup`.The 3rd step is named `Build action`. The step sets an environment variable to use: `COMPOSER_ROOT_VERSION` is set to `dev-trunk`. This step runs a script: `pnpm install\ncomposer install\ncomposer build-development\n`. The 4th step is named `Send notification`. This step runs action `./projects/github-actions/test-results-to-slack`.The step defines 5 input parameters for the action: `github_token` is set to `${{ secrets.GITHUB_TOKEN }}`, `slack_token` is set to `${{ secrets.SLACK_TOKEN }}`, `slack_channel` is set to `${{ secrets.SLACK_E2E_CHANNEL }}`, `slack_icon_emoji` is set to `:jetpack:` and `suite_name` is set to `blocks performance`. "}
{"id": "63c4968633b087f6bde2c8ea", "level": "level5", "llm_response": "```yaml\nname: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - '[0-9]+.[0-9]+.[0-9]+'\n      - '[0-9]+.[0-9]+.[0-9]+rc[0-9]+'\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment: [py36, py37, flake8]\n        python: [3.6, 3.7]\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Install tox\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install tox\n\n      - name: Run tox\n        run: tox -e ${{ matrix.environment }}\n```", "answer": "```yaml name: Run checks\n\non:\n  push:\n    branches:\n      - main\n    tags:\n      - \"[0-9]+.[0-9]+.[0-9]+\"\n      - \"[0-9]+.[0-9]+.[0-9]+rc[0-9]+\"\n\n  pull_request:\n    branches:\n      - main\n\njobs:\n  tox:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment:\n          - \"py36\"\n          - \"py37\"\n          - \"flake8\"\n\n        include:\n          - environment: \"py36\"\n            python: \"3.6\"\n          - environment: \"py37\"\n            python: \"3.7\"\n          - environment: \"flake8\"\n            python: \"3.7\"\n\n    container:\n      image: python:${{ matrix.python }}\n\n    steps:\n      - uses: actions/checkout@master\n      - name: Install tox\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install tox\n      - name: Run tox\n        run: |\n          tox -e ${{ matrix.environment }}\n```", "prompt": "Generate a GitHub Workflow named `Run checks` for a GitHub repository whose primary programming language is Python. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main, a tag whose name matches [0-9]+.[0-9]+.[0-9]+ or a tag whose name matches [0-9]+.[0-9]+.[0-9]+rc[0-9]+. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. The workflow has one job. The job id of the 1st job is `tox`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `environment` has 3 values: py36, py37 and flake8. For each object in the [{'environment': 'py36', 'python': '3.6'}, {'environment': 'py37', 'python': '3.7'}, {'environment': 'flake8', 'python': '3.7'}] list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. The job creates a Docker container that uses `python:${{ matrix.python }}` image. The job `tox` has 3 steps. The 1st step is named ``. This step runs action `actions/checkout` from the master branch. The 2nd step is named `Install tox`. This step runs a script: `python -m pip install --upgrade pip\npython -m pip install tox\n`. The 3rd step is named `Run tox`. This step runs a script: `tox -e ${{ matrix.environment }}\n`. "}
{"id": "63c494187843b612699fef56", "level": "level5", "llm_response": "```yaml\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug:\n        description: 'Enable debug mode'\n        required: false\n        default: false\n        type: boolean\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: false\n\njobs:\n  fork_update_pr:\n    id: fork_update_pr\n    runs-on: ubuntu-latest\n    if: github.repository_owner != 'HariSekhon'\n    steps:\n      - name: Call reusable workflow\n        uses: HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master\n        with:\n          debug: ${{ github.event.inputs.debug }}\n```", "answer": "```yaml #\n#  Author: Hari Sekhon\n#  Date: Tue Feb 4 09:53:28 2020 +0000\n#\n#  vim:ts=2:sts=2:sw=2:et\n#\n#  https://github.com/HariSekhon/Kubernetes-configs\n#\n#  If you're using my code you're welcome to connect with me on LinkedIn and optionally send me feedback\n#\n#  https://www.linkedin.com/in/HariSekhon\n#\n\n---\nname: Fork Update PR\n\non:\n  workflow_dispatch:\n    inputs:\n      debug:\n        type: boolean\n        required: false\n        default: false\n  schedule:\n    - cron: '0 10 * * 1'\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: ${{ github.ref }}-${{ github.workflow }}\n  cancel-in-progress: false\n\njobs:\n  fork_update_pr:\n    # github.event.repository context not available in scheduled workflows\n    #if: github.event.repository.fork == true\n    if: github.repository_owner != 'HariSekhon'\n    name: Fork Update PR\n    uses: HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master\n    with:\n      debug: ${{ github.event.inputs.debug }}\n```", "prompt": "Generate a GitHub Workflow named `Fork Update PR` for a GitHub repository whose primary programming language is Shell. This workflow will be triggered by multiple events: 1) someone manually triggers the workflow. This workflow receives an input: debug-the data type is boolean, it is optional and its default value is False. 2) the scheduled time has come: at 10:00 am, only on monday. The workflow modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `contents` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the ${{ github.ref }}-${{ github.workflow }} concurrency group will run at a time. The workflow has one job. The 1st job is named `Fork Update PR` and its job id is `fork_update_pr`. This job will run only if the condition(github.repository_owner != 'HariSekhon') is met. This job will call a reusable workflow located at `HariSekhon/GitHub-Actions/.github/workflows/fork-update-pr.yaml@master`. The job will pass an input to the called workflow: the input `debug` is `${{ github.event.inputs.debug }}`. "}
{"id": "63c494e67843b61269a04123", "level": "level5", "llm_response": "```yaml\nname: CI\n\non:\n  pull_request:\n    branches:\n      - '**'\n    paths-ignore:\n      - .github/**\n      - .vscode/**\n      - README.md\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '2.10.4'\n          channel: stable\n      - name: Checkout OneSignal-Flutter-SDK\n        uses: actions/checkout@v3\n      - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n        run: flutter pub get\n      - name: Static Analysis\n        run: flutter analyze\n      - name: Ensure the Dart code is formatted correctly\n        run: flutter format --set-exit-if-changed --dry-run .\n      - name: Run Flutter unit tests\n        run: flutter test\n```", "answer": "```yaml name: CI\non:\n  pull_request:\n    branches:\n      - '**'\n    paths-ignore:\n      - '.github/**'\n      - '.vscode/**'\n      - 'README.md'\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '2.10.4'\n          channel: 'stable'\n\n      - name: Checkout OneSignal-Flutter-SDK\n        uses: actions/checkout@v3\n\n      - name: Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6\n        run: flutter pub get\n\n      - name: Static Analysis\n        run: flutter analyze\n\n      - name: Ensure the Dart code is formatted correctly\n        run: flutter format --set-exit-if-changed --dry-run .\n\n      - name: Run Flutter unit tests\n        run: flutter test\n```", "prompt": "Generate a GitHub Workflow named `CI` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a pull_request event targeting: a branch whose name matches **. When all the path names of pull_request event match patterns in the paths-ignore filter(.github/**, .vscode/** or README.md), the workflow will not run. 2) someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 6 steps. The 1st step is named `Setup Flutter`. This step runs action `subosito/flutter-action` tagged as v2. The step defines 2 input parameters for the action: `flutter-version` is set to `2.10.4` and `channel` is set to `stable`. The 2nd step is named `Checkout OneSignal-Flutter-SDK`. This step runs action `actions/checkout` tagged as v3. The 3rd step is named `Install Dependencies \ud83d\udd17\u26d3\ud83d\udce6`. This step runs a script: `flutter pub get`. The 4th step is named `Static Analysis`. This step runs a script: `flutter analyze`. The 5th step is named `Ensure the Dart code is formatted correctly`. This step runs a script: `flutter format --set-exit-if-changed --dry-run .`. The 6th step is named `Run Flutter unit tests`. This step runs a script: `flutter test`. "}
{"id": "63c4957b8052faa2781b219f", "level": "level5", "llm_response": "```yaml\nname: Go\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - '**.go'\n  pull_request:\n    branches:\n      - main\n    paths:\n      - '**.go'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: 1.18\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -cover -v ./...\n```", "answer": "```yaml name: Go\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - '**.go'\n  pull_request:\n    branches: [ main ]\n    paths:\n      - '**.go'\n\njobs:\n\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Go\n      uses: actions/setup-go@v3\n      with:\n        go-version: 1.18\n\n    - name: Build\n      run: go build -v ./...\n\n    - name: Test\n      run: go test -cover -v ./...\n```", "prompt": "Generate a GitHub Workflow named `Go` for a GitHub repository whose primary programming language is Go. This workflow will be triggered by multiple events: 1) The workflow would run whenever there is a push event to: a branch named main. Only if at least one path of push event matches a pattern in the paths filter(**.go), the workflow runs. 2) The workflow would run whenever there is a pull_request event targeting: a branch named main. Only if at least one path of pull_request event matches a pattern in the paths filter(**.go), the workflow runs. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 4 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Set up Go`. This step runs action `actions/setup-go` tagged as v3. The step defines an input parameter for the action: `go-version` is set to `1.18`. The 3rd step is named `Build`. This step runs a script: `go build -v ./...`. The 4th step is named `Test`. This step runs a script: `go test -cover -v ./...`. "}
{"id": "63c495928052faa2781b2bc1", "level": "level5", "llm_response": "```yaml\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    id: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Create Release\n        id: create_release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}\n        uses: actions/create-release@latest\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: ${{ github.ref }}\n          draft: False\n          prerelease: False\n```", "answer": "```yaml \n# https://github.com/actions/create-release\nname: Create Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    name: Create Release\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@master\n\n      - name: Create Release\n        id: create_release\n        uses: actions/create-release@latest\n        env:\n          GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}\n        with:\n          tag_name: ${{ github.ref }}\n          release_name: ${{ github.ref }}\n          draft: false\n          prerelease: false\n```", "prompt": "Generate a GitHub Workflow named `Create Release` for a GitHub repository whose primary programming language is Erlang. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a tag whose name matches v*. The workflow has one job. The 1st job is named `Create Release` and its job id is `build`. This job will run on ubuntu-latest runner. The job `build` has 2 steps. The 1st step is named `Checkout code`. This step runs action `actions/checkout` from the master branch. The 2nd step is named `Create Release` and its id is `create_release`. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.GIT_TOKEN }}`. This step runs action `actions/create-release` tagged as latest. The step defines 4 input parameters for the action: `tag_name` is set to `${{ github.ref }}`, `release_name` is set to `${{ github.ref }}`, `draft` is set to `False` and `prerelease` is set to `False`. "}
{"id": "63c496686fc19abdf9c9bea4", "level": "level5", "llm_response": "```yaml\nname: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Set environment variable\n        run: echo \"GITHUB_TOKEN=${{ secrets.ADMIN_GITHUB_TOKEN }}\" >> $GITHUB_ENV\n\n      - name: Update release draft\n        uses: release-drafter/release-drafter@v5\n```", "answer": "```yaml name: Drafts/updates the next repository release\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  update_release_draft:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: release-drafter/release-drafter@v5\n        env:\n          GITHUB_TOKEN: ${{ secrets.ADMIN_GITHUB_TOKEN }}```", "prompt": "Generate a GitHub Workflow named `Drafts/updates the next repository release` for a GitHub repository whose primary programming language is Scala. This workflow will be triggered by an event: The workflow would run whenever there is a push event to: a branch named main. The workflow has one job. The job id of the 1st job is `update_release_draft`. This job will run on ubuntu-latest runner. The job `update_release_draft` has one step. The 1st step is named ``. The step sets an environment variable to use: `GITHUB_TOKEN` is set to `${{ secrets.ADMIN_GITHUB_TOKEN }}`. This step runs action `release-drafter/release-drafter` tagged as v5. "}
{"id": "63c494768052faa2781ab616", "level": "level5", "llm_response": "```yaml\nname: Static analysis\n\non:\n  pull_request:\n\njobs:\n  static-psalm-analysis:\n    id: static-psalm-analysis\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ocp-version: [v20.0.7, v21.0.0, dev-stable22, dev-stable23, dev-master]\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@master\n\n    - name: Set up PHP\n      uses: shivammathur/setup-php@master\n      with:\n        php-version: '7.4'\n        tools: 'composer:v1'\n        coverage: 'none'\n\n    - name: Install dependencies\n      run: composer i\n\n    - name: Install dependencies\n      run: composer require --dev christophwurst/nextcloud:${{ matrix.ocp-version }}\n\n    - name: Run coding standards check\n      run: composer run psalm\n```", "answer": "```yaml name: Static analysis\n\non: [pull_request]\n\njobs:\n  static-psalm-analysis:\n      runs-on: ubuntu-latest\n      strategy:\n          matrix:\n              ocp-version: [ 'v20.0.7', 'v21.0.0', 'dev-stable22', 'dev-stable23', 'dev-master' ]\n      name: Nextcloud ${{ matrix.ocp-version }}\n      steps:\n          - name: Checkout\n            uses: actions/checkout@master\n          - name: Set up php\n            uses: shivammathur/setup-php@master\n            with:\n                php-version: 7.4\n                tools: composer:v1\n                coverage: none\n          - name: Install dependencies\n            run: composer i\n          - name: Install dependencies\n            run: composer require --dev christophwurst/nextcloud:${{ matrix.ocp-version }}\n          - name: Run coding standards check\n            run: composer run psalm\n```", "prompt": "Generate a GitHub Workflow named `Static analysis` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow has one job. The 1st job is named `Nextcloud ${{ matrix.ocp-version }}` and its job id is `static-psalm-analysis`. This job will run on ubuntu-latest runner. The job uses a matrix strategy to automatically create multiple job runs that are based on the combinations of the variables. The variable `ocp-version` has 5 values: v20.0.7, v21.0.0, dev-stable22, dev-stable23 and dev-master. The job `static-psalm-analysis` has 5 steps. The 1st step is named `Checkout`. This step runs action `actions/checkout` from the master branch. The 2nd step is named `Set up php`. This step runs action `shivammathur/setup-php` from the master branch. The step defines 3 input parameters for the action: `php-version` is set to `7.4`, `tools` is set to `composer:v1` and `coverage` is set to `none`. The 3rd step is named `Install dependencies`. This step runs a script: `composer i`. The 4th step is named `Install dependencies`. This step runs a script: `composer require --dev christophwurst/nextcloud:${{ matrix.ocp-version }}`. The 5th step is named `Run coding standards check`. This step runs a script: `composer run psalm`. "}
{"id": "63c4951f8052faa2781af9e5", "level": "level5", "llm_response": "```yaml\nname: IRC Notification\n\non:\n  push:\n    branches:\n      - master\n  repository_dispatch:\n    types:\n      - clone\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: irc push\n        if: github.event_name == 'push' && github.event.ref == 'refs/heads/master' && github.repository == 'CollaboraOnline/online'\n        uses: vmiklos/notify-irc@bfd6f632b683859f6cd074e2ee9db68bef204f7d\n        with:\n          channel: '#cool-dev'\n          nickname: 'github-online'\n          message: ${{ toJson(github.event) }}\n```", "answer": "```yaml name: \"IRC Notification\"\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: irc push\n        uses: vmiklos/notify-irc@bfd6f632b683859f6cd074e2ee9db68bef204f7d\n        if: github.event_name == 'push' && github.event.ref == 'refs/heads/master' && github.repository == 'CollaboraOnline/online'\n        with:\n          channel: \"#cool-dev\"\n          nickname: github-online\n          message: |\n            ${{ toJson(github.event) }}\n```", "prompt": "Generate a GitHub Workflow named `IRC Notification` for a GitHub repository whose primary programming language is JavaScript. This workflow will be triggered by an event: a commit or tag is pushed, or a repository is cloned. The workflow has one job. The job id of the 1st job is `test`. This job will run on ubuntu-latest runner. The job `test` has one step. The 1st step is named `irc push`. This step will run only if the condition(github.event_name == 'push' && github.event.ref == 'refs/heads/master' && github.repository == 'CollaboraOnline/online') is met. This step runs action `vmiklos/notify-irc` whose commit is bfd6f632b683859f6cd074e2ee9db68bef204f7d. The step defines 3 input parameters for the action: `channel` is set to `#cool-dev`, `nickname` is set to `github-online` and `message` is set to `${{ toJson(github.event) }}\n`. "}
{"id": "63c493ee7843b612699fde0c", "level": "level5", "llm_response": "```yaml\nname: nf-core AWS test\n\non:\n  workflow_dispatch:\n\njobs:\n  run-tower:\n    runs-on: ubuntu-latest\n    if: github.repository == 'nf-core/mag'\n    steps:\n      - name: Launch workflow via tower\n        uses: nf-core/tower-action@v3\n        with:\n          workspace_id: ${{ secrets.TOWER_WORKSPACE_ID }}\n          access_token: ${{ secrets.TOWER_ACCESS_TOKEN }}\n          compute_env: ${{ secrets.TOWER_COMPUTE_ENV }}\n          workdir: s3://${{ secrets.AWS_S3_BUCKET }}/work/mag/work-${{ github.sha }}\n          parameters: |\n            {\n              \"outdir\": \"s3://${{ secrets.AWS_S3_BUCKET }}/mag/results-test-${{ github.sha }}\"\n            }\n          profiles: test,aws_tower\n```", "answer": "```yaml name: nf-core AWS test\n# This workflow can be triggered manually with the GitHub actions workflow dispatch button.\n# It runs the -profile 'test' on AWS batch\n\non:\n  workflow_dispatch:\njobs:\n  run-tower:\n    name: Run AWS tests\n    if: github.repository == 'nf-core/mag'\n    runs-on: ubuntu-latest\n    steps:\n      # Launch workflow using Tower CLI tool action\n      - name: Launch workflow via tower\n        uses: nf-core/tower-action@v3\n        with:\n          workspace_id: ${{ secrets.TOWER_WORKSPACE_ID }}\n          access_token: ${{ secrets.TOWER_ACCESS_TOKEN }}\n          compute_env: ${{ secrets.TOWER_COMPUTE_ENV }}\n          workdir: s3://${{ secrets.AWS_S3_BUCKET }}/work/mag/work-${{ github.sha }}\n          parameters: |\n            {\n              \"outdir\": \"s3://${{ secrets.AWS_S3_BUCKET }}/mag/results-test-${{ github.sha }}\"\n            }\n          profiles: test,aws_tower\n```", "prompt": "Generate a GitHub Workflow named `nf-core AWS test` for a GitHub repository whose primary programming language is Nextflow. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The 1st job is named `Run AWS tests` and its job id is `run-tower`. This job will run only if the condition(github.repository == 'nf-core/mag') is met. This job will run on ubuntu-latest runner. The job `run-tower` has one step. The 1st step is named `Launch workflow via tower`. This step runs action `nf-core/tower-action` tagged as v3. The step defines 6 input parameters for the action: `workspace_id` is set to `${{ secrets.TOWER_WORKSPACE_ID }}`, `access_token` is set to `${{ secrets.TOWER_ACCESS_TOKEN }}`, `compute_env` is set to `${{ secrets.TOWER_COMPUTE_ENV }}`, `workdir` is set to `s3://${{ secrets.AWS_S3_BUCKET }}/work/mag/work-${{ github.sha }}`, `parameters` is set to `{\n  \"outdir\": \"s3://${{ secrets.AWS_S3_BUCKET }}/mag/results-test-${{ github.sha }}\"\n}\n` and `profiles` is set to `test,aws_tower`. "}
{"id": "63c496981899db58864d3f73", "level": "level5", "llm_response": "```yaml\nname: Triage tasks\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: triage-${{ github.event.number }}\n  cancel-in-progress: true\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Check commit format\n        uses: Homebrew/actions/check-commit-format@master\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n\n      - name: Label pull request\n        if: always()\n        uses: Homebrew/actions/label-pull-requests@master\n        with:\n          token: ${{ secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN }}\n          def: |\n            - label: new cask\n              status: added\n              path: Casks/.+\n\n            - label: marked for removal/rejection\n              status: removed\n              path: Casks/.+\n\n            - label: documentation\n              path: (.*\\.md|\\.github/ISSUE_TEMPLATE/.*\\.yml)\n\n            - label: bump-cask-pr\n              pr_body_content: Created with `brew bump-cask-pr`\n\n            - label: missing description\n              path: Casks/.+\n              missing_content: \\n  desc .+\\n\n\n            - label: appcast migration needed\n              path: Casks/.+\n              content: \\n  appcast .+\\n\n```", "answer": "```yaml name: Triage tasks\n\non: pull_request_target\n\nconcurrency:\n  group: \"triage-${{ github.event.number }}\"\n  cancel-in-progress: true\n\npermissions:\n  contents: read\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check commit format\n        uses: Homebrew/actions/check-commit-format@master\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n      - name: Label pull request\n        uses: Homebrew/actions/label-pull-requests@master\n        if: always()\n        with:\n          token: ${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}\n          def: |\n            - label: new cask\n              status: added\n              path: Casks/.+\n\n            - label: marked for removal/rejection\n              status: removed\n              path: Casks/.+\n\n            - label: documentation\n              path: (.*\\.md|\\.github/ISSUE_TEMPLATE/.*\\.yml)\n\n            - label: bump-cask-pr\n              pr_body_content: Created with `brew bump-cask-pr`\n\n            - label: missing description\n              path: Casks/.+\n              missing_content: \\n  desc .+\\n\n\n            - label: appcast migration needed\n              path: Casks/.+\n              content: \\n  appcast .+\\n\n```", "prompt": "Generate a GitHub Workflow named `Triage tasks` for a GitHub repository whose primary programming language is Ruby. This workflow will be triggered by an event: there is activity relating to a pull request. The workflow modifies the default permissions for the GITHUB_TOKEN: read access is granted to the GITHUB_TOKEN in the `contents` scope. This permission setting applies to all jobs in the workflow. Only a single workflow using the triage-${{ github.event.number }} concurrency group will run at a time. When this workflow is queued, any currently running workflow in the same concurrency group will be canceled. The workflow has one job. The job id of the 1st job is `triage`. This job will run on ubuntu-latest runner. The job `triage` has 2 steps. The 1st step is named `Check commit format`. This step runs action `Homebrew/actions/check-commit-format` from the master branch. The step defines an input parameter for the action: `token` is set to `${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}`. The 2nd step is named `Label pull request`. This step will run only if the condition(always()) is met. This step runs action `Homebrew/actions/label-pull-requests` from the master branch. The step defines 2 input parameters for the action: `token` is set to `${{secrets.HOMEBREW_GITHUB_PUBLIC_REPO_TOKEN}}` and `def` is set to `- label: new cask\n  status: added\n  path: Casks/.+\n\n- label: marked for removal/rejection\n  status: removed\n  path: Casks/.+\n\n- label: documentation\n  path: (.*\\.md|\\.github/ISSUE_TEMPLATE/.*\\.yml)\n\n- label: bump-cask-pr\n  pr_body_content: Created with `brew bump-cask-pr`\n\n- label: missing description\n  path: Casks/.+\n  missing_content: \\n  desc .+\\n\n\n- label: appcast migration needed\n  path: Casks/.+\n  content: \\n  appcast .+\\n\n`. "}
{"id": "63c494a27843b61269a02781", "level": "level5", "llm_response": "```yaml\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n    - cron: '0 8 * * *'\n\njobs:\n  stale:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n    steps:\n      - uses: actions/stale@v5\n        with:\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n          ascending: 'true'\n          stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n          stale-pr-message: 'This PR has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n          stale-issue-label: 'no-issue-activity'\n          stale-pr-label: 'no-pr-activity'\n```", "answer": "```yaml # This workflow warns and then closes issues and PRs that have had no activity for a specified amount of time.\n#\n# You can adjust the behavior by modifying this file.\n# For more information, see:\n# https://github.com/actions/stale\nname: Mark stale issues and pull requests\n\non:\n  schedule:\n  - cron: '16 8 * * *'\n\njobs:\n  stale:\n\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n    - uses: actions/stale@v5\n      with:\n        repo-token: ${{ secrets.GITHUB_TOKEN }}\n        ascending: true\n        stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-pr-message: 'This PR has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions'\n        stale-issue-label: 'no-issue-activity'\n        stale-pr-label: 'no-pr-activity'\n```", "prompt": "Generate a GitHub Workflow named `Mark stale issues and pull requests` for a GitHub repository whose primary programming language is Dart. This workflow will be triggered by an event: the scheduled time has come: at 08:16 am. The workflow has one job. The job id of the 1st job is `stale`. This job will run on ubuntu-latest runner. The job `stale` modifies the default permissions for the GITHUB_TOKEN: write access is granted to the GITHUB_TOKEN in the `issues` scope and write access is granted to the GITHUB_TOKEN in the `pull-requests` scope. This permission setting only applies to the job `stale`. The job `stale` has one step. The 1st step is named ``. This step runs action `actions/stale` tagged as v5. The step defines 6 input parameters for the action: `repo-token` is set to `${{ secrets.GITHUB_TOKEN }}`, `ascending` is set to `True`, `stale-issue-message` is set to `This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions`, `stale-pr-message` is set to `This PR has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions`, `stale-issue-label` is set to `no-issue-activity` and `stale-pr-label` is set to `no-pr-activity`. "}
{"id": "63c4963d6fc19abdf9c9abf2", "level": "level5", "llm_response": "```yaml\nname: Submit to Web Store\n\non:\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n\n    - name: Cache pnpm modules\n      uses: actions/cache@v3\n      with:\n        path: ~/.pnpm-store\n        key: ${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}\n        restore-keys: ${{ runner.os }}-\n\n    - name: Set up pnpm\n      uses: pnpm/action-setup@v2.2.1\n      with:\n        version: 7.1.0\n        run_install: True\n\n    - name: Build and zip extension artifact\n      run: pnpm build -- --zip\n\n    - name: Browser Platform Publish\n      uses: PlasmoHQ/bpp@v2\n      with:\n        keys: ${{ secrets.SUBMIT_KEYS }}\n        artifact: build/chrome-mv3-prod.zip\n```", "answer": "```yaml name: \"Submit to Web Store\"\r\non:\r\n  workflow_dispatch:\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Cache pnpm modules\r\n        uses: actions/cache@v3\r\n        with:\r\n          path: ~/.pnpm-store\r\n          key: ${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}\r\n          restore-keys: |\r\n            ${{ runner.os }}-\r\n      - uses: pnpm/action-setup@v2.2.1\r\n        with:\r\n          version: 7.1.0\r\n          run_install: true\r\n      - name: Build and zip extension artifact\r\n        run: pnpm build -- --zip\r\n      - name: Browser Platform Publish\r\n        uses: PlasmoHQ/bpp@v2\r\n        with:\r\n          keys: ${{ secrets.SUBMIT_KEYS }}\r\n          artifact: build/chrome-mv3-prod.zip\r\n```", "prompt": "Generate a GitHub Workflow named `Submit to Web Store` for a GitHub repository whose primary programming language is TypeScript. This workflow will be triggered by an event: someone manually triggers the workflow. The workflow has one job. The job id of the 1st job is `build`. This job will run on ubuntu-latest runner. The job `build` has 5 steps. The 1st step is named ``. This step runs action `actions/checkout` tagged as v3. The 2nd step is named `Cache pnpm modules`. This step runs action `actions/cache` tagged as v3. The step defines 3 input parameters for the action: `path` is set to `~/.pnpm-store`, `key` is set to `${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}` and `restore-keys` is set to `${{ runner.os }}-\n`. The 3rd step is named ``. This step runs action `pnpm/action-setup` tagged as v2.2.1. The step defines 2 input parameters for the action: `version` is set to `7.1.0` and `run_install` is set to `True`. The 4th step is named `Build and zip extension artifact`. This step runs a script: `pnpm build -- --zip`. The 5th step is named `Browser Platform Publish`. This step runs action `PlasmoHQ/bpp` tagged as v2. The step defines 2 input parameters for the action: `keys` is set to `${{ secrets.SUBMIT_KEYS }}` and `artifact` is set to `build/chrome-mv3-prod.zip`. "}
